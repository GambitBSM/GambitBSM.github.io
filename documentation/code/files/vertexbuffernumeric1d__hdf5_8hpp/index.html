<!doctype html><html lang=en><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="ie=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><link rel=preload as=font href=https://gambitbsm.org/fonts/vendor/jost/jost-v4-latin-regular.woff2 type=font/woff2 crossorigin><link rel=preload as=font href=https://gambitbsm.org/fonts/vendor/jost/jost-v4-latin-500.woff2 type=font/woff2 crossorigin><link rel=preload as=font href=https://gambitbsm.org/fonts/vendor/jost/jost-v4-latin-700.woff2 type=font/woff2 crossorigin><script>(()=>{var e=localStorage.getItem("theme");e==="dark"&&document.documentElement.setAttribute("data-dark-mode","")})()</script><link rel=stylesheet href=https://gambitbsm.org/main.e0ef67572fa591316dbb2b276e1aed52fd04025355d700a37b20ae76eb126fadbe7ceaddbb47632a2f1bf66c490a69e0cd1f1a0dc12b2980ae4b5ffc6d257d62.css integrity="sha512-4O9nVy+lkTFtuysnbhrtUv0EAlNV1wCjeyCudusSb62+fOrdu0djKi8b9mxJCmngzR8aDcErKYCuS1/8bSV9Yg==" crossorigin=anonymous><noscript><style>img.lazyload{display:none}</style></noscript><meta name=robots content="index, follow"><meta name=googlebot content="index, follow, max-snippet:-1, max-image-preview:large, max-video-preview:-1"><meta name=bingbot content="index, follow, max-snippet:-1, max-image-preview:large, max-video-preview:-1"><title>file hdf5printer/VertexBufferNumeric1D_HDF5.hpp - GAMBIT</title><meta name=description content="[No description available]"><link rel=canonical href=https://gambitbsm.org/documentation/code/files/vertexbuffernumeric1d__hdf5_8hpp/><meta property="og:locale" content="en_US"><meta property="og:type" content="article"><meta property="og:title" content="file hdf5printer/VertexBufferNumeric1D_HDF5.hpp"><meta property="og:description" content="[No description available]"><meta property="og:url" content="https://gambitbsm.org/documentation/code/files/vertexbuffernumeric1d__hdf5_8hpp/"><meta property="og:site_name" content="GAMBIT"><meta property="og:image" content="https://gambitbsm.org/gambit_logo.png"><meta property="og:image:alt" content="GAMBIT"><meta name=twitter:card content="summary_large_image"><meta name=twitter:site content><meta name=twitter:creator content><meta name=twitter:title content="file hdf5printer/VertexBufferNumeric1D_HDF5.hpp"><meta name=twitter:description content="[No description available]"><meta name=twitter:image content="https://gambitbsm.org/gambit_logo.png"><meta name=twitter:image:alt content="file hdf5printer/VertexBufferNumeric1D_HDF5.hpp"><script type=application/ld+json>{"@context":"https://schema.org","@graph":[{"@type":"Organization","@id":"https://gambitbsm.org/#/schema/organization/1","name":"Doks","url":"https://gambitbsm.org/","sameAs":["https://github.com/GambitBSM"],"logo":{"@type":"ImageObject","@id":"https://gambitbsm.org/#/schema/image/1","url":"https://gambitbsm.org/logo-doks.png","width":450,"height":416,"caption":"Doks"},"image":{"@id":"https://gambitbsm.org/#/schema/image/1"}},{"@type":"WebSite","@id":"https://gambitbsm.org/#/schema/website/1","url":"https://gambitbsm.org/","name":"GAMBIT","description":"Documentation for GAMBIT, the Global And Modular BSM Inference Tool","publisher":{"@id":"https://gambitbsm.org/#/schema/organization/1"}},{"@type":"WebPage","@id":"https://gambitbsm.org/documentation/code/files/vertexbuffernumeric1d__hdf5_8hpp/","url":"https://gambitbsm.org/documentation/code/files/vertexbuffernumeric1d__hdf5_8hpp/","name":"file hdf5printer\/VertexBufferNumeric1D_HDF5.hpp","description":"[No description available]","isPartOf":{"@id":"https://gambitbsm.org/#/schema/website/1"},"about":{"@id":"https://gambitbsm.org/#/schema/organization/1"},"datePublished":"0001-01-01T00:00:00CET","dateModified":"0001-01-01T00:00:00CET","breadcrumb":{"@id":"https://gambitbsm.org/documentation/code/files/vertexbuffernumeric1d__hdf5_8hpp/#/schema/breadcrumb/1"},"primaryImageOfPage":{"@id":"https://gambitbsm.org/documentation/code/files/vertexbuffernumeric1d__hdf5_8hpp/#/schema/image/2"},"inLanguage":"en-US","potentialAction":[{"@type":"ReadAction","target":["https://gambitbsm.org/documentation/code/files/vertexbuffernumeric1d__hdf5_8hpp/"]}]},{"@type":"BreadcrumbList","@id":"https://gambitbsm.org/documentation/code/files/vertexbuffernumeric1d__hdf5_8hpp/#/schema/breadcrumb/1","name":"Breadcrumbs","itemListElement":[{"@type":"ListItem","position":1,"item":{"@type":"WebPage","@id":"https://gambitbsm.org/","url":"https://gambitbsm.org/","name":"Home"}},{"@type":"ListItem","position":2,"item":{"@type":"WebPage","@id":"https://gambitbsm.org/documentation/","url":"https://gambitbsm.org/documentation/","name":"Documentation"}},{"@type":"ListItem","position":3,"item":{"@type":"WebPage","@id":"https://gambitbsm.org/documentation/code/","url":"https://gambitbsm.org/documentation/code/","name":"Code"}},{"@type":"ListItem","position":4,"item":{"@type":"WebPage","@id":"https://gambitbsm.org/documentation/code/files/","url":"https://gambitbsm.org/documentation/code/files/","name":"Files"}},{"@type":"ListItem","position":5,"item":{"@id":"https://gambitbsm.org/documentation/code/files/vertexbuffernumeric1d__hdf5_8hpp/"}}]},{"@context":"https://schema.org","@graph":[{"@type":"ImageObject","@id":"https://gambitbsm.org/documentation/code/files/vertexbuffernumeric1d__hdf5_8hpp/#/schema/image/2","url":"https://gambitbsm.org/gambit_logo.png","contentUrl":"https://gambitbsm.org/gambit_logo.png","caption":"file hdf5printer\/VertexBufferNumeric1D_HDF5.hpp"}]}]}</script><meta name=theme-color content="#fff"><link rel=icon href=https://gambitbsm.org/favicon.ico sizes=any><link rel=icon type=image/svg+xml href=https://gambitbsm.org/favicon.svg><link rel=apple-touch-icon sizes=180x180 href=https://gambitbsm.org/apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=https://gambitbsm.org/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=https://gambitbsm.org/favicon-16x16.png><link rel=manifest crossorigin=use-credentials href=https://gambitbsm.org/site.webmanifest></head><body class="documentation single light"><div class=sticky-top><div class=header-bar></div><header class="navbar navbar-expand-md navbar-light doks-navbar"><nav class="container-xxl flex-wrap flex-md-nowrap" aria-label="Main navigation"><a class="navbar-brand p-0 me-auto" href=https://gambitbsm.org/ aria-label=GAMBIT><img class=logo-light src=https://gambitbsm.org/gambit_logo.png width=50px>
<img class="logo-dark d-none" src=https://gambitbsm.org/gambit_logo.png width=50px>
GAMBIT</a>
<button class="btn btn-menu order-2 d-block d-lg-none" type=button data-bs-toggle=offcanvas data-bs-target=#offcanvasDoks aria-controls=offcanvasDoks aria-label="Open main menu"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-menu"><line x1="3" y1="12" x2="21" y2="12"/><line x1="3" y1="6" x2="21" y2="6"/><line x1="3" y1="18" x2="21" y2="18"/></svg></button><div class="offcanvas offcanvas-end border-0 py-lg-1" tabindex=-1 id=offcanvasDoks data-bs-backdrop=true aria-labelledby=offcanvasDoksLabel><div class="header-bar d-lg-none"></div><div class="offcanvas-header d-lg-none"><h2 class="h5 offcanvas-title ps-2" id=offcanvasDoksLabel><a class=text-dark href=/>GAMBIT</a></h2><button type=button class="btn-close text-reset me-2" data-bs-dismiss=offcanvas aria-label="Close main menu"></button></div><div class="offcanvas-body p-4 p-lg-0"><ul class="nav flex-column flex-lg-row align-items-lg-center mt-2 mt-lg-0 ms-lg-2 me-lg-auto"><li class="nav-item dropdown"><a class="nav-link dropdown-toggle ps-0 py-1" href=# id=navbarDropdownMenuLink role=button data-bs-toggle=dropdown aria-expanded=false>Releases
<span class=dropdown-caret><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-chevron-down"><polyline points="6 9 12 15 18 9"/></svg></span></a><ul class="dropdown-menu dropdown-menu-main shadow rounded border-0" aria-labelledby=navbarDropdownMenuLink><li><a class=dropdown-item href=https://github.com/GambitBSM/gambit_2.6>GAMBIT 2-6 ⧉</a></li><li><a class=dropdown-item href=https://github.com/GambitBSM/gambit_2.5>GAMBIT 2-5 ⧉</a></li><li><a class=dropdown-item href=https://github.com/GambitBSM/gambit_2.4>GAMBIT 2-4 ⧉</a></li><li><a class=dropdown-item href=https://github.com/GambitBSM/gambit_2.3>GAMBIT 2-3 ⧉</a></li><li><a class=dropdown-item href=https://github.com/GambitBSM/gambit_2.2>GAMBIT 2-2 ⧉</a></li><li><a class=dropdown-item href=https://github.com/GambitBSM/gambit_2.1>GAMBIT 2-1 ⧉</a></li><li><a class=dropdown-item href=https://github.com/GambitBSM/gambit_2.6/tags>All releases ⧉</a></li></ul></li><li class="nav-item dropdown"><a class="nav-link dropdown-toggle ps-0 py-1" href=# id=navbarDropdownMenuLink role=button data-bs-toggle=dropdown aria-expanded=false>Documentation
<span class=dropdown-caret><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-chevron-down"><polyline points="6 9 12 15 18 9"/></svg></span></a><ul class="dropdown-menu dropdown-menu-main shadow rounded border-0" aria-labelledby=navbarDropdownMenuLink><li><a class=dropdown-item href=/documentation/installation/introduction/>Installation</a></li><li><a class=dropdown-item href=/documentation/physics/>Physics</a></li><li><a class=dropdown-item href=/documentation/tutorials/the_gambit_interface>Tutorials</a></li><li><a class=dropdown-item href=/documentation/help/common_problems_and_questions/>Help</a></li><li><a class=dropdown-item href=/documentation/code/index_classes>Code Reference</a></li></ul></li><li class="nav-item dropdown"><a class="nav-link dropdown-toggle ps-0 py-1" href=# id=navbarDropdownMenuLink role=button data-bs-toggle=dropdown aria-expanded=false>Community
<span class=dropdown-caret><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-chevron-down"><polyline points="6 9 12 15 18 9"/></svg></span></a><ul class="dropdown-menu dropdown-menu-main shadow rounded border-0" aria-labelledby=navbarDropdownMenuLink><li><a class=dropdown-item href=https://github.com/GambitBSM/wiki>Wiki</a></li><li><a class=dropdown-item href=/community/publications/>Publications</a></li><li><a class=dropdown-item href=/community/talks/>Talks</a></li><li><a class=dropdown-item href=/community/members/>Members</a></li><li><a class=dropdown-item href=/community/code_of_conduct/>Code of Conduct</a></li><li><a class=dropdown-item href=/community/contact/>Contact</a></li></ul></li></ul><hr class="text-black-50 my-4 d-lg-none"><form class="doks-search position-relative flex-grow-1 ms-lg-auto me-lg-2"><input id=search class="form-control is-search" type=search placeholder="Search site..." aria-label="Search site..." autocomplete=off><div id=suggestions class="shadow bg-white rounded d-none"></div></form><hr class="text-black-50 my-4 d-lg-none"><ul class="nav flex-column flex-lg-row"><li class=nav-item><a class="nav-link social-link" href=https://github.com/GambitBSM><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-github"><path d="M9 19c-5 1.5-5-2.5-7-3m14 6v-3.87a3.37 3.37.0 00-.94-2.61c3.14-.35 6.44-1.54 6.44-7A5.44 5.44.0 0020 4.77 5.07 5.07.0 0019.91 1S18.73.65 16 2.48a13.38 13.38.0 00-7 0C6.27.65 5.09 1 5.09 1A5.07 5.07.0 005 4.77 5.44 5.44.0 003.5 8.55c0 5.42 3.3 6.61 6.44 7A3.37 3.37.0 009 18.13V22"/></svg><small class="ms-2 d-lg-none">GitHub</small></a></li></ul><hr class="text-black-50 my-4 d-lg-none"><button id=mode class="btn btn-link" type=button aria-label="Toggle user interface mode">
<span class=toggle-dark><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-moon"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg></span><span class=toggle-light><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-sun"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></span></button></div></div></nav></header></div><div class="wrap container-xxl" role=document><div class=content><div class="row flex-xl-nowrap"><div class="col-lg-5 col-xl-4 docs-sidebar"><nav class=docs-links aria-label="Main navigation"><ul class="list-unstyled collapsible-sidebar"><li class=mb-1><button class="btn btn-toggle align-items-center rounded collapsed" data-bs-toggle=collapse data-bs-target=#section-installation aria-expanded=false>
Installation</button><div class=collapse id=section-installation><ul class="btn-toggle-nav list-unstyled fw-normal pb-1 small"><li><a class="docs-link rounded" href=/documentation/installation/introduction/>Getting Started</a></li><li><a class="docs-link rounded" href=/documentation/installation/docker_usage/>Docker Usage</a></li><li><a class="docs-link rounded" href=/documentation/installation/installation_for_linux/>Installation for Linux</a></li><li><a class="docs-link rounded" href=/documentation/installation/installation_for_windows/>Installation for Windows</a></li><li><a class="docs-link rounded" href=/documentation/installation/installation_for_macos/>Installation for macOS</a></li></ul></div></li><li class=mb-1><button class="btn btn-toggle align-items-center rounded collapsed" data-bs-toggle=collapse data-bs-target=#section-tutorials aria-expanded=false>
Tutorials</button><div class=collapse id=section-tutorials><ul class="btn-toggle-nav list-unstyled fw-normal pb-1 small"><li><a class="docs-link rounded" href=/documentation/tutorials/the_gambit_interface/>1 - The GAMBIT Interface</a></li><li><a class="docs-link rounded" href=/documentation/tutorials/in_person_tutorials/>In person tutorials</a></li></ul></div></li><li class=mb-1><button class="btn btn-toggle align-items-center rounded collapsed" data-bs-toggle=collapse data-bs-target=#section-physics aria-expanded=false>
Physics</button><div class=collapse id=section-physics><ul class="btn-toggle-nav list-unstyled fw-normal pb-1 small"><li><a class="docs-link rounded" href=/documentation/physics/analyses/>ColliderBit analysis</a></li></ul></div></li><li class=mb-1><button class="btn btn-toggle align-items-center rounded collapsed" data-bs-toggle=collapse data-bs-target=#section-help aria-expanded=false>
Help</button><div class=collapse id=section-help><ul class="btn-toggle-nav list-unstyled fw-normal pb-1 small"><li><a class="docs-link rounded" href=/documentation/help/common_problems_and_questions/>Common Problems and Questions</a></li><li><a class="docs-link rounded" href=/documentation/help/compiler_matrix/>Compiler Matrix</a></li><li><a class="docs-link rounded" href=/documentation/help/known_issues/>Known Issues</a></li><li><a class="docs-link rounded" href=/documentation/help/configuration_examples/>Configuration Examples</a></li><li><a class="docs-link rounded" href=/documentation/help/support/>Support</a></li></ul></div></li><li class=mb-1><button class="btn btn-toggle align-items-center rounded collapsed" data-bs-toggle=collapse data-bs-target=#section-code aria-expanded=false>
Code Reference</button><div class=collapse id=section-code><ul class="btn-toggle-nav list-unstyled fw-normal pb-1 small"><li><a class="docs-link rounded" href=/documentation/code/index_classes/>Classes</a></li><li><a class="docs-link rounded" href=/documentation/code/index_files/>Files</a></li><li><a class="docs-link rounded" href=/documentation/code/index_pages/>Pages</a></li><li><a class="docs-link rounded" href=/documentation/code/index_namespaces/>Namespaces</a></li></ul></div></li></ul></nav></div><nav class="docs-toc d-none d-xl-block col-xl-3" aria-label="Secondary navigation"><div class=d-xl-none><button class="btn btn-outline-primary btn-sm doks-toc-toggle collapsed" type=button data-bs-toggle=collapse data-bs-target=#onThisPage aria-controls=doks-docs-nav aria-expanded=false aria-label="Toggle On this page navigation">
<span>On this page</span>
<span><svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24" class="doks doks-expand" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><title>Expand</title><polyline points="7 13 12 18 17 13"/><polyline points="7 6 12 11 17 6"/></svg><svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24" class="doks doks-collapse" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><title>Collapse</title><polyline points="17 11 12 6 7 11"/><polyline points="17 18 12 13 7 18"/></svg></span></button><div class=collapse id=onThisPage><div class="card card-body mt-3 py-1"><div class=page-links><nav id=TableOfContents><ul><li><a href=#namespaces>Namespaces</a></li><li><a href=#classes>Classes</a></li><li><a href=#detailed-description>Detailed Description</a></li><li><a href=#source-code>Source code</a></li></ul></nav></div></div></div></div><div class="page-links d-none d-xl-block"><h3>On this page</h3><nav id=TableOfContents><ul><li><a href=#namespaces>Namespaces</a></li><li><a href=#classes>Classes</a></li><li><a href=#detailed-description>Detailed Description</a></li><li><a href=#source-code>Source code</a></li></ul></nav></div></nav><main class="docs-content col-lg-11 col-xl-9 mx-xl-auto"><nav aria-label=breadcrumb><ol class=breadcrumb><li class=breadcrumb-item><a href=/>Home</a></li><li class=breadcrumb-item><a href=/documentation/>Documentation</a></li><li class=breadcrumb-item><a href=/documentation/code/>Code Reference</a></li><li class="breadcrumb-item active" aria-current=page>file hdf5printer/VertexBufferNumeric1D_HDF5.hpp</li></ol></nav><p class=lead></p><h1 id=file-hdf5printer-vertexbuffernumeric1d-hdf5-hpp>file hdf5printer/VertexBufferNumeric1D_HDF5.hpp <a href=#file-hdf5printer-vertexbuffernumeric1d-hdf5-hpp class=anchor aria-hidden=true>#</a></h1><p>[No description available] <a href=#detailed-description>More&mldr;</a></p><h2 id=namespaces>Namespaces <a href=#namespaces class=anchor aria-hidden=true>#</a></h2><table><thead><tr><th>Name</th></tr></thead><tbody><tr><td><strong><a href=/documentation/code/namespaces/namespacegambit/>Gambit</a></strong><br>TODO: see if we can use this one:</td></tr><tr><td><strong><a href=/documentation/code/namespaces/namespacegambit_1_1printers/>Gambit::Printers</a></strong><br>Forward declaration.</td></tr></tbody></table><h2 id=classes>Classes <a href=#classes class=anchor aria-hidden=true>#</a></h2><table><thead><tr><th></th><th>Name</th></tr></thead><tbody><tr><td>class</td><td><strong><a href=/documentation/code/classes/classgambit_1_1printers_1_1vertexbuffernumeric1d__hdf5/>Gambit::Printers::VertexBufferNumeric1D_HDF5</a></strong><br>VertexBuffer for simple numerical types - derived version that handles output to hdf5.</td></tr></tbody></table><h2 id=detailed-description>Detailed Description <a href=#detailed-description class=anchor aria-hidden=true>#</a></h2><p><strong>Author</strong>: Ben Farmer (<a href=mailto:benjamin.farmer@fysik.su.se>benjamin.farmer@fysik.su.se</a>)</p><p><strong>Date</strong>: 2015 May</p><p>Declaration of VertexBufferNumeric1D_HDF5 class. This version of VertexBufferNumeric1D adds routines for sending the Numeric1D buffers to a DataSetInterface object, which in turn handles the output to a HDF5 file.</p><hr><p>Authors (add name and date if you modify):</p><hr><h2 id=source-code>Source code <a href=#source-code class=anchor aria-hidden=true>#</a></h2><pre><code>//   GAMBIT: Global and Modular BSM Inference Tool
//   *********************************************
///  \file
///
///  Declaration of VertexBufferNumeric1D_HDF5 
///  class. 
///  This version of VertexBufferNumeric1D adds
///  routines for sending the Numeric1D buffers
///  to a DataSetInterface object, which in turn
///  handles the output to a HDF5 file.
///
///  *********************************************
///
///  Authors (add name and date if you modify):
///   
///  \author Ben Farmer
///          (benjamin.farmer@fysik.su.se)
///  \date 2015 May
///
///  *********************************************
 
#ifndef __VertexBufferNumeric1D_HDF5_hpp__
#define __VertexBufferNumeric1D_HDF5_hpp__

#include &lt;cstddef&gt;
#include &lt;sstream&gt;

// HDF5 C bindings
#include &lt;hdf5.h&gt; 
 
// Gambit
#include &quot;gambit/Printers/VertexBufferNumeric1D.hpp&quot;
#include &quot;gambit/Printers/printers/hdf5printer/DataSetInterfaceScalar.hpp&quot;
#include &quot;gambit/Utils/standalone_error_handlers.hpp&quot;
#include &quot;gambit/Logs/logger.hpp&quot;

// MPI bindings
#include &quot;gambit/Utils/mpiwrapper.hpp&quot;

//#define HDF5_BUF_DEBUG /* Triggers debugging output */
//#define MONITOR_BUF &quot;pointID&quot; /* String ID of buffer to monitor. */
 
namespace Gambit {
  
  namespace Printers {
 
      /// VertexBuffer for simple numerical types - derived version that handles output to hdf5
      template&lt;class T, std::size_t CHUNKLENGTH&gt;
      class VertexBufferNumeric1D_HDF5 : public VertexBufferNumeric1D&lt;T,CHUNKLENGTH&gt; 
      {
         private:
           /// Interfaces to HDF5 datasets
           DataSetInterfaceScalar&lt;bool,CHUNKLENGTH&gt; _dsetvalid; // validity bools
           DataSetInterfaceScalar&lt;T,CHUNKLENGTH&gt;    _dsetdata;  // actual data 

           /// Getters for HDF5 dataset interfaces (extra error checking)
           DataSetInterfaceScalar&lt;bool,CHUNKLENGTH&gt;&amp; dsetvalid(); // validity bools
           DataSetInterfaceScalar&lt;T,CHUNKLENGTH&gt;&amp;    dsetdata();  // actual data             

           /// Extendible backup buffers for RA writes that need to be
           /// postponed due to the original sync writes not having been
           /// performed yet.
           std::vector&lt;std::pair&lt;T,PPIDpair&gt;&gt; postpone_write_queue_and_locs;             

           /// Dimension-0 index of the next empty hyperslab in the output datasets
           unsigned long nextemptyslab = 0;

           /// Variable obtained from somewhere external to the buffer,
           /// used to track the synchronisation position with other buffers
           /// Currently only used to ensure the RA buffers end up the same
           /// size as the sync buffers.
           unsigned long target_sync_pos = 0;

         public:
           /// Constructors
           VertexBufferNumeric1D_HDF5();
           #ifdef WITH_MPI
           VertexBufferNumeric1D_HDF5
             ( hid_t location_id
             , const std::string&amp; name
             , const int vID
             , const unsigned int i
             , const bool sync
             , const bool silence
             , const bool resume
             , const BuffTags&amp; tags
             , const GMPI::Comm&amp; pComm
             );
           #endif
 
           // No MPI constructor
           VertexBufferNumeric1D_HDF5
             ( hid_t location_id
             , const std::string&amp; name
             , const int vID
             , const unsigned int i
             , const bool sync
             , const bool silence
             , const bool resume
             , const char access
             );
     
           /// Destructor
           /// Make sure buffer contents are written to file when buffer object is destroyed
           ~VertexBufferNumeric1D_HDF5();

           /// (virtual for debugging purposes)
           /// Current absolute &quot;write head&quot; position for synchronised buffers
           virtual unsigned long dset_head_pos() { return nextemptyslab + this-&gt;get_head_position(); }

           // Print to std::cout a report on the sync status of this buffer
           virtual void sync_report();

           /// Write sync buffer to HDF5 dataset
           virtual void write_to_disk();

           /// Write externally-supplied buffer to HDF5 dataset
           virtual void write_external_to_disk(const T (&amp;values)[CHUNKLENGTH], const bool (&amp;isvalid)[CHUNKLENGTH]);

           /// Reset the output (non-synchronised datasets only, unless force=true)
           virtual void reset(bool force=false);

           // Finalise writing to underlying output. Do not do any more writing after this!
           virtual void finalise();

           /// Send random access write queue to dataset interfaces for writing
           virtual void RA_write_to_disk(const std::map&lt;PPIDpair, ulong&gt;&amp; PPID_to_dsetindex);

           /// Attempt to write any postponed RA_write attempts to disk
           void attempt_postponed_RA_write_to_disk(const std::map&lt;PPIDpair, ulong&gt;&amp; PPID_to_dsetindex);

           /// Update the variables needed to tracks the currently target dset slot
           /// (really just updates the nextemptyslab variable)
           virtual void update_dset_head_pos()
           {
              if(this-&gt;myRank==0 or not this-&gt;MPI_mode()) // Only the master process has access to this information, unless we are in non-MPI mode
              {
                if(dsetvalid().get_nextemptyslab() != dsetdata().get_nextemptyslab())
                {
                  // The two datasets controlled by this buffer should always remain synchronised!
                  std::ostringstream errmsg;
                  errmsg &lt;&lt; &quot;rank &quot;&lt;&lt;this-&gt;myRank&lt;&lt;&quot;: Error! Validity and Data datasets have gone out of sync in buffer with label '&quot;&lt;&lt;this-&gt;get_label()&lt;&lt;&quot;'! This is a bug in the VertexBufferNumeric1D_HDF5 class. Please report it.&quot;;
                  printer_error().raise(LOCAL_INFO, errmsg.str()); 
                }
                nextemptyslab = dsetvalid().get_nextemptyslab();
              }
           }

           /// Ensure dataset &quot;write head&quot; (i.e. next append) is prepared to
           /// write to the supplied absolute dataset index (e.g. by inserting
           /// blank entries if need)
           void synchronise_output_to_position(const ulong i);
        
           /// Check how many RA writes are waiting in the postpone queue
           /// (mostly for debugging purposes)
           std::size_t postponed_RA_queue_length() { return postpone_write_queue_and_locs.size(); }

           // Needed for checking that dataset sizes on disk are consistent
           ulong get_dataset_length();

      };
 


      /// @{ VertexBufferNumeric1D_HDF5 member function definitions
 
      /// Constructors
      template&lt;class T, std::size_t CHUNKLENGTH&gt;
      VertexBufferNumeric1D_HDF5&lt;T,CHUNKLENGTH&gt;::VertexBufferNumeric1D_HDF5()
        : VertexBufferNumeric1D&lt;T,CHUNKLENGTH&gt;()
        , _dsetvalid()
        , _dsetdata()
        , postpone_write_queue_and_locs()
      {}

      #ifdef WITH_MPI
      template&lt;class T, std::size_t CHUNKLENGTH&gt;
      VertexBufferNumeric1D_HDF5&lt;T,CHUNKLENGTH&gt;::VertexBufferNumeric1D_HDF5(
          hid_t location_id
        , const std::string&amp; name
        , const int vID
        , const unsigned int i
        , const bool sync
        , const bool silence
        , const bool resume
        , const BuffTags&amp; tags
        , const GMPI::Comm&amp; pComm
        )
        : VertexBufferNumeric1D&lt;T,CHUNKLENGTH&gt;(
            name
          , vID
          , i
          , sync
          , silence
          , resume
          , tags
          , pComm
          )
        , _dsetvalid()
        , _dsetdata()
        , postpone_write_queue_and_locs()
      {
        if(this-&gt;MPI_mode() and location_id==-1 and this-&gt;myRank==0)
        {
           std::ostringstream errmsg;
           errmsg &lt;&lt; &quot;rank &quot;&lt;&lt;this-&gt;myRank&lt;&lt;&quot;: Error! Tried to create buffer '&quot;&lt;&lt;this-&gt;get_label()&lt;&lt;&quot;', but supplied HDF5 location pointer was -1 (and we are the rank 0 process, who needs this pointer)&quot;;
           printer_error().raise(LOCAL_INFO, errmsg.str()); 
        }
        else if(not silence)
        {
          if(resume) 
          { 
             logger()&lt;&lt;LogTags::printers&lt;&lt;&quot;Attempting to resume writing to dataset '&quot;&lt;&lt;name&lt;&lt;&quot;_isvalid'...&quot;;
          }
          else
          {
             logger()&lt;&lt;LogTags::printers&lt;&lt;&quot;Creating new dataset '&quot;&lt;&lt;name&lt;&lt;&quot;_isvalid'...&quot;;
          }
          _dsetvalid = DataSetInterfaceScalar&lt;bool,CHUNKLENGTH&gt;(location_id, name+&quot;_isvalid&quot;, resume);

          if(resume) 
          { 
             logger()&lt;&lt;std::endl&lt;&lt;LogTags::printers&lt;&lt;&quot;Attempting to resume writing to dataset '&quot;&lt;&lt;name&lt;&lt;&quot;'...&quot;;
          }
          else
          {
             logger()&lt;&lt;std::endl&lt;&lt;LogTags::printers&lt;&lt;&quot;Creating new dataset '&quot;&lt;&lt;name&lt;&lt;&quot;'...&quot;;
          }
          _dsetdata  = DataSetInterfaceScalar&lt;T,CHUNKLENGTH&gt;(location_id, name, resume);

          logger()&lt;&lt;EOM; // Leave this to calling function
        }
      }
      #endif     
 
      // No MPI constructor
      template&lt;class T, std::size_t CHUNKLENGTH&gt;
      VertexBufferNumeric1D_HDF5&lt;T,CHUNKLENGTH&gt;::VertexBufferNumeric1D_HDF5(
          hid_t location_id
        , const std::string&amp; name
        , const int vID
        , const unsigned int i
        , const bool sync
        , const bool silence
        , const bool resume
        , char access
        )
        : VertexBufferNumeric1D&lt;T,CHUNKLENGTH&gt;(
            name
          , vID
          , i
          , sync
          , silence
          , resume
          , access
          )
        , _dsetvalid()
        , _dsetdata()
        , postpone_write_queue_and_locs()
      {
        if(this-&gt;MPI_mode() and location_id==-1 and this-&gt;myRank==0)
        {
           std::ostringstream errmsg;
           errmsg &lt;&lt; &quot;rank &quot;&lt;&lt;this-&gt;myRank&lt;&lt;&quot;: Error! Tried to create buffer '&quot;&lt;&lt;this-&gt;get_label()&lt;&lt;&quot;', but supplied HDF5 location pointer was NULL (and we are the rank 0 process, who needs this pointer)&quot;;
           printer_error().raise(LOCAL_INFO, errmsg.str()); 
        }
        else if(not silence)
        {
          if(resume) 
          { 
             logger()&lt;&lt;LogTags::printers&lt;&lt;&quot;Attempting to resume writing to dataset '&quot;&lt;&lt;name&lt;&lt;&quot;_isvalid'...&quot;;
          }
          else
          {
             logger()&lt;&lt;LogTags::printers&lt;&lt;&quot;Creating new dataset '&quot;&lt;&lt;name&lt;&lt;&quot;_isvalid'...&quot;;
          }
          _dsetvalid = DataSetInterfaceScalar&lt;bool,CHUNKLENGTH&gt;(location_id, name+&quot;_isvalid&quot;, resume, this-&gt;access_mode());

          if(resume) 
          { 
             logger()&lt;&lt;std::endl&lt;&lt;LogTags::printers&lt;&lt;&quot;Attempting to resume writing to dataset '&quot;&lt;&lt;name&lt;&lt;&quot;'...&quot;;
          }
          else
          {
             logger()&lt;&lt;std::endl&lt;&lt;LogTags::printers&lt;&lt;&quot;Creating new dataset '&quot;&lt;&lt;name&lt;&lt;&quot;'...&quot;;
          }
          _dsetdata  = DataSetInterfaceScalar&lt;T,CHUNKLENGTH&gt;(location_id, name, resume, this-&gt;access_mode());

          logger()&lt;&lt;EOM; // Leave this to calling function
        }
      }
 
      /// Destructor
      template&lt;class T, std::size_t L&gt;
      VertexBufferNumeric1D_HDF5&lt;T,L&gt;::~VertexBufferNumeric1D_HDF5() 
      {
         //TODO: Do this in some more controlled way
         //if(this-&gt;is_synchronised()) { write_to_disk(); }
         //else 
         //{ 
         //   RA_write_to_disk(); 
         //}
      }

      // Print out report on buffer sync status       
      template&lt;class T, std::size_t L&gt;
      void VertexBufferNumeric1D_HDF5&lt;T,L&gt;::sync_report()
      {
         std::cout&lt;&lt;&quot;rank &quot;&lt;&lt;this-&gt;myRank&lt;&lt;&quot;:-----------------------------------------&quot;&lt;&lt;std::endl;
         std::cout&lt;&lt;&quot;rank &quot;&lt;&lt;this-&gt;myRank&lt;&lt;&quot;: Begin sync report for buffer &quot;&lt;&lt;this-&gt;get_label()&lt;&lt;std::endl;
         std::cout&lt;&lt;&quot;rank &quot;&lt;&lt;this-&gt;myRank&lt;&lt;&quot;: Synchronised? = &quot;&lt;&lt;this-&gt;is_synchronised()&lt;&lt;std::endl;
         std::cout&lt;&lt;&quot;rank &quot;&lt;&lt;this-&gt;myRank&lt;&lt;&quot;: nextemptyslab = &quot;&lt;&lt;nextemptyslab&lt;&lt;std::endl;
         std::cout&lt;&lt;&quot;rank &quot;&lt;&lt;this-&gt;myRank&lt;&lt;&quot;: head_position = &quot;&lt;&lt;this-&gt;get_head_position()&lt;&lt;std::endl;
         std::cout&lt;&lt;&quot;rank &quot;&lt;&lt;this-&gt;myRank&lt;&lt;&quot;: dset_head_pos = &quot;&lt;&lt;this-&gt;dset_head_pos()&lt;&lt;std::endl;
         std::cout&lt;&lt;&quot;rank &quot;&lt;&lt;this-&gt;myRank&lt;&lt;&quot;: donepoint()   = &quot;&lt;&lt;this-&gt;donepoint()&lt;&lt;std::endl;
         std::cout&lt;&lt;&quot;rank &quot;&lt;&lt;this-&gt;myRank&lt;&lt;&quot;: sync_buffer_full() = &quot;&lt;&lt;this-&gt;sync_buffer_full&lt;&lt;std::endl;
         std::cout&lt;&lt;&quot;rank &quot;&lt;&lt;this-&gt;myRank&lt;&lt;&quot;: End sync report for buffer &quot;&lt;&lt;this-&gt;get_label()&lt;&lt;std::endl;
         std::cout&lt;&lt;&quot;rank &quot;&lt;&lt;this-&gt;myRank&lt;&lt;&quot;:-----------------------------------------&quot;&lt;&lt;std::endl;

      }
    
      /// @{ Safe dataset getters
      template&lt;class T, std::size_t L&gt;
      DataSetInterfaceScalar&lt;bool,L&gt;&amp; VertexBufferNumeric1D_HDF5&lt;T,L&gt;::dsetvalid()
      {
        #ifdef WITH_MPI
        if(this-&gt;MPI_mode() and this-&gt;myRank!=0)
        {
            std::ostringstream errmsg;
            errmsg &lt;&lt; &quot;rank &quot;&lt;&lt;this-&gt;myRank&lt;&lt;&quot;: Error! VertexBuffer (HDF5 type) in non-master process tried to access dsetvalid! This doesn't exist except on the master process (buffer is &quot;&lt;&lt;this-&gt;get_label()&lt;&lt;&quot;)&quot;;
            printer_error().raise(LOCAL_INFO, errmsg.str()); 
        }
        #endif 
        return _dsetvalid;
      }

      template&lt;class T, std::size_t L&gt;
      DataSetInterfaceScalar&lt;T,L&gt;&amp; VertexBufferNumeric1D_HDF5&lt;T,L&gt;::dsetdata()
      {
        #ifdef WITH_MPI
        if(this-&gt;MPI_mode() and this-&gt;myRank!=0)
        {
            std::ostringstream errmsg;
            errmsg &lt;&lt; &quot;rank &quot;&lt;&lt;this-&gt;myRank&lt;&lt;&quot;Error! VertexBuffer (HDF5 type) in non-master process tried to access dsetdata! This doesn't exist except on the master process (buffer is &quot;&lt;&lt;this-&gt;get_label()&lt;&lt;&quot;)&quot;;
            printer_error().raise(LOCAL_INFO, errmsg.str()); 
        }
        #endif 
        return _dsetdata;
      }
      /// @}

      /// Override of buffer dump function to handle HDF5 output
      template&lt;class T, std::size_t L&gt;
      void VertexBufferNumeric1D_HDF5&lt;T,L&gt;::write_to_disk()
      {
         if(this-&gt;is_synchronised()) {
           // Check if buffer is empty, and whether we really want to write an
           // empty buffer to disk.
           if( not this-&gt;sync_buffer_is_empty() or
               this-&gt;dset_head_pos() &gt;= dsetvalid().dset_length()
             ) // Should only have to check one of the datasets... perhaps add error checking for this.
           {
             dsetvalid().writenewchunk(this-&gt;buffer_valid); 
             dsetdata().writenewchunk(this-&gt;buffer_entries);
             // Update the head tracking variables to reflect the new dset chunk
             update_dset_head_pos();
           }
         }
         else {
            std::ostringstream errmsg;
            errmsg &lt;&lt; &quot;rank &quot;&lt;&lt;this-&gt;myRank&lt;&lt;&quot;: Error! Tried to write_to_disk() synchronised write buffer of buffer with name &quot;&lt;&lt;this-&gt;get_label()&lt;&lt;&quot;, but buffer is not flagged as running in synchronised mode! Please report this bug.&quot;;
            printer_error().raise(LOCAL_INFO, errmsg.str()); 
         }
      }

      /// Manual command to send an arbitrary buffer to be written to disk
      template&lt;class T, std::size_t CHUNKLENGTH&gt;
      void VertexBufferNumeric1D_HDF5&lt;T,CHUNKLENGTH&gt;::write_external_to_disk(const T (&amp;values)[CHUNKLENGTH], const bool (&amp;isvalid)[CHUNKLENGTH])
      {
         if(not this-&gt;is_silenced()) {
           dsetvalid().writenewchunk(isvalid); 
           dsetdata().writenewchunk(values);
           // Update sync information to reflect the presence of the new chunk
           update_dset_head_pos();
         }
      }

      /// Reset the output (non-synchronised datasets only)
      template&lt;class T, std::size_t L&gt;
      void VertexBufferNumeric1D_HDF5&lt;T,L&gt;::reset(bool force) 
      { 
         if(not force and this-&gt;is_synchronised())
         {
            std::ostringstream errmsg;
            errmsg &lt;&lt; &quot;rank &quot;&lt;&lt;this-&gt;myRank&lt;&lt;&quot;: Error! Tried to reset() a synchronised buffer! This is forbidden unless force=true. (buffer name = &quot;&lt;&lt;this-&gt;get_label()&lt;&lt;&quot;)&quot;;
            printer_error().raise(LOCAL_INFO, errmsg.str()); 
         }

         // Clear the sync buffers
         this-&gt;clear();

         /// Empty the queue of postponed writes, because it would now
         /// be erased had we gotten around to writing it.
         postpone_write_queue_and_locs.clear();

         if(this-&gt;myRank==0 or not this-&gt;MPI_mode()) // Can only touch datasets on master process (unless we are in non-MPI mode)
         {
            /// Invalidate the contents of the linked datasets
            /// This can be done by simply resetting the all validity bools to &quot;false&quot;
            dsetvalid().zero();
            //dsetdata().zero(); // Should work fine, but should be unneccesary.

            // Point the write head (or &quot;cursor&quot;) back at the beginning of the output datasets.
            dsetvalid().reset_nextemptyslab();
            dsetdata().reset_nextemptyslab();
         }
      }

      /// Attempt to write postponed RA entries to disk 
      template&lt;class T, std::size_t CHUNKLENGTH&gt;
      void VertexBufferNumeric1D_HDF5&lt;T,CHUNKLENGTH&gt;::attempt_postponed_RA_write_to_disk(const std::map&lt;PPIDpair, ulong&gt;&amp; PPID_to_dsetindex)
      {
         /// Use the provided PPIDpair--&gt;dset_location map to locate the target
         /// parameter points in the output dataset. 
         /// (Temp RA buffers for immediate writes)
         bool valid[CHUNKLENGTH]; 
         T        now_write_queue[CHUNKLENGTH];             
         hsize_t  now_abs_write_locations[CHUNKLENGTH];
         uint     now_i=0; // queue_length

         /// Postponed entries which still cannot be written will be added here.
         std::vector&lt;std::pair&lt;T,PPIDpair&gt;&gt; failed;
         
         /// Need to go through the postponed entries one CHUNKLENGTH at a time
         typedef typename std::vector&lt;std::pair&lt;T,PPIDpair&gt;&gt;::iterator it_type;
         it_type itpp = postpone_write_queue_and_locs.begin();
         while(itpp != postpone_write_queue_and_locs.end())
         {
            T&amp;        val = itpp-&gt;first;
            PPIDpair&amp; loc = itpp-&gt;second;

            // Convert loc to abs dataset index (if possible)
            std::map&lt;PPIDpair, ulong&gt;::const_iterator it 
                = PPID_to_dsetindex.find(loc);

            if(it==PPID_to_dsetindex.end())
            {
               // No PPID found
               failed.push_back(*itpp);
            }
            else
            {
               // PPID found; convert to absolute dataset index and add to &quot;now&quot; queue
               now_write_queue[now_i]         = val;
               now_abs_write_locations[now_i] = it-&gt;second;
               now_i++;
            }

            // Increment iterator (need to do this before 'if' statement around RA_write call)
            ++itpp; 

            // Write &quot;now&quot; buffers to disk, if they aren't empty
            if(now_i != 0)
            {
               if(now_i&gt;CHUNKLENGTH)
               {
                  std::ostringstream errmsg;
                  errmsg &lt;&lt; &quot;rank &quot;&lt;&lt;this-&gt;myRank&lt;&lt;&quot;: Error! now_i has exceeded CHUNKLENGTH (now_i==&quot;&lt;&lt;now_i&lt;&lt;&quot;) during attempt to perform postponed RA_writes. (buffer name = &quot;&lt;&lt;this-&gt;get_label()&lt;&lt;&quot;)&quot;;
                  printer_error().raise(LOCAL_INFO, errmsg.str()); 
               }

               // Do the write only if buffer is full or postpone queue is finished and we
               // are about to finish looping.
               if(now_i==CHUNKLENGTH or itpp == postpone_write_queue_and_locs.end())
               {
                  std::fill(valid, valid+CHUNKLENGTH, false); 
                  std::fill(valid, valid+now_i, true); 
                  dsetvalid().RA_write(valid,           now_abs_write_locations, now_i); 
                  dsetdata().RA_write (now_write_queue, now_abs_write_locations, now_i);
                  //std::cout&lt;&lt;&quot;Wrote &quot;&lt;&lt;now_i&lt;&lt;&quot; postponed RA items to disk&quot;&lt;&lt;std::endl;
                  now_i = 0; // Reset buffer
               }
            }
         }
         // put failed write attempts back into the postpone queue
         postpone_write_queue_and_locs = failed;
      }


      /// Send random access write queue to dataset interfaces for writing
      template&lt;class T, std::size_t CHUNKLENGTH&gt;
      void VertexBufferNumeric1D_HDF5&lt;T,CHUNKLENGTH&gt;::RA_write_to_disk(const std::map&lt;PPIDpair, ulong&gt;&amp; PPID_to_dsetindex)
      {
        if(this-&gt;is_synchronised())
        {
           std::ostringstream errmsg;
           errmsg &lt;&lt; &quot;rank &quot;&lt;&lt;this-&gt;myRank&lt;&lt;&quot;: Error! Non-synchronised buffer attempted to perform RA_write_to_disk! Only non-synchronised buffers are permitted to do this. (buffer name = &quot;&lt;&lt;this-&gt;get_label()&lt;&lt;&quot;)&quot;;
           printer_error().raise(LOCAL_INFO, errmsg.str()); 
        }

        if(not this-&gt;is_silenced()) 
         {
            dsetvalid().extend_dset(target_sync_pos);
            dsetdata().extend_dset(target_sync_pos);

            #ifdef DEBUG_MODE
            std::cout&lt;&lt;&quot;rank &quot;&lt;&lt;this-&gt;myRank&lt;&lt;&quot;: Extended RA dset '&quot;&lt;&lt;this-&gt;get_label()&lt;&lt;&quot;' to at least size &quot;&lt;&lt;target_sync_pos&lt;&lt;std::endl; 
            #endif

            if (this-&gt;RA_queue_length!=0 or postpone_write_queue_and_locs.size()!=0) 
            {
               #ifdef DEBUG_MODE
               std::cout&lt;&lt;&quot;rank &quot;&lt;&lt;this-&gt;myRank&lt;&lt;&quot;: Doing RA_write_to_disk for buffer '&quot;&lt;&lt;this-&gt;get_label()&lt;&lt;&quot;' (note: target_sync_pos=&quot;&lt;&lt;target_sync_pos&lt;&lt;&quot;, dset_head_pos()=&quot;&lt;&lt;this-&gt;dset_head_pos()&lt;&lt;&quot;)&quot;&lt;&lt;std::endl;
               #endif 

               // Attempt to write any existing postponed RA write attempts to disk (again)
               attempt_postponed_RA_write_to_disk(PPID_to_dsetindex);

               //std::cout&lt;&lt;&quot;rank &quot;&lt;&lt;this-&gt;myRank&lt;&lt;&quot;: Number of items remaining in postpone queue after write attempt = &quot;&lt;&lt;postpone_write_queue_and_locs.size()&lt;&lt;&quot;); buffer is '&quot;&lt;&lt;this-&gt;get_label()&lt;&lt;&quot;'&quot;&lt;&lt;std::endl;

               /// Use the provided PPIDpair--&gt;dset_location map to locate the target
               /// parameter points in the output dataset. 
               /// (Temp RA buffers for immediate writes)
               bool valid[CHUNKLENGTH]; 
               T        now_write_queue[CHUNKLENGTH];             
               hsize_t  now_abs_write_locations[CHUNKLENGTH];
               uint     now_i=0; // queue_length

               // Now go through the current RA_queue and try to write them to disk
               for(ulong i=0; i&lt;this-&gt;RA_queue_length; i++)
               {
                 // Some write locations may not be known yet due to the original
                 // data not yet having been written to disk from its sync buffer.
                 // We will have to postpone writing these until the next RA_write
                 // attempt.
                 std::map&lt;PPIDpair, ulong&gt;::const_iterator it 
                     = PPID_to_dsetindex.find(this-&gt;RA_write_locations[i]);
                 if(it==PPID_to_dsetindex.end())
                 {
                    // No PPID found; add to &quot;postpone&quot; queue
                    postpone_write_queue_and_locs.push_back(
                                  std::make_pair(this-&gt;RA_write_queue[i],
                                                 this-&gt;RA_write_locations[i])
                                  );
                 }
                 else
                 {
                    // PPID found; convert to absolute dataset index and add to &quot;now&quot; queue
                    now_write_queue[now_i]         = this-&gt;RA_write_queue[i];
                    now_abs_write_locations[now_i] = it-&gt;second;
                    now_i++;
                 }
               }               

               // Write &quot;now&quot; buffers to disk, if they aren't empty
               if(now_i != 0)
               {
                  if(now_i&gt;CHUNKLENGTH)
                  {
                     std::ostringstream errmsg;
                     errmsg &lt;&lt; &quot;rank &quot;&lt;&lt;this-&gt;myRank&lt;&lt;&quot;: Error! now_i has exceeded CHUNKLENGTH (now_i==&quot;&lt;&lt;now_i&lt;&lt;&quot;). (buffer name = &quot;&lt;&lt;this-&gt;get_label()&lt;&lt;&quot;)&quot;;
                     printer_error().raise(LOCAL_INFO, errmsg.str()); 
                  }
                  std::fill(valid, valid+CHUNKLENGTH, false); 
                  std::fill(valid, valid+now_i, true); 
                  #ifdef DEBUG_MODE
                  std::cout&lt;&lt;&quot;rank &quot;&lt;&lt;this-&gt;myRank&lt;&lt;&quot;: writing buffer for &quot;&lt;&lt;this-&gt;get_label()&lt;&lt;&quot; to disk; now_i=&quot;&lt;&lt;now_i&lt;&lt;std::endl;
                  #endif
                  dsetvalid().RA_write(valid,           now_abs_write_locations, now_i); 
                  dsetdata().RA_write (now_write_queue, now_abs_write_locations, now_i);
               }

            }
         }
      }

      /// Ensure dataset &quot;write head&quot; (i.e. next append) is prepared to
      /// write to the supplied absolute dataset index (e.g. by inserting
      /// blank entries if need)
      ///
      /// NEW MEANING:
      /// Ensure that the supplied index has been written to, and that the
      /// next append will happen to the next index above it.
      template&lt;class T, std::size_t L&gt;
      void VertexBufferNumeric1D_HDF5&lt;T,L&gt;::synchronise_output_to_position(const ulong sync_pos)
      {
         if(not this-&gt;is_silenced()) 
         {
            // Make sure the correct dset_head_pos() is known
            update_dset_head_pos();

            // Update the variable which tracks the current sync position.
            // (do this regardless of whether this is a sync buffer or not)
            target_sync_pos = sync_pos;

            #ifdef HDF5_BUF_DEBUG
            std::cout&lt;&lt;&quot;rank &quot;&lt;&lt;this-&gt;myRank&lt;&lt;&quot;: Updated target_sync_pos to '&quot;&lt;&lt;target_sync_pos&lt;&lt;&quot; in buffer &quot;&lt;&lt;this-&gt;get_label()&lt;&lt;std::endl; 
            #endif

            if(this-&gt;is_synchronised()) 
            {
               #ifdef HDF5_BUF_DEBUG
               #ifdef MONITOR_BUF
               if(this-&gt;get_label()==MONITOR_BUF) {
               #endif
               std::cout&lt;&lt;&quot;rank &quot;&lt;&lt;this-&gt;myRank&lt;&lt;&quot;: Synchronising buffer '&quot;&lt;&lt;this-&gt;get_label()&lt;&lt;&quot;' to position &quot;&lt;&lt;sync_pos&lt;&lt;&quot; (current dset_head_pos() = &quot;&lt;&lt;this-&gt;dset_head_pos()&lt;&lt;&quot;)&quot;&lt;&lt;std::endl;
               #ifdef MONITOR_BUF
               }
               #endif
               #endif 

               // Compare target position to current sync position and see what we need to do
               // The plus one is because the head_pos should be one larger than the sync_pos
               // for buffers who already did an append to the sync_pos; these buffers therefore
               // do not need to move.
               //
               const long movediff = sync_pos+1 - this-&gt;dset_head_pos();
               if(movediff==1)             
               {
                   // Set the current point as having no valid data and move to the next
                   this-&gt;skip_append();    
               } 
               else if(movediff&lt;0)
               {
                   std::ostringstream errmsg;
                   errmsg &lt;&lt; &quot;rank &quot;&lt;&lt;this-&gt;myRank&lt;&lt;&quot;: Error! Attempted to move HDF5 write position backwards in buffer with label '&quot;&lt;&lt;this-&gt;get_label()&lt;&lt;&quot;'! (movediff (&quot;&lt;&lt;movediff&lt;&lt;&quot;) = sync_pos (&quot;&lt;&lt;sync_pos&lt;&lt;&quot;)+1 - dset_head_pos() (&quot;&lt;&lt;this-&gt;dset_head_pos()&lt;&lt;&quot;)) This is a bug in the VertexBufferNumeric1D_HDF5 class or in a class which uses it (probably HDF5Printer). Please report it. (Note, writing to old points can be done but requires using special write functions).&quot;;
                   printer_error().raise(LOCAL_INFO, errmsg.str());
               } 
               else if (movediff==0)
               {
                 if(this-&gt;donepoint())
                 {
                   std::ostringstream errmsg;
                   errmsg &lt;&lt; &quot;rank &quot;&lt;&lt;this-&gt;myRank&lt;&lt;&quot;: Error! Attempted to move HDF5 write position by 0 slots in buffer with label '&quot;&lt;&lt;this-&gt;get_label()&lt;&lt;&quot;' (movediff (&quot;&lt;&lt;movediff&lt;&lt;&quot;) = sync_pos (&quot;&lt;&lt;sync_pos&lt;&lt;&quot;)+1 - dset_head_pos (&quot;&lt;&lt;this-&gt;dset_head_pos()&lt;&lt;&quot;)); this part is fine, however the buffer indicates that this position has already received a write (donepoint()==true) so it should have moved forward! This is a bug in the VertexBufferNumeric1D_HDF5 class or in a class which uses it (probably HDF5Printer). Please report it.&quot;;
                   printer_error().raise(LOCAL_INFO, errmsg.str());
                 }
                 // otherwise no problem; carry on.
               }
               else if (movediff&gt;1) // and movediff!=CHUNKLENGTH+1) 
               {
                   std::ostringstream errmsg;
                   errmsg &lt;&lt; &quot;rank &quot;&lt;&lt;this-&gt;myRank&lt;&lt;&quot;: Error! Attempted to move HDF5 write position by &gt;1 slots (&quot;&lt;&lt;movediff&lt;&lt;&quot;) in buffer with label '&quot;&lt;&lt;this-&gt;get_label()&lt;&lt;&quot;' (movediff (&quot;&lt;&lt;movediff&lt;&lt;&quot;) = sync_pos (&quot;&lt;&lt;sync_pos&lt;&lt;&quot;)+1 - dset_head_pos() (&quot;&lt;&lt;this-&gt;dset_head_pos()&lt;&lt;&quot;)). Buffer synchronisation should only happen one slot at a time. This is a bug in the VertexBufferNumeric1D_HDF5 class or in a class which uses it (probably HDF5Printer). Please report it.&quot;;
                   printer_error().raise(LOCAL_INFO, errmsg.str());
               }

               #ifdef HDF5_BUF_DEBUG
               #ifdef MONITOR_BUF
               if(this-&gt;get_label()==MONITOR_BUF) {
               #endif
               long slots_left = L;
               slots_left -= this-&gt;get_head_position() - this-&gt;donepoint();
               std::cout&lt;&lt;&quot;rank &quot;&lt;&lt;this-&gt;myRank&lt;&lt;&quot;: Moved &quot;&lt;&lt;movediff&lt;&lt;&quot; slot(s). # unwritten slots left in buffer = &quot;&lt;&lt;slots_left&lt;&lt;&quot;. buffer_is_full = &quot;&lt;&lt;this-&gt;sync_buffer_is_full()&lt;&lt;std::endl;         
               std::cout&lt;&lt;&quot;rank &quot;&lt;&lt;this-&gt;myRank&lt;&lt;&quot;:   Buffer length:&quot;&lt;&lt;L&lt;&lt;std::endl;
               std::cout&lt;&lt;&quot;rank &quot;&lt;&lt;this-&gt;myRank&lt;&lt;&quot;:   head_position:&quot;&lt;&lt;this-&gt;get_head_position()&lt;&lt;std::endl;     
               std::cout&lt;&lt;&quot;rank &quot;&lt;&lt;this-&gt;myRank&lt;&lt;&quot;:   donepoint()  :&quot;&lt;&lt;this-&gt;donepoint()&lt;&lt;std::endl;        
    
               #ifdef MONITOR_BUF
               }
               #endif
               #endif 
            }
         }
      }
 
      template&lt;class T, std::size_t L&gt;
      ulong VertexBufferNumeric1D_HDF5&lt;T,L&gt;::get_dataset_length()
      {
         if(dsetvalid().dset_length() != dsetdata().dset_length())
         {
            std::ostringstream errmsg;
            errmsg &lt;&lt; &quot;rank &quot;&lt;&lt;this-&gt;myRank&lt;&lt;&quot;: Error! Lengths of 'data' and 'valid' datasets for buffer &quot;&lt;&lt;this-&gt;get_label()&lt;&lt;&quot; are different (&quot;&lt;&lt;dsetdata().dset_length()&lt;&lt;&quot; and &quot;&lt;&lt;dsetvalid().dset_length()&lt;&lt;&quot; respectively). This should never happen.&quot;;
            printer_error().raise(LOCAL_INFO, errmsg.str());
         }
         return dsetdata().dset_length();
      }

      // Finalise writing to underlying output. Do not do any more writing after this!
      template&lt;class T, std::size_t L&gt;
      void VertexBufferNumeric1D_HDF5&lt;T,L&gt;::finalise()
      {
         dsetdata().closeDataSet();
         dsetvalid().closeDataSet();
      }
      /// @} 
  }
}

#endif
</code></pre><hr><p>Updated on 2025-02-12 at 16:10:34 +0000</p></main></div></div></div><footer class="footer text-muted"><div class=container-xxl><div class=row><div class="col-lg-8 order-last order-lg-first"><ul class=list-inline><li class=list-inline-item>Powered by <a href=https://gohugo.io/>Hugo</a> and <a href=https://getdoks.org/>Doks</a></li></ul></div><div class="col-lg-8 order-first order-lg-last text-lg-end"><ul class=list-inline><li class=list-inline-item><a href=/license/>License</a></li></ul></div></div></div></footer><script src=/js/bootstrap.min.862c9eb8ab97f8c1c8584b21ce31113d8553917669561b040011b0061009a0b6c7a6b61fb659f56eabfa9f45259f001417dba1d65b229f685f3cdbb709482f8e.js integrity="sha512-hiyeuKuX+MHIWEshzjERPYVTkXZpVhsEABGwBhAJoLbHprYftln1bqv6n0UlnwAUF9uh1lsin2hfPNu3CUgvjg==" crossorigin=anonymous defer></script>
<script src=/js/highlight.min.3fa03d1d36ae7a66d6d5d2e19796832d40b4a5417eaaae1dfba8837d033467084e8c051f25aee596d415422573116115ccc5c2b29970d3490dafdce1a920a402.js integrity="sha512-P6A9HTauembW1dLhl5aDLUC0pUF+qq4d+6iDfQM0ZwhOjAUfJa7lltQVQiVzEWEVzMXCsplw00kNr9zhqSCkAg==" crossorigin=anonymous defer></script>
<script src=/main.min.04459eeb2d9d601a3ccc10d2699fb84f0442d5f5d3a16372b023be7564838ed2a755b908598f715d6b42c0be95895835b2e872f4fa4acd028ef3904671a92f1a.js integrity="sha512-BEWe6y2dYBo8zBDSaZ+4TwRC1fXToWNysCO+dWSDjtKnVbkIWY9xXWtCwL6ViVg1suhy9PpKzQKO85BGcakvGg==" crossorigin=anonymous defer></script>
<script src=https://gambitbsm.org/index.min.684b99a00b8914ff7921825fa64f7a4e13264f15c4e0eb2ce0356cd30fb1290346919cfd28e5f6a1299ee7f9557cabd8a153cae9690106c2d72ef883e2efc7c7.js integrity="sha512-aEuZoAuJFP95IYJfpk96ThMmTxXE4Oss4DVs0w+xKQNGkZz9KOX2oSme5/lVfKvYoVPK6WkBBsLXLviD4u/Hxw==" crossorigin=anonymous defer></script></body></html>