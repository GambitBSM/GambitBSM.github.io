<!doctype html><html lang=en-us><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="ie=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><link rel=preload as=font href=https://gambitbsm.org/fonts/vendor/jost/jost-v4-latin-regular.woff2 type=font/woff2 crossorigin><link rel=preload as=font href=https://gambitbsm.org/fonts/vendor/jost/jost-v4-latin-500.woff2 type=font/woff2 crossorigin><link rel=preload as=font href=https://gambitbsm.org/fonts/vendor/jost/jost-v4-latin-700.woff2 type=font/woff2 crossorigin><script>(()=>{var e=localStorage.getItem("theme");e==="dark"&&document.documentElement.setAttribute("data-dark-mode","")})()</script><link rel=stylesheet href=https://gambitbsm.org/main.f8151591b2672085f0933fc9a990f490d47a5bae835eba13e592ae582ffe5e3a9177998e140a75a274da31357b8222d58a74d4a9f10720e05b02bc2a37e6f0ec.css integrity="sha512-+BUVkbJnIIXwkz/JqZD0kNR6W66DXroT5ZKuWC/+XjqRd5mOFAp1onTaMTV7giLVinTUqfEHIOBbArwqN+bw7A==" crossorigin=anonymous><noscript><style>img.lazyload{display:none}</style></noscript><meta name=robots content="index, follow"><meta name=googlebot content="index, follow, max-snippet:-1, max-image-preview:large, max-video-preview:-1"><meta name=bingbot content="index, follow, max-snippet:-1, max-image-preview:large, max-video-preview:-1"><title>file hdf5printer/hdf5printer/retrieve_overloads.cpp - GAMBIT</title><meta name=description content="[No description available]"><link rel=canonical href=https://gambitbsm.org/documentation/code/files/hdf5printer_2retrieve__overloads_8cpp/><meta property="og:locale" content="en_US"><meta property="og:type" content="article"><meta property="og:title" content="file hdf5printer/hdf5printer/retrieve_overloads.cpp"><meta property="og:description" content="[No description available]"><meta property="og:url" content="https://gambitbsm.org/documentation/code/files/hdf5printer_2retrieve__overloads_8cpp/"><meta property="og:site_name" content="GAMBIT"><meta property="og:image" content="https://gambitbsm.org/gambit_logo.png"><meta property="og:image:alt" content="GAMBIT"><meta name=twitter:card content="summary_large_image"><meta name=twitter:site content><meta name=twitter:creator content><meta name=twitter:title content="file hdf5printer/hdf5printer/retrieve_overloads.cpp"><meta name=twitter:description content="[No description available]"><meta name=twitter:image content="https://gambitbsm.org/gambit_logo.png"><meta name=twitter:image:alt content="file hdf5printer/hdf5printer/retrieve_overloads.cpp"><script type=application/ld+json>{"@context":"https://schema.org","@graph":[{"@type":"Organization","@id":"https://gambitbsm.org/#/schema/organization/1","name":"Doks","url":"https://gambitbsm.org/","sameAs":["https://github.com/GambitBSM"],"logo":{"@type":"ImageObject","@id":"https://gambitbsm.org/#/schema/image/1","url":"https://gambitbsm.org/logo-doks.png","width":450,"height":416,"caption":"Doks"},"image":{"@id":"https://gambitbsm.org/#/schema/image/1"}},{"@type":"WebSite","@id":"https://gambitbsm.org/#/schema/website/1","url":"https://gambitbsm.org/","name":"GAMBIT","description":"Documentation for GAMBIT, the Global And Modular BSM Inference Tool","publisher":{"@id":"https://gambitbsm.org/#/schema/organization/1"}},{"@type":"WebPage","@id":"https://gambitbsm.org/documentation/code/files/hdf5printer_2retrieve__overloads_8cpp/","url":"https://gambitbsm.org/documentation/code/files/hdf5printer_2retrieve__overloads_8cpp/","name":"file hdf5printer\/hdf5printer\/retrieve_overloads.cpp","description":"[No description available]","isPartOf":{"@id":"https://gambitbsm.org/#/schema/website/1"},"about":{"@id":"https://gambitbsm.org/#/schema/organization/1"},"datePublished":"0001-01-01T00:00:00CET","dateModified":"0001-01-01T00:00:00CET","breadcrumb":{"@id":"https://gambitbsm.org/documentation/code/files/hdf5printer_2retrieve__overloads_8cpp/#/schema/breadcrumb/1"},"primaryImageOfPage":{"@id":"https://gambitbsm.org/documentation/code/files/hdf5printer_2retrieve__overloads_8cpp/#/schema/image/2"},"inLanguage":"en-US","potentialAction":[{"@type":"ReadAction","target":["https://gambitbsm.org/documentation/code/files/hdf5printer_2retrieve__overloads_8cpp/"]}]},{"@type":"BreadcrumbList","@id":"https://gambitbsm.org/documentation/code/files/hdf5printer_2retrieve__overloads_8cpp/#/schema/breadcrumb/1","name":"Breadcrumbs","itemListElement":[{"@type":"ListItem","position":1,"item":{"@type":"WebPage","@id":"https://gambitbsm.org/","url":"https://gambitbsm.org/","name":"Home"}},{"@type":"ListItem","position":2,"item":{"@type":"WebPage","@id":"https://gambitbsm.org/documentation/","url":"https://gambitbsm.org/documentation/","name":"Documentation"}},{"@type":"ListItem","position":3,"item":{"@type":"WebPage","@id":"https://gambitbsm.org/documentation/code/","url":"https://gambitbsm.org/documentation/code/","name":"Code"}},{"@type":"ListItem","position":4,"item":{"@type":"WebPage","@id":"https://gambitbsm.org/documentation/code/files/","url":"https://gambitbsm.org/documentation/code/files/","name":"Files"}},{"@type":"ListItem","position":5,"item":{"@id":"https://gambitbsm.org/documentation/code/files/hdf5printer_2retrieve__overloads_8cpp/"}}]},{"@context":"https://schema.org","@graph":[{"@type":"ImageObject","@id":"https://gambitbsm.org/documentation/code/files/hdf5printer_2retrieve__overloads_8cpp/#/schema/image/2","url":"https://gambitbsm.org/gambit_logo.png","contentUrl":"https://gambitbsm.org/gambit_logo.png","caption":"file hdf5printer\/hdf5printer\/retrieve_overloads.cpp"}]}]}</script><meta name=theme-color content="#fff"><link rel=icon href=https://gambitbsm.org/favicon.ico sizes=any><link rel=icon type=image/svg+xml href=https://gambitbsm.org/favicon.svg><link rel=apple-touch-icon sizes=180x180 href=https://gambitbsm.org/apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=https://gambitbsm.org/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=https://gambitbsm.org/favicon-16x16.png><link rel=manifest crossorigin=use-credentials href=https://gambitbsm.org/site.webmanifest></head><body class="documentation single light"><div class=sticky-top><div class=header-bar></div><header class="navbar navbar-expand-md navbar-light doks-navbar"><nav class="container-xxl flex-wrap flex-md-nowrap" aria-label="Main navigation"><a class="navbar-brand p-0 me-auto" href=https://gambitbsm.org/ aria-label=GAMBIT><img class=logo-light src=https://gambitbsm.org/gambit_logo.png width=50px>
<img class="logo-dark d-none" src=https://gambitbsm.org/gambit_logo.png width=50px>
GAMBIT</a>
<button class="btn btn-menu order-2 d-block d-lg-none" type=button data-bs-toggle=offcanvas data-bs-target=#offcanvasDoks aria-controls=offcanvasDoks aria-label="Open main menu"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-menu"><line x1="3" y1="12" x2="21" y2="12"/><line x1="3" y1="6" x2="21" y2="6"/><line x1="3" y1="18" x2="21" y2="18"/></svg></button><div class="offcanvas offcanvas-end border-0 py-lg-1" tabindex=-1 id=offcanvasDoks data-bs-backdrop=true aria-labelledby=offcanvasDoksLabel><div class="header-bar d-lg-none"></div><div class="offcanvas-header d-lg-none"><h2 class="h5 offcanvas-title ps-2" id=offcanvasDoksLabel><a class=text-dark href=/>GAMBIT</a></h2><button type=button class="btn-close text-reset me-2" data-bs-dismiss=offcanvas aria-label="Close main menu"></button></div><div class="offcanvas-body p-4 p-lg-0"><ul class="nav flex-column flex-lg-row align-items-lg-center mt-2 mt-lg-0 ms-lg-2 me-lg-auto"><li class="nav-item dropdown"><a class="nav-link dropdown-toggle ps-0 py-1" href=# id=navbarDropdownMenuLink role=button data-bs-toggle=dropdown aria-expanded=false>Releases
<span class=dropdown-caret><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-chevron-down"><polyline points="6 9 12 15 18 9"/></svg></span></a><ul class="dropdown-menu dropdown-menu-main shadow rounded border-0" aria-labelledby=navbarDropdownMenuLink><li><a class=dropdown-item href=https://github.com/GambitBSM/gambit_2.4>GAMBIT 2-4 ⧉</a></li><li><a class=dropdown-item href=https://github.com/GambitBSM/gambit_2.3>GAMBIT 2-3 ⧉</a></li><li><a class=dropdown-item href=https://github.com/GambitBSM/gambit_2.2>GAMBIT 2-2 ⧉</a></li><li><a class=dropdown-item href=https://github.com/GambitBSM/gambit_2.1>GAMBIT 2-1 ⧉</a></li><li><a class=dropdown-item href=https://github.com/GambitBSM/gambit_2.4/tags>All releases ⧉</a></li></ul></li><li class="nav-item dropdown"><a class="nav-link dropdown-toggle ps-0 py-1" href=# id=navbarDropdownMenuLink role=button data-bs-toggle=dropdown aria-expanded=false>Documentation
<span class=dropdown-caret><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-chevron-down"><polyline points="6 9 12 15 18 9"/></svg></span></a><ul class="dropdown-menu dropdown-menu-main shadow rounded border-0" aria-labelledby=navbarDropdownMenuLink><li><a class=dropdown-item href=/documentation/installation/introduction/>Installation</a></li><li><a class=dropdown-item href=/documentation/tutorials/the_gambit_interface>Tutorials</a></li><li><a class=dropdown-item href=/documentation/help/common_problems_and_questions/>Help</a></li><li><a class=dropdown-item href=/documentation/code/index_classes>Code Reference</a></li></ul></li><li class="nav-item dropdown"><a class="nav-link dropdown-toggle ps-0 py-1" href=# id=navbarDropdownMenuLink role=button data-bs-toggle=dropdown aria-expanded=false>Community
<span class=dropdown-caret><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-chevron-down"><polyline points="6 9 12 15 18 9"/></svg></span></a><ul class="dropdown-menu dropdown-menu-main shadow rounded border-0" aria-labelledby=navbarDropdownMenuLink><li><a class=dropdown-item href=/community/publications/>Publications</a></li><li><a class=dropdown-item href=/community/talks/>Talks</a></li><li><a class=dropdown-item href=/community/members/>Members</a></li><li><a class=dropdown-item href=/community/code_of_conduct/>Code of Conduct</a></li><li><a class=dropdown-item href=/community/contact/>Contact</a></li></ul></li></ul><hr class="text-black-50 my-4 d-lg-none"><form class="doks-search position-relative flex-grow-1 ms-lg-auto me-lg-2"><input id=search class="form-control is-search" type=search placeholder="Search site..." aria-label="Search site..." autocomplete=off><div id=suggestions class="shadow bg-white rounded d-none"></div></form><hr class="text-black-50 my-4 d-lg-none"><ul class="nav flex-column flex-lg-row"><li class=nav-item><a class="nav-link social-link" href=https://github.com/GambitBSM><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-github"><path d="M9 19c-5 1.5-5-2.5-7-3m14 6v-3.87a3.37 3.37.0 00-.94-2.61c3.14-.35 6.44-1.54 6.44-7A5.44 5.44.0 0020 4.77 5.07 5.07.0 0019.91 1S18.73.65 16 2.48a13.38 13.38.0 00-7 0C6.27.65 5.09 1 5.09 1A5.07 5.07.0 005 4.77 5.44 5.44.0 003.5 8.55c0 5.42 3.3 6.61 6.44 7A3.37 3.37.0 009 18.13V22"/></svg><small class="ms-2 d-lg-none">GitHub</small></a></li></ul><hr class="text-black-50 my-4 d-lg-none"><button id=mode class="btn btn-link" type=button aria-label="Toggle user interface mode">
<span class=toggle-dark><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-moon"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg></span><span class=toggle-light><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-sun"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></span></button></div></div></nav></header></div><div class="wrap container-xxl" role=document><div class=content><div class="row flex-xl-nowrap"><div class="col-lg-5 col-xl-4 docs-sidebar"><nav class=docs-links aria-label="Main navigation"><ul class="list-unstyled collapsible-sidebar"><li class=mb-1><button class="btn btn-toggle align-items-center rounded collapsed" data-bs-toggle=collapse data-bs-target=#section-installation aria-expanded=false>
Installation</button><div class=collapse id=section-installation><ul class="btn-toggle-nav list-unstyled fw-normal pb-1 small"><li><a class="docs-link rounded" href=/documentation/installation/introduction/>Getting Started</a></li><li><a class="docs-link rounded" href=/documentation/installation/docker_usage/>Docker Usage</a></li><li><a class="docs-link rounded" href=/documentation/installation/installation_for_linux/>Installation for Linux</a></li><li><a class="docs-link rounded" href=/documentation/installation/installation_for_windows/>Installation for Windows</a></li><li><a class="docs-link rounded" href=/documentation/installation/installation_for_macos/>Installation for macOS</a></li></ul></div></li><li class=mb-1><button class="btn btn-toggle align-items-center rounded collapsed" data-bs-toggle=collapse data-bs-target=#section-tutorials aria-expanded=false>
Tutorials</button><div class=collapse id=section-tutorials><ul class="btn-toggle-nav list-unstyled fw-normal pb-1 small"><li><a class="docs-link rounded" href=/documentation/tutorials/the_gambit_interface/>1 - The GAMBIT Interface</a></li></ul></div></li><li class=mb-1><button class="btn btn-toggle align-items-center rounded collapsed" data-bs-toggle=collapse data-bs-target=#section-help aria-expanded=false>
Help</button><div class=collapse id=section-help><ul class="btn-toggle-nav list-unstyled fw-normal pb-1 small"><li><a class="docs-link rounded" href=/documentation/help/common_problems_and_questions/>Common Problems and Questions</a></li><li><a class="docs-link rounded" href=/documentation/help/compiler_matrix/>Compiler Matrix</a></li><li><a class="docs-link rounded" href=/documentation/help/known_issues/>Known Issues</a></li><li><a class="docs-link rounded" href=/documentation/help/configuration_examples/>Configuration Examples</a></li></ul></div></li><li class=mb-1><button class="btn btn-toggle align-items-center rounded collapsed" data-bs-toggle=collapse data-bs-target=#section-code aria-expanded=false>
Code Reference</button><div class=collapse id=section-code><ul class="btn-toggle-nav list-unstyled fw-normal pb-1 small"><li><a class="docs-link rounded" href=/documentation/code/index_classes/>Classes</a></li><li><a class="docs-link rounded" href=/documentation/code/index_files/>Files</a></li><li><a class="docs-link rounded" href=/documentation/code/index_pages/>Pages</a></li><li><a class="docs-link rounded" href=/documentation/code/index_namespaces/>Namespaces</a></li></ul></div></li></ul></nav></div><nav class="docs-toc d-none d-xl-block col-xl-3" aria-label="Secondary navigation"><div class=d-xl-none><button class="btn btn-outline-primary btn-sm doks-toc-toggle collapsed" type=button data-bs-toggle=collapse data-bs-target=#onThisPage aria-controls=doks-docs-nav aria-expanded=false aria-label="Toggle On this page navigation">
<span>On this page</span>
<span><svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24" class="doks doks-expand" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><title>Expand</title><polyline points="7 13 12 18 17 13"/><polyline points="7 6 12 11 17 6"/></svg><svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24" class="doks doks-collapse" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><title>Collapse</title><polyline points="17 11 12 6 7 11"/><polyline points="17 18 12 13 7 18"/></svg></span></button><div class=collapse id=onThisPage><div class="card card-body mt-3 py-1"><div class=page-links><nav id=TableOfContents><ul><li><a href=#namespaces>Namespaces</a></li><li><a href=#classes>Classes</a></li><li><a href=#defines>Defines</a></li><li><a href=#detailed-description>Detailed Description</a></li><li><a href=#macros-documentation>Macros Documentation</a><ul><li><a href=#define-retrieve>define RETRIEVE</a></li><li><a href=#define-retrievefrom>define RETRIEVEFROM</a></li><li><a href=#define-labelnxn>define LABELNXN</a></li><li><a href=#define-label3x3diag>define LABEL3X3DIAG</a></li><li><a href=#define-getpar>define GETPAR</a></li></ul></li><li><a href=#source-code>Source code</a></li></ul></nav></div></div></div></div><div class="page-links d-none d-xl-block"><h3>On this page</h3><nav id=TableOfContents><ul><li><a href=#namespaces>Namespaces</a></li><li><a href=#classes>Classes</a></li><li><a href=#defines>Defines</a></li><li><a href=#detailed-description>Detailed Description</a></li><li><a href=#macros-documentation>Macros Documentation</a><ul><li><a href=#define-retrieve>define RETRIEVE</a></li><li><a href=#define-retrievefrom>define RETRIEVEFROM</a></li><li><a href=#define-labelnxn>define LABELNXN</a></li><li><a href=#define-label3x3diag>define LABEL3X3DIAG</a></li><li><a href=#define-getpar>define GETPAR</a></li></ul></li><li><a href=#source-code>Source code</a></li></ul></nav></div></nav><main class="docs-content col-lg-11 col-xl-9 mx-xl-auto"><nav aria-label=breadcrumb><ol class=breadcrumb><li class=breadcrumb-item><a href=/>Home</a></li><li class=breadcrumb-item><a href=/documentation/>Documentation</a></li><li class=breadcrumb-item><a href=/documentation/code/>Code Reference</a></li><li class="breadcrumb-item active" aria-current=page>file hdf5printer/hdf5printer/retrieve_overloads.cpp</li></ol></nav><p class=lead></p><h1 id=file-hdf5printer-hdf5printer-retrieve-overloads-cpp>file hdf5printer/hdf5printer/retrieve_overloads.cpp <a href=#file-hdf5printer-hdf5printer-retrieve-overloads-cpp class=anchor aria-hidden=true>#</a></h1><p>[No description available] <a href=#detailed-description>More&mldr;</a></p><h2 id=namespaces>Namespaces <a href=#namespaces class=anchor aria-hidden=true>#</a></h2><table><thead><tr><th>Name</th></tr></thead><tbody><tr><td><strong><a href=/documentation/code/namespaces/namespacegambit/>Gambit</a></strong><br>TODO: see if we can use this one:</td></tr><tr><td><strong><a href=/documentation/code/namespaces/namespacegambit_1_1printers/>Gambit::Printers</a></strong><br>Forward declaration.</td></tr></tbody></table><h2 id=classes>Classes <a href=#classes class=anchor aria-hidden=true>#</a></h2><table><thead><tr><th></th><th>Name</th></tr></thead><tbody><tr><td>struct</td><td><strong><a href=/documentation/code/classes/structgambit_1_1printers_1_1slhacombo/>Gambit::Printers::SLHAcombo</a></strong></td></tr></tbody></table><h2 id=defines>Defines <a href=#defines class=anchor aria-hidden=true>#</a></h2><table><thead><tr><th></th><th>Name</th></tr></thead><tbody><tr><td></td><td><strong><a href=/documentation/code/files/hdf5printer_2retrieve__overloads_8cpp/#define-retrieve>RETRIEVE</a></strong>(TYPE)<br>Retrieve functions.</td></tr><tr><td></td><td><strong><a href=/documentation/code/files/hdf5printer_2retrieve__overloads_8cpp/#define-retrievefrom>RETRIEVEFROM</a></strong>(INTYPE, OUTTYPE)</td></tr><tr><td></td><td><strong><a href=/documentation/code/files/hdf5printer_2retrieve__overloads_8cpp/#define-labelnxn>LABELNXN</a></strong>(N, baseentry, tag, block)</td></tr><tr><td></td><td><strong><a href=/documentation/code/files/hdf5printer_2retrieve__overloads_8cpp/#define-label3x3diag>LABEL3X3DIAG</a></strong>(baseentry, tag, block)</td></tr><tr><td></td><td><strong><a href=/documentation/code/files/hdf5printer_2retrieve__overloads_8cpp/#define-getpar>GETPAR</a></strong>(OUT, NAME, TAG, TEMP_INDEX)</td></tr></tbody></table><h2 id=detailed-description>Detailed Description <a href=#detailed-description class=anchor aria-hidden=true>#</a></h2><p><strong>Author</strong>:</p><ul><li>Ben Farmer (<a href=mailto:benjamin.farmer@monash.edu.au>benjamin.farmer@monash.edu.au</a>)</li><li>Pat Scott (<a href=mailto:p.scott@imperial.ac.uk>p.scott@imperial.ac.uk</a>)</li></ul><p><strong>Date</strong>:</p><ul><li>2017 Jan</li><li>2017 March</li></ul><p>HDF5 interface reaader class retrieve function overloads. Add a new overload of the _retrieve function in this file if you want to be able to read a new type for postprocessing.</p><hr><p>Authors (add name and date if you modify):</p><hr><h2 id=macros-documentation>Macros Documentation <a href=#macros-documentation class=anchor aria-hidden=true>#</a></h2><h3 id=define-retrieve>define RETRIEVE <a href=#define-retrieve class=anchor aria-hidden=true>#</a></h3><pre><code>#define RETRIEVE(
    TYPE
)
        _retrieve(TYPE&amp; out, const std::string&amp; l, const uint r, const ulong p) \
        { return  _retrieve_template(out,l,0,r,p); }
</code></pre><p>Retrieve functions.</p><p>Templatable retrieve functions</p><h3 id=define-retrievefrom>define RETRIEVEFROM <a href=#define-retrievefrom class=anchor aria-hidden=true>#</a></h3><pre><code>#define RETRIEVEFROM(
    INTYPE,
    OUTTYPE
)
        _retrieve(INTYPE&amp; out, const std::string&amp; l, const uint r, const ulong p) \
        { \
           OUTTYPE outtmp; \
           bool valid = _retrieve_template(outtmp,l,0,r,p); \
           out = (INTYPE)outtmp; \
           return valid; \
        }
</code></pre><h3 id=define-labelnxn>define LABELNXN <a href=#define-labelnxn class=anchor aria-hidden=true>#</a></h3><pre><code>#define LABELNXN(
    N,
    baseentry,
    tag,
    block
)
          for(int i=1; i&lt;=N; i++){ for(int j=1; j&lt;=N; j++) { \
            std::stringstream entry; \
            entry&lt;&lt;baseentry&lt;&lt;&quot;_(&quot;&lt;&lt;i&lt;&lt;&quot;,&quot;&lt;&lt;j&lt;&lt;&quot;)&quot;; \
            labels_to_SLHA[entry.str()] = SLHAcombo(tag, block, i, j); \
          }}
</code></pre><h3 id=define-label3x3diag>define LABEL3X3DIAG <a href=#define-label3x3diag class=anchor aria-hidden=true>#</a></h3><pre><code>#define LABEL3X3DIAG(
    baseentry,
    tag,
    block
)
          for(int i=1; i&lt;=3; i++){ \
            std::stringstream entry; \
            entry&lt;&lt;baseentry&lt;&lt;&quot;_(&quot;&lt;&lt;i&lt;&lt;&quot;,&quot;&lt;&lt;i&lt;&lt;&quot;)&quot;; \
            labels_to_SLHA[entry.str()] = SLHAcombo(tag, block, i, i); \
          }
</code></pre><h3 id=define-getpar>define GETPAR <a href=#define-getpar class=anchor aria-hidden=true>#</a></h3><pre><code>#define GETPAR(
    OUT,
    NAME,
    TAG,
    TEMP_INDEX
)
        { \
           bool found_tmp; \
           retrieve_and_add_to_SLHAea(out, found_tmp, spec_type, NAME, SLHAcombo(TAG, &quot;TEMP&quot;, TEMP_INDEX), all_dataset_labels, rank, pointID); \
           if(not found_tmp) \
           { \
              std::ostringstream err; \
              err&lt;&lt;&quot;Failed to find &quot;&lt;&lt;NAME&lt;&lt;&quot; (&quot;&lt;&lt;TAG&lt;&lt;&quot;) needed to compute SLHA spectrum information!&quot;; \
              printer_error().raise(LOCAL_INFO,err.str()); \
           } \
           OUT = SLHAea_get(out,&quot;TEMP&quot;,TEMP_INDEX); \
        }
</code></pre><h2 id=source-code>Source code <a href=#source-code class=anchor aria-hidden=true>#</a></h2><pre><code>//   GAMBIT: Global and Modular BSM Inference Tool
//   *********************************************
///  \file
///
///  HDF5 interface reaader class retrieve function
///  overloads.  Add a new overload of the _retrieve
///  function in this file if you want to be able
///  to read a new type for postprocessing.
///
///  *********************************************
///
///  Authors (add name and date if you modify):
///
///  \author Ben Farmer
///          (benjamin.farmer@monash.edu.au)
///  \date 2017 Jan
///
///  \author Pat Scott
///          (p.scott@imperial.ac.uk)
///  \date 2017 March
///
///  *********************************************

#include &quot;gambit/Printers/printers/hdf5reader.hpp&quot;
#include &quot;gambit/Printers/printers/hdf5printer.hpp&quot;

namespace Gambit
{
  namespace Printers
  {

     /// @{ Retrieve functions

     /// Templatable retrieve functions
     #define RETRIEVE(TYPE) _retrieve(TYPE&amp; out, const std::string&amp; l, const uint r, const ulong p) \
        { return  _retrieve_template(out,l,0,r,p); }
     bool HDF5Reader::RETRIEVE(int      )
     bool HDF5Reader::RETRIEVE(uint     )
     bool HDF5Reader::RETRIEVE(long     )
     bool HDF5Reader::RETRIEVE(ulong    )
     bool HDF5Reader::RETRIEVE(float    )
     bool HDF5Reader::RETRIEVE(double   )
     #undef RETRIEVE

     #define RETRIEVEFROM(INTYPE,OUTTYPE) _retrieve(INTYPE&amp; out, const std::string&amp; l, const uint r, const ulong p) \
        { \
           OUTTYPE outtmp; \
           bool valid = _retrieve_template(outtmp,l,0,r,p); \
           out = (INTYPE)outtmp; \
           return valid; \
        }
     bool HDF5Reader::RETRIEVEFROM(longlong, long)
     bool HDF5Reader::RETRIEVEFROM(ulonglong, ulong)
     #undef RETRIEVEFROM

     // Bools can't quite use the template function directly, since there
     // are some issues with bools and MPI/HDF5 types. Easier to just convert
     // the bool to an int first (this is how they are printed in the first place anyway).
     bool HDF5Reader::_retrieve(bool&amp; out, const std::string&amp; l, const uint rank, const ulong pID)
     {
       uint tmp_out;
       bool tmp_ret;
       tmp_ret = _retrieve_template(tmp_out,l,0,rank,pID);
       out = tmp_out;
       return tmp_ret;
     }

     bool HDF5Reader::_retrieve(ModelParameters&amp; out, const std::string&amp; modelname, const uint rank, const ulong pointID)
     {
        bool is_valid = true;
        /// Work out all the output labels which correspond to the input modelname
        bool found_at_least_one(false);

        //std::cout &lt;&lt; &quot;Searching for ModelParameters of model '&quot;&lt;&lt;modelname&lt;&lt;&quot;'&quot;&lt;&lt;std::endl;
        // Iterate through names in HDF5 group
        for(std::vector&lt;std::string&gt;::const_iterator
            it = all_datasets.begin();
            it!= all_datasets.end(); ++it)
        {
          //std::cout &lt;&lt; &quot;Candidate: &quot; &lt;&lt;*it&lt;&lt;std::endl;
          std::string param_name; // *output* of parsing function, parameter name
          std::string label_root; // *output* of parsing function, label minus parameter name
          if(parse_label_for_ModelParameters(*it, modelname, param_name, label_root))
          {
            // Add the found parameter name to the ModelParameters object
            out._definePar(param_name);
            if(found_at_least_one)
            {
              if(out.getOutputName()!=label_root)
              {
                std::ostringstream err;
                err &lt;&lt; &quot;Error! HDF5Reader could not retrieve ModelParameters matching the model name '&quot;
                    &lt;&lt;modelname&lt;&lt;&quot;' in the HDF5 file:group &quot;&lt;&lt;file&lt;&lt;&quot;:&quot;&lt;&lt;group
                    &lt;&lt;&quot;' (while calling 'retrieve'). Candidate parameters WERE found, however their dataset &quot;
                    &lt;&lt;&quot;labels indicate the presence of an inconsistency or ambiguity in the output. For &quot;
                    &lt;&lt;&quot;example, we just tried to retrive a model parameter from the dataset:\n  &quot;&lt;&lt;*it
                    &lt;&lt;&quot;\nand successfully found the parameter &quot;&lt;&lt;param_name
                    &lt;&lt;&quot;, however the root of the label, that is,\n  &quot;&lt;&lt;label_root
                    &lt;&lt;&quot;\ndoes not match the root expected based upon previous parameter retrievals for this &quot;
                    &lt;&lt;&quot;model, which was\n  &quot;&lt;&lt;out.getOutputName()&lt;&lt;&quot;\nThis may indicate that multiple sets &quot;
                    &lt;&lt;&quot;of model parameters are present in the output file for the same model! This is not &quot;
                    &lt;&lt;&quot;allowed, please report this bug against whatever master YAML file (or external code?) &quot;
                    &lt;&lt;&quot;produced the output file you are trying to read.&quot;;
                printer_error().raise(LOCAL_INFO,err.str());
              }
            }
            else
            {
              out.setOutputName(label_root);
            }
            // Get the corresponding value out of the data file
            double value; // *output* of retrieve function
            bool tmp_is_valid;
            tmp_is_valid = _retrieve(value, *it, rank, pointID);
            found_at_least_one = true;
            if(tmp_is_valid)
            {
               out.setValue(param_name, value);
            }
            else
            {
               // If one parameter value is 'invalid' then we cannot reconstruct
               // the ModelParameters object, so we mark the whole thing invalid.
               out.setValue(param_name, 0);
               is_valid = false;
            }
          }
        }

        if(not found_at_least_one)
        {
          // Didn't find any matches!
           std::ostringstream err;
           err &lt;&lt; &quot;Error! HDF5Reader failed to find any ModelParameters matching the model name '&quot;&lt;&lt;modelname&lt;&lt;&quot;' in the HDF5 file:group &quot;&lt;&lt;file&lt;&lt;&quot;:&quot;&lt;&lt;group&lt;&lt;&quot;' (while calling 'retrieve'). Please check that model name and input file/group are correct.&quot;;
           printer_error().raise(LOCAL_INFO,err.str());
        }
        /// done!
        return is_valid;
     }

     struct SLHAcombo
     {
        SLHAcombo(const std::string&amp; t, const std::string&amp; b, int i)
         : tag(t)
         , block(b)
         , indices{i}
        {}

        SLHAcombo(const std::string&amp; t, const std::string&amp; b, int i, int j)
         : tag(t)
         , block(b)
         , indices{i,j}
        {}

        SLHAcombo() : tag(), block(), indices() {}

        std::string tag;
        std::string block;
        std::vector&lt;int&gt; indices;
     };

     bool HDF5Reader::retrieve_and_add_to_SLHAea(SLHAstruct&amp; out, bool&amp; found, const std::string&amp; spec_type, const std::string&amp; entry, const SLHAcombo&amp; item, const std::set&lt;std::string&gt;&amp; all_dataset_labels, const uint rank, const ulong pointID)
     {
        std::string tag   = item.tag;
        std::string block = item.block;
        std::vector&lt;int&gt; indices = item.indices;

        // Create full dataset label
        std::stringstream dataset_label;
        dataset_label&lt;&lt;&quot;#&quot;&lt;&lt;spec_type&lt;&lt;&quot; @SpecBit::get_MSSM_spectrum_as_map::&quot;&lt;&lt;entry;
        if(tag!=&quot;&quot;) dataset_label&lt;&lt;&quot; &quot;&lt;&lt;tag;

        //std::cout&lt;&lt;dataset_label.str()&lt;&lt;std::endl;
        auto jt = all_dataset_labels.find(dataset_label.str());
        if(jt==all_dataset_labels.end())
        {
           found = false; // No entry with this name!
           return false;
        }
        else
        {
           found = true;
        }

        // Ok, found! Now retrieve the data
        double value = -999; // *output* of retrieve function
        bool tmp_is_valid = false;
        tmp_is_valid = _retrieve(value, dataset_label.str(), rank, pointID);
        //std::cout&lt;&lt;&quot;Spectrum entry found! entry:&quot;&lt;&lt;entry&lt;&lt;&quot;, tag:&quot;&lt;&lt;tag&lt;&lt;&quot;, valid:&quot;&lt;&lt;tmp_is_valid&lt;&lt;&quot;, value:&quot;&lt;&lt;value&lt;&lt;std::endl;
        if(tmp_is_valid)
        {
            // Stick entry into the SLHAea object
            SLHAea_check_block(out, block); // Make sure block exists first
            if(indices.size()==1)
            {
                SLHAea_add(out, block, indices.at(0), value, entry+&quot; (&quot;+tag+&quot;)&quot;);
            }
            else if(indices.size()==2)
            {
                SLHAea_add(out, block, indices.at(0), indices.at(1), value, entry+&quot; (&quot;+tag+&quot;)&quot;);
            }
            else
            {
                std::ostringstream err;
                err&lt;&lt;&quot;Received invalid number of target SLHA indices for dataset: &quot;&lt;&lt;dataset_label.str()&lt;&lt;std::endl&lt;&lt;&quot;Indices were: &quot;&lt;&lt;indices;
                printer_error().raise(LOCAL_INFO,err.str());
            }
        }
        return tmp_is_valid;
     }

     /// Retrieve (SLHA-only) SM spectrum information as an SLHAea object
     bool HDF5Reader::_retrieve(SMslha_SLHAstruct&amp; out_main, const std::string&amp; spec_type, const uint rank, const ulong pointID)
     {
        SLHAstruct&amp; out(out_main); // Interpret as ordinary SLHAea base class to get operator[] etc
        bool is_valid = true;
        std::map&lt;std::string,SLHAcombo&gt; labels_to_SLHA;

        // Read all dataset labels into a structure that we can search quickly
        std::set&lt;std::string&gt; all_dataset_labels = get_all_labels();

        // MASS
        labels_to_SLHA[&quot;Z0&quot;     ] = SLHAcombo(&quot;Pole_Mass&quot;, &quot;SMINPUTS&quot;, 4);
        labels_to_SLHA[&quot;W+&quot;     ] = SLHAcombo(&quot;Pole_Mass&quot;, &quot;MASS&quot;, 24);
        labels_to_SLHA[&quot;e-&quot;     ] = SLHAcombo(&quot;Pole_Mass&quot;, &quot;SMINPUTS&quot;, 11);
        labels_to_SLHA[&quot;mu-&quot;    ] = SLHAcombo(&quot;Pole_Mass&quot;, &quot;SMINPUTS&quot;, 13);
        labels_to_SLHA[&quot;tau-&quot;   ] = SLHAcombo(&quot;Pole_Mass&quot;, &quot;SMINPUTS&quot;, 7);
        labels_to_SLHA[&quot;t&quot;      ] = SLHAcombo(&quot;Pole_Mass&quot;, &quot;SMINPUTS&quot;, 6);
        labels_to_SLHA[&quot;b&quot;      ] = SLHAcombo(&quot;Pole_Mass&quot;, &quot;SMINPUTS&quot;, 5);
        labels_to_SLHA[&quot;nu_1&quot;   ] = SLHAcombo(&quot;Pole_Mass&quot;, &quot;SMINPUTS&quot;, 12);
        labels_to_SLHA[&quot;nu_2&quot;   ] = SLHAcombo(&quot;Pole_Mass&quot;, &quot;SMINPUTS&quot;, 14);
        labels_to_SLHA[&quot;nu_3&quot;   ] = SLHAcombo(&quot;Pole_Mass&quot;, &quot;SMINPUTS&quot;, 8);

        // Light quark running masses (always at 2 GeV, I think it is. Whatever SLHA standard says.)
        labels_to_SLHA[&quot;u_1&quot;   ] = SLHAcombo(&quot;mass1&quot;, &quot;SMINPUTS&quot;, 22);
        labels_to_SLHA[&quot;d_1&quot;   ] = SLHAcombo(&quot;mass1&quot;, &quot;SMINPUTS&quot;, 21);
        labels_to_SLHA[&quot;d_2&quot;   ] = SLHAcombo(&quot;mass1&quot;, &quot;SMINPUTS&quot;, 23);

        // Automatically extract and add the rest of the entries
        for(auto it=labels_to_SLHA.begin(); it!=labels_to_SLHA.end(); ++it)
        {
           bool found(true);
           bool tmp_is_valid = retrieve_and_add_to_SLHAea(out, found, spec_type, it-&gt;first, it-&gt;second, all_dataset_labels, rank, pointID);
           if(not found)
           {
              std::ostringstream err;
              err &lt;&lt; &quot;Error! HDF5Reader encountered an error while attempting to read a spectrum of type '&quot;&lt;&lt;spec_type&lt;&lt;&quot;' from the HDF5 file:group &quot;&lt;&lt;file&lt;&lt;&quot;:&quot;&lt;&lt;group&lt;&lt;&quot;' (while calling 'retrieve'). A required dataset could not be found (&quot;&lt;&lt;it-&gt;first&lt;&lt;&quot;)&quot;;
              printer_error().raise(LOCAL_INFO,err.str());
           }
           else if(not tmp_is_valid)
           {
              // No need to read any more if some required spectrum entries are invalid. Whole spectrum is invalid.
              is_valid = false;
              break;
           }
        }
        return is_valid;
      }

     /// Retrieve MSSM spectrum information as an SLHAea object
     bool HDF5Reader::_retrieve(MSSM_SLHAstruct&amp; out_main, const std::string&amp; spec_type, const uint rank, const ulong pointID)
     {
        SLHAstruct&amp; out(out_main); // Interpret as ordinary SLHAea base class to get operator[] etc
        bool is_valid = true;

        // Rather than iterate through the datasets, we know what entries we need to find, so we will just
        // directly look for them.
        // TODO: We can automate this after the SpecBit redesign, and probably
        // just use the spectrum &quot;setter&quot; functions to insert this data directly into Spectrum objects.
        // Unfortunately those don't exist in the current SimpleSpectrum objects, but they will exist after
        // the redesign.
        std::map&lt;std::string,SLHAcombo&gt; labels_to_SLHA;

        // MASS
        labels_to_SLHA[&quot;A0&quot;     ] = SLHAcombo(&quot;Pole_Mass&quot;, &quot;MASS&quot;, 36);
        labels_to_SLHA[&quot;H+&quot;     ] = SLHAcombo(&quot;Pole_Mass&quot;, &quot;MASS&quot;, 37);
        labels_to_SLHA[&quot;W+&quot;     ] = SLHAcombo(&quot;Pole_Mass&quot;, &quot;MASS&quot;, 24);
        labels_to_SLHA[&quot;h0_1&quot;   ] = SLHAcombo(&quot;Pole_Mass&quot;, &quot;MASS&quot;, 25);
        labels_to_SLHA[&quot;h0_2&quot;   ] = SLHAcombo(&quot;Pole_Mass&quot;, &quot;MASS&quot;, 35);
        labels_to_SLHA[&quot;~g&quot;     ] = SLHAcombo(&quot;Pole_Mass&quot;, &quot;MASS&quot;, 1000021);
        labels_to_SLHA[&quot;~chi+_1&quot;] = SLHAcombo(&quot;Pole_Mass&quot;, &quot;MASS&quot;, 1000024);
        labels_to_SLHA[&quot;~chi+_2&quot;] = SLHAcombo(&quot;Pole_Mass&quot;, &quot;MASS&quot;, 1000037);
        labels_to_SLHA[&quot;~chi0_1&quot;] = SLHAcombo(&quot;Pole_Mass&quot;, &quot;MASS&quot;, 1000022);
        labels_to_SLHA[&quot;~chi0_2&quot;] = SLHAcombo(&quot;Pole_Mass&quot;, &quot;MASS&quot;, 1000023);
        labels_to_SLHA[&quot;~chi0_3&quot;] = SLHAcombo(&quot;Pole_Mass&quot;, &quot;MASS&quot;, 1000025);
        labels_to_SLHA[&quot;~chi0_4&quot;] = SLHAcombo(&quot;Pole_Mass&quot;, &quot;MASS&quot;, 1000035);
        labels_to_SLHA[&quot;~d_1&quot;   ] = SLHAcombo(&quot;Pole_Mass&quot;, &quot;MASS&quot;, 1000001);
        labels_to_SLHA[&quot;~d_2&quot;   ] = SLHAcombo(&quot;Pole_Mass&quot;, &quot;MASS&quot;, 1000003);
        labels_to_SLHA[&quot;~d_3&quot;   ] = SLHAcombo(&quot;Pole_Mass&quot;, &quot;MASS&quot;, 1000005);
        labels_to_SLHA[&quot;~d_4&quot;   ] = SLHAcombo(&quot;Pole_Mass&quot;, &quot;MASS&quot;, 2000001);
        labels_to_SLHA[&quot;~d_5&quot;   ] = SLHAcombo(&quot;Pole_Mass&quot;, &quot;MASS&quot;, 2000003);
        labels_to_SLHA[&quot;~d_6&quot;   ] = SLHAcombo(&quot;Pole_Mass&quot;, &quot;MASS&quot;, 2000005);
        labels_to_SLHA[&quot;~u_1&quot;   ] = SLHAcombo(&quot;Pole_Mass&quot;, &quot;MASS&quot;, 1000002);
        labels_to_SLHA[&quot;~u_2&quot;   ] = SLHAcombo(&quot;Pole_Mass&quot;, &quot;MASS&quot;, 1000004);
        labels_to_SLHA[&quot;~u_3&quot;   ] = SLHAcombo(&quot;Pole_Mass&quot;, &quot;MASS&quot;, 1000006);
        labels_to_SLHA[&quot;~u_4&quot;   ] = SLHAcombo(&quot;Pole_Mass&quot;, &quot;MASS&quot;, 2000002);
        labels_to_SLHA[&quot;~u_5&quot;   ] = SLHAcombo(&quot;Pole_Mass&quot;, &quot;MASS&quot;, 2000004);
        labels_to_SLHA[&quot;~u_6&quot;   ] = SLHAcombo(&quot;Pole_Mass&quot;, &quot;MASS&quot;, 2000006);
        labels_to_SLHA[&quot;~e-_1&quot;  ] = SLHAcombo(&quot;Pole_Mass&quot;, &quot;MASS&quot;, 1000011);
        labels_to_SLHA[&quot;~e-_2&quot;  ] = SLHAcombo(&quot;Pole_Mass&quot;, &quot;MASS&quot;, 1000013);
        labels_to_SLHA[&quot;~e-_3&quot;  ] = SLHAcombo(&quot;Pole_Mass&quot;, &quot;MASS&quot;, 1000015);
        labels_to_SLHA[&quot;~e-_4&quot;  ] = SLHAcombo(&quot;Pole_Mass&quot;, &quot;MASS&quot;, 2000011);
        labels_to_SLHA[&quot;~e-_5&quot;  ] = SLHAcombo(&quot;Pole_Mass&quot;, &quot;MASS&quot;, 2000013);
        labels_to_SLHA[&quot;~e-_6&quot;  ] = SLHAcombo(&quot;Pole_Mass&quot;, &quot;MASS&quot;, 2000015);
        labels_to_SLHA[&quot;~nu_1&quot;  ] = SLHAcombo(&quot;Pole_Mass&quot;, &quot;MASS&quot;, 1000012);
        labels_to_SLHA[&quot;~nu_2&quot;  ] = SLHAcombo(&quot;Pole_Mass&quot;, &quot;MASS&quot;, 1000014);
        labels_to_SLHA[&quot;~nu_3&quot;  ] = SLHAcombo(&quot;Pole_Mass&quot;, &quot;MASS&quot;, 1000016);
        // Standard Model masses. Turns out we do need to retrieve these, since
        // they might have shifted from SMINPUTS in the spectrum generation process.


        // MSOFT
        labels_to_SLHA[&quot;M1&quot;  ] = SLHAcombo(&quot;mass1&quot;, &quot;MSOFT&quot;, 1);
        labels_to_SLHA[&quot;M2&quot;  ] = SLHAcombo(&quot;mass1&quot;, &quot;MSOFT&quot;, 2);
        labels_to_SLHA[&quot;M3&quot;  ] = SLHAcombo(&quot;mass1&quot;, &quot;MSOFT&quot;, 3);
        labels_to_SLHA[&quot;mHd2&quot;] = SLHAcombo(&quot;mass2&quot;, &quot;MSOFT&quot;, 21);
        labels_to_SLHA[&quot;mHu2&quot;] = SLHAcombo(&quot;mass2&quot;, &quot;MSOFT&quot;, 22);

        // HMIX
        labels_to_SLHA[&quot;Mu&quot;]  = SLHAcombo(&quot;mass1&quot;, &quot;HMIX&quot;, 1);
        // Need these two for Higgs vev and tanbeta. Not SLHA, so store in TEMP block temporarily.
        //labels_to_SLHA[&quot;vd&quot;]  = SLHAcombo(&quot;mass1&quot;, &quot;TEMP&quot;, 1);
        //labels_to_SLHA[&quot;vu&quot;]  = SLHAcombo(&quot;mass1&quot;, &quot;TEMP&quot;, 2);
        //labels_to_SLHA[&quot;mA2&quot;] = SLHAcombo(&quot;mass2&quot;, &quot;HMIX&quot;, 4);

        // TD, TU, TE
        #define LABELNXN(N,baseentry,tag,block) \
          for(int i=1; i&lt;=N; i++){ for(int j=1; j&lt;=N; j++) { \
            std::stringstream entry; \
            entry&lt;&lt;baseentry&lt;&lt;&quot;_(&quot;&lt;&lt;i&lt;&lt;&quot;,&quot;&lt;&lt;j&lt;&lt;&quot;)&quot;; \
            labels_to_SLHA[entry.str()] = SLHAcombo(tag, block, i, j); \
          }}
        LABELNXN(3,&quot;TYd&quot;,&quot;mass1&quot;,&quot;TD&quot;)
        LABELNXN(3,&quot;TYu&quot;,&quot;mass1&quot;,&quot;TU&quot;)
        LABELNXN(3,&quot;TYe&quot;,&quot;mass1&quot;,&quot;TE&quot;)

        // MSQ2, MSL2, MSD2, MSU2, MSE2
        LABELNXN(3,&quot;mq2&quot;,&quot;mass2&quot;,&quot;MSQ2&quot;)
        LABELNXN(3,&quot;ml2&quot;,&quot;mass2&quot;,&quot;MSL2&quot;)
        LABELNXN(3,&quot;md2&quot;,&quot;mass2&quot;,&quot;MSD2&quot;)
        LABELNXN(3,&quot;mu2&quot;,&quot;mass2&quot;,&quot;MSU2&quot;)
        LABELNXN(3,&quot;me2&quot;,&quot;mass2&quot;,&quot;MSE2&quot;)

        // NMIX, UMIX, VMIX
        LABELNXN(4,&quot;~chi0&quot;,&quot;Pole_Mixing&quot;,&quot;NMIX&quot;)
        LABELNXN(2,&quot;~chi-&quot;,&quot;Pole_Mixing&quot;,&quot;UMIX&quot;)
        LABELNXN(2,&quot;~chi+&quot;,&quot;Pole_Mixing&quot;,&quot;VMIX&quot;)

        // USQMIX, DSQMIX, SELMIX, SNUMIX
        LABELNXN(6,&quot;~u&quot;,&quot;Pole_Mixing&quot;,&quot;USQMIX&quot;)
        LABELNXN(6,&quot;~d&quot;,&quot;Pole_Mixing&quot;,&quot;DSQMIX&quot;)
        LABELNXN(6,&quot;~e-&quot;,&quot;Pole_Mixing&quot;,&quot;SELMIX&quot;)
        LABELNXN(3,&quot;~nu&quot;,&quot;Pole_Mixing&quot;,&quot;SNUMIX&quot;)

        // SCALARMIX, PSEUDOSCALARMIX, CHARGEMIX
        // TODO: These are not SLHA! Will be
        // changed after SpecBit redesign
        LABELNXN(2,&quot;h0&quot;,&quot;Pole_Mixing&quot;,&quot;SCALARMIX&quot;)
        LABELNXN(2,&quot;A0&quot;,&quot;Pole_Mixing&quot;,&quot;PSEUDOSCALARMIX&quot;)
        LABELNXN(2,&quot;H+&quot;,&quot;Pole_Mixing&quot;,&quot;CHARGEMIX&quot;)
        #undef LABELNXN

        // YD, YU, YE
        #define LABEL3X3DIAG(baseentry,tag,block) \
          for(int i=1; i&lt;=3; i++){ \
            std::stringstream entry; \
            entry&lt;&lt;baseentry&lt;&lt;&quot;_(&quot;&lt;&lt;i&lt;&lt;&quot;,&quot;&lt;&lt;i&lt;&lt;&quot;)&quot;; \
            labels_to_SLHA[entry.str()] = SLHAcombo(tag, block, i, i); \
          }
        LABEL3X3DIAG(&quot;Yd&quot;,&quot;dimensionless&quot;,&quot;YD&quot;)
        LABEL3X3DIAG(&quot;Yu&quot;,&quot;dimensionless&quot;,&quot;YU&quot;)
        LABEL3X3DIAG(&quot;Ye&quot;,&quot;dimensionless&quot;,&quot;YE&quot;)
        #undef LABEL3X3DIAG

        // GAUGE
        labels_to_SLHA[&quot;g2&quot;] = SLHAcombo(&quot;dimensionless&quot;, &quot;GAUGE&quot;, 2);
        labels_to_SLHA[&quot;g3&quot;] = SLHAcombo(&quot;dimensionless&quot;, &quot;GAUGE&quot;, 3);

        // Read all dataset labels into a structure that we can search quickly
        std::set&lt;std::string&gt; all_dataset_labels = get_all_labels();

        // Macro to help retrive parameters for custom calculations
        #define GETPAR(OUT,NAME,TAG,TEMP_INDEX) \
        { \
           bool found_tmp; \
           retrieve_and_add_to_SLHAea(out, found_tmp, spec_type, NAME, SLHAcombo(TAG, &quot;TEMP&quot;, TEMP_INDEX), all_dataset_labels, rank, pointID); \
           if(not found_tmp) \
           { \
              std::ostringstream err; \
              err&lt;&lt;&quot;Failed to find &quot;&lt;&lt;NAME&lt;&lt;&quot; (&quot;&lt;&lt;TAG&lt;&lt;&quot;) needed to compute SLHA spectrum information!&quot;; \
              printer_error().raise(LOCAL_INFO,err.str()); \
           } \
           OUT = SLHAea_get(out,&quot;TEMP&quot;,TEMP_INDEX); \
        }

        // Manually compute tanb and mA2
        double vd,vu,BMu;
        GETPAR(vd,&quot;vd&quot;,&quot;mass1&quot;,1)
        GETPAR(vu,&quot;vu&quot;,&quot;mass1&quot;,2)
        GETPAR(BMu,&quot;BMu&quot;,&quot;mass2&quot;,4)

        const double tb = vu/vd;
        const double cb = cos(atan(tb));
        const double c2b = cos(2*atan(tb));
        const double sb = sin(atan(tb));
        const double vev = sqrt(vu*vu + vd*vd);
        const double mA2 = BMu / (cb*sb);

        double g1,g2,gprime;
        GETPAR(g1,&quot;g1&quot;,&quot;dimensionless&quot;,31)
        GETPAR(g2,&quot;g2&quot;,&quot;dimensionless&quot;,32)
        gprime = g1*sqrt(3./5.);

        const double sin2thetaW = (gprime*gprime) / (gprime*gprime + g2*g2);

        double TYu3,yt; // 3rd gen trilinear and Yukawa
        GETPAR(TYu3,&quot;TYu_(3,3)&quot;,&quot;mass1&quot;,41)
        GETPAR(yt,&quot;Yu_(3,3)&quot;,&quot;dimensionless&quot;,42)
        const double At = TYu3 / yt;

        // Tree level Z and top masses, needed for MSUSY reconstruction
        // for old data sets where the scale was not saved in output
        const double MZ = (1/2.)*sqrt(gprime*gprime + g2*g2)*vev;
        const double Mt = yt*vu/sqrt(2.);

        double Mu;
        GETPAR(Mu,&quot;Mu&quot;,&quot;mass1&quot;,51)
        // stop mixing parameter
        const double Xt = At - Mu / tb;

        double mq2_3, mu2_3;
        GETPAR(mq2_3,&quot;mq2_(3,3)&quot;,&quot;mass2&quot;,20)
        GETPAR(mu2_3,&quot;mu2_(3,3)&quot;,&quot;mass2&quot;,21)

        // reconstruct stop masses
        const double A = mq2_3 + mu2_3 + 0.5*MZ*MZ*c2b + 2*Mt*Mt;
        const double B = mq2_3 - mu2_3 + (0.5-(4./3.)*sin2thetaW)*MZ*MZ*c2b;
        const double m2st1 = 0.5*(A - sqrt(B*B + 4*Mt*Mt*Xt*Xt));
        const double m2st2 = 0.5*(A + sqrt(B*B + 4*Mt*Mt*Xt*Xt));

        // assuming no family mixing
        const double MSUSY = sqrt(sqrt(m2st1)*sqrt(m2st2));
        #undef GETPAR

        // Read the &quot;scale&quot; entry, since we need to add this info to the block
        // top rows.
        double scale;
        bool found(true);
        retrieve_and_add_to_SLHAea(out, found, spec_type, &quot;scale(Q)&quot;, SLHAcombo(&quot;&quot;, &quot;TEMP&quot;, 0), all_dataset_labels, rank, pointID);
        if(not found)
        {
           // In some older datasets we forgot to add the scale to the output.
           // For now we will assume the spectrum was output by FlexibleSUSY, in which case
           // the running parameters will be defined at the SUSY scale (geometric mean of
           // DRbar stop masses). TODO: Set this behaviour with an option, maybe? Not sure how though.

           // Proper calculation of DRbar stop masses, from https://arxiv.org/pdf/0904.2169.pdf Eq. 29 (with non-MSSM bits removed)
           // We assume that there is no flavour/family mixing, which is true for all our scans so far.
           // TODO: Make sure that scale is output if we do have this mixing in the future!
           // Retrieve extra needed values first
           scale = MSUSY;
        }
        else
        {
           scale = SLHAea_get(out,&quot;TEMP&quot;,0);
        }

        // Add blocks that require scale info
        SLHAea_add_block(out, &quot;GAUGE&quot;, scale);
        SLHAea_add_block(out, &quot;YU&quot;, scale);
        SLHAea_add_block(out, &quot;YD&quot;, scale);
        SLHAea_add_block(out, &quot;YE&quot;, scale);
        SLHAea_add_block(out, &quot;TU&quot;, scale);
        SLHAea_add_block(out, &quot;TD&quot;, scale);
        SLHAea_add_block(out, &quot;TE&quot;, scale);
        SLHAea_add_block(out, &quot;HMIX&quot;, scale);
        SLHAea_add_block(out, &quot;MSQ2&quot;, scale);
        SLHAea_add_block(out, &quot;MSL2&quot;, scale);
        SLHAea_add_block(out, &quot;MSD2&quot;, scale);
        SLHAea_add_block(out, &quot;MSU2&quot;, scale);
        SLHAea_add_block(out, &quot;MSE2&quot;, scale);
        SLHAea_add_block(out, &quot;MSOFT&quot;, scale);

        // Automatically extract and add the rest of the entries
        for(auto it=labels_to_SLHA.begin(); it!=labels_to_SLHA.end(); ++it)
        {
           bool found(true);
           bool tmp_is_valid = retrieve_and_add_to_SLHAea(out, found, spec_type, it-&gt;first, it-&gt;second, all_dataset_labels, rank, pointID);
           if(not found)
           {
              std::ostringstream err;
              err &lt;&lt; &quot;Error! HDF5Reader encountered an error while attempting to read a spectrum of type '&quot;&lt;&lt;spec_type&lt;&lt;&quot;' from the HDF5 file:group &quot;&lt;&lt;file&lt;&lt;&quot;:&quot;&lt;&lt;group&lt;&lt;&quot;' (while calling 'retrieve'). A required dataset could not be found (&quot;&lt;&lt;it-&gt;first&lt;&lt;&quot;)&quot;;
              printer_error().raise(LOCAL_INFO,err.str());
           }
           else if(not tmp_is_valid)
           {
              // No need to read any more if some required spectrum entries are invalid. Whole spectrum is invalid.
              is_valid = false;
              break;
           }
        }

        // Need to manually fix up a few entries where we didn't store the spectrum info directly
        // in SLHA format.
        if(is_valid)
        {
           SLHAea_add(out, &quot;HMIX&quot;, 2, tb, &quot;tan beta (Q)&quot;);
           SLHAea_add(out, &quot;HMIX&quot;, 3, vev, &quot;Higgs vev (Q)&quot;);
           SLHAea_add(out, &quot;HMIX&quot;, 4, mA2, &quot;m_A^2 = BMu/(cb*sb) (Q)&quot;);
           // Normalisation of g1
           SLHAea_add(out, &quot;GAUGE&quot;, 1, gprime, &quot;g' (Q)&quot;, true);

           // Add off-diagonal Yukawa terms (all zero due to SLHA conventions, but
           // we require them internally due to automated handling of matrices
           // We do this here rather than read the zeros from the output in case we
           // don't bother to output them in the future.
           std::vector&lt;std::string&gt; blocks = {&quot;Yu&quot;,&quot;Yd&quot;,&quot;Ye&quot;};
           for(auto it=blocks.begin(); it!=blocks.end(); ++it)
           {
              for(int i=1; i&lt;=3; i++){ for(int j=1; j&lt;=3; j++) {
                 std::stringstream label;
                 label&lt;&lt;(*it)&lt;&lt;&quot;_(&quot;&lt;&lt;i&lt;&lt;&quot;,&quot;&lt;&lt;j&lt;&lt;&quot;)&quot;;
                 if(i!=j) SLHAea_add(out, (*it), i, j, 0, label.str());
              }}
           }
        }

        return is_valid;
     }


     bool HDF5Reader::_retrieve(std::vector&lt;double&gt;&amp; /*out*/,  const std::string&amp; /*label*/, const uint /*rank*/, const ulong /*pointID*/)
     { printer_error().raise(LOCAL_INFO,&quot;NOT YET IMPLEMENTED&quot;); return false; }
     bool HDF5Reader::_retrieve(map_str_dbl&amp; /*out*/,          const std::string&amp; /*label*/, const uint /*rank*/, const ulong /*pointID*/)
     { printer_error().raise(LOCAL_INFO,&quot;NOT YET IMPLEMENTED&quot;); return false; }
     bool HDF5Reader::_retrieve(map_str_str&amp; /*out*/,          const std::string&amp; /*label*/, const uint /*rank*/, const ulong /*pointID*/)
     { printer_error().raise(LOCAL_INFO,&quot;NOT YET IMPLEMENTED&quot;); return false; }
     bool HDF5Reader::_retrieve(map_const_str_dbl&amp; /*out*/,    const std::string&amp; /*label*/, const uint /*rank*/, const ulong /*pointID*/)
     { printer_error().raise(LOCAL_INFO,&quot;NOT YET IMPLEMENTED&quot;); return false; }
     bool HDF5Reader::_retrieve(map_str_map_str_dbl&amp; /*out*/,  const std::string&amp; /*label*/, const uint /*rank*/, const ulong /*pointID*/)
     { printer_error().raise(LOCAL_INFO,&quot;NOT YET IMPLEMENTED&quot;); return false; }
     bool HDF5Reader::_retrieve(map_const_str_map_const_str_dbl&amp; /*out*/, const std::string&amp; /*label*/, const uint /*rank*/, const ulong /*pointID*/)
     { printer_error().raise(LOCAL_INFO,&quot;NOT YET IMPLEMENTED&quot;); return false; }
     bool HDF5Reader::_retrieve(triplet&lt;double&gt;&amp; /*out*/,      const std::string&amp; /*label*/, const uint /*rank*/, const ulong /*pointID*/)
     { printer_error().raise(LOCAL_INFO,&quot;NOT YET IMPLEMENTED&quot;); return false; }
     bool HDF5Reader::_retrieve(map_intpair_dbl&amp; /*out*/,      const std::string&amp; /*label*/, const uint /*rank*/, const ulong /*pointID*/)
     { printer_error().raise(LOCAL_INFO,&quot;NOT YET IMPLEMENTED&quot;); return false; }
     bool HDF5Reader::_retrieve(flav_prediction&amp; /*out*/,      const std::string&amp; /*label*/, const uint /*rank*/, const ulong /*pointID*/)
     { printer_error().raise(LOCAL_INFO,&quot;NOT YET IMPLEMENTED&quot;); return false; }

     #ifndef SCANNER_STANDALONE // All the types inside HDF5_BACKEND_TYPES need to go inside this def guard.

       bool HDF5Reader::_retrieve(DM_nucleon_couplings&amp; /*out*/, const std::string&amp; /*label*/, const uint /*rank*/, const ulong /*pointID*/)
       { printer_error().raise(LOCAL_INFO,&quot;NOT YET IMPLEMENTED&quot;); return false; }
       bool HDF5Reader::_retrieve(BBN_container&amp; /*out*/, const std::string&amp; /*label*/, const uint /*rank*/, const ulong /*pointID*/)
       { printer_error().raise(LOCAL_INFO,&quot;NOT YET IMPLEMENTED&quot;); return false; }

     #endif

     /// Helper function to parse a capability name to a dataset name
     void HDF5Reader::parse_capability_label(const std::string&amp; capability_label, std::string&amp; dataset_label)
     {
       // Set the dataset label to default to the given label
       dataset_label = capability_label;

       // Do the rest only if the label does not have the form of a dataset name
       if(capability_label[0] == '#')
         return ;

       std::stringstream ss;
       ss &lt;&lt; &quot;#&quot; &lt;&lt; capability_label;

       for(auto dataset : all_datasets)
       {
          // Find the capability name from the dataset and compare
          std::string cap = Utils::delimiterSplit(dataset,&quot; &quot;)[0];
          if(ss.str() == cap)
            dataset_label = dataset;
       }
     }



     /// @}

  }
}
</code></pre><hr><p>Updated on 2023-06-26 at 21:36:54 +0000</p></main></div></div></div><footer class="footer text-muted"><div class=container-xxl><div class=row><div class="col-lg-8 order-last order-lg-first"><ul class=list-inline><li class=list-inline-item>Powered by <a href=https://gohugo.io/>Hugo</a> and <a href=https://getdoks.org/>Doks</a></li></ul></div><div class="col-lg-8 order-first order-lg-last text-lg-end"><ul class=list-inline><li class=list-inline-item><a href=/license/>License</a></li></ul></div></div></div></footer><script src=/js/bootstrap.min.a08b5ca912a508bc013bbd939befee438a0d2f798076e860e42147c7c0e2a01cf714847f7f5a2824876ce72867b0182df10e3537711faff352dd1ef41550be7c.js integrity="sha512-oItcqRKlCLwBO72Tm+/uQ4oNL3mAduhg5CFHx8DioBz3FIR/f1ooJIds5yhnsBgt8Q41N3Efr/NS3R70FVC+fA==" crossorigin=anonymous defer></script>
<script src=/js/highlight.min.ce91dadbce67e8eef36fa222c1c74c99f623c836cf6a316dffa1aeb390ab659d9a20d8145ceac39e049c555414fc360d31315e7980535dc6c03eb5374b7d559d.js integrity="sha512-zpHa285n6O7zb6IiwcdMmfYjyDbPajFt/6Gus5CrZZ2aINgUXOrDngScVVQU/DYNMTFeeYBTXcbAPrU3S31VnQ==" crossorigin=anonymous defer></script>
<script src=/main.min.57d9a84956f7d60008c47938c7fdd2f75e8618ff1d09c5a5e2b32f91debaf7681f7ceca8b51aded60067c2136172134a91ebc0674487c76a04e3244d927ebdde.js integrity="sha512-V9moSVb31gAIxHk4x/3S916GGP8dCcWl4rMvkd6692gffOyotRre1gBnwhNhchNKkevAZ0SHx2oE4yRNkn693g==" crossorigin=anonymous defer></script>
<script src=https://gambitbsm.org/index.min.95720397d55302de0e04fb8f4bf89a7396888a3be86803aa187cbc45924e9c35452b4bef718cd568b25ad872307d8f5537eab4c0045b8043c40628674a4fc53d.js integrity="sha512-lXIDl9VTAt4OBPuPS/iac5aIijvoaAOqGHy8RZJOnDVFK0vvcYzVaLJa2HIwfY9VN+q0wARbgEPEBihnSk/FPQ==" crossorigin=anonymous defer></script></body></html>