<!doctype html><html lang=en><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="ie=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><link rel=preload as=font href=https://gambitbsm.org/fonts/vendor/jost/jost-v4-latin-regular.woff2 type=font/woff2 crossorigin><link rel=preload as=font href=https://gambitbsm.org/fonts/vendor/jost/jost-v4-latin-500.woff2 type=font/woff2 crossorigin><link rel=preload as=font href=https://gambitbsm.org/fonts/vendor/jost/jost-v4-latin-700.woff2 type=font/woff2 crossorigin><script>(()=>{var e=localStorage.getItem("theme");e==="dark"&&document.documentElement.setAttribute("data-dark-mode","")})()</script><link rel=stylesheet href=https://gambitbsm.org/main.e0ef67572fa591316dbb2b276e1aed52fd04025355d700a37b20ae76eb126fadbe7ceaddbb47632a2f1bf66c490a69e0cd1f1a0dc12b2980ae4b5ffc6d257d62.css integrity="sha512-4O9nVy+lkTFtuysnbhrtUv0EAlNV1wCjeyCudusSb62+fOrdu0djKi8b9mxJCmngzR8aDcErKYCuS1/8bSV9Yg==" crossorigin=anonymous><noscript><style>img.lazyload{display:none}</style></noscript><meta name=robots content="index, follow"><meta name=googlebot content="index, follow, max-snippet:-1, max-image-preview:large, max-video-preview:-1"><meta name=bingbot content="index, follow, max-snippet:-1, max-image-preview:large, max-video-preview:-1"><title>file Elements/daFunk.hpp - GAMBIT</title><meta name=description content="[No description available]"><link rel=canonical href=https://gambitbsm.org/documentation/code/files/dafunk_8hpp/><meta property="og:locale" content="en_US"><meta property="og:type" content="article"><meta property="og:title" content="file Elements/daFunk.hpp"><meta property="og:description" content="[No description available]"><meta property="og:url" content="https://gambitbsm.org/documentation/code/files/dafunk_8hpp/"><meta property="og:site_name" content="GAMBIT"><meta property="og:image" content="https://gambitbsm.org/gambit_logo.png"><meta property="og:image:alt" content="GAMBIT"><meta name=twitter:card content="summary_large_image"><meta name=twitter:site content><meta name=twitter:creator content><meta name=twitter:title content="file Elements/daFunk.hpp"><meta name=twitter:description content="[No description available]"><meta name=twitter:image content="https://gambitbsm.org/gambit_logo.png"><meta name=twitter:image:alt content="file Elements/daFunk.hpp"><script type=application/ld+json>{"@context":"https://schema.org","@graph":[{"@type":"Organization","@id":"https://gambitbsm.org/#/schema/organization/1","name":"Doks","url":"https://gambitbsm.org/","sameAs":["https://github.com/GambitBSM"],"logo":{"@type":"ImageObject","@id":"https://gambitbsm.org/#/schema/image/1","url":"https://gambitbsm.org/logo-doks.png","width":450,"height":416,"caption":"Doks"},"image":{"@id":"https://gambitbsm.org/#/schema/image/1"}},{"@type":"WebSite","@id":"https://gambitbsm.org/#/schema/website/1","url":"https://gambitbsm.org/","name":"GAMBIT","description":"Documentation for GAMBIT, the Global And Modular BSM Inference Tool","publisher":{"@id":"https://gambitbsm.org/#/schema/organization/1"}},{"@type":"WebPage","@id":"https://gambitbsm.org/documentation/code/files/dafunk_8hpp/","url":"https://gambitbsm.org/documentation/code/files/dafunk_8hpp/","name":"file Elements\/daFunk.hpp","description":"[No description available]","isPartOf":{"@id":"https://gambitbsm.org/#/schema/website/1"},"about":{"@id":"https://gambitbsm.org/#/schema/organization/1"},"datePublished":"0001-01-01T00:00:00CET","dateModified":"0001-01-01T00:00:00CET","breadcrumb":{"@id":"https://gambitbsm.org/documentation/code/files/dafunk_8hpp/#/schema/breadcrumb/1"},"primaryImageOfPage":{"@id":"https://gambitbsm.org/documentation/code/files/dafunk_8hpp/#/schema/image/2"},"inLanguage":"en-US","potentialAction":[{"@type":"ReadAction","target":["https://gambitbsm.org/documentation/code/files/dafunk_8hpp/"]}]},{"@type":"BreadcrumbList","@id":"https://gambitbsm.org/documentation/code/files/dafunk_8hpp/#/schema/breadcrumb/1","name":"Breadcrumbs","itemListElement":[{"@type":"ListItem","position":1,"item":{"@type":"WebPage","@id":"https://gambitbsm.org/","url":"https://gambitbsm.org/","name":"Home"}},{"@type":"ListItem","position":2,"item":{"@type":"WebPage","@id":"https://gambitbsm.org/documentation/","url":"https://gambitbsm.org/documentation/","name":"Documentation"}},{"@type":"ListItem","position":3,"item":{"@type":"WebPage","@id":"https://gambitbsm.org/documentation/code/","url":"https://gambitbsm.org/documentation/code/","name":"Code"}},{"@type":"ListItem","position":4,"item":{"@type":"WebPage","@id":"https://gambitbsm.org/documentation/code/files/","url":"https://gambitbsm.org/documentation/code/files/","name":"Files"}},{"@type":"ListItem","position":5,"item":{"@id":"https://gambitbsm.org/documentation/code/files/dafunk_8hpp/"}}]},{"@context":"https://schema.org","@graph":[{"@type":"ImageObject","@id":"https://gambitbsm.org/documentation/code/files/dafunk_8hpp/#/schema/image/2","url":"https://gambitbsm.org/gambit_logo.png","contentUrl":"https://gambitbsm.org/gambit_logo.png","caption":"file Elements\/daFunk.hpp"}]}]}</script><meta name=theme-color content="#fff"><link rel=icon href=https://gambitbsm.org/favicon.ico sizes=any><link rel=icon type=image/svg+xml href=https://gambitbsm.org/favicon.svg><link rel=apple-touch-icon sizes=180x180 href=https://gambitbsm.org/apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=https://gambitbsm.org/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=https://gambitbsm.org/favicon-16x16.png><link rel=manifest crossorigin=use-credentials href=https://gambitbsm.org/site.webmanifest></head><body class="documentation single light"><div class=sticky-top><div class=header-bar></div><header class="navbar navbar-expand-md navbar-light doks-navbar"><nav class="container-xxl flex-wrap flex-md-nowrap" aria-label="Main navigation"><a class="navbar-brand p-0 me-auto" href=https://gambitbsm.org/ aria-label=GAMBIT><img class=logo-light src=https://gambitbsm.org/gambit_logo.png width=50px>
<img class="logo-dark d-none" src=https://gambitbsm.org/gambit_logo.png width=50px>
GAMBIT</a>
<button class="btn btn-menu order-2 d-block d-lg-none" type=button data-bs-toggle=offcanvas data-bs-target=#offcanvasDoks aria-controls=offcanvasDoks aria-label="Open main menu"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-menu"><line x1="3" y1="12" x2="21" y2="12"/><line x1="3" y1="6" x2="21" y2="6"/><line x1="3" y1="18" x2="21" y2="18"/></svg></button><div class="offcanvas offcanvas-end border-0 py-lg-1" tabindex=-1 id=offcanvasDoks data-bs-backdrop=true aria-labelledby=offcanvasDoksLabel><div class="header-bar d-lg-none"></div><div class="offcanvas-header d-lg-none"><h2 class="h5 offcanvas-title ps-2" id=offcanvasDoksLabel><a class=text-dark href=/>GAMBIT</a></h2><button type=button class="btn-close text-reset me-2" data-bs-dismiss=offcanvas aria-label="Close main menu"></button></div><div class="offcanvas-body p-4 p-lg-0"><ul class="nav flex-column flex-lg-row align-items-lg-center mt-2 mt-lg-0 ms-lg-2 me-lg-auto"><li class="nav-item dropdown"><a class="nav-link dropdown-toggle ps-0 py-1" href=# id=navbarDropdownMenuLink role=button data-bs-toggle=dropdown aria-expanded=false>Releases
<span class=dropdown-caret><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-chevron-down"><polyline points="6 9 12 15 18 9"/></svg></span></a><ul class="dropdown-menu dropdown-menu-main shadow rounded border-0" aria-labelledby=navbarDropdownMenuLink><li><a class=dropdown-item href=https://github.com/GambitBSM/gambit_2.6>GAMBIT 2-6 ⧉</a></li><li><a class=dropdown-item href=https://github.com/GambitBSM/gambit_2.5>GAMBIT 2-5 ⧉</a></li><li><a class=dropdown-item href=https://github.com/GambitBSM/gambit_2.4>GAMBIT 2-4 ⧉</a></li><li><a class=dropdown-item href=https://github.com/GambitBSM/gambit_2.3>GAMBIT 2-3 ⧉</a></li><li><a class=dropdown-item href=https://github.com/GambitBSM/gambit_2.2>GAMBIT 2-2 ⧉</a></li><li><a class=dropdown-item href=https://github.com/GambitBSM/gambit_2.1>GAMBIT 2-1 ⧉</a></li><li><a class=dropdown-item href=https://github.com/GambitBSM/gambit_light_1.0>GAMBIT Light ⧉</a></li><li><a class=dropdown-item href=https://github.com/GambitBSM/gambit_2.6/tags>All releases ⧉</a></li></ul></li><li class="nav-item dropdown"><a class="nav-link dropdown-toggle ps-0 py-1" href=# id=navbarDropdownMenuLink role=button data-bs-toggle=dropdown aria-expanded=false>Documentation
<span class=dropdown-caret><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-chevron-down"><polyline points="6 9 12 15 18 9"/></svg></span></a><ul class="dropdown-menu dropdown-menu-main shadow rounded border-0" aria-labelledby=navbarDropdownMenuLink><li><a class=dropdown-item href=/documentation/installation/introduction/>Installation</a></li><li><a class=dropdown-item href=/documentation/physics/analyses>Physics</a></li><li><a class=dropdown-item href=/documentation/tutorials/the_gambit_interface>Tutorials</a></li><li><a class=dropdown-item href=/documentation/help/common_problems_and_questions/>Help</a></li><li><a class=dropdown-item href=/documentation/code/index_classes>Code Reference</a></li></ul></li><li class="nav-item dropdown"><a class="nav-link dropdown-toggle ps-0 py-1" href=# id=navbarDropdownMenuLink role=button data-bs-toggle=dropdown aria-expanded=false>Community
<span class=dropdown-caret><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-chevron-down"><polyline points="6 9 12 15 18 9"/></svg></span></a><ul class="dropdown-menu dropdown-menu-main shadow rounded border-0" aria-labelledby=navbarDropdownMenuLink><li><a class=dropdown-item href=https://github.com/GambitBSM/wiki>Wiki</a></li><li><a class=dropdown-item href=/community/publications/>Publications</a></li><li><a class=dropdown-item href=/community/talks/>Talks</a></li><li><a class=dropdown-item href=/community/members/>Members</a></li><li><a class=dropdown-item href=/community/code_of_conduct/>Code of Conduct</a></li><li><a class="dropdown-item active" href=/community/contact/ aria-current=true>Contact</a></li></ul></li></ul><hr class="text-black-50 my-4 d-lg-none"><form class="doks-search position-relative flex-grow-1 ms-lg-auto me-lg-2"><input id=search class="form-control is-search" type=search placeholder="Search site..." aria-label="Search site..." autocomplete=off><div id=suggestions class="shadow bg-white rounded d-none"></div></form><hr class="text-black-50 my-4 d-lg-none"><ul class="nav flex-column flex-lg-row"><li class=nav-item><a class="nav-link social-link" href=https://github.com/GambitBSM><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-github"><path d="M9 19c-5 1.5-5-2.5-7-3m14 6v-3.87a3.37 3.37.0 00-.94-2.61c3.14-.35 6.44-1.54 6.44-7A5.44 5.44.0 0020 4.77 5.07 5.07.0 0019.91 1S18.73.65 16 2.48a13.38 13.38.0 00-7 0C6.27.65 5.09 1 5.09 1A5.07 5.07.0 005 4.77 5.44 5.44.0 003.5 8.55c0 5.42 3.3 6.61 6.44 7A3.37 3.37.0 009 18.13V22"/></svg><small class="ms-2 d-lg-none">GitHub</small></a></li></ul><hr class="text-black-50 my-4 d-lg-none"><button id=mode class="btn btn-link" type=button aria-label="Toggle user interface mode">
<span class=toggle-dark><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-moon"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg></span><span class=toggle-light><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-sun"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></span></button></div></div></nav></header></div><div class="wrap container-xxl" role=document><div class=content><div class="row flex-xl-nowrap"><div class="col-lg-5 col-xl-4 docs-sidebar"><nav class=docs-links aria-label="Main navigation"><ul class="list-unstyled collapsible-sidebar"><li class=mb-1><button class="btn btn-toggle align-items-center rounded collapsed" data-bs-toggle=collapse data-bs-target=#section-installation aria-expanded=false>
Installation</button><div class=collapse id=section-installation><ul class="btn-toggle-nav list-unstyled fw-normal pb-1 small"><li><a class="docs-link rounded" href=/documentation/installation/introduction/>Getting Started</a></li><li><a class="docs-link rounded" href=/documentation/installation/docker_usage/>Docker Usage</a></li><li><a class="docs-link rounded" href=/documentation/installation/installation_for_linux/>Installation for Linux</a></li><li><a class="docs-link rounded" href=/documentation/installation/installation_for_windows/>Installation for Windows</a></li><li><a class="docs-link rounded" href=/documentation/installation/installation_for_macos/>Installation for macOS</a></li></ul></div></li><li class=mb-1><button class="btn btn-toggle align-items-center rounded collapsed" data-bs-toggle=collapse data-bs-target=#section-tutorials aria-expanded=false>
Tutorials</button><div class=collapse id=section-tutorials><ul class="btn-toggle-nav list-unstyled fw-normal pb-1 small"><li><a class="docs-link rounded" href=/documentation/tutorials/the_gambit_interface/>1 - The GAMBIT Interface</a></li><li><a class="docs-link rounded" href=/documentation/tutorials/in_person_tutorials/>In person tutorials</a></li></ul></div></li><li class=mb-1><button class="btn btn-toggle align-items-center rounded collapsed" data-bs-toggle=collapse data-bs-target=#section-physics aria-expanded=false>
Physics</button><div class=collapse id=section-physics><ul class="btn-toggle-nav list-unstyled fw-normal pb-1 small"><li><a class="docs-link rounded" href=/documentation/physics/analyses/>ColliderBit analysis</a></li></ul></div></li><li class=mb-1><button class="btn btn-toggle align-items-center rounded collapsed" data-bs-toggle=collapse data-bs-target=#section-help aria-expanded=false>
Help</button><div class=collapse id=section-help><ul class="btn-toggle-nav list-unstyled fw-normal pb-1 small"><li><a class="docs-link rounded" href=/documentation/help/common_problems_and_questions/>Common Problems and Questions</a></li><li><a class="docs-link rounded" href=/documentation/help/compiler_matrix/>Compiler Matrix</a></li><li><a class="docs-link rounded" href=/documentation/help/known_issues/>Known Issues</a></li><li><a class="docs-link rounded" href=/documentation/help/configuration_examples/>Configuration Examples</a></li><li><a class="docs-link rounded" href=/documentation/help/support/>Support</a></li></ul></div></li><li class=mb-1><button class="btn btn-toggle align-items-center rounded collapsed" data-bs-toggle=collapse data-bs-target=#section-code aria-expanded=false>
Code Reference</button><div class=collapse id=section-code><ul class="btn-toggle-nav list-unstyled fw-normal pb-1 small"><li><a class="docs-link rounded" href=/documentation/code/index_classes/>Classes</a></li><li><a class="docs-link rounded" href=/documentation/code/index_files/>Files</a></li><li><a class="docs-link rounded" href=/documentation/code/index_pages/>Pages</a></li><li><a class="docs-link rounded" href=/documentation/code/index_namespaces/>Namespaces</a></li></ul></div></li></ul></nav></div><nav class="docs-toc d-none d-xl-block col-xl-3" aria-label="Secondary navigation"><div class=d-xl-none><button class="btn btn-outline-primary btn-sm doks-toc-toggle collapsed" type=button data-bs-toggle=collapse data-bs-target=#onThisPage aria-controls=doks-docs-nav aria-expanded=false aria-label="Toggle On this page navigation">
<span>On this page</span>
<span><svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24" class="doks doks-expand" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><title>Expand</title><polyline points="7 13 12 18 17 13"/><polyline points="7 6 12 11 17 6"/></svg><svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24" class="doks doks-collapse" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><title>Collapse</title><polyline points="17 11 12 6 7 11"/><polyline points="17 18 12 13 7 18"/></svg></span></button><div class=collapse id=onThisPage><div class="card card-body mt-3 py-1"><div class=page-links><nav id=TableOfContents><ul><li><a href=#namespaces>Namespaces</a></li><li><a href=#classes>Classes</a></li><li><a href=#defines>Defines</a></li><li><a href=#macros-documentation>Macros Documentation</a><ul><li><a href=#define-def-funktrait>define DEF_FUNKTRAIT</a></li><li><a href=#define-math-operation>define MATH_OPERATION</a></li><li><a href=#define-math-operation-1>define MATH_OPERATION</a></li><li><a href=#define-math-operation-2>define MATH_OPERATION</a></li></ul></li><li><a href=#source-code>Source code</a></li></ul></nav></div></div></div></div><div class="page-links d-none d-xl-block"><h3>On this page</h3><nav id=TableOfContents><ul><li><a href=#namespaces>Namespaces</a></li><li><a href=#classes>Classes</a></li><li><a href=#defines>Defines</a></li><li><a href=#macros-documentation>Macros Documentation</a><ul><li><a href=#define-def-funktrait>define DEF_FUNKTRAIT</a></li><li><a href=#define-math-operation>define MATH_OPERATION</a></li><li><a href=#define-math-operation-1>define MATH_OPERATION</a></li><li><a href=#define-math-operation-2>define MATH_OPERATION</a></li></ul></li><li><a href=#source-code>Source code</a></li></ul></nav></div></nav><main class="docs-content col-lg-11 col-xl-9 mx-xl-auto"><nav aria-label=breadcrumb><ol class=breadcrumb><li class=breadcrumb-item><a href=/>Home</a></li><li class=breadcrumb-item><a href=/documentation/>Documentation</a></li><li class=breadcrumb-item><a href=/documentation/code/>Code Reference</a></li><li class="breadcrumb-item active" aria-current=page>file Elements/daFunk.hpp</li></ol></nav><p class=lead></p><h1 id=file-elements-dafunk-hpp>file Elements/daFunk.hpp <a href=#file-elements-dafunk-hpp class=anchor aria-hidden=true>#</a></h1><p>[No description available]</p><h2 id=namespaces>Namespaces <a href=#namespaces class=anchor aria-hidden=true>#</a></h2><table><thead><tr><th>Name</th></tr></thead><tbody><tr><td><strong><a href=/documentation/code/namespaces/namespacedafunk/>daFunk</a></strong></td></tr><tr><td><strong><a href=/documentation/code/namespaces/namespacedafunk_1_1detail/>daFunk::detail</a></strong></td></tr></tbody></table><h2 id=classes>Classes <a href=#classes class=anchor aria-hidden=true>#</a></h2><table><thead><tr><th></th><th>Name</th></tr></thead><tbody><tr><td>struct</td><td><strong><a href=/documentation/code/classes/structdafunk_1_1index__list/>daFunk::index_list</a></strong></td></tr><tr><td>struct</td><td><strong><a href=/documentation/code/classes/structdafunk_1_1detail_1_1range__builder_3_01min_00_01min_00_01is_8_8_8_01_4/>daFunk::detail::range_builder&lt; MIN, MIN, Is&mldr; ></a></strong></td></tr><tr><td>struct</td><td><strong><a href=/documentation/code/classes/structdafunk_1_1detail_1_1range__builder/>daFunk::detail::range_builder</a></strong></td></tr><tr><td>class</td><td><strong><a href=/documentation/code/classes/classdafunk_1_1funkbase/>daFunk::FunkBase</a></strong></td></tr><tr><td>class</td><td><strong><a href=/documentation/code/classes/classdafunk_1_1livingvector/>daFunk::livingVector</a></strong></td></tr><tr><td>class</td><td><strong><a href=/documentation/code/classes/classdafunk_1_1funkbound/>daFunk::FunkBound</a></strong></td></tr><tr><td>class</td><td><strong><a href=/documentation/code/classes/classdafunk_1_1funkplain/>daFunk::FunkPlain</a></strong></td></tr><tr><td>class</td><td><strong><a href=/documentation/code/classes/classdafunk_1_1funkconst/>daFunk::FunkConst</a></strong></td></tr><tr><td>class</td><td><strong><a href=/documentation/code/classes/classdafunk_1_1funkderived/>daFunk::FunkDerived</a></strong></td></tr><tr><td>class</td><td><strong><a href=/documentation/code/classes/classdafunk_1_1funkfunc/>daFunk::FunkFunc</a></strong></td></tr><tr><td>class</td><td><strong><a href=/documentation/code/classes/classdafunk_1_1funkfuncm/>daFunk::FunkFuncM</a></strong></td></tr><tr><td>class</td><td><strong><a href=/documentation/code/classes/classdafunk_1_1funkdelta/>daFunk::FunkDelta</a></strong></td></tr><tr><td>class</td><td><strong><a href=/documentation/code/classes/classdafunk_1_1funkvar/>daFunk::FunkVar</a></strong></td></tr><tr><td>class</td><td><strong><a href=/documentation/code/classes/classdafunk_1_1funkmath__umin/>daFunk::FunkMath_umin</a></strong></td></tr><tr><td>class</td><td><strong><a href=/documentation/code/classes/classdafunk_1_1funkinterp/>daFunk::FunkInterp</a></strong></td></tr><tr><td>class</td><td><strong><a href=/documentation/code/classes/classdafunk_1_1funkifelse/>daFunk::FunkIfElse</a></strong></td></tr><tr><td>class</td><td><strong><a href=/documentation/code/classes/classdafunk_1_1throwerror/>daFunk::ThrowError</a></strong></td></tr><tr><td>class</td><td><strong><a href=/documentation/code/classes/classdafunk_1_1bottle/>daFunk::Bottle</a></strong></td></tr><tr><td>class</td><td><strong><a href=/documentation/code/classes/classdafunk_1_1funkintegrate__gsl1d/>daFunk::FunkIntegrate_gsl1d</a></strong></td></tr></tbody></table><h2 id=defines>Defines <a href=#defines class=anchor aria-hidden=true>#</a></h2><table><thead><tr><th></th><th>Name</th></tr></thead><tbody><tr><td></td><td><strong><a href=/documentation/code/files/dafunk_8hpp/#define-def-funktrait>DEF_FUNKTRAIT</a></strong>(C)</td></tr><tr><td></td><td><strong><a href=/documentation/code/files/dafunk_8hpp/#define-math-operation>MATH_OPERATION</a></strong>(OPERATION)</td></tr><tr><td></td><td><strong><a href=/documentation/code/files/dafunk_8hpp/#define-math-operation>MATH_OPERATION</a></strong>(OPERATION, SYMBOL)</td></tr><tr><td></td><td><strong><a href=/documentation/code/files/dafunk_8hpp/#define-math-operation>MATH_OPERATION</a></strong>(OPERATION)</td></tr></tbody></table><h2 id=macros-documentation>Macros Documentation <a href=#macros-documentation class=anchor aria-hidden=true>#</a></h2><h3 id=define-def-funktrait>define DEF_FUNKTRAIT <a href=#define-def-funktrait class=anchor aria-hidden=true>#</a></h3><pre><code>#define DEF_FUNKTRAIT(
    C
)
class C {                                           \
    public:                                         \
        static daFunk::FunkPlain* ptr;              \
        static void set(daFunk::FunkPlain* new_ptr) \
        {                                           \
            delete ptr;                             \
            ptr = new_ptr;                          \
        }                                           \
};                                                  \
daFunk::FunkPlain* C::ptr = NULL;
</code></pre><h3 id=define-math-operation>define MATH_OPERATION <a href=#define-math-operation class=anchor aria-hidden=true>#</a></h3><pre><code>#define MATH_OPERATION(
    OPERATION
)
    class FunkMath_##OPERATION: public FunkBase                                                           \
    {                                                                                                     \
        public:                                                                                           \
            FunkMath_##OPERATION(Funk f)                                                                  \
            {                                                                                             \
                functions = vec(f);                                                                       \
                arguments = f-&gt;getArgs();                                                                 \
                singularities = f-&gt;getSingl();                                                            \
            }                                                                                             \
            double value(const std::vector&lt;double&gt; &amp; data, size_t bindID)                                       \
            {                                                                                             \
                return OPERATION(functions[0]-&gt;value(data, bindID));                                      \
            }                                                                                             \
    };                                                                                                    \
    inline Funk OPERATION (Funk f) { return Funk(new FunkMath_##OPERATION(f)); }
</code></pre><h3 id=define-math-operation-1>define MATH_OPERATION <a href=#define-math-operation-1 class=anchor aria-hidden=true>#</a></h3><pre><code>#define MATH_OPERATION(
    OPERATION,
    SYMBOL
)

</code></pre><h3 id=define-math-operation-2>define MATH_OPERATION <a href=#define-math-operation-2 class=anchor aria-hidden=true>#</a></h3><pre><code>#define MATH_OPERATION(
    OPERATION
)
    class FunkMath_##OPERATION: public FunkBase                                                           \
    {                                                                                                     \
        public:                                                                                           \
            FunkMath_##OPERATION(Funk f)                                                                  \
            {                                                                                             \
                functions = vec(f);                                                                       \
                arguments = f-&gt;getArgs();                                                                 \
                singularities = f-&gt;getSingl();                                                            \
            }                                                                                             \
            double value(const std::vector&lt;double&gt; &amp; data, size_t bindID)                                       \
            {                                                                                             \
                return OPERATION(functions[0]-&gt;value(data, bindID));                                      \
            }                                                                                             \
    };                                                                                                    \
    inline Funk OPERATION (Funk f) { return Funk(new FunkMath_##OPERATION(f)); }
</code></pre><h2 id=source-code>Source code <a href=#source-code class=anchor aria-hidden=true>#</a></h2><pre><code>/*
 * _______
 * \  ___ `'.                                 _..._        .
 *  ' |--.\  \                _.._          .'     '.    .'|
 *  | |    \  '             .' .._|        .   .-.   . .'  |
 *  | |     |  '    __      | '            |  '   '  |&lt;    |
 *  | |     |  | .:--.'.  __| |__  _    _  |  |   |  | |   | ____
 *  | |     ' .'/ |   \ ||__   __|| '  / | |  |   |  | |   | \ .'
 *  | |___.' /' `&quot; __ | |   | |  .' | .' | |  |   |  | |   |/  .
 * /_______.'/   .'.''| |   | |  /  | /  | |  |   |  | |    /\  \
 * \_______|/   / /   | |_  | | |   `'.  | |  |   |  | |   |  \  \
 *              \ \._,\ '/  | | '   .'|  '/|  |   |  | '    \  \  \
 *               `--'  `&quot;   |_|  `-'  `--' '--'   '--''------'  '---'
 *
 *                         daFunk - dynamisch allokierbare Funktionen
 *
 *  v0.1 Dec 2014
 *  v0.2 Mar 2015 - Completely rewritten internal structure
 *  v0.3 May 2016 - Extensions
 *
 *  Christoph Weniger, created Dec 2014, edited until May 2016
 *  &lt;c.weniger@uva.nl&gt;
 *
 *  with contributions related to thread-safety from
 *  Lars A. Dal, Apr, Jun 2015
 *  &lt;l.a.dal@fys.uio.no&gt;
 *
 *
 *
 * The MIT License (MIT)
 *
 * Copyright (c) 2016 Christoph Weniger
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of
 * this software and associated documentation files (the &quot;Software&quot;), to deal in
 * the Software without restriction, including without limitation the rights to
 * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies
 * of the Software, and to permit persons to whom the Software is furnished to do
 * so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */

#ifndef __DAFUNK_HPP__
#define __DAFUNK_HPP__

#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;algorithm&gt;
#include &lt;map&gt;
#include &lt;set&gt;
#include &lt;cmath&gt;
#include &lt;stdexcept&gt;

//#define NDEBUG
#include &lt;assert.h&gt;

//#define GAMBIT_DIR

#ifdef GAMBIT_DIR
#include &lt;omp.h&gt;
#include &quot;gambit/Utils/standalone_error_handlers.hpp&quot;
#include &quot;gambit/Utils/util_macros.hpp&quot;
#endif

#include &quot;boost/shared_ptr.hpp&quot;
#include &quot;boost/enable_shared_from_this.hpp&quot;

//#include &lt;memory&gt;
//using std::shared_ptr;
//using std::enable_shared_from_this;

namespace daFunk {class FunkPlain;}

#define DEF_FUNKTRAIT(C)                            \
class C {                                           \
    public:                                         \
        static daFunk::FunkPlain* ptr;              \
        static void set(daFunk::FunkPlain* new_ptr) \
        {                                           \
            delete ptr;                             \
            ptr = new_ptr;                          \
        }                                           \
};                                                  \
daFunk::FunkPlain* C::ptr = NULL;

// Extensions
#include &lt;gsl/gsl_integration.h&gt;
#include &lt;gsl/gsl_errno.h&gt;

namespace daFunk
{
    //
    // Type declarations etc.
    //

    using boost::shared_ptr;
    using boost::enable_shared_from_this;
    using boost::dynamic_pointer_cast;
    using boost::static_pointer_cast;

    class FunkBase;
    class FunkBound;
    class FunkIntegrate_gsl1d;

    typedef shared_ptr&lt;FunkBase&gt; Funk;
    typedef shared_ptr&lt;FunkBound&gt; BoundFunk;
    typedef std::vector&lt;std::string&gt; ArgsType;
    typedef std::map&lt;std::string, std::vector&lt;std::pair&lt;Funk, Funk&gt;&gt;&gt; Singularities;

    //template &lt;typename... Args&gt;
    //using PlainPtr = double(*)(Args&amp;...);
    typedef double(*PlainPtr1)(double&amp;);
    typedef double(*PlainPtr2)(double&amp;,double&amp;);
    typedef double(*PlainPtr3)(double&amp;,double&amp;,double&amp;);
    typedef double(*PlainPtr4)(double&amp;,double&amp;,double&amp;,double&amp;);

    //template &lt;typename... Args&gt;
    //using PlainPtrs = std::pair&lt;double(*)(Args...,void*), void*&gt;;
    typedef std::pair&lt;double(*)(double,void*), void*&gt; PlainPtrs1;
    typedef std::pair&lt;double(*)(double,double,void*), void*&gt; PlainPtrs2;
    typedef std::pair&lt;double(*)(double,double,double,void*), void*&gt; PlainPtrs3;
    typedef std::pair&lt;double(*)(double,double,double,double,void*), void*&gt; PlainPtrs4;


    //
    // Vector initialization from argument list
    //
    // Usage: std::vector&lt;T&gt; v = vec&lt;T&gt;(v1, v2, v3, ...);
    //

    template &lt;typename T&gt;
    inline std::vector&lt;T&gt; vec(std::vector&lt;T&gt; vector)
    {
        return vector;
    }
    template &lt;typename T, typename... Args&gt;
    inline std::vector&lt;T&gt; vec(std::vector&lt;T&gt; vector, T value, Args... args)
    {
        vector.push_back(value);
        return vec&lt;T&gt;(vector, args...);
    }
    template &lt;typename T, typename... Args&gt;
    inline std::vector&lt;T&gt; vec(T value, Args... args)
    {
        std::vector&lt;T&gt; vector;
        vector.push_back(value);
        vector = vec&lt;T&gt;(vector, args...);
        return vector;
    }
    template &lt;typename T&gt;
    inline std::vector&lt;T&gt; vec()
    {
        std::vector&lt;T&gt; vector;
        return vector;
    }

    //
    // Math helper functions
    //

    // Generate linear 1-dim grid
    inline std::vector&lt;double&gt; linspace(double x0, double x1, unsigned int n)
    {
        std::vector&lt;double&gt; ret;
        double dx = 0;
        if (n &gt; 1)
            dx = (x1-x0)/(n-1);
        for (unsigned int i = 0; i&lt;n; i++)
        {
            ret.push_back(x0 + i * dx);
        }
        return ret;
    }

    // Generate logarithmic 1-dim grid
    inline std::vector&lt;double&gt; logspace(double x0, double x1, unsigned int n)
    {
        std::vector&lt;double&gt; ret;
        double dx = 0;
        if (n &gt; 1)
            dx = (x1-x0)/(n-1);
        for (unsigned int i = 0; i&lt;n; i++)
        {
            ret.push_back(pow(10, x0 + i * dx));
        }
        return ret;
    }


    //
    // Helper functions for internal calculations
    //

    inline bool args_match(ArgsType args1, ArgsType args2)
    {
        bool m = true;
        for ( auto it = args1.begin(); it!=args1.end(); it++ )
        {
            if ( std::find(args2.begin(), args2.end(), *it) == args2.end() )
                m = false;
        }
        if ( args1.size() != args2.size() ) m = false;
        return m;
    }

    inline std::string args_string(ArgsType args)
    {
        std::string msg = &quot;&quot;;
        for ( auto it = args.begin(); it!=args.end(); it++ )
        {
            msg += *it;
            if ( it != args.end() - 1)
                msg += &quot;, &quot;;
        }
        return msg;
    }

    inline ArgsType joinArgs(ArgsType args1, ArgsType args2)
    {
        args1.insert(args1.end(), args2.begin(), args2.end());
        std::set&lt;std::string&gt; argsset(args1.begin(), args1.end());
        args1.assign(argsset.begin(), argsset.end());
        return args1;
    }

    inline ArgsType eraseArg(ArgsType args, std::string arg)
    {
        auto it = std::find(args.begin(), args.end(), arg);
        if (it!=args.end()) args.erase(it);
        return args;
    }

    inline Singularities joinSingl(Singularities s1, Singularities s2)
    {
        for ( auto it = s2.begin(); it != s2.end(); ++it )
        {
            if ( s1.find(it-&gt;first) == s1.end() )
                s1[it-&gt;first] = it-&gt;second;
            else
            {
                for ( auto it2 = it-&gt;second.begin(); it2 != it-&gt;second.end(); ++it2 )
                {
                    if ( std::find(s1[it-&gt;first].begin(), s1[it-&gt;first].end(), *it2) == s1[it-&gt;first].end() )
                        s1[it-&gt;first].push_back(*it2);
                }
            }
        }
        return s1;
    }


    //
    // Index lists (taken from stackoverflow)
    //

    // The structure that encapsulates index lists
    template &lt;size_t... Is&gt;
    struct index_list
    {
    };

    // Collects internal details for generating index ranges [MIN, MAX)
    namespace detail
    {
        // Declare primary template for index range builder
        template &lt;size_t MIN, size_t N, size_t... Is&gt;
        struct range_builder;

        // Base step
        template &lt;size_t MIN, size_t... Is&gt;
        struct range_builder&lt;MIN, MIN, Is...&gt;
        {
            typedef index_list&lt;Is...&gt; type;
        };

        // Induction step
        template &lt;size_t MIN, size_t N, size_t... Is&gt;
        struct range_builder : public range_builder&lt;MIN, N - 1, N - 1, Is...&gt;
        {
        };
    }


    //
    // **** The central virtual base class ****
    //

    class FunkBase: public enable_shared_from_this&lt;FunkBase&gt;
    {
        public:
            FunkBase() {};
            virtual ~FunkBase() {};

            // Standard setting handles
            template &lt;typename... Args&gt; Funk set(std::string arg, Funk g, Args... args);
            template &lt;typename... Args&gt; Funk set(std::string arg, double x, Args... args);
            template &lt;typename... Args&gt; Funk set(std::string arg, std::string arg1, Args... args);
            template &lt;typename... Args&gt; Funk set();

            // Standard binding handles
            template &lt;typename... Args&gt; shared_ptr&lt;FunkBound&gt; bind(Args... args);

            // Convenience functions
            const std::vector&lt;std::string&gt; &amp; getArgs() { return this-&gt;arguments; };
            std::size_t getNArgs() {return this-&gt;arguments.size();};
            bool hasArg(std::string);
            bool hasArgs();
            Funk help();
            template &lt;typename... Args&gt; bool assert_args(Args... args);

            // Return value &amp; standard resolve
            virtual double value(const std::vector&lt;double&gt; &amp;, size_t bindID) = 0;

            // datamap maps the required function arguments onto the specific
            // entries in the double-valued data array generated by eval().
            // datalen acts like a pointer on the last entry of that array, and
            // can be increased if more workspace is required.  bindID ensures
            // that resolution for various different binds can happen in
            // parallel with the same Funk objects.
            virtual void resolve(std::map&lt;std::string, size_t&gt; datamap, size_t &amp; datalen, size_t bindID, std::map&lt;std::string,size_t&gt; &amp;argmap);


            // Singularities handling
            Singularities getSingl() { return singularities; }
        private:  // Note: This works currently only for constant functions
            Funk set_singularity(std::string arg, Funk pos, Funk width);
            Funk set_singularity(std::string arg, double pos, Funk width);
            Funk set_singularity(std::string arg, Funk pos, double width);
        public:
            Funk set_singularity(std::string arg, double pos, double width);

            // Print message
            Funk print(std::string arg);


            //
            // &quot;External&quot; functions
            //

            // Integration
            template &lt;typename... Args&gt; shared_ptr&lt;FunkIntegrate_gsl1d&gt; gsl_integration(Args... args);

            // Plain function generators
            PlainPtrs1 plain(std::string);
            PlainPtrs2 plain(std::string, std::string);
            PlainPtrs3 plain(std::string, std::string, std::string);
            PlainPtrs4 plain(std::string, std::string, std::string, std::string);
            template &lt;typename T&gt;
            PlainPtr1 plain(std::string);
            template &lt;typename T&gt;
            PlainPtr2 plain(std::string, std::string);
            template &lt;typename T&gt;
            PlainPtr3 plain(std::string, std::string, std::string);
            template &lt;typename T&gt;
            PlainPtr4 plain(std::string, std::string, std::string, std::string);

        protected:
            std::vector&lt;Funk&gt; functions;  // Dependent functions
            ArgsType arguments;  // Argument names
            std::vector&lt;std::vector&lt;size_t&gt; &gt; indices;  // Indices for data object
            size_t datalen;
            Singularities singularities;
    };

    // A vector class with global knowledge about its health status.
    // (BoundFunk objects are occasionally destructed *after* livingVector has
    // been destructed, causing segfaults if not catched properly.)
    class livingVector: public std::vector&lt;size_t&gt;
    {
        public:
            ~livingVector()
            {
                livingVector::is_dead() = true;
            }
            static bool &amp; is_dead()
            {
                static bool dead = false;
                return dead;
            }
    };

    class FunkBound
    {
        public:
            FunkBound(Funk f, size_t datalen, size_t bindID) : f(f), datalen(datalen), bindID(bindID) {};
            ~FunkBound() {bindID_manager(bindID,false);};
            double value(std::vector&lt;double&gt; &amp; map, size_t bindID) {(void)bindID; (void)map; return 0;};

            template &lt;typename... Args&gt; inline double eval(Args... argss)
            {
                auto data = vec&lt;double&gt;(argss...);
                data.resize(datalen);
                return f-&gt;value(data, bindID);
            }

            template &lt;typename... Args&gt; inline std::vector&lt;double&gt; vect(Args... argss)
            {
                std::vector&lt;std::vector&lt;double&gt;&gt; coll;
                return this-&gt;vect2(coll, argss...);
            }

        private:
            template &lt;typename... Args&gt;
            friend shared_ptr&lt;FunkBound&gt; FunkBase::bind(Args... argss);
            // Function for generating unique bindIDs.
            // IDs are sequential, starting from 0.
            static void bindID_manager(size_t &amp;bindID, bool bind)
            {
              static size_t n_idx = 0;
              static livingVector free;
              if(bind)
              {
                #pragma omp critical (bindID_allocation)
                {
                    if(free.empty())
                    {
                        // Increment after assignment (n_idx++ instead of ++n_idx)
                        bindID = n_idx++;
                    }
                    else
                    {
                        bindID = free.back();
                        free.pop_back();
                    }
                }
              }
              else
              {
                    if ( not livingVector::is_dead() )
                    {
                        #pragma omp critical (bindID_allocation)
                        free.push_back(bindID);
                    }
              }
            }
            template &lt;typename... Args&gt; inline std::vector&lt;double&gt; vect2(std::vector&lt;std::vector&lt;double&gt;&gt; &amp; coll)
            {
                size_t size = 1;
                std::vector&lt;bool&gt; vec_flag;
                for ( auto it = coll.begin(); it != coll.end(); ++it )
                {
                    if ( it-&gt;size() == 1 )
                    {
                        vec_flag.push_back(false);
                        continue;
                    }
                    vec_flag.push_back(true);
                    if ( size == 1 ) size = it-&gt;size();
                    if ( size != it-&gt;size() )
                    {
                        std::cerr &lt;&lt; &quot;daFunk::FunkBase WARNING: Inconsistent vector lengths.&quot; &lt;&lt; std::endl;
                        return vec&lt;double&gt;();
                    }
                }
                auto r = vec&lt;double&gt;();
                auto data = vec&lt;double&gt;();
                data.resize(datalen);
                for ( size_t i = 0; i != size; ++i )
                {
                    for ( size_t j = 0; j != coll.size(); ++j )
                    {
                        if ( vec_flag[j] )
                            data[j] = coll[j][i];
                        else
                            data[j] = coll[j][0];
                    }
                    r.push_back(f-&gt;value(data, bindID));
                }
                return r;
            }

            template &lt;typename... Args&gt; inline std::vector&lt;double&gt; vect2(std::vector&lt;std::vector&lt;double&gt;&gt; &amp; coll, double x, Args... argss)
            {
                coll.push_back(vec&lt;double&gt;(x));
                return this-&gt;vect2(coll, argss...);
            }

            template &lt;typename... Args&gt; inline std::vector&lt;double&gt; vect2(std::vector&lt;std::vector&lt;double&gt;&gt; &amp; coll, std::vector&lt;double&gt; v, Args... argss)
            {
                coll.push_back(v);
                return this-&gt;vect2(coll, argss...);
            }

            Funk f;  // bound function

            // datalen is the length of the double-valued data array that is
            // needed as workspace for function evaluation, and that is created
            // on the heap for each eval separately to ensure thread-safety.
            size_t datalen;

            // bindID has the purpose of allowing bound functions (instances of
            // FunkBase and daughter classes) to be bound by various binding
            // functions simultaneously.
            size_t bindID;
    };


    //
    // Derived class with (templated) static member functions as plain function
    // prototypes.
    //

    class FunkPlain: public FunkBase
    {
        public:
            FunkPlain(Funk fin, std::string arg1) : f(fin-&gt;bind(arg1)) {}
            FunkPlain(Funk fin, std::string arg1, std::string arg2) : f(fin-&gt;bind(arg1, arg2)) {}
            FunkPlain(Funk fin, std::string arg1, std::string arg2, std::string arg3) : f(fin-&gt;bind(arg1, arg2, arg3)) {}
            FunkPlain(Funk fin, std::string arg1, std::string arg2, std::string arg3, std::string arg4) : f(fin-&gt;bind(arg1, arg2, arg3, arg4)) {}

            static double plain1p(double x1, void* ptr)
            {
                FunkPlain * funkPtrPtr = static_cast&lt;FunkPlain*&gt;(ptr);
                return funkPtrPtr-&gt;f-&gt;eval(x1);
            }
            static double plain2p(double x1, double x2, void* ptr)
            {
                FunkPlain * funkPtrPtr = static_cast&lt;FunkPlain*&gt;(ptr);
                return funkPtrPtr-&gt;f-&gt;eval(x1, x2);
            }
            static double plain3p(double x1, double x2, double x3, void* ptr)
            {
                FunkPlain * funkPtrPtr = static_cast&lt;FunkPlain*&gt;(ptr);
                return funkPtrPtr-&gt;f-&gt;eval(x1, x2, x3);
            }
            static double plain4p(double x1, double x2, double x3, double x4, void* ptr)
            {
                FunkPlain * funkPtrPtr = static_cast&lt;FunkPlain*&gt;(ptr);
                return funkPtrPtr-&gt;f-&gt;eval(x1, x2, x3, x4);
            }

            template &lt;typename T&gt;
            static double plain1(double&amp; x1)
            {
                FunkPlain * funkPtrPtr = static_cast&lt;FunkPlain*&gt;(T::ptr);
                return funkPtrPtr-&gt;f-&gt;eval(x1);
            }
            template &lt;typename T&gt;
            static double plain2(double&amp; x1, double&amp; x2)
            {
                FunkPlain * funkPtrPtr = static_cast&lt;FunkPlain*&gt;(T::ptr);
                return funkPtrPtr-&gt;f-&gt;eval(x1, x2);
            }
            template &lt;typename T&gt;
            static double plain3(double&amp; x1, double&amp; x2, double&amp; x3)
            {
                FunkPlain * funkPtrPtr = static_cast&lt;FunkPlain*&gt;(T::ptr);
                return funkPtrPtr-&gt;f-&gt;eval(x1, x2, x3);
            }
            template &lt;typename T&gt;
            static double plain4(double&amp; x1, double&amp; x2, double&amp; x3, double&amp; x4)
            {
                FunkPlain * funkPtrPtr = static_cast&lt;FunkPlain*&gt;(T::ptr);
                return funkPtrPtr-&gt;f-&gt;eval(x1, x2, x3, x4);
            }

            double value(const std::vector&lt;double&gt; &amp; args, size_t bindID)
            {
                (void)args;
                (void)bindID;
                assert ( 0 == 1 );  // This function should never be called
                return 0;
            }

        private:
            shared_ptr&lt;FunkBound&gt; f;  // bound function
            std::string arg1, arg2, arg3, arg4;
    };

    //
    // Derived class that implements constant
    //

    class FunkConst: public FunkBase
    {
        public:
            template &lt;typename... Args&gt;
            FunkConst(double c, Args ...argss) : c(c) { arguments = vec&lt;std::string&gt;(argss...); }
            FunkConst(double c) : c(c) { arguments.resize(0); }

            double value(const std::vector&lt;double&gt; &amp; data, size_t bindID)
            {
                (void)data;
                (void)bindID;
                return c;
            }

        private:
            double c;
    };
    template &lt;typename... Args&gt;
    inline Funk one(Args... argss) { return Funk(new FunkConst(1., argss...)); }
    template &lt;typename... Args&gt;
    inline Funk zero(Args... argss) { return Funk(new FunkConst(0., argss...)); }
    template &lt;typename... Args&gt;
    inline Funk cnst(double x, Args... argss) { return Funk(new FunkConst(x, argss...)); }


    //
    // Derived class that implements setting of parameters
    //

    class FunkDerived: public FunkBase
    {
        public:
            FunkDerived(Funk f, std::string arg, Funk g) : my_arg(arg)
            {
                setup(f, arg, g);
            };

            FunkDerived(Funk f, std::string arg, double x) : my_arg(arg)
            {
                setup(f, arg, cnst(x));
            }

            // We need to sneak in an additional parameter
            void resolve(std::map&lt;std::string, size_t&gt; datamap, size_t &amp; datalen, size_t bindID, std::map&lt;std::string,size_t&gt; &amp;argmap)
            {
                functions[1]-&gt;resolve(datamap, datalen, bindID, argmap);  // resolve g
                // add new slot for result from of g
                if(my_index.size() &lt;= bindID)
                {
                    my_index.resize(bindID+1);
                    // TODO: Introduce informative error message if bind fails
                    // because of inconsistencies, e.g. along the lines:
                    //
                    //    std::cout &lt;&lt; &quot;FATAL ERROR: bind() attempts to resolve dependencies for FunkDerived&quot; &lt;&lt; std::endl;
                    //    std::cout &lt;&lt; &quot;object inconsistently.&quot; &lt;&lt; std::endl;
                    //    std::cout &lt;&lt; &quot;Encountered while resolving &quot; &lt;&lt; my_arg &lt;&lt; &quot; and:&quot; &lt;&lt; std::endl;
                    //    for (auto it = datamap.begin(); it != datamap.end(); it++)
                    //    {
                    //        std::cout &lt;&lt; &quot;  &quot; &lt;&lt; it-&gt;first &lt;&lt; std::endl;
                    //    }
                    //    exit(1);
                }
                if ( argmap.find(my_arg) == argmap.end() )
                {
                    if(datamap.find(my_arg) == datamap.end())
                    {
                        my_index[bindID] = datalen;
                        argmap[my_arg]   = datalen;
                        ++datalen;
                    }
                    else
                    {
                        my_index[bindID] = datamap[my_arg];
                    }
                }
                else
                {
                    my_index[bindID] = argmap[my_arg];
                }
                datamap[my_arg]  = my_index[bindID];  // add or overwrite entry in datamap
                functions[0]-&gt;resolve(datamap, datalen, bindID, argmap);  // resolve f
            }

            double value(const std::vector&lt;double&gt; &amp; data, size_t bindID)
            {
                std::vector&lt;double&gt; data2(data);
                data2[my_index[bindID]] = functions[1]-&gt;value(data, bindID);
                return functions[0]-&gt;value(data2, bindID);
            }

        private:
            std::string my_arg;


            void setup(Funk f, std::string arg, Funk g)
            {
                functions = vec(f, g);
                Singularities tmp_singl = f-&gt;getSingl();
                if ( tmp_singl.erase(arg) &gt; 0 )
                    std::cout &lt;&lt; &quot;daFunk::FunkBase WARNING: Loosing singularity information while setting &quot; &lt;&lt; arg &lt;&lt; std::endl;
                singularities = joinSingl(g-&gt;getSingl(), tmp_singl);
                arguments = joinArgs(eraseArg(f-&gt;getArgs(), arg), g-&gt;getArgs());
            };
            std::vector&lt;size_t&gt; my_index;
    };


    //
    // Derived class for the import of plain functions
    //

    template &lt;bool threadsafe, typename... funcargs&gt;
    class FunkFunc : public FunkBase
    {
        public:
            template &lt;typename... Args&gt;
            FunkFunc(double (*f)(funcargs...), Args... argss)
            {
                ptr = f;
                digest_input(argss...);
            }

            double value(const std::vector&lt;double&gt; &amp; data, size_t bindID)
            {
                std::tuple&lt;typename std::remove_reference&lt;funcargs&gt;::type...&gt; my_input;
                double result;
                size_t i = 0;
                #pragma omp critical (FunkFunc_setInput)
                {
                    for ( auto f = functions.begin(); f != functions.end(); ++f, ++i)
                    {
                        *map[i] = (*f)-&gt;value(data, bindID);
                    }
                    my_input = input;
                }
                if(threadsafe)
                {
                    result = ppp(typename detail::range_builder&lt;0, sizeof...(funcargs)&gt;::type(), my_input);
                }
                else
                {
                    #pragma omp critical (FunkFunc_externalFunctionCall)
                    {
                        result = ppp(typename detail::range_builder&lt;0, sizeof...(funcargs)&gt;::type(), my_input);
                    }
                }
                return result;
            }

            template &lt;size_t... Args&gt;
            double ppp(index_list&lt;Args...&gt;, std::tuple&lt;typename std::remove_reference&lt;funcargs&gt;::type...&gt; &amp; my_input)
            {
                return (*ptr)(std::get&lt;Args&gt;(my_input)...);
            }

        private:
            std::tuple&lt;typename std::remove_reference&lt;funcargs&gt;::type...&gt; input;
            std::vector&lt;double*&gt; map;
            double (*ptr)(funcargs...);

            // Digest input parameters
            // (forwarding everything except daFunk::Funk types, which is mapped onto
            // funktion parameters)
            template&lt;typename T, typename... Args&gt;
            void digest_input(T x, Args... argss)
            {
                const int i = sizeof...(funcargs) - sizeof...(argss) - 1;
                std::get&lt;i&gt;(input) = x;
                digest_input(argss...);
            }
            template&lt;typename... Args&gt;
            void digest_input(Funk f, Args... argss)
            {
                const int i = sizeof...(funcargs) - sizeof...(argss) - 1;
                map.push_back(&amp;std::get&lt;i&gt;(input));
                arguments = joinArgs(arguments, f-&gt;getArgs());
                functions.push_back(f);
                singularities = joinSingl(singularities, f-&gt;getSingl());
                digest_input(argss...);
            }
            void digest_input() {};
    };

    template &lt;typename... funcargs, typename... Args&gt;
    Funk func(double (*f)(funcargs...), Args... args) {
        return Funk(new FunkFunc&lt;false, funcargs...&gt;(f, args...));
    }
    // Version that assumes the function to be threadsafe
    template &lt;typename... funcargs, typename... Args&gt;
    Funk func_fromThreadsafe(double (*f)(funcargs...), Args... args) {
        return Funk(new FunkFunc&lt;true, funcargs...&gt;(f, args...));
    }


    template &lt;bool threadsafe, typename O, typename... funcargs&gt;
    class FunkFuncM : public FunkBase
    {
        public:
            template &lt;typename... Args&gt;
            FunkFuncM(O* obj, double (O::* f)(funcargs...), Args... argss) : obj(obj)
            {
                ptr = f;
                digest_input(argss...);
            }

            template &lt;typename... Args&gt;
            FunkFuncM(shared_ptr&lt;O&gt; obj, double (O::* f)(funcargs...), Args... argss) : shared_obj(obj), obj(&amp;*obj)
            {
                ptr = f;
                digest_input(argss...);
            }

            double value(const std::vector&lt;double&gt; &amp; data, size_t bindID)
            {
                std::tuple&lt;typename std::remove_reference&lt;funcargs&gt;::type...&gt; my_input;
                double result;
                size_t i = 0;
                #pragma omp critical(FunkFuncM_value)
                {
                    for ( auto f = functions.begin(); f != functions.end(); ++f, ++i)
                    {
                        *map[i] = (*f)-&gt;value(data, bindID);
                    }
                    my_input = input;
                }
                if(threadsafe)
                {
                    result = ppp(typename detail::range_builder&lt;0, sizeof...(funcargs)&gt;::type(), my_input);
                }
                else
                {
                    #pragma omp critical (FunkFuncM_objectFunctionCall)
                    {
                        result = ppp(typename detail::range_builder&lt;0, sizeof...(funcargs)&gt;::type(), my_input);
                    }
                }
                return result;
            }

            template &lt;size_t... Args&gt;
            double ppp(index_list&lt;Args...&gt;, std::tuple&lt;typename std::remove_reference&lt;funcargs&gt;::type...&gt; &amp; my_input)
            {
                return (*obj.*ptr)(std::get&lt;Args&gt;(my_input)...);
            }

        private:
            std::tuple&lt;typename std::remove_reference&lt;funcargs&gt;::type...&gt; input;
            std::vector&lt;double*&gt; map;
            double (O::* ptr)(funcargs...);
            shared_ptr&lt;O&gt; shared_obj;
            O* obj;

            // Digest input parameters
            // (forwarding everything except daFunk::Funk types, which is mapped onto
            // funktion parameters)
            template&lt;typename T, typename... Args&gt;
            void digest_input(T x, Args... argss)
            {
                const int i = sizeof...(funcargs) - sizeof...(argss) - 1;
                std::get&lt;i&gt;(input) = x;
                digest_input(argss...);
            }
            template&lt;typename... Args&gt;
            void digest_input(Funk f, Args... argss)
            {
                const int i = sizeof...(funcargs) - sizeof...(argss) - 1;
                map.push_back(&amp;std::get&lt;i&gt;(input));
                arguments = joinArgs(arguments, f-&gt;getArgs());
                functions.push_back(f);
                singularities = joinSingl(singularities, f-&gt;getSingl());
                digest_input(argss...);
            }
            void digest_input() {};
    };


    template &lt;typename O, typename... funcargs, typename... Args&gt;
    Funk funcM(O* obj, double (O::* f)(funcargs...), Args... args) {
        return Funk(new FunkFuncM&lt;false, O, funcargs...&gt;(obj, f, args...));
    }
    template &lt;typename O, typename... funcargs, typename... Args&gt;
    Funk funcM(shared_ptr&lt;O&gt; obj, double (O::* f)(funcargs...), Args... args) {
        return Funk(new FunkFuncM&lt;false, O, funcargs...&gt;(obj, f, args...));
    }

    // Versions that assume the object to be threadsafe
    template &lt;typename O, typename... funcargs, typename... Args&gt;
    Funk funcM_fromThreadsafe(O* obj, double (O::* f)(funcargs...), Args... args) {
        return Funk(new FunkFuncM&lt;true, O, funcargs...&gt;(obj, f, args...));
    }
    template &lt;typename O, typename... funcargs, typename... Args&gt;
    Funk funcM_fromThreadsafe(shared_ptr&lt;O&gt; obj, double (O::* f)(funcargs...), Args... args) {
        return Funk(new FunkFuncM&lt;true, O, funcargs...&gt;(obj, f, args...));
    }

    //
    // Derived class that implements delta function
    //

    class FunkDelta: public FunkBase
    {
        public:
            FunkDelta(std::string arg, double pos, double width) : pos(pos), width(width)
            {
                arguments = vec(arg);
                singularities[arg].push_back(std::pair&lt;Funk, Funk&gt;(cnst(pos), cnst(width)));
            }

            double value(const std::vector&lt;double&gt; &amp; data, size_t bindID)
            {
                double x = data[indices[bindID][0]];
                return exp(-pow(x-pos,2)/pow(width,2)/2)/sqrt(2*M_PI)/width;
            }

        private:
            double pos, width;
    };
    inline Funk delta(std::string arg, double pos, double width) { return Funk(new FunkDelta(arg, pos, width)); }

    //
    // Derived class that implements simple linear variable
    //

    class FunkVar: public FunkBase
    {
        public:
            FunkVar(std::string arg)
            {
                arguments = vec(arg);
            }

            double value(const std::vector&lt;double&gt; &amp; data, size_t bindID)
            {
                return data[indices[bindID][0]];
            }
    };
    inline Funk var(std::string arg) { return Funk(new FunkVar(arg)); }


    //
    // Definition of FunkBase member functions
    //

    inline Funk FunkBase::set_singularity(std::string arg, Funk pos, Funk width)
    {
        singularities[arg].push_back(std::pair&lt;Funk, Funk&gt;(pos, width));
        return shared_from_this();
    }
    inline Funk FunkBase::set_singularity(std::string arg, double pos, Funk width)
    { return shared_from_this()-&gt;set_singularity(arg, cnst(pos), width); }
    inline Funk FunkBase::set_singularity(std::string arg, double pos, double width)
    { return shared_from_this()-&gt;set_singularity(arg, cnst(pos), cnst(width)); }
    inline Funk FunkBase::set_singularity(std::string arg, Funk pos, double width)
    { return shared_from_this()-&gt;set_singularity(arg, pos, cnst(width)); }

    inline void FunkBase::resolve(std::map&lt;std::string, size_t&gt; datamap, size_t &amp; datalen, size_t bindID, std::map&lt;std::string,size_t&gt; &amp;argmap)
    {
        // Resolve my dependencies
        auto it1 = arguments.begin();
        std::vector&lt;size_t&gt; tmp_indices;
        tmp_indices.resize(arguments.size());
        auto it2 = tmp_indices.begin();
        for (; it1 != arguments.end() &amp;&amp; it2 != tmp_indices.end(); ++it1, ++it2 )
        {
            try
            {
                *it2 = datamap.at(*it1);
            }
            catch (std::out_of_range &amp; e)
            {
                std::string msg = &quot;FunkBase::resolve() encountered internal problem when resolving &quot; + *it1 + &quot;.\n&quot;;
                            msg+= &quot; --- Actual arguments of object: &quot; + args_string(arguments);
#ifdef GAMBIT_DIR
                Gambit::utils_error().raise(LOCAL_INFO, msg);
#else
                throw std::invalid_argument(msg);
#endif
            }
        }

        // Set indices
        if(indices.size() &lt;= bindID)
        {
            indices.resize(bindID+1);
            // TODO: Throw error if problems are encountered
            //std::cout &lt;&lt; &quot;FATAL ERROR: bind() attempts to resolve dependencies of FunkBase&quot; &lt;&lt; std::endl;
            //std::cout &lt;&lt; &quot;object inconsistently.&quot; &lt;&lt; std::endl;
            //std::cout &lt;&lt; &quot;Encountered while resolving: &quot; &lt;&lt; std::endl;
            //for (auto it = datamap.begin(); it != datamap.end(); it++)
            //{
            //    std::cout &lt;&lt; &quot;  &quot; &lt;&lt; it-&gt;first &lt;&lt; std::endl;
            //}
            //exit(1);
        }
        indices[bindID] = tmp_indices;

        // Resolve other dependencies
        for (auto it = functions.begin(); it != functions.end(); ++it)
        {
            (*it)-&gt;resolve(datamap, datalen, bindID, argmap);
        }

    }

    template &lt;typename... Args&gt; inline bool FunkBase::assert_args(Args... args)
    {
        std::vector&lt;std::vector&lt;std::string&gt;&gt; list = vec&lt;std::vector&lt;std::string&gt;&gt;(args...);
        std::set&lt;std::string&gt; myargs(arguments.begin(), arguments.end());
        for ( auto it = list.begin(); it != list.end(); ++it )
        {
            std::set&lt;std::string&gt; theirargs(it-&gt;begin(), it-&gt;end());
            if ( myargs == theirargs )
                return true;
        }
        return false;

    }

    template &lt;typename... Args&gt; inline Funk FunkBase::set(std::string arg, Funk g, Args... args)
    {
        Funk f = shared_from_this();
        if ( std::find(arguments.begin(), arguments.end(), arg) != arguments.end() )
        {
            f = Funk(new FunkDerived(f, arg, g));
        }
        else
        {
            std::cout &lt;&lt; &quot;daFunk::FunkBase WARNING: Ignoring \&quot;&quot; &lt;&lt; arg &lt;&lt; &quot;\&quot; = function.&quot; &lt;&lt; std::endl;
        }
        return f-&gt;set(args...);
    }

    template &lt;typename... Args&gt; inline Funk FunkBase::set(std::string arg, std::string arg1, Args... args)
        { return shared_from_this()-&gt;set(arg, var(arg1))-&gt;set(args...); }

    template &lt;typename... Args&gt; inline Funk FunkBase::set(std::string arg, double x, Args... args)
        { return shared_from_this()-&gt;set(arg, cnst(x))-&gt;set(args...); }

    template &lt;&gt; inline Funk FunkBase::set()
        { return shared_from_this(); }

    template &lt;typename... Args&gt; inline shared_ptr&lt;FunkBound&gt; FunkBase::bind(Args... argss)
    {
        size_t bindID;
        FunkBound::bindID_manager(bindID,true);
        std::map&lt;std::string, size_t&gt; datamap;
        size_t i;
        auto bound_arguments = vec&lt;std::string&gt;(argss...);
        datalen = bound_arguments.size();
        i = 0;
        for ( auto it = bound_arguments.begin(); it != bound_arguments.end(); ++it, ++i )
        {
            datamap[*it] = i;
        }
        std::map&lt;std::string,size_t&gt; argmap;
        if ( not args_match(arguments, bound_arguments) )
        {
            std::string msg = &quot;FunkBase::bind() tries to resolve wrong arguments.\n&quot;;
                        msg+= &quot; --- Arguments that are supposed to be bound: &quot; + args_string(bound_arguments) + &quot;\n&quot;;
                        msg+= &quot; --- Actual arguments of object: &quot; + args_string(arguments);
#ifdef GAMBIT_DIR
            Gambit::utils_error().raise(LOCAL_INFO, msg);
#else
            throw std::invalid_argument(msg);
#endif
        }
        this-&gt;resolve(datamap, datalen, bindID, argmap);
        return shared_ptr&lt;FunkBound&gt;(new FunkBound(shared_from_this(), datalen, bindID));
    }

    inline bool FunkBase::hasArg(std::string arg)
    {
        return ( std::find(arguments.begin(), arguments.end(), arg) != arguments.end() );
    }

    inline bool FunkBase::hasArgs()
    {
        return ( this-&gt;arguments.size() != 0 );
    }

    template &lt;typename... Args&gt; inline shared_ptr&lt;FunkIntegrate_gsl1d&gt; FunkBase::gsl_integration(Args... args)
    {
        return getIntegrate_gsl1d(shared_from_this(), args...);
    }

    inline Funk FunkBase::help()
    {
        std::cout &lt;&lt; &quot;Arguments:&quot;;
        for ( auto it = arguments.begin(); it != arguments.end(); it++ )
        {
            std::cout &lt;&lt; &quot; \&quot;&quot; &lt;&lt; *it &lt;&lt; &quot;\&quot;&quot;;
        }
        if ( arguments.size() == 0 )
            std::cout &lt;&lt; &quot; none&quot;;
        std::cout &lt;&lt; std::endl;
        for ( auto it = singularities.begin() ; it != singularities.end(); ++it )
        {
            std::cout &lt;&lt; &quot;Singularities in &quot; &lt;&lt; it-&gt;first &lt;&lt; &quot;: &quot; &lt;&lt; it-&gt;second.size() &lt;&lt; std::endl;
        }
        return shared_from_this();
    }

    inline PlainPtrs1 FunkBase::plain(std::string arg1)
    {
        void* ptr = new FunkPlain(shared_from_this(), arg1);
        return PlainPtrs1(&amp;FunkPlain::plain1p, ptr);
    }
    inline PlainPtrs2 FunkBase::plain(std::string arg1, std::string arg2)
    {
        void* ptr = new FunkPlain(shared_from_this(), arg1, arg2);
        return PlainPtrs2(&amp;FunkPlain::plain2p, ptr);
    }
    inline PlainPtrs3 FunkBase::plain(std::string arg1, std::string arg2, std::string arg3)
    {
        void* ptr = new FunkPlain(shared_from_this(), arg1, arg2, arg3);
        return PlainPtrs3(&amp;FunkPlain::plain3p, ptr);
    }
    inline PlainPtrs4 FunkBase::plain(std::string arg1, std::string arg2, std::string arg3, std::string arg4)
    {
        void* ptr = new FunkPlain(shared_from_this(), arg1, arg2, arg3, arg4);
        return PlainPtrs4(&amp;FunkPlain::plain4p, ptr);
    }

    template &lt;typename T&gt;
    inline PlainPtr1 FunkBase::plain(std::string arg1)
    {
        T::set(new FunkPlain(shared_from_this(), arg1));
        return &amp;FunkPlain::plain1&lt;T&gt;;
    }
    template &lt;typename T&gt;
    inline PlainPtr2 FunkBase::plain(std::string arg1, std::string arg2)
    {
        T::set(new FunkPlain(shared_from_this(), arg1, arg2));
        return &amp;FunkPlain::plain2&lt;T&gt;;
    }
    template &lt;typename T&gt;
    inline PlainPtr3 FunkBase::plain(std::string arg1, std::string arg2, std::string arg3)
    {
        T::set(new FunkPlain(shared_from_this(), arg1, arg2, arg3));
        return &amp;FunkPlain::plain3&lt;T&gt;;
    }
    template &lt;typename T&gt;
    inline PlainPtr4 FunkBase::plain(std::string arg1, std::string arg2, std::string arg3, std::string arg4)
    {
        T::set(new FunkPlain(shared_from_this(), arg1, arg2, arg3, arg4));
        return &amp;FunkPlain::plain4&lt;T&gt;;
    }


    //
    // Mathematical functions from cmath
    //

    // Unary minus sign
    class FunkMath_umin: public FunkBase
    {
        public:
            FunkMath_umin(Funk f)
            {
                functions = vec(f);
                singularities = f-&gt;getSingl();
                arguments = f-&gt;getArgs();
            }
            double value(const std::vector&lt;double&gt; &amp; data, size_t bindID)
            {
                return -(functions[0]-&gt;value(data, bindID));
            }
    };
    inline Funk operator - (Funk f) { return Funk(new FunkMath_umin(f)); }

    // Unary operations
#define MATH_OPERATION(OPERATION)                                                                         \
    class FunkMath_##OPERATION: public FunkBase                                                           \
    {                                                                                                     \
        public:                                                                                           \
            FunkMath_##OPERATION(Funk f)                                                                  \
            {                                                                                             \
                functions = vec(f);                                                                       \
                arguments = f-&gt;getArgs();                                                                 \
                singularities = f-&gt;getSingl();                                                            \
            }                                                                                             \
            double value(const std::vector&lt;double&gt; &amp; data, size_t bindID)                                       \
            {                                                                                             \
                return OPERATION(functions[0]-&gt;value(data, bindID));                                      \
            }                                                                                             \
    };                                                                                                    \
    inline Funk OPERATION (Funk f) { return Funk(new FunkMath_##OPERATION(f)); }
    MATH_OPERATION(cos)
    MATH_OPERATION(sin)
    MATH_OPERATION(tan)
    MATH_OPERATION(acos)
    MATH_OPERATION(asin)
    MATH_OPERATION(atan)
    MATH_OPERATION(cosh)
    MATH_OPERATION(sinh)
    MATH_OPERATION(tanh)
    MATH_OPERATION(acosh)
    MATH_OPERATION(asinh)
    MATH_OPERATION(atanh)
    MATH_OPERATION(exp)
    MATH_OPERATION(log)
    MATH_OPERATION(log10)
    MATH_OPERATION(sqrt)
    MATH_OPERATION(fabs)
#undef MATH_OPERATION

    // Standard binary operations
#define MATH_OPERATION(OPERATION, SYMBOL)                                                                 \
    class FunkMath_##OPERATION: public FunkBase                                                           \
    {                                                                                                     \
        public:                                                                                           \
            FunkMath_##OPERATION(Funk f1, Funk f2)                                                        \
            {                                                                                             \
                functions = vec(f1, f2); \
                arguments = joinArgs(f1-&gt;getArgs(), f2-&gt;getArgs()); \
                singularities = joinSingl(f1-&gt;getSingl(), f2-&gt;getSingl());\
            }                                                                                             \
            FunkMath_##OPERATION(double x, Funk f2)                 \
            {                                                                                             \
                auto f1 = cnst(x); \
                functions = vec(f1, f2); \
                arguments = joinArgs(f1-&gt;getArgs(), f2-&gt;getArgs()); \
                singularities = joinSingl(f1-&gt;getSingl(), f2-&gt;getSingl());\
            }                                                                                             \
            FunkMath_##OPERATION(Funk f1, double x)              \
            {                                                                                             \
                auto f2 = cnst(x); \
                functions = vec(f1, f2); \
                arguments = joinArgs(f1-&gt;getArgs(), f2-&gt;getArgs()); \
                singularities = joinSingl(f1-&gt;getSingl(), f2-&gt;getSingl());\
            }                                                                                             \
            double value(const std::vector&lt;double&gt; &amp; data, size_t bindID)                                 \
            {                                                                                             \
                return functions[0]-&gt;value(data, bindID) SYMBOL functions[1]-&gt;value(data, bindID);        \
            }                                                                                             \
    };                                                                                                    \
    inline Funk operator SYMBOL (Funk f1, Funk f2) { return Funk(new FunkMath_##OPERATION(f1, f2)); }     \
    inline Funk operator SYMBOL (double x, Funk f) { return Funk(new FunkMath_##OPERATION(x, f)); }       \
    inline Funk operator SYMBOL (Funk f, double x) { return Funk(new FunkMath_##OPERATION(f, x)); }
    MATH_OPERATION(Sum,+)
    MATH_OPERATION(Mul,*)
    MATH_OPERATION(Div,/)
    MATH_OPERATION(Dif,-)
#undef MATH_OPERATION

    // More binary operations
#define MATH_OPERATION(OPERATION)                                                                         \
    class FunkMath_##OPERATION: public FunkBase                                                           \
    {                                                                                                     \
        public:                                                                                           \
            FunkMath_##OPERATION(Funk f1, Funk f2)                                                        \
            {                                                                                             \
                functions = vec(f1, f2);                                                                  \
                arguments = joinArgs(f1-&gt;getArgs(), f2-&gt;getArgs());                                       \
                singularities = joinSingl(f1-&gt;getSingl(), f2-&gt;getSingl());                                \
            }                                                                                             \
            FunkMath_##OPERATION(double x, Funk f2)                                                       \
            {                                                                                             \
                auto f1 = cnst(x);                                                                        \
                functions = vec(f1, f2);                                                                  \
                arguments = joinArgs(f1-&gt;getArgs(), f2-&gt;getArgs());                                       \
                singularities = joinSingl(f1-&gt;getSingl(), f2-&gt;getSingl());                                \
            }                                                                                             \
            FunkMath_##OPERATION(Funk f1, double x)                                                       \
            {                                                                                             \
                auto f2 = cnst(x);                                                                        \
                functions = vec(f1, f2);                                                                  \
                arguments = joinArgs(f1-&gt;getArgs(), f2-&gt;getArgs());                                       \
                singularities = joinSingl(f1-&gt;getSingl(), f2-&gt;getSingl());                                \
            }                                                                                             \
            double value(const std::vector&lt;double&gt; &amp; data, size_t bindID)                                 \
            {                                                                                             \
                return OPERATION(functions[0]-&gt;value(data, bindID), functions[1]-&gt;value(data, bindID));   \
            }                                                                                             \
    };                                                                                                    \
    inline Funk OPERATION (Funk f1, Funk f2) { return Funk(new FunkMath_##OPERATION(f1, f2)); }           \
    inline Funk OPERATION (double x, Funk f) { return Funk(new FunkMath_##OPERATION(x, f)); }             \
    inline Funk OPERATION (Funk f, double x) { return Funk(new FunkMath_##OPERATION(f, x)); }
    MATH_OPERATION(pow)
    MATH_OPERATION(fmin)
    MATH_OPERATION(fmax)
#undef MATH_OPERATION

    ////////////////////////////////////////
    // *** End of core implementation ***
    ////////////////////////////////////////



    ////////////////////////////////////////
    //        *** Extensions ***
    ////////////////////////////////////////


    //
    // Derived class: 1dim linear or logarithmic interpolation
    //

    class FunkInterp : public FunkBase
    {
        public:
            FunkInterp(Funk f, std::vector&lt;double&gt; &amp; Xgrid, std::vector&lt;double&gt; &amp; Ygrid, std::string mode = &quot;lin&quot;)
            {
                setup(f, Xgrid, Ygrid, mode);
            }
            FunkInterp(std::string arg, std::vector&lt;double&gt; &amp; Xgrid, std::vector&lt;double&gt; &amp; Ygrid, std::string mode = &quot;lin&quot;)
            {
                setup(var(arg), Xgrid, Ygrid, mode);
            }
            FunkInterp(double x, std::vector&lt;double&gt; &amp; Xgrid, std::vector&lt;double&gt; &amp; Ygrid, std::string mode = &quot;lin&quot;)
            {
                setup(cnst(x), Xgrid, Ygrid, mode);
            }

            double value(const std::vector&lt;double&gt; &amp; data, size_t bindID)
            {
                functions[0]-&gt;value(data, bindID);
                return (this-&gt;*ptr)(data[indices[bindID][0]]);
            }

        private:
            void setup(Funk f, std::vector&lt;double&gt; &amp; Xgrid, std::vector&lt;double&gt; &amp; Ygrid, std::string mode)
            {
                // TODO: Catch invalid setup
                functions = vec(f);
                singularities = f-&gt;getSingl();
                arguments = f-&gt;getArgs();
                this-&gt;Xgrid = Xgrid;
                this-&gt;Ygrid = Ygrid;
                if ( mode == &quot;lin&quot; ) this-&gt;ptr = &amp;FunkInterp::linearInterp;
                else if ( mode == &quot;log&quot; ) this-&gt;ptr = &amp;FunkInterp::logInterp;
            }

            double logInterp(double x)
            {
                // Linear interpolation in log-log space
                int i = 0; int imax = Xgrid.size() - 1;
                if (x&lt;Xgrid[0] or x&gt;Xgrid[imax]) return 0;
                for (; i &lt; imax; i++) {if (Xgrid[i] &gt; x) break;};
                double x0 = Xgrid[i-1];
                double x1 = Xgrid[i];
                double y0 = Ygrid[i-1];
                double y1 = Ygrid[i];
                return y0 * std::exp(std::log(y1/y0) * std::log(x/x0) / std::log(x1/x0));
            }

            double linearInterp(double x)
            {
                // Linear interpolation in lin-lin space
                int i = 0; int imax = Xgrid.size() - 1;
                if (x&lt;Xgrid[0] or x&gt;Xgrid[imax]) return 0;
                for (; i &lt; imax; i++) {if (Xgrid[i] &gt; x) break;};
                double x0 = Xgrid[i-1];
                double x1 = Xgrid[i];
                double y0 = Ygrid[i-1];
                double y1 = Ygrid[i];
                return y0 + (x-x0)/(x1-x0)*(y1-y0);
            }

            double(FunkInterp::*ptr)(double);
            std::vector&lt;double&gt; Xgrid;
            std::vector&lt;double&gt; Ygrid;
            std::string mode;
    };
    template &lt;typename T&gt; inline shared_ptr&lt;FunkInterp&gt; interp(T f, std::vector&lt;double&gt; x, std::vector&lt;double&gt; y) { return shared_ptr&lt;FunkInterp&gt;(new FunkInterp(f, x, y)); }


    //
    // Basic if..else clause
    //

    class FunkIfElse: public FunkBase
    {
        public:
            FunkIfElse(Funk f, Funk g, Funk h)
            {
                functions = vec(f, g, h);
                singularities = joinSingl(joinSingl(f-&gt;getSingl(), g-&gt;getSingl()), h-&gt;getSingl());
                arguments = joinArgs(joinArgs(f-&gt;getArgs(), g-&gt;getArgs()), h-&gt;getArgs());
            }
            double value(const std::vector&lt;double&gt; &amp; data, size_t bindID)
            {
              if ( functions[0]-&gt;value(data,bindID) &gt;= 0. )
                return functions[1]-&gt;value(data,bindID);
              else
                return functions[2]-&gt;value(data,bindID);
            }
    };
    inline Funk ifelse(Funk f, Funk g, Funk h) { return Funk(new FunkIfElse(f, g, h)); }
    inline Funk ifelse(Funk f, double g, Funk h) { return Funk(new FunkIfElse(f, cnst(g), h)); }
    inline Funk ifelse(Funk f, double g, double h) { return Funk(new FunkIfElse(f, cnst(g), cnst(h))); }
    inline Funk ifelse(Funk f, Funk g, double h) { return Funk(new FunkIfElse(f, g, cnst(h))); }


    //
    // Throw errors when called
    //

    class ThrowError: public FunkBase
    {
        public:
            ThrowError(std::string msg) : msg(msg)
            {
            }
            double value(const std::vector&lt;double&gt; &amp; data, size_t bindID)
            {
              (void)bindID;
              (void)data;
#ifdef GAMBIT_DIR
              if ( omp_get_level() == 0 )  // Outside of OMP blocks
              {
                  Gambit::utils_error().raise(LOCAL_INFO, &quot;daFunk::ThrowError says: &quot; + msg);
              }
              else  // Inside of OMP blocks
              {
                  Gambit::piped_errors.request(LOCAL_INFO, &quot;daFunk::ThrowError says: &quot; + msg);
              }
#else
              throw std::invalid_argument(&quot;daFunk::ThrowError says: &quot; + msg);
#endif
              return 0;
            }

        private:
            std::string msg;  // Error message to throw when function is called
    };
    inline Funk throwError(std::string msg) { return Funk(new ThrowError(msg)); }

#ifdef GAMBIT_DIR
    class RaiseInvalidPoint: public FunkBase
    {
        public:
            RaiseInvalidPoint(std::string msg) : msg(msg)
            {
            }
            double value(const std::vector&lt;double&gt; &amp; data, size_t bindID)
            {
              (void)bindID;
              (void)data;
              if ( omp_get_level() == 0 )  // Outside of OMP blocks
              {
                  Gambit::utils_warning().raise(LOCAL_INFO, &quot;daFunk::RaiseInvalidPoint says: &quot; + msg);
                  Gambit::invalid_point().raise(&quot;daFunk::RaiseInvalidPoint says: &quot; + msg);
              }
              else  // Inside OMP blocks
              {
                  Gambit::utils_warning().raise(LOCAL_INFO, &quot;daFunk::RaisePipedInvalidPoint says: &quot; + msg);
                  Gambit::piped_invalid_point.request(&quot;daFunk::RaisePipedInvalidPoint says: &quot; + msg);
              }
              return 0;
            }

        private:
            std::string msg;  // Error message to throw when function is called
    };
    inline Funk raiseInvalidPoint(std::string msg) { return Funk(new RaiseInvalidPoint(msg)); }
#endif


    //
    // Prints message when called
    //

    class Bottle: public FunkBase
    {
        public:
            Bottle(Funk f, std::string msg) : msg(msg)
            {
                functions = vec(f);
                singularities = f-&gt;getSingl();
                arguments = f-&gt;getArgs();
            }
            double value(const std::vector&lt;double&gt; &amp; data, size_t bindID)
            {
              std::cout &lt;&lt; &quot;daFunk::Message says:\n&quot; &lt;&lt; msg &lt;&lt; std::endl;
              return functions[0]-&gt;value(data, bindID);
            }

        private:
            std::string msg;  // Message in a bottle.  Ha!
    };
    //inline Funk print(std::string msg) { return Funk(new Bottle(msg)); }
    inline Funk FunkBase::print(std::string msg)
    { return Funk(new Bottle(shared_from_this(), msg)); }


    //
    // GSL integration
    //

    class FunkIntegrate_gsl1d: public FunkBase, public gsl_function
    {
        public:
            FunkIntegrate_gsl1d(Funk f0, std::string arg, Funk f1, Funk f2)
            {
                setup(f0, arg, f1, f2);
            }
            FunkIntegrate_gsl1d(Funk f0, std::string arg, double x, Funk f)
            {
                setup(f0, arg, cnst(x), f);
            }
            FunkIntegrate_gsl1d(Funk f0, std::string arg, double x, double y)
            {
                setup(f0, arg, cnst(x), cnst(y));
            }
            FunkIntegrate_gsl1d(Funk f0, std::string arg, Funk f, double x)
            {
                setup(f0, arg, f, cnst(x));
            }
            FunkIntegrate_gsl1d(Funk f0, std::string arg, std::string x, Funk f)
            {
                setup(f0, arg, var(x), f);
            }
            FunkIntegrate_gsl1d(Funk f0, std::string arg, std::string x, std::string y)
            {
                setup(f0, arg, var(x), var(y));
            }
            FunkIntegrate_gsl1d(Funk f0, std::string arg, Funk f, std::string x)
            {
                setup(f0, arg, f, var(x));
            }
            FunkIntegrate_gsl1d(Funk f0, std::string arg, std::string x, double y)
            {
                setup(f0, arg, var(x), cnst(y));
            }
            FunkIntegrate_gsl1d(Funk f0, std::string arg, double y, std::string x)
            {
                setup(f0, arg, cnst(y), var(x));
            }

            void resolve(std::map&lt;std::string, size_t&gt; datamap, size_t &amp; datalen, size_t bindID, std::map&lt;std::string,size_t&gt; &amp;argmap)
            {
                functions[1]-&gt;resolve(datamap, datalen, bindID, argmap);  // Resolve boundary 0
                functions[2]-&gt;resolve(datamap, datalen, bindID, argmap);  // Resolve boundary 1

                // Set indices
                if(index.size() &lt;= bindID)
                {
                    index.resize(bindID+1);
                    // TODO: Throw error if problems are encountered
                    //std::cout &lt;&lt; &quot;FATAL ERROR: bind() attempts to resolve dependencies of FunkIntegrate_gsl1d&quot; &lt;&lt; std::endl;
                    //std::cout &lt;&lt; &quot;object inconsistently.&quot; &lt;&lt; std::endl;
                    //std::cout &lt;&lt; &quot;Encountered while resolving &quot; &lt;&lt; arg &lt;&lt; &quot; and:&quot; &lt;&lt; std::endl;
                    //for (auto it = datamap.begin(); it != datamap.end(); it++)
                    //{
                    //    std::cout &lt;&lt; &quot;  &quot; &lt;&lt; it-&gt;first &lt;&lt; std::endl;
                    //}
                    //exit(1);
                }
                if ( argmap.find(arg) == argmap.end() )
                {
                    if(datamap.find(arg) == datamap.end())
                    {
                        index[bindID] = datalen;
                        argmap[arg]   = datalen;
                        ++datalen;
                    }
                    else
                    {
                        index[bindID] = datamap[arg];
                    }
                }
                else
                {
                    index[bindID] = argmap[arg];
                }
                datamap[arg]  = index[bindID];
                functions[0]-&gt;resolve(datamap, datalen, bindID, argmap);
                for ( auto it = my_singularities.begin(); it != my_singularities.end(); ++it )
                {
                    it-&gt;first-&gt;resolve(datamap, datalen, bindID, argmap);
                    it-&gt;second-&gt;resolve(datamap, datalen, bindID, argmap);
                }
            }

            ~FunkIntegrate_gsl1d()
            {
                gsl_integration_workspace_free(gsl_workspace);
            }

            shared_ptr&lt;FunkIntegrate_gsl1d&gt; set_epsrel(double epsrel)
            { this-&gt;epsrel = epsrel; return static_pointer_cast&lt;FunkIntegrate_gsl1d&gt;(this-&gt;FunkIntegrate_gsl1d::shared_from_this()); }
            shared_ptr&lt;FunkIntegrate_gsl1d&gt; set_epsabs(double epsabs)
            { this-&gt;epsabs = epsabs; return static_pointer_cast&lt;FunkIntegrate_gsl1d&gt;(this-&gt;shared_from_this()); }
            shared_ptr&lt;FunkIntegrate_gsl1d&gt; set_limit(size_t limit)
            { this-&gt;limit = limit; return static_pointer_cast&lt;FunkIntegrate_gsl1d&gt;(this-&gt;shared_from_this()); }
            shared_ptr&lt;FunkIntegrate_gsl1d&gt; set_singularity_factor(double f)
            { this-&gt;singl_factor = f; return static_pointer_cast&lt;FunkIntegrate_gsl1d&gt;(this-&gt;shared_from_this()); }
            shared_ptr&lt;FunkIntegrate_gsl1d&gt; set_use_log_fallback(bool flag)
            { this-&gt;use_log_fallback = flag; return static_pointer_cast&lt;FunkIntegrate_gsl1d&gt;(this-&gt;shared_from_this()); }

            double value(const std::vector&lt;double&gt; &amp; data, size_t bindID)
            {
                double result;
                #pragma omp critical(FunkIntegrate_gsl1d_integration)
                {
                    local_data = data;
                    local_bindID = bindID;
                    double error;
                    function=&amp;FunkIntegrate_gsl1d::invoke;
                    params=this;
                    double x0 = functions[1]-&gt;value(data, bindID);
                    double x1 = functions[2]-&gt;value(data, bindID);
                    gsl_set_error_handler_off();
                    int status = 0;
                    if ( my_singularities.size() == 0 )
                    {
                        status = gsl_integration_qags(this, x0, x1, epsabs, epsrel, limit, gsl_workspace, &amp;result, &amp;error);
                    }
                    else
                    {
                        double s = 0;
                        std::vector&lt;double&gt; ranges;
                        ranges.push_back(x0);
                        ranges.push_back(x1);
                        for ( auto it = my_singularities.begin(); it != my_singularities.end(); ++it )
                        {
                            double mean = it-&gt;first-&gt;value(data, bindID);
                            double sigma = it-&gt;second-&gt;value(data, bindID);
                            double z0 = mean - singl_factor*sigma;
                            double z1 = mean + singl_factor*sigma;
                            if ( z0 == z1 )
                                std::cout &lt;&lt; &quot;daFunk::FunkBase WARNING: Singularity width is beyond machine precision.&quot; &lt;&lt; std::endl;
                            if ( z0 &gt; x0 and z0 &lt; x1 ) ranges.push_back(z0);
                            if ( z1 &gt; x0 and z1 &lt; x1 ) ranges.push_back(z1);
                        }
                        std::sort(ranges.begin(), ranges.end());
                        for ( auto it = ranges.begin(); it != ranges.end()-1; ++it )
                        {
                            status = gsl_integration_qags(this, *it, *(it+1), epsabs, epsrel, limit, gsl_workspace, &amp;result, &amp;error);
                            s += result;
                            if (status) break;
                        }
                        result = s;
                    }
                    if (status and this-&gt;use_log_fallback)
                    {
                        // The last resort: A cheap integration on log grid, linear interpolation
                        const double N = 300;
                        std::vector&lt;double&gt; Xgrid = 
                            logspace(std::log10(x0), std::log10(x1), N);
                        double sum = 0, y0, y1, dx;
                        local_data[index[bindID]] = Xgrid[0];
                        y0 = functions[0]-&gt;value(local_data, bindID);
                        for (size_t i = 0; i&lt;N-1; i++)
                        {
                            local_data[index[bindID]] = Xgrid[i+1];
                            y1 = functions[0]-&gt;value(local_data, bindID);
                            dx = Xgrid[i+1]-Xgrid[i];
                            sum += dx*(y0+y1)/2;
                            y0 = y1;
                        }
                        result = sum;
                    }
                    // TODO: Implement flags to optionally throw an error
                    if (status and not this-&gt;use_log_fallback)
                    {
                        std::cerr &lt;&lt; &quot;daFunk::FunkIntegrate_gsl1d WARNING: &quot; &lt;&lt; gsl_strerror(status) &lt;&lt; std::endl;
                        std::cerr &lt;&lt; &quot;Attempt to integrate from &quot; &lt;&lt; x0 &lt;&lt; &quot; to &quot; &lt;&lt; x1 &lt;&lt; std::endl;
                        std::cerr &lt;&lt; &quot;Attempt to integrate from &quot; &lt;&lt; x0 &lt;&lt; &quot; to &quot; &lt;&lt; x1 &lt;&lt; std::endl;
                        std::cerr &lt;&lt; &quot;Details about the integrand:&quot; &lt;&lt; std::endl;
                        functions[0]-&gt;help();
//                        std::cout &lt;&lt; &quot;Dumping integrand:&quot; &lt;&lt; std::endl;
//                        for ( double x = x0; x &lt;= x1; x = (x0&gt;0) ? x*1.01 : x+(x1-x0)/1000)
//                            std::cerr &lt;&lt; &quot;  &quot; &lt;&lt; x &lt;&lt; &quot; &quot; &lt;&lt; invoke(x, this) &lt;&lt; std::endl;
                        std::cerr &lt;&lt; &quot;Returning zero.&quot; &lt;&lt; std::endl;
                        result = 0.;
                    }
                }
                return result;
            }

        private:
            void setup(Funk f0, std::string arg, Funk f1, Funk f2)
            {
                this-&gt;functions = vec(f0, f1, f2);

                singularities = joinSingl(f1-&gt;getSingl(), f2-&gt;getSingl());
                if ( f0-&gt;getSingl().find(arg) != f0-&gt;getSingl().end() )
                    my_singularities = f0-&gt;getSingl()[arg];
                Singularities tmp_singl = f0-&gt;getSingl();
                tmp_singl.erase(arg);
                singularities = joinSingl(singularities, tmp_singl);

                arguments = joinArgs(eraseArg(f0-&gt;getArgs(), arg), joinArgs(f1-&gt;getArgs(), f2-&gt;getArgs()));
                gsl_workspace = gsl_integration_workspace_alloc (100000);

                this-&gt;arg = arg;
                limit = 100;
                epsrel = 1e-2;
                epsabs = 1e-2;
                use_log_fallback = false;
                singl_factor = 4;
            }

            // Static member function that invokes integrand
            static double invoke(double x, void *params) {
                FunkIntegrate_gsl1d * ptr = static_cast&lt;FunkIntegrate_gsl1d*&gt;(params);
                ptr-&gt;local_data[ptr-&gt;index[ptr-&gt;local_bindID]] = x;
                return ptr-&gt;functions[0]-&gt;value(ptr-&gt;local_data, ptr-&gt;local_bindID);
            }

            // Required for rewiring input parameters
            std::vector&lt;double&gt; local_data;
            size_t local_bindID;
            std::vector&lt;std::pair&lt;Funk, Funk&gt;&gt; my_singularities;

            // Integration range and function pointer
            std::string arg;

            // GSL workspace and parameters
            gsl_integration_workspace * gsl_workspace;
            size_t limit;
            std::vector&lt;size_t&gt; index;
            double epsrel;
            double epsabs;
            bool use_log_fallback;

            double singl_factor;
    };

    // Standard behaviour
    template &lt;typename T1, typename T2&gt;
    inline shared_ptr&lt;FunkIntegrate_gsl1d&gt; getIntegrate_gsl1d(Funk fptr, std::string arg, T1 x1, T2 x2) { return shared_ptr&lt;FunkIntegrate_gsl1d&gt;(new FunkIntegrate_gsl1d(fptr, arg, x1, x2)); }

    //
    // Helper function for producing singularity-augmented x-grids
    //

    inline std::vector&lt;double&gt; augmentSingl(const std::vector&lt;double&gt; &amp; xgrid, Funk f, int N = 100, double sigma = 3)
    {
        std::vector&lt;double&gt; result = xgrid;
        double xmin = result.front();
        double xmax = result.back();

        if ( f-&gt;getNArgs() != 1 )
        {
            std::string msg = &quot;augment_with_singularities(): takes only functions with one argument.\n&quot;;
                        msg+= &quot;  --- Actual arguments are: &quot; + args_string(f-&gt;getArgs());
#ifdef GAMBIT_DIR
            Gambit::utils_error().raise(LOCAL_INFO, msg);
#else
            throw std::invalid_argument(msg);
#endif
        }

        std::string arg = f-&gt;getArgs()[0];
        Singularities singlsMap = f-&gt;getSingl();

        if ( singlsMap.find(arg) != singlsMap.end() )
        {
            auto singls = singlsMap.at(arg);
            for (auto it = singls.begin(); it != singls.end(); it ++)
            {
                double position= it-&gt;first-&gt;bind()-&gt;eval();
                double width = it-&gt;second-&gt;bind()-&gt;eval();
                std::vector&lt;double&gt; singlgrid = linspace(std::max(position-width*sigma, xmin), std::min(position+width*sigma, xmax), N);
                result.insert(result.end(), singlgrid.begin(), singlgrid.end());
            }
        }
        // Sort the values only once
        std::sort(result.begin(), result.end());

        // Only use unique values, i.e. do not resolve the same singularity twice.
        result.erase(std::unique(result.begin(), result.end()), result.end());

        return result;
    }
}


#endif  // __DAFUNK_HPP__
</code></pre><hr><p>Updated on 2025-02-12 at 16:10:34 +0000</p></main></div></div></div><footer class="footer text-muted"><div class=container-xxl><div class=row><div class="col-lg-8 order-last order-lg-first"><ul class=list-inline><li class=list-inline-item>Powered by <a href=https://gohugo.io/>Hugo</a> and <a href=https://getdoks.org/>Doks</a></li></ul></div><div class="col-lg-8 order-first order-lg-last text-lg-end"><ul class=list-inline><li class=list-inline-item><a href=/license/>License</a></li></ul></div></div></div></footer><script src=/js/bootstrap.min.862c9eb8ab97f8c1c8584b21ce31113d8553917669561b040011b0061009a0b6c7a6b61fb659f56eabfa9f45259f001417dba1d65b229f685f3cdbb709482f8e.js integrity="sha512-hiyeuKuX+MHIWEshzjERPYVTkXZpVhsEABGwBhAJoLbHprYftln1bqv6n0UlnwAUF9uh1lsin2hfPNu3CUgvjg==" crossorigin=anonymous defer></script>
<script src=/js/highlight.min.3fa03d1d36ae7a66d6d5d2e19796832d40b4a5417eaaae1dfba8837d033467084e8c051f25aee596d415422573116115ccc5c2b29970d3490dafdce1a920a402.js integrity="sha512-P6A9HTauembW1dLhl5aDLUC0pUF+qq4d+6iDfQM0ZwhOjAUfJa7lltQVQiVzEWEVzMXCsplw00kNr9zhqSCkAg==" crossorigin=anonymous defer></script>
<script src=/main.min.04459eeb2d9d601a3ccc10d2699fb84f0442d5f5d3a16372b023be7564838ed2a755b908598f715d6b42c0be95895835b2e872f4fa4acd028ef3904671a92f1a.js integrity="sha512-BEWe6y2dYBo8zBDSaZ+4TwRC1fXToWNysCO+dWSDjtKnVbkIWY9xXWtCwL6ViVg1suhy9PpKzQKO85BGcakvGg==" crossorigin=anonymous defer></script>
<script src=https://gambitbsm.org/index.min.11993bf08828f2249a519146b2945803f1a32d7c677aabbab7c06d2c504becd826614ef26fd0871ab1c823df4063b24a8f7dbca65e952ac3aa424b8173e579db.js integrity="sha512-EZk78Igo8iSaUZFGspRYA/GjLXxnequ6t8BtLFBL7NgmYU7yb9CHGrHII99AY7JKj328pl6VKsOqQkuBc+V52w==" crossorigin=anonymous defer></script></body></html>