<!doctype html><html lang=en-us><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="ie=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><link rel=preload as=font href=/fonts/vendor/jost/jost-v4-latin-regular.woff2 type=font/woff2 crossorigin><link rel=preload as=font href=/fonts/vendor/jost/jost-v4-latin-500.woff2 type=font/woff2 crossorigin><link rel=preload as=font href=/fonts/vendor/jost/jost-v4-latin-700.woff2 type=font/woff2 crossorigin><script>(()=>{var e=localStorage.getItem("theme");e==="dark"&&document.documentElement.setAttribute("data-dark-mode","")})()</script><link rel=stylesheet href=/main.f8151591b2672085f0933fc9a990f490d47a5bae835eba13e592ae582ffe5e3a9177998e140a75a274da31357b8222d58a74d4a9f10720e05b02bc2a37e6f0ec.css integrity="sha512-+BUVkbJnIIXwkz/JqZD0kNR6W66DXroT5ZKuWC/+XjqRd5mOFAp1onTaMTV7giLVinTUqfEHIOBbArwqN+bw7A==" crossorigin=anonymous><noscript><style>img.lazyload{display:none}</style></noscript><meta name=robots content="index, follow"><meta name=googlebot content="index, follow, max-snippet:-1, max-image-preview:large, max-video-preview:-1"><meta name=bingbot content="index, follow, max-snippet:-1, max-image-preview:large, max-video-preview:-1"><title>file src/logmaster.cpp - GAMBIT</title><meta name=description content="[No description available]"><link rel=canonical href=/documentation/code/files/logmaster_8cpp/><meta property="og:locale" content="en_US"><meta property="og:type" content="article"><meta property="og:title" content="file src/logmaster.cpp"><meta property="og:description" content="[No description available]"><meta property="og:url" content="/documentation/code/files/logmaster_8cpp/"><meta property="og:site_name" content="GAMBIT"><meta property="og:image" content="/gambit_logo.png"><meta property="og:image:alt" content="GAMBIT"><meta name=twitter:card content="summary_large_image"><meta name=twitter:site content><meta name=twitter:creator content><meta name=twitter:title content="file src/logmaster.cpp"><meta name=twitter:description content="[No description available]"><meta name=twitter:image content="/gambit_logo.png"><meta name=twitter:image:alt content="file src/logmaster.cpp"><script type=application/ld+json>{"@context":"https://schema.org","@graph":[{"@type":"Organization","@id":"/#/schema/organization/1","name":"Doks","url":"/","sameAs":["https://github.com/GambitBSM"],"logo":{"@type":"ImageObject","@id":"/#/schema/image/1","url":"/logo-doks.png","width":450,"height":416,"caption":"Doks"},"image":{"@id":"/#/schema/image/1"}},{"@type":"WebSite","@id":"/#/schema/website/1","url":"/","name":"GAMBIT","description":"Documentation for GAMBIT, the Global And Modular BSM Inference Tool","publisher":{"@id":"/#/schema/organization/1"}},{"@type":"WebPage","@id":"/documentation/code/files/logmaster_8cpp/","url":"/documentation/code/files/logmaster_8cpp/","name":"file src\/logmaster.cpp","description":"[No description available]","isPartOf":{"@id":"/#/schema/website/1"},"about":{"@id":"/#/schema/organization/1"},"datePublished":"0001-01-01T00:00:00CET","dateModified":"0001-01-01T00:00:00CET","breadcrumb":{"@id":"/documentation/code/files/logmaster_8cpp/#/schema/breadcrumb/1"},"primaryImageOfPage":{"@id":"/documentation/code/files/logmaster_8cpp/#/schema/image/2"},"inLanguage":"en-US","potentialAction":[{"@type":"ReadAction","target":["/documentation/code/files/logmaster_8cpp/"]}]},{"@type":"BreadcrumbList","@id":"/documentation/code/files/logmaster_8cpp/#/schema/breadcrumb/1","name":"Breadcrumbs","itemListElement":[{"@type":"ListItem","position":1,"item":{"@type":"WebPage","@id":"/","url":"/","name":"Home"}},{"@type":"ListItem","position":2,"item":{"@id":"/documentationcodefileslogmaster_8cpp/"}}]},{"@context":"https://schema.org","@graph":[{"@type":"ImageObject","@id":"/documentation/code/files/logmaster_8cpp/#/schema/image/2","url":"/gambit_logo.png","contentUrl":"/gambit_logo.png","caption":"file src\/logmaster.cpp"}]}]}</script><meta name=theme-color content="#fff"><link rel=icon href=/favicon.ico sizes=any><link rel=icon type=image/svg+xml href=/favicon.svg><link rel=apple-touch-icon sizes=180x180 href=/apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=/favicon-16x16.png><link rel=manifest crossorigin=use-credentials href=/site.webmanifest></head><body class="documentation single light"><div class=sticky-top><div class=header-bar></div><header class="navbar navbar-expand-md navbar-light doks-navbar"><nav class="container-xxl flex-wrap flex-md-nowrap" aria-label="Main navigation"><a class="navbar-brand p-0 me-auto" href=/ aria-label=GAMBIT><img class=logo-light src=/gambit_logo.png width=50px>
<img class="logo-dark d-none" src=/gambit_logo.png width=50px>
GAMBIT</a>
<button class="btn btn-menu order-2 d-block d-lg-none" type=button data-bs-toggle=offcanvas data-bs-target=#offcanvasDoks aria-controls=offcanvasDoks aria-label="Open main menu"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-menu"><line x1="3" y1="12" x2="21" y2="12"/><line x1="3" y1="6" x2="21" y2="6"/><line x1="3" y1="18" x2="21" y2="18"/></svg></button><div class="offcanvas offcanvas-end border-0 py-lg-1" tabindex=-1 id=offcanvasDoks data-bs-backdrop=true aria-labelledby=offcanvasDoksLabel><div class="header-bar d-lg-none"></div><div class="offcanvas-header d-lg-none"><h2 class="h5 offcanvas-title ps-2" id=offcanvasDoksLabel><a class=text-dark href=/>GAMBIT</a></h2><button type=button class="btn-close text-reset me-2" data-bs-dismiss=offcanvas aria-label="Close main menu"></button></div><div class="offcanvas-body p-4 p-lg-0"><ul class="nav flex-column flex-lg-row align-items-lg-center mt-2 mt-lg-0 ms-lg-2 me-lg-auto"><li class="nav-item dropdown"><a class="nav-link dropdown-toggle ps-0 py-1" href=# id=navbarDropdownMenuLink role=button data-bs-toggle=dropdown aria-expanded=false>Releases
<span class=dropdown-caret><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-chevron-down"><polyline points="6 9 12 15 18 9"/></svg></span></a><ul class="dropdown-menu dropdown-menu-main shadow rounded border-0" aria-labelledby=navbarDropdownMenuLink><li><a class=dropdown-item href=https://github.com/GambitBSM/gambit_2.4>GAMBIT 2-4 ⧉</a></li><li><a class=dropdown-item href=https://github.com/GambitBSM/gambit_2.3>GAMBIT 2-3 ⧉</a></li><li><a class=dropdown-item href=https://github.com/GambitBSM/gambit_2.2>GAMBIT 2-2 ⧉</a></li><li><a class=dropdown-item href=https://github.com/GambitBSM/gambit_2.1>GAMBIT 2-1 ⧉</a></li><li><a class=dropdown-item href=https://github.com/GambitBSM/gambit_2.4/tags>All releases ⧉</a></li></ul></li><li class="nav-item dropdown"><a class="nav-link dropdown-toggle ps-0 py-1" href=# id=navbarDropdownMenuLink role=button data-bs-toggle=dropdown aria-expanded=false>Documentation
<span class=dropdown-caret><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-chevron-down"><polyline points="6 9 12 15 18 9"/></svg></span></a><ul class="dropdown-menu dropdown-menu-main shadow rounded border-0" aria-labelledby=navbarDropdownMenuLink><li><a class=dropdown-item href=/documentation/installation/introduction/>Installation</a></li><li><a class=dropdown-item href=/documentation/tutorials/the_gambit_interface>Tutorials</a></li><li><a class=dropdown-item href=/documentation/help/common_problems_and_questions/>Help</a></li><li><a class=dropdown-item href=/documentation/code/index_classes>Code Reference</a></li></ul></li><li class="nav-item dropdown"><a class="nav-link dropdown-toggle ps-0 py-1" href=# id=navbarDropdownMenuLink role=button data-bs-toggle=dropdown aria-expanded=false>Community
<span class=dropdown-caret><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-chevron-down"><polyline points="6 9 12 15 18 9"/></svg></span></a><ul class="dropdown-menu dropdown-menu-main shadow rounded border-0" aria-labelledby=navbarDropdownMenuLink><li><a class=dropdown-item href=/community/publications/>Publications</a></li><li><a class=dropdown-item href=/community/talks/>Talks</a></li><li><a class=dropdown-item href=/community/members/>Members</a></li><li><a class=dropdown-item href=/community/code_of_conduct/>Code of Conduct</a></li><li><a class=dropdown-item href=/community/contact/>Contact</a></li></ul></li></ul><hr class="text-black-50 my-4 d-lg-none"><form class="doks-search position-relative flex-grow-1 ms-lg-auto me-lg-2"><input id=search class="form-control is-search" type=search placeholder="Search site..." aria-label="Search site..." autocomplete=off><div id=suggestions class="shadow bg-white rounded d-none"></div></form><hr class="text-black-50 my-4 d-lg-none"><ul class="nav flex-column flex-lg-row"><li class=nav-item><a class="nav-link social-link" href=https://github.com/GambitBSM><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-github"><path d="M9 19c-5 1.5-5-2.5-7-3m14 6v-3.87a3.37 3.37.0 00-.94-2.61c3.14-.35 6.44-1.54 6.44-7A5.44 5.44.0 0020 4.77 5.07 5.07.0 0019.91 1S18.73.65 16 2.48a13.38 13.38.0 00-7 0C6.27.65 5.09 1 5.09 1A5.07 5.07.0 005 4.77 5.44 5.44.0 003.5 8.55c0 5.42 3.3 6.61 6.44 7A3.37 3.37.0 009 18.13V22"/></svg><small class="ms-2 d-lg-none">GitHub</small></a></li></ul><hr class="text-black-50 my-4 d-lg-none"><button id=mode class="btn btn-link" type=button aria-label="Toggle user interface mode">
<span class=toggle-dark><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-moon"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg></span><span class=toggle-light><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-sun"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></span></button></div></div></nav></header></div><div class="wrap container-xxl" role=document><div class=content><div class="row flex-xl-nowrap"><div class="col-lg-5 col-xl-4 docs-sidebar"><nav class=docs-links aria-label="Main navigation"><ul class="list-unstyled collapsible-sidebar"><li class=mb-1><button class="btn btn-toggle align-items-center rounded collapsed" data-bs-toggle=collapse data-bs-target=#section-installation aria-expanded=false>
Installation</button><div class=collapse id=section-installation><ul class="btn-toggle-nav list-unstyled fw-normal pb-1 small"><li><a class="docs-link rounded" href=/documentation/installation/introduction/>Getting Started</a></li><li><a class="docs-link rounded" href=/documentation/installation/docker_usage/>Docker Usage</a></li><li><a class="docs-link rounded" href=/documentation/installation/installation_for_linux/>Installation for Linux</a></li><li><a class="docs-link rounded" href=/documentation/installation/installation_for_windows/>Installation for Windows</a></li><li><a class="docs-link rounded" href=/documentation/installation/installation_for_macos/>Installation for macOS</a></li></ul></div></li><li class=mb-1><button class="btn btn-toggle align-items-center rounded collapsed" data-bs-toggle=collapse data-bs-target=#section-tutorials aria-expanded=false>
Tutorials</button><div class=collapse id=section-tutorials><ul class="btn-toggle-nav list-unstyled fw-normal pb-1 small"><li><a class="docs-link rounded" href=/documentation/tutorials/the_gambit_interface/>1 - The GAMBIT Interface</a></li></ul></div></li><li class=mb-1><button class="btn btn-toggle align-items-center rounded collapsed" data-bs-toggle=collapse data-bs-target=#section-help aria-expanded=false>
Help</button><div class=collapse id=section-help><ul class="btn-toggle-nav list-unstyled fw-normal pb-1 small"><li><a class="docs-link rounded" href=/documentation/help/common_problems_and_questions/>Common Problems and Questions</a></li><li><a class="docs-link rounded" href=/documentation/help/compiler_matrix/>Compiler Matrix</a></li><li><a class="docs-link rounded" href=/documentation/help/known_issues/>Known Issues</a></li><li><a class="docs-link rounded" href=/documentation/help/configuration_examples/>Configuration Examples</a></li></ul></div></li><li class=mb-1><button class="btn btn-toggle align-items-center rounded collapsed" data-bs-toggle=collapse data-bs-target=#section-code aria-expanded=false>
Code Reference</button><div class=collapse id=section-code><ul class="btn-toggle-nav list-unstyled fw-normal pb-1 small"><li><a class="docs-link rounded" href=/documentation/code/index_classes/>Classes</a></li><li><a class="docs-link rounded" href=/documentation/code/index_files/>Files</a></li><li><a class="docs-link rounded" href=/documentation/code/index_pages/>Pages</a></li><li><a class="docs-link rounded" href=/documentation/code/index_namespaces/>Namespaces</a></li></ul></div></li></ul></nav></div><nav class="docs-toc d-none d-xl-block col-xl-3" aria-label="Secondary navigation"><div class=d-xl-none><button class="btn btn-outline-primary btn-sm doks-toc-toggle collapsed" type=button data-bs-toggle=collapse data-bs-target=#onThisPage aria-controls=doks-docs-nav aria-expanded=false aria-label="Toggle On this page navigation">
<span>On this page</span>
<span><svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24" class="doks doks-expand" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><title>Expand</title><polyline points="7 13 12 18 17 13"/><polyline points="7 6 12 11 17 6"/></svg><svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24" class="doks doks-collapse" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><title>Collapse</title><polyline points="17 11 12 6 7 11"/><polyline points="17 18 12 13 7 18"/></svg></span></button><div class=collapse id=onThisPage><div class="card card-body mt-3 py-1"><div class=page-links><nav id=TableOfContents><ul><li><a href=#namespaces>Namespaces</a></li><li><a href=#detailed-description>Detailed Description</a></li><li><a href=#source-code>Source code</a></li></ul></nav></div></div></div></div><div class="page-links d-none d-xl-block"><h3>On this page</h3><nav id=TableOfContents><ul><li><a href=#namespaces>Namespaces</a></li><li><a href=#detailed-description>Detailed Description</a></li><li><a href=#source-code>Source code</a></li></ul></nav></div></nav><main class="docs-content col-lg-11 col-xl-9 mx-xl-auto"><nav aria-label=breadcrumb><ol class=breadcrumb><li class=breadcrumb-item><a href=/>Home</a></li><li class=breadcrumb-item><a href=/documentation/>Documentation</a></li><li class=breadcrumb-item><a href=/documentation/code/>Code Reference</a></li><li class="breadcrumb-item active" aria-current=page>file src/logmaster.cpp</li></ol></nav><p class=lead></p><h1 id=file-src-logmaster-cpp>file src/logmaster.cpp <a href=#file-src-logmaster-cpp class=anchor aria-hidden=true>#</a></h1><p>[No description available] <a href=#detailed-description>More&mldr;</a></p><h2 id=namespaces>Namespaces <a href=#namespaces class=anchor aria-hidden=true>#</a></h2><table><thead><tr><th>Name</th></tr></thead><tbody><tr><td><strong><a href=/documentation/code/namespaces/namespacegambit/>Gambit</a></strong><br>TODO: see if we can use this one:</td></tr><tr><td><strong><a href=/documentation/code/namespaces/namespacegambit_1_1logging/>Gambit::Logging</a></strong><br>Forward declare minimial logging components needed to use logger.</td></tr></tbody></table><h2 id=detailed-description>Detailed Description <a href=#detailed-description class=anchor aria-hidden=true>#</a></h2><p><strong>Author</strong>:</p><ul><li>Ben Farmer (<a href=mailto:benjamin.farmer@monash.edu.au>benjamin.farmer@monash.edu.au</a>)</li><li>Pat Scott (<a href=mailto:patscott@physics.mcgill.ca>patscott@physics.mcgill.ca</a>)</li></ul><p><strong>Date</strong>:</p><ul><li>2014 Mar</li><li>2014 Mar, May</li></ul><p>Member functions of logging classes</p><hr><p>Authors (add name and date if you modify):</p><hr><h2 id=source-code>Source code <a href=#source-code class=anchor aria-hidden=true>#</a></h2><pre><code>//   GAMBIT: Global and Modular BSM Inference Tool
//   *********************************************
///  \file
///
///  Member functions of logging classes
///
///  *********************************************
///
///  Authors (add name and date if you modify):
///
///  \author Ben Farmer
///          (benjamin.farmer@monash.edu.au)
///  \date 2014 Mar
///
///  \author Pat Scott
///          (patscott@physics.mcgill.ca)
///  \date 2014 Mar, May
///
///  *********************************************


// Standard libraries
#include &lt;set&gt;
#include &lt;fstream&gt;
#include &lt;cstdarg&gt;
#include &lt;stdexcept&gt;
#include &lt;algorithm&gt;
#include &lt;limits&gt;
#include &lt;chrono&gt;
#include &lt;omp.h&gt;

// Gambit
#include &quot;gambit/Logs/logmaster.hpp&quot;
#include &quot;gambit/Logs/logging.hpp&quot;
#include &quot;gambit/Utils/signal_helpers.hpp&quot;
#include &quot;gambit/Utils/util_functions.hpp&quot;
#include &quot;gambit/Utils/standalone_error_handlers.hpp&quot;
#include &quot;gambit/Utils/mpiwrapper.hpp&quot;
#include &quot;gambit/cmake/cmake_variables.hpp&quot;

// Code!
namespace Gambit
{

  namespace Logging
  {
    using namespace LogTags;

    //%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    /// @{ Logger class member function definitions
    //%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

    /// Logging &quot;controller&quot; object
    /// Keeps track of the individual logging objects.
    LogMaster::LogMaster()
      : loggers_readyQ (false)
      , silenced       (false)
      , separate_file_per_process(true)
      , log_debug_messages(false)
      , MPIrank        (0)
      , MPIsize        (1)
      , globlMaxThreads(omp_get_max_threads())
      , current_module (NULL)
      , current_backend(NULL)
      , stream         (NULL)
      , streamtags     (NULL)
      , backlog        (NULL)
    {
      // Note! MPIrank and MPIsize will not be correct until initialisation occurs!
    }

    /// Alternate constructor
    // Mainly for testing; lets you pass in pre-built loggers and their tags
    LogMaster::LogMaster(std::map&lt;std::set&lt;int&gt;,BaseLogger*&gt;&amp; loggersIN)
      : loggers        (loggersIN)
      , loggers_readyQ (true)
      , silenced       (false)
      , separate_file_per_process(true)
      , log_debug_messages(false)
      , MPIrank        (0)
      , MPIsize        (1)
      , globlMaxThreads(omp_get_max_threads())
      , current_module (NULL)
      , current_backend(NULL)
      , stream         (NULL)
      , streamtags     (NULL)
      , backlog        (NULL)
    {
      // Note! MPIrank and MPIsize will not be correct until initialisation occurs!
    }

    // Initialise dynamic memory required for thread safety
    void LogMaster::init_memory()
    {
      int n = globlMaxThreads;
      // Reserve enough space to hold as many variables as there are slots (threads) allowed
      if(stream==NULL)
      {
        #pragma omp critical(logmaster_common_init_memory_stream)
        {
          if(stream==NULL) stream = new std::ostringstream[n];
        }
      }
      if(streamtags==NULL)
      {
        #pragma omp critical(logmaster_common_init_memory_streamtags)
        {
          if(streamtags==NULL) streamtags = new std::set&lt;int&gt;[n];
        }
      }
      if(backlog==NULL)
      {
        #pragma omp critical(logmaster_common_init_memory_backlog)
        {
          if(backlog==NULL) backlog = new std::deque&lt;Message&gt;[n];
        }
      }
      if(current_module==NULL)
      {
        #pragma omp critical(logmaster_common_init_memory_current_module)
        {
          if(current_module==NULL) current_module = new int[n];
          std::fill(current_module, current_module+n, -1);
        }
      }
      if(current_backend==NULL)
      {
        #pragma omp critical(logmaster_common_init_memory_current_backend)
        {
          if(current_backend==NULL) current_backend = new int[n];
          std::fill(current_backend, current_backend+n, -1);
        }
      }
    }

    // Print the backlogs to the default log file
    void LogMaster::emit_backlog(bool verbose)
    {
       if (backlog!=NULL)
       {
         bool backlog_empty = true;
         for(int i=0; i&lt;globlMaxThreads; i++)
         {
            if(backlog[i].size()!=0) backlog_empty = false;
         }
         if (not backlog_empty)
         {
           if (verbose) *this&lt;&lt;&quot;Logger backlog buffer not empty during LogMaster destruction; attempting to deliver unsent messages to the logs...&quot;&lt;&lt;EOM;
           // If LogMaster was never initialised, create a default log file to which the messages can be dumped.
           if (not loggers_readyQ)
           {
             str log_path = Utils::construct_runtime_scratch(false) + &quot;default.log&quot;;
             #ifdef WITH_MPI
               if (GMPI::Is_initialized() and not GMPI::Is_finalized())
                 log_path += (&quot;_&quot; + std::to_string(GMPI::Comm().Get_rank()));
             #endif
             if (verbose) std::cout&lt;&lt;std::endl&lt;&lt;&quot;GAMBIT logger was never initialised. Outputting default log to &quot;&lt;&lt;log_path&lt;&lt;std::endl;
             StdLogger* deflogger = new StdLogger(log_path);
             std::set&lt;int&gt; deftag;
             deftag.insert(def);
             loggers[deftag] = deflogger;
             loggers_readyQ = true;
           }
           // Dump buffered messages
           empty_backlog();
         }
       }
    }

    // Destructor
    LogMaster::~LogMaster()
    {
       // See signal_handling.cpp for why we should not bail out in this situation
       // // LogMaster should not be destructed from within a parallel block. This check helps detect such a bug.
       // if(omp_get_level()!=0)
       // {
       //    // Raising an error from within the loggers within a parallel block probably will not end well, just use cout.
       //    #pragma omp critical(logmaster_destructor)
       //    {
       //      std::cout &lt;&lt; &quot;rank &quot;&lt;&lt;MPIrank&lt;&lt;&quot;: &quot;&lt;&lt; LOCAL_INFO &lt;&lt; &quot;: Tried to destruct LogMaster from inside an omp parallel block! This should not be allowed to happen, please file a bug report.&quot; &lt;&lt; std::endl;
       //      exit(EXIT_FAILURE);
       //    }
       // }

       if(not silenced)
       {
         // Check if there is anything in the output stream that has not been sent, and send it if there is
         // (these messages will get backlogged because they are sent (ended) from a parallel block, but we are
         // about to empty the backlogs anyway so that is no problem).
         if (stream != NULL and streamtags!= NULL)
         {
           #pragma omp parallel
           {
              int i = omp_get_thread_num();
              if (not stream[i].str().empty() or not streamtags[i].empty())
              {
                *this &lt;&lt;&quot;#### NO EOM RECEIVED FOR MESSAGE FROM THREAD (&quot;&lt;&lt;i&lt;&lt;&quot;): MESSAGE MAY BE INCOMPLETE ####&quot;&lt;&lt;warn&lt;&lt;EOM;
              }
           }
         }

         // Output the message backlogs if needed
         emit_backlog(true);

       }

       // Delete logger objects
       for(std::map&lt;std::set&lt;int&gt;,BaseLogger*&gt;::iterator keyvalue = loggers.begin(); keyvalue != loggers.end(); ++keyvalue)
       {
         // Ensure their filestreams have been flushed before we delete them.
         // (not sure if this is really needed, I think the message is in the operating systems domain by this point)
         // Edit:  I think I have decided that this is unnecessary
         //(keyvalue-&gt;second)-&gt;flush();
         delete (keyvalue-&gt;second);
       }

       // Delete the thread variables
       if (stream != NULL)         delete [] stream;
       if (streamtags != NULL)     delete [] streamtags;
       if (backlog != NULL)        delete [] backlog;
       if (current_module !=NULL)  delete [] current_module;
       if (current_backend !=NULL) delete [] current_backend;
    }

    /// Function to construct loggers according to blueprint
    // This is the function that yaml_parser.hpp uses. You provide tags as a set of strings, and the filename as a string. We then construct the logger objects in here.
    void LogMaster::initialise(std::vector&lt;std::pair&lt; std::set&lt;std::string&gt;, std::string &gt;&gt;&amp; loggerinfo)
    {
       // Fix up the MPI variables
       #ifdef WITH_MPI
       if(GMPI::Is_initialized())
       {
         GMPI::Comm COMM_WORLD;
         MPIsize = COMM_WORLD.Get_size();
         MPIrank = COMM_WORLD.Get_rank();
       }
       #endif

       // Check options and inform user what they are
       if (MPIrank == 0) std::cout &lt;&lt; &quot;Initialising logger...&quot;;
       // NOTE! Option to merge log files no longer exists. Concurrent write access is a nightmare. Log messages were
       // being lost due to different processes overwriting each others data, and using the FileLock system doesn't
       // help because the issue is the file pointer location. To fix that, files have to be closed and reopened
       // constantly, which creates a lot of overhead. On top of this, it is very hard to overwrite old log files at the
       // beginning of the run since we have to coordinate who creates the file at the beginning of the run, would have
       // to add a bunch of message passing. Overall it just isn't worth it.
       // #ifdef WITH_MPI
       // std::cout &lt;&lt; std::endl &lt;&lt; &quot;  separate_file_per_process = &quot;;
       // if(separate_file_per_process){ std::cout &lt;&lt; &quot;true; log messages will be stored in separate files for each MPI process (filename will be appended with underscore + MPI rank)&quot;; }
       // else{ std::cout &lt;&lt; &quot;false; log messages from separate MPI processes will be merged into one file (orchestrated by the OS; some mangling of concurrently written log messages may occur. Set this separate_file_per_process to 'True' if this mangling is a problem for you)&quot;;}
       // #endif
       std::ostringstream logmsg;
       logmsg &lt;&lt; &quot;  log_debug_messages = &quot;;
       if(log_debug_messages) logmsg &lt;&lt; &quot;true; log messages tagged as 'Debug' WILL be logged. &quot; &lt;&lt; endl &lt;&lt; &quot;WARNING: This may lead to very large log files!&quot;;
       else
       {
          // Add &quot;Debug&quot; tag to the global ignore list
          ignore.insert(LogTag::debug);
          logmsg &lt;&lt; &quot;false; log messages tagged as 'Debug' will NOT be logged&quot;;
       }

       if (MPIrank == 0) std::cout &lt;&lt; logmsg.str() &lt;&lt; std::endl;
       *this &lt;&lt; LogTag::logs &lt;&lt; LogTag::debug &lt;&lt; logmsg.str() &lt;&lt; EOM;

       // Iterate through map and build the logger objects
       for(std::vector&lt;std::pair&lt; std::set&lt;std::string&gt;, std::string &gt;&gt;::iterator infopair = loggerinfo.begin();
            infopair != loggerinfo.end(); ++infopair)
       {
          std::set&lt;std::string&gt; yamltags = infopair-&gt;first;
          std::string filename = infopair-&gt;second;
          std::set&lt;int&gt; tags;

          if(separate_file_per_process and MPIsize&gt;1
             and filename!=&quot;stdout&quot; and filename!=&quot;stderr&quot;)
          {
            std::ostringstream unique_filename;
            unique_filename &lt;&lt; filename &lt;&lt; &quot;_&quot; &lt;&lt; MPIrank;
            filename = unique_filename.str();
          }

          // Log the loggers being created :)
          // (will be put into a preliminary buffer until loggers are all constructed)
          *this &lt;&lt; LogTag::logs &lt;&lt; LogTag::debug &lt;&lt; std::endl &lt;&lt; &quot;Creating logger for tags [&quot;;

          // Iterate through string tags and convert them to the corresponding index
          for(std::set&lt;std::string&gt;::iterator stag = yamltags.begin();
                stag != yamltags.end(); ++stag)
          {
            // Finding the tag index from the tag string is kind of a drag, have to do a brute search
            int newtag = str2tag(*stag);
            // Check that valid tag was found (returns -1 if no tag found)
            if(newtag==-1)
            {
              // If we didn't find the tag, raise an exception (probably means there was an error in the yaml file)
              std::ostringstream errormsg;
              errormsg &lt;&lt; &quot;If you have an entry something like this:&quot;&lt;&lt; endl
                       &lt;&lt; &quot;  Logger:&quot; &lt;&lt; endl
                       &lt;&lt; &quot;    redirection:&quot; &lt;&lt; endl
                       &lt;&lt; &quot;    [&quot; &lt;&lt; *stag &lt;&lt; &quot;] : \&quot;blah.log\&quot;&quot; &lt;&lt; endl
                       &lt;&lt; &quot;in your yaml file, then you probably should remove the last line.  The LogTag&quot; &lt;&lt; endl
                       &lt;&lt; &quot;\&quot;&quot; &lt;&lt; *stag &lt;&lt; &quot;\&quot; is not recognised by the logger system.  This commonly happens&quot; &lt;&lt; endl
                       &lt;&lt; &quot;if you try to redirect log output for a module that either doesn't exist, or was&quot; &lt;&lt; endl
                       &lt;&lt; &quot;ditched at cmake time.&quot; &lt;&lt; endl;
              logging_error().raise(LOCAL_INFO,errormsg.str());
            }
            *this &lt;&lt; *stag &lt;&lt;&quot;, &quot;;
            tags.insert(newtag);
          }
          // Build the logger object
          StdLogger* newlogger;
          if(filename==&quot;stdout&quot;)
          {
            newlogger = new StdLogger(std::cout);
          }
          else if(filename==&quot;stderr&quot;)
          {
            newlogger = new StdLogger(std::cerr);
          }
          else
          {
            newlogger = new StdLogger(filename);
          }
          *this &lt;&lt; &quot;]; output is \&quot;&quot; &lt;&lt; filename &lt;&lt; &quot;\&quot;&quot;;
          loggers[tags] = newlogger;
       }
       *this &lt;&lt; EOM; // End message about loggers.
       // Set logger objects ready for use and dump any buffered messages
       loggers_readyQ = true;
       empty_backlog();
    }

    // Overload for initialise to allow input of logging instructions via maps
    void LogMaster::initialise(std::map&lt;std::set&lt;std::string&gt;, std::string&gt;&amp; loggerinfo)
    {
       std::vector&lt;std::pair&lt; std::set&lt;std::string&gt;, std::string &gt;&gt; loggerinfo_vec;
       // Iterate through map and convert it to a vector of pairs
       for(std::map&lt;std::set&lt;std::string&gt;, std::string&gt;::iterator infopair = loggerinfo.begin();
            infopair != loggerinfo.end(); ++infopair)
       {
          loggerinfo_vec.push_back(std::make_pair(infopair-&gt;first,infopair-&gt;second));
       }
       // Run the 'normal' initialise function
       initialise(loggerinfo_vec);
    }

    // Overload for initialise, to make it easier to manually initialise the logger in standalone modules
    void LogMaster::initialise(std::map&lt;std::string, std::string&gt;&amp; loggerinfo)
    {
      std::map&lt;std::set&lt;std::string&gt;, std::string&gt; loggerinfo_set;
      // Translate the string containing the tags into (map of) a set of tags
      for(std::map&lt;std::string, std::string&gt;::iterator infopair = loggerinfo.begin();
            infopair != loggerinfo.end(); ++infopair)
      {
        std::vector&lt;std::string&gt; tags_vec(Utils::delimiterSplit(infopair-&gt;first, &quot;,&quot;));
        std::set&lt;std::string&gt; tags_set(tags_vec.begin(), tags_vec.end());
        loggerinfo_set[tags_set] = infopair-&gt;second;
      }
      // Run the 'normal' initialise function
      initialise(loggerinfo_set);
    }

    // Function to completely silence all log messages
    void LogMaster::disable()
    {
       loggers_readyQ = true;
       silenced = true;
    }

    // Turn logs back on
    void LogMaster::enable()
    {
       silenced = false;
    }

    // Function to check if all log messages are silenced
    bool LogMaster::disabled()
    {
       return silenced;
    }

    // Dump the backlog buffer to the 'finalsend' function
    void LogMaster::empty_backlog()
    {
       // See signal_handling.cpp for why we should not bail out in this situation
       //if(omp_get_level()!=0)
       //{
       //   // Raising an error from within the loggers within a parallel block probably will not end well, just use cout.
       //   #pragma omp critical(logmaster_empty_backlog)
       //   {
       //     std::cout &lt;&lt; LOCAL_INFO &lt;&lt; &quot;: (rank &quot;&lt;&lt;MPIrank&lt;&lt;&quot;) Tried to run empty_backlog() (in LogMaster) from inside an omp parallel block! This should not be possible, please file a bug report.&quot; &lt;&lt; std::endl;
       //     exit(EXIT_FAILURE);
       //   }
       //}

       for(int i=0; i&lt;globlMaxThreads; i++)
       {
         for(size_t j=0; j&lt;backlog[i].size(); j++)
         {
            finalsend(backlog[i].front());
            backlog[i].pop_front();
         }
       }
    }

    /// Main logging function (user-friendly overloaded version)
    // Need a bunch of overloads of this to deal with
    void LogMaster::send(const std::string&amp; message)
    {
      std::set&lt;LogTag&gt; tags;
      send(message,tags);
    }

    void LogMaster::send(const std::string&amp; message, LogTag tag1)
    {
      std::set&lt;LogTag&gt; tags;
      tags.insert(tag1);
      send(message,tags);
    }

    void LogMaster::send(const std::string&amp; message, LogTag tag1, LogTag tag2)
    {
      std::set&lt;LogTag&gt; tags;
      tags.insert(tag1);
      tags.insert(tag2);
      send(message,tags);
    }

    void LogMaster::send(const std::string&amp; message, LogTag tag1, LogTag tag2, LogTag tag3)
    {
      std::set&lt;LogTag&gt; tags;
      tags.insert(tag1);
      tags.insert(tag2);
      tags.insert(tag3);
      send(message,tags);
    }

    void LogMaster::send(const std::string&amp; message, LogTag tag1, LogTag tag2, LogTag tag3, LogTag tag4)
    {
      std::set&lt;LogTag&gt; tags;
      tags.insert(tag1);
      tags.insert(tag2);
      tags.insert(tag3);
      tags.insert(tag4);
      send(message,tags);
    }

    void LogMaster::send(const std::string&amp; message, LogTag tag1, LogTag tag2, LogTag tag3, LogTag tag4, LogTag tag5)
    {
      std::set&lt;LogTag&gt; tags;
      tags.insert(tag1);
      tags.insert(tag2);
      tags.insert(tag3);
      tags.insert(tag4);
      tags.insert(tag5);
      send(message,tags);
    }

    //...add more as needed

    /// stringstream versions....
    void LogMaster::send(const std::ostringstream&amp; message)
    {
      std::set&lt;LogTag&gt; tags;
      send(message.str(),tags);
    }

    void LogMaster::send(const std::ostringstream&amp; message, LogTag tag1)
    {
      std::set&lt;LogTag&gt; tags;
      tags.insert(tag1);
      send(message.str(),tags);
    }

    void LogMaster::send(const std::ostringstream&amp; message, LogTag tag1, LogTag tag2)
    {
      std::set&lt;LogTag&gt; tags;
      tags.insert(tag1);
      tags.insert(tag2);
      send(message.str(),tags);
    }

    void LogMaster::send(const std::ostringstream&amp; message, LogTag tag1, LogTag tag2, LogTag tag3)
    {
      std::set&lt;LogTag&gt; tags;
      tags.insert(tag1);
      tags.insert(tag2);
      tags.insert(tag3);
      send(message.str(),tags);
    }

    void LogMaster::send(const std::ostringstream&amp; message, LogTag tag1, LogTag tag2, LogTag tag3, LogTag tag4)
    {
      std::set&lt;LogTag&gt; tags;
      tags.insert(tag1);
      tags.insert(tag2);
      tags.insert(tag3);
      tags.insert(tag4);
      send(message.str(),tags);
    }

    void LogMaster::send(const std::ostringstream&amp; message, LogTag tag1, LogTag tag2, LogTag tag3, LogTag tag4, LogTag tag5)
    {
      std::set&lt;LogTag&gt; tags;
      tags.insert(tag1);
      tags.insert(tag2);
      tags.insert(tag3);
      tags.insert(tag4);
      tags.insert(tag5);
      send(message.str(),tags);
    }

    //...add more as needed


    // Overload to allow tags to be cast to ints, for delivery to the &quot;full&quot; send function
    void LogMaster::send(const std::string&amp; message, std::set&lt;LogTag&gt;&amp; tags)
    {
      //std::set&lt;int&gt;&amp; int_tags = static_cast&lt; std::set&lt;int&gt; &gt;(tags);
      // I cannot seem to get the static cast to work, so just copying for now:
      //std::set&lt;int&gt; int_tags(tags);
      // Gah that seems not to work for the same reason, do one by one:
      std::set&lt;int&gt; int_tags;
      for(std::set&lt;LogTag&gt;::iterator tag = tags.begin(); tag != tags.end(); ++tag)
      {
        int_tags.insert(*tag); //static_cast&lt;int&gt;(*tag));
      }
      send(message, int_tags);
    }

    /// Serious version of main logging function
    // Ok this is the function that actual does things; the above are all just &quot;syntatic sugar&quot;, as the cool kids say.
    // In the end, this function should construct all the Message structs.
    void LogMaster::send(const std::string&amp; message, std::set&lt;int&gt;&amp; tags)
    {
       // LogMaster keeps an internal map of all the logging objects, where the keys are sets of 'LogTag's, constructed according to the inifile. So to figure out where the message has to go, we just compare the &quot;tags&quot; to these keys; if any of these keys are a subset of our tags, then we send the message to that LogHub.
       // Well almost. We have to seperate out the components first, because we can &quot;send&quot; a message to multiple components at once, but a direction command will never include two component tags (it is an error if it does).

       // Testing...
       //std::cout&lt;&lt;&quot;msg: &quot;&lt;&lt;message&lt;&lt;std::endl;

       // Preliminary stuff

       // Get thread number
       int i = omp_get_thread_num();

       // Automatically add the &quot;def&quot; (Default) tag so that the message definitely tries to go somewhere
       tags.insert(def);

       // Automatically add the tags for the &quot;current&quot; module and backend to the tags list
       if (current_module[i] != -1)
       {
         //std::cout&lt;&lt;&quot;current_module=&quot;&lt;&lt;current_module&lt;&lt;&quot;; adding tag &quot;&lt;&lt;tag2str()[current_module]&lt;&lt;std::endl;
         tags.insert(current_module[i]);
       }
       if (current_backend[i] != -1)
       {
         //std::cout&lt;&lt;&quot;current_backend=&quot;&lt;&lt;current_backend&lt;&lt;&quot;; adding tag &quot;&lt;&lt;tag2str()[current_backend]&lt;&lt;std::endl;
         tags.insert(current_backend[i]);
       }

       // If the loggers have not yet been initialised, buffer the message
       if(omp_get_level()!=0 or not loggers_readyQ)
       {
         backlog[i].emplace_back(message,tags); //time stamp automatically added NOW
       }
       else
       {
         if(omp_get_level()==0) empty_backlog();
         finalsend(Message(message,tags)); //time stamp automatically added NOW
       }
    } // end LogHub::send

    /// Version of send function used by buffer dump; skips all the tag modification stuff
    void LogMaster::finalsend(const Message&amp; mail)
    {
       // Check the 'ignore' set; if any of the specified tags are in this set, then do nothing more, i.e. ignore the message.
       // (need to add extra stuff to ignore modules and backends, since these cannot be normal tags)
       // Also ignore the message if logs have been 'silenced'.
       if( silenced or not Utils::is_disjoint(mail.tags, ignore) )
       {
         //std::cout&lt;&lt;&quot;Ignoring message...&quot;&lt;&lt;std::endl;
         return;
       }

       // If the &quot;cout&quot; tag is seen, repeat the message to stdout
       if(mail.tags.find(repeat_to_cout) != mail.tags.end()) std::cout &lt;&lt; mail.message &lt;&lt; std::endl;

       // If the &quot;cerr&quot; tag is seen, repeat the message to sterr
       if(mail.tags.find(repeat_to_cerr) != mail.tags.end()) std::cerr &lt;&lt; mail.message &lt;&lt; std::endl;

       // Sort the tags
       const SortedMessage sortedmsg(mail);

       // Main loop for message distribution

       // Loop through the map of loggers and see if any of them match subsets of 'key'.
       for(std::map&lt;std::set&lt;int&gt;,BaseLogger*&gt;::iterator keyvalue = loggers.begin(); keyvalue != loggers.end(); ++keyvalue)
       {
         // if set1 includes set2
         if( std::includes(mail.tags.begin(), mail.tags.end(),
                           (keyvalue-&gt;first).begin(), (keyvalue-&gt;first).end()) )
         {
           // Matching logger object found! Send it the sorted message object
           (keyvalue-&gt;second)-&gt;write(sortedmsg);
         }
       } //end loop over loggers
    } // end LogMaster::finalsend

    /// stringstream overloads...
    void LogMaster::send(const std::ostringstream&amp; message, std::set&lt;LogTag&gt;&amp; tags)
    {
      send(message.str(), tags);
    }

    void LogMaster::send(const std::ostringstream&amp; message, std::set&lt;int&gt;&amp; tags)
    {
      send(message.str(), tags);
    }

    void LogMaster::entering_module(int i)
    {
       init_memory();
       current_module[omp_get_thread_num()] = i;
    }

    void LogMaster::leaving_module()
    {
       init_memory();
       current_module[omp_get_thread_num()] = -1;
       leaving_backend();
    }

    void LogMaster::entering_backend(int i)
    {
       init_memory();
       current_backend[omp_get_thread_num()] = i;
       *this&lt;&lt;&quot;Setting current_backend=&quot;&lt;&lt;i;
       *this&lt;&lt;logs&lt;&lt;debug&lt;&lt;EOM;
    }
    void LogMaster::leaving_backend()
    {
       init_memory();
       int cb_test;
       cb_test = current_backend[omp_get_thread_num()];
       if (cb_test == -1) return;
       current_backend[omp_get_thread_num()] = -1;
       *this&lt;&lt;&quot;Restoring current_backend=&quot;&lt;&lt;-1;
       *this&lt;&lt;logs&lt;&lt;debug&lt;&lt;EOM;
    }

    /// Handle LogTag input
    void LogMaster::input(const LogTag&amp; tag)
    {
       init_memory();
       streamtags[omp_get_thread_num()].insert(tag);
    }

    /// Handle end of message character
    void LogMaster::input(const endofmessage&amp;)
    {
       init_memory();
       size_t i = omp_get_thread_num();
       // Collect the stream and tags, then send the message
       send(stream[i].str(), streamtags[i]);
       // Clear stream and tags for next message;
       stream[i].str(std::string()); //TODO: check that this works properly on all compilers...
       streamtags[i].clear();
    }

    /// Handle strings
    void LogMaster::input(const std::string&amp; in)
    {
       init_memory();
       stream[omp_get_thread_num()] &lt;&lt; in;
    }

    /// Handle various stream manipulators
    void LogMaster::input(const manip1 fp)
    {
       init_memory();
       stream[omp_get_thread_num()] &lt;&lt; fp;
    }

    void LogMaster::input(const manip2 fp)
    {
       init_memory();
       stream[omp_get_thread_num()] &lt;&lt; fp;
    }

    void LogMaster::input(const manip3 fp)
    {
       init_memory();
       stream[omp_get_thread_num()] &lt;&lt; fp;
    }

    /// @}

  } //end namespace Logging
} // end namespace Gambit
</code></pre><hr><p>Updated on 2023-06-26 at 21:36:54 +0000</p></main></div></div></div><footer class="footer text-muted"><div class=container-xxl><div class=row><div class="col-lg-8 order-last order-lg-first"><ul class=list-inline><li class=list-inline-item>Powered by <a href=https://gohugo.io/>Hugo</a> and <a href=https://getdoks.org/>Doks</a></li></ul></div><div class="col-lg-8 order-first order-lg-last text-lg-end"><ul class=list-inline><li class=list-inline-item><a href=/license/>License</a></li></ul></div></div></div></footer><script src=/js/bootstrap.min.a08b5ca912a508bc013bbd939befee438a0d2f798076e860e42147c7c0e2a01cf714847f7f5a2824876ce72867b0182df10e3537711faff352dd1ef41550be7c.js integrity="sha512-oItcqRKlCLwBO72Tm+/uQ4oNL3mAduhg5CFHx8DioBz3FIR/f1ooJIds5yhnsBgt8Q41N3Efr/NS3R70FVC+fA==" crossorigin=anonymous defer></script>
<script src=/js/highlight.min.ce91dadbce67e8eef36fa222c1c74c99f623c836cf6a316dffa1aeb390ab659d9a20d8145ceac39e049c555414fc360d31315e7980535dc6c03eb5374b7d559d.js integrity="sha512-zpHa285n6O7zb6IiwcdMmfYjyDbPajFt/6Gus5CrZZ2aINgUXOrDngScVVQU/DYNMTFeeYBTXcbAPrU3S31VnQ==" crossorigin=anonymous defer></script>
<script src=/main.min.57d9a84956f7d60008c47938c7fdd2f75e8618ff1d09c5a5e2b32f91debaf7681f7ceca8b51aded60067c2136172134a91ebc0674487c76a04e3244d927ebdde.js integrity="sha512-V9moSVb31gAIxHk4x/3S916GGP8dCcWl4rMvkd6692gffOyotRre1gBnwhNhchNKkevAZ0SHx2oE4yRNkn693g==" crossorigin=anonymous defer></script>
<script src=/index.min.95720397d55302de0e04fb8f4bf89a7396888a3be86803aa187cbc45924e9c35452b4bef718cd568b25ad872307d8f5537eab4c0045b8043c40628674a4fc53d.js integrity="sha512-lXIDl9VTAt4OBPuPS/iac5aIijvoaAOqGHy8RZJOnDVFK0vvcYzVaLJa2HIwfY9VN+q0wARbgEPEBihnSk/FPQ==" crossorigin=anonymous defer></script></body></html>