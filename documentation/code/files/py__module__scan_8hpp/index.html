<!doctype html><html lang=en><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="ie=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><link rel=preload as=font href=https://gambitbsm.org/fonts/vendor/jost/jost-v4-latin-regular.woff2 type=font/woff2 crossorigin><link rel=preload as=font href=https://gambitbsm.org/fonts/vendor/jost/jost-v4-latin-500.woff2 type=font/woff2 crossorigin><link rel=preload as=font href=https://gambitbsm.org/fonts/vendor/jost/jost-v4-latin-700.woff2 type=font/woff2 crossorigin><script>(()=>{var e=localStorage.getItem("theme");e==="dark"&&document.documentElement.setAttribute("data-dark-mode","")})()</script><link rel=stylesheet href=https://gambitbsm.org/main.e0ef67572fa591316dbb2b276e1aed52fd04025355d700a37b20ae76eb126fadbe7ceaddbb47632a2f1bf66c490a69e0cd1f1a0dc12b2980ae4b5ffc6d257d62.css integrity="sha512-4O9nVy+lkTFtuysnbhrtUv0EAlNV1wCjeyCudusSb62+fOrdu0djKi8b9mxJCmngzR8aDcErKYCuS1/8bSV9Yg==" crossorigin=anonymous><noscript><style>img.lazyload{display:none}</style></noscript><meta name=robots content="index, follow"><meta name=googlebot content="index, follow, max-snippet:-1, max-image-preview:large, max-video-preview:-1"><meta name=bingbot content="index, follow, max-snippet:-1, max-image-preview:large, max-video-preview:-1"><title>file ScannerBit/py_module_scan.hpp - GAMBIT</title><meta name=description content="[No description available]"><link rel=canonical href=https://gambitbsm.org/documentation/code/files/py__module__scan_8hpp/><meta property="og:locale" content="en_US"><meta property="og:type" content="article"><meta property="og:title" content="file ScannerBit/py_module_scan.hpp"><meta property="og:description" content="[No description available]"><meta property="og:url" content="https://gambitbsm.org/documentation/code/files/py__module__scan_8hpp/"><meta property="og:site_name" content="GAMBIT"><meta property="og:image" content="https://gambitbsm.org/gambit_logo.png"><meta property="og:image:alt" content="GAMBIT"><meta name=twitter:card content="summary_large_image"><meta name=twitter:site content><meta name=twitter:creator content><meta name=twitter:title content="file ScannerBit/py_module_scan.hpp"><meta name=twitter:description content="[No description available]"><meta name=twitter:image content="https://gambitbsm.org/gambit_logo.png"><meta name=twitter:image:alt content="file ScannerBit/py_module_scan.hpp"><script type=application/ld+json>{"@context":"https://schema.org","@graph":[{"@type":"Organization","@id":"https://gambitbsm.org/#/schema/organization/1","name":"Doks","url":"https://gambitbsm.org/","sameAs":["https://github.com/GambitBSM"],"logo":{"@type":"ImageObject","@id":"https://gambitbsm.org/#/schema/image/1","url":"https://gambitbsm.org/logo-doks.png","width":450,"height":416,"caption":"Doks"},"image":{"@id":"https://gambitbsm.org/#/schema/image/1"}},{"@type":"WebSite","@id":"https://gambitbsm.org/#/schema/website/1","url":"https://gambitbsm.org/","name":"GAMBIT","description":"Documentation for GAMBIT, the Global And Modular BSM Inference Tool","publisher":{"@id":"https://gambitbsm.org/#/schema/organization/1"}},{"@type":"WebPage","@id":"https://gambitbsm.org/documentation/code/files/py__module__scan_8hpp/","url":"https://gambitbsm.org/documentation/code/files/py__module__scan_8hpp/","name":"file ScannerBit\/py_module_scan.hpp","description":"[No description available]","isPartOf":{"@id":"https://gambitbsm.org/#/schema/website/1"},"about":{"@id":"https://gambitbsm.org/#/schema/organization/1"},"datePublished":"0001-01-01T00:00:00CET","dateModified":"0001-01-01T00:00:00CET","breadcrumb":{"@id":"https://gambitbsm.org/documentation/code/files/py__module__scan_8hpp/#/schema/breadcrumb/1"},"primaryImageOfPage":{"@id":"https://gambitbsm.org/documentation/code/files/py__module__scan_8hpp/#/schema/image/2"},"inLanguage":"en-US","potentialAction":[{"@type":"ReadAction","target":["https://gambitbsm.org/documentation/code/files/py__module__scan_8hpp/"]}]},{"@type":"BreadcrumbList","@id":"https://gambitbsm.org/documentation/code/files/py__module__scan_8hpp/#/schema/breadcrumb/1","name":"Breadcrumbs","itemListElement":[{"@type":"ListItem","position":1,"item":{"@type":"WebPage","@id":"https://gambitbsm.org/","url":"https://gambitbsm.org/","name":"Home"}},{"@type":"ListItem","position":2,"item":{"@type":"WebPage","@id":"https://gambitbsm.org/documentation/","url":"https://gambitbsm.org/documentation/","name":"Documentation"}},{"@type":"ListItem","position":3,"item":{"@type":"WebPage","@id":"https://gambitbsm.org/documentation/code/","url":"https://gambitbsm.org/documentation/code/","name":"Code"}},{"@type":"ListItem","position":4,"item":{"@type":"WebPage","@id":"https://gambitbsm.org/documentation/code/files/","url":"https://gambitbsm.org/documentation/code/files/","name":"Files"}},{"@type":"ListItem","position":5,"item":{"@id":"https://gambitbsm.org/documentation/code/files/py__module__scan_8hpp/"}}]},{"@context":"https://schema.org","@graph":[{"@type":"ImageObject","@id":"https://gambitbsm.org/documentation/code/files/py__module__scan_8hpp/#/schema/image/2","url":"https://gambitbsm.org/gambit_logo.png","contentUrl":"https://gambitbsm.org/gambit_logo.png","caption":"file ScannerBit\/py_module_scan.hpp"}]}]}</script><meta name=theme-color content="#fff"><link rel=icon href=https://gambitbsm.org/favicon.ico sizes=any><link rel=icon type=image/svg+xml href=https://gambitbsm.org/favicon.svg><link rel=apple-touch-icon sizes=180x180 href=https://gambitbsm.org/apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=https://gambitbsm.org/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=https://gambitbsm.org/favicon-16x16.png><link rel=manifest crossorigin=use-credentials href=https://gambitbsm.org/site.webmanifest></head><body class="documentation single light"><div class=sticky-top><div class=header-bar></div><header class="navbar navbar-expand-md navbar-light doks-navbar"><nav class="container-xxl flex-wrap flex-md-nowrap" aria-label="Main navigation"><a class="navbar-brand p-0 me-auto" href=https://gambitbsm.org/ aria-label=GAMBIT><img class=logo-light src=https://gambitbsm.org/gambit_logo.png width=50px>
<img class="logo-dark d-none" src=https://gambitbsm.org/gambit_logo.png width=50px>
GAMBIT</a>
<button class="btn btn-menu order-2 d-block d-lg-none" type=button data-bs-toggle=offcanvas data-bs-target=#offcanvasDoks aria-controls=offcanvasDoks aria-label="Open main menu"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-menu"><line x1="3" y1="12" x2="21" y2="12"/><line x1="3" y1="6" x2="21" y2="6"/><line x1="3" y1="18" x2="21" y2="18"/></svg></button><div class="offcanvas offcanvas-end border-0 py-lg-1" tabindex=-1 id=offcanvasDoks data-bs-backdrop=true aria-labelledby=offcanvasDoksLabel><div class="header-bar d-lg-none"></div><div class="offcanvas-header d-lg-none"><h2 class="h5 offcanvas-title ps-2" id=offcanvasDoksLabel><a class=text-dark href=/>GAMBIT</a></h2><button type=button class="btn-close text-reset me-2" data-bs-dismiss=offcanvas aria-label="Close main menu"></button></div><div class="offcanvas-body p-4 p-lg-0"><ul class="nav flex-column flex-lg-row align-items-lg-center mt-2 mt-lg-0 ms-lg-2 me-lg-auto"><li class="nav-item dropdown"><a class="nav-link dropdown-toggle ps-0 py-1" href=# id=navbarDropdownMenuLink role=button data-bs-toggle=dropdown aria-expanded=false>Releases
<span class=dropdown-caret><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-chevron-down"><polyline points="6 9 12 15 18 9"/></svg></span></a><ul class="dropdown-menu dropdown-menu-main shadow rounded border-0" aria-labelledby=navbarDropdownMenuLink><li><a class=dropdown-item href=https://github.com/GambitBSM/gambit_2.6>GAMBIT 2-6 ⧉</a></li><li><a class=dropdown-item href=https://github.com/GambitBSM/gambit_2.5>GAMBIT 2-5 ⧉</a></li><li><a class=dropdown-item href=https://github.com/GambitBSM/gambit_2.4>GAMBIT 2-4 ⧉</a></li><li><a class=dropdown-item href=https://github.com/GambitBSM/gambit_2.3>GAMBIT 2-3 ⧉</a></li><li><a class=dropdown-item href=https://github.com/GambitBSM/gambit_2.2>GAMBIT 2-2 ⧉</a></li><li><a class=dropdown-item href=https://github.com/GambitBSM/gambit_2.1>GAMBIT 2-1 ⧉</a></li><li><a class=dropdown-item href=https://github.com/GambitBSM/gambit_light_1.0>GAMBIT Light ⧉</a></li><li><a class=dropdown-item href=https://github.com/GambitBSM/gambit_2.6/tags>All releases ⧉</a></li></ul></li><li class="nav-item dropdown"><a class="nav-link dropdown-toggle ps-0 py-1" href=# id=navbarDropdownMenuLink role=button data-bs-toggle=dropdown aria-expanded=false>Documentation
<span class=dropdown-caret><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-chevron-down"><polyline points="6 9 12 15 18 9"/></svg></span></a><ul class="dropdown-menu dropdown-menu-main shadow rounded border-0" aria-labelledby=navbarDropdownMenuLink><li><a class=dropdown-item href=/documentation/installation/introduction/>Installation</a></li><li><a class=dropdown-item href=/documentation/physics/analyses>Physics</a></li><li><a class=dropdown-item href=/documentation/tutorials/the_gambit_interface>Tutorials</a></li><li><a class=dropdown-item href=/documentation/help/common_problems_and_questions/>Help</a></li><li><a class=dropdown-item href=/documentation/code/index_classes>Code Reference</a></li></ul></li><li class="nav-item dropdown"><a class="nav-link dropdown-toggle ps-0 py-1" href=# id=navbarDropdownMenuLink role=button data-bs-toggle=dropdown aria-expanded=false>Community
<span class=dropdown-caret><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-chevron-down"><polyline points="6 9 12 15 18 9"/></svg></span></a><ul class="dropdown-menu dropdown-menu-main shadow rounded border-0" aria-labelledby=navbarDropdownMenuLink><li><a class=dropdown-item href=https://github.com/GambitBSM/wiki>Wiki</a></li><li><a class=dropdown-item href=/community/publications/>Publications</a></li><li><a class=dropdown-item href=/community/talks/>Talks</a></li><li><a class=dropdown-item href=/community/members/>Members</a></li><li><a class=dropdown-item href=/community/code_of_conduct/>Code of Conduct</a></li><li><a class="dropdown-item active" href=/community/contact/ aria-current=true>Contact</a></li></ul></li></ul><hr class="text-black-50 my-4 d-lg-none"><form class="doks-search position-relative flex-grow-1 ms-lg-auto me-lg-2"><input id=search class="form-control is-search" type=search placeholder="Search site..." aria-label="Search site..." autocomplete=off><div id=suggestions class="shadow bg-white rounded d-none"></div></form><hr class="text-black-50 my-4 d-lg-none"><ul class="nav flex-column flex-lg-row"><li class=nav-item><a class="nav-link social-link" href=https://github.com/GambitBSM><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-github"><path d="M9 19c-5 1.5-5-2.5-7-3m14 6v-3.87a3.37 3.37.0 00-.94-2.61c3.14-.35 6.44-1.54 6.44-7A5.44 5.44.0 0020 4.77 5.07 5.07.0 0019.91 1S18.73.65 16 2.48a13.38 13.38.0 00-7 0C6.27.65 5.09 1 5.09 1A5.07 5.07.0 005 4.77 5.44 5.44.0 003.5 8.55c0 5.42 3.3 6.61 6.44 7A3.37 3.37.0 009 18.13V22"/></svg><small class="ms-2 d-lg-none">GitHub</small></a></li></ul><hr class="text-black-50 my-4 d-lg-none"><button id=mode class="btn btn-link" type=button aria-label="Toggle user interface mode">
<span class=toggle-dark><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-moon"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg></span><span class=toggle-light><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-sun"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></span></button></div></div></nav></header></div><div class="wrap container-xxl" role=document><div class=content><div class="row flex-xl-nowrap"><div class="col-lg-5 col-xl-4 docs-sidebar"><nav class=docs-links aria-label="Main navigation"><ul class="list-unstyled collapsible-sidebar"><li class=mb-1><button class="btn btn-toggle align-items-center rounded collapsed" data-bs-toggle=collapse data-bs-target=#section-installation aria-expanded=false>
Installation</button><div class=collapse id=section-installation><ul class="btn-toggle-nav list-unstyled fw-normal pb-1 small"><li><a class="docs-link rounded" href=/documentation/installation/introduction/>Getting Started</a></li><li><a class="docs-link rounded" href=/documentation/installation/docker_usage/>Docker Usage</a></li><li><a class="docs-link rounded" href=/documentation/installation/installation_for_linux/>Installation for Linux</a></li><li><a class="docs-link rounded" href=/documentation/installation/installation_for_windows/>Installation for Windows</a></li><li><a class="docs-link rounded" href=/documentation/installation/installation_for_macos/>Installation for macOS</a></li></ul></div></li><li class=mb-1><button class="btn btn-toggle align-items-center rounded collapsed" data-bs-toggle=collapse data-bs-target=#section-tutorials aria-expanded=false>
Tutorials</button><div class=collapse id=section-tutorials><ul class="btn-toggle-nav list-unstyled fw-normal pb-1 small"><li><a class="docs-link rounded" href=/documentation/tutorials/the_gambit_interface/>1 - The GAMBIT Interface</a></li><li><a class="docs-link rounded" href=/documentation/tutorials/in_person_tutorials/>In person tutorials</a></li></ul></div></li><li class=mb-1><button class="btn btn-toggle align-items-center rounded collapsed" data-bs-toggle=collapse data-bs-target=#section-physics aria-expanded=false>
Physics</button><div class=collapse id=section-physics><ul class="btn-toggle-nav list-unstyled fw-normal pb-1 small"><li><a class="docs-link rounded" href=/documentation/physics/analyses/>ColliderBit analysis</a></li></ul></div></li><li class=mb-1><button class="btn btn-toggle align-items-center rounded collapsed" data-bs-toggle=collapse data-bs-target=#section-help aria-expanded=false>
Help</button><div class=collapse id=section-help><ul class="btn-toggle-nav list-unstyled fw-normal pb-1 small"><li><a class="docs-link rounded" href=/documentation/help/common_problems_and_questions/>Common Problems and Questions</a></li><li><a class="docs-link rounded" href=/documentation/help/compiler_matrix/>Compiler Matrix</a></li><li><a class="docs-link rounded" href=/documentation/help/known_issues/>Known Issues</a></li><li><a class="docs-link rounded" href=/documentation/help/configuration_examples/>Configuration Examples</a></li><li><a class="docs-link rounded" href=/documentation/help/support/>Support</a></li></ul></div></li><li class=mb-1><button class="btn btn-toggle align-items-center rounded collapsed" data-bs-toggle=collapse data-bs-target=#section-code aria-expanded=false>
Code Reference</button><div class=collapse id=section-code><ul class="btn-toggle-nav list-unstyled fw-normal pb-1 small"><li><a class="docs-link rounded" href=/documentation/code/index_classes/>Classes</a></li><li><a class="docs-link rounded" href=/documentation/code/index_files/>Files</a></li><li><a class="docs-link rounded" href=/documentation/code/index_pages/>Pages</a></li><li><a class="docs-link rounded" href=/documentation/code/index_namespaces/>Namespaces</a></li></ul></div></li></ul></nav></div><nav class="docs-toc d-none d-xl-block col-xl-3" aria-label="Secondary navigation"><div class=d-xl-none><button class="btn btn-outline-primary btn-sm doks-toc-toggle collapsed" type=button data-bs-toggle=collapse data-bs-target=#onThisPage aria-controls=doks-docs-nav aria-expanded=false aria-label="Toggle On this page navigation">
<span>On this page</span>
<span><svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24" class="doks doks-expand" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><title>Expand</title><polyline points="7 13 12 18 17 13"/><polyline points="7 6 12 11 17 6"/></svg><svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24" class="doks doks-collapse" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><title>Collapse</title><polyline points="17 11 12 6 7 11"/><polyline points="17 18 12 13 7 18"/></svg></span></button><div class=collapse id=onThisPage><div class="card card-body mt-3 py-1"><div class=page-links><nav id=TableOfContents><ul><li><a href=#namespaces>Namespaces</a></li><li><a href=#classes>Classes</a></li><li><a href=#functions>Functions</a></li><li><a href=#detailed-description>Detailed Description</a></li><li><a href=#functions-documentation>Functions Documentation</a><ul><li><a href=#function-pybind11-embedded-module>function PYBIND11_EMBEDDED_MODULE</a></li></ul></li><li><a href=#source-code>Source code</a></li></ul></nav></div></div></div></div><div class="page-links d-none d-xl-block"><h3>On this page</h3><nav id=TableOfContents><ul><li><a href=#namespaces>Namespaces</a></li><li><a href=#classes>Classes</a></li><li><a href=#functions>Functions</a></li><li><a href=#detailed-description>Detailed Description</a></li><li><a href=#functions-documentation>Functions Documentation</a><ul><li><a href=#function-pybind11-embedded-module>function PYBIND11_EMBEDDED_MODULE</a></li></ul></li><li><a href=#source-code>Source code</a></li></ul></nav></div></nav><main class="docs-content col-lg-11 col-xl-9 mx-xl-auto"><nav aria-label=breadcrumb><ol class=breadcrumb><li class=breadcrumb-item><a href=/>Home</a></li><li class=breadcrumb-item><a href=/documentation/>Documentation</a></li><li class=breadcrumb-item><a href=/documentation/code/>Code Reference</a></li><li class="breadcrumb-item active" aria-current=page>file ScannerBit/py_module_scan.hpp</li></ol></nav><p class=lead></p><h1 id=file-scannerbit-py-module-scan-hpp>file ScannerBit/py_module_scan.hpp <a href=#file-scannerbit-py-module-scan-hpp class=anchor aria-hidden=true>#</a></h1><p>[No description available] <a href=#detailed-description>More&mldr;</a></p><h2 id=namespaces>Namespaces <a href=#namespaces class=anchor aria-hidden=true>#</a></h2><table><thead><tr><th>Name</th></tr></thead><tbody><tr><td><strong><a href=/documentation/code/namespaces/namespacegambit/>Gambit</a></strong><br>TODO: see if we can use this one:</td></tr><tr><td><strong><a href=/documentation/code/namespaces/namespacegambit_1_1scanner/>Gambit::Scanner</a></strong></td></tr><tr><td><strong><a href=/documentation/code/namespaces/namespacegambit_1_1scanner_1_1plugins/>Gambit::Scanner::Plugins</a></strong></td></tr><tr><td><strong><a href=/documentation/code/namespaces/namespacegambit_1_1scanner_1_1plugins_1_1scannerpyplugin/>Gambit::Scanner::Plugins::ScannerPyPlugin</a></strong></td></tr></tbody></table><h2 id=classes>Classes <a href=#classes class=anchor aria-hidden=true>#</a></h2><table><thead><tr><th></th><th>Name</th></tr></thead><tbody><tr><td>class</td><td><strong><a href=/documentation/code/classes/classgambit_1_1scanner_1_1plugins_1_1scannerpyplugin_1_1like__ptr__base/>Gambit::Scanner::Plugins::ScannerPyPlugin::like_ptr_base</a></strong><br>A class that wraps a shared pointer to a <a href=/documentation/code/classes/classgambit_1_1scanner_1_1function__base/>Function_Base</a> object.</td></tr><tr><td>struct</td><td><strong><a href=/documentation/code/classes/structgambit_1_1scanner_1_1plugins_1_1scannerpyplugin_1_1like__hypercube/>Gambit::Scanner::Plugins::ScannerPyPlugin::like_hypercube</a></strong><br>A derived class of <a href>like_ptr_base</a> for managing <a href=/documentation/code/classes/classgambit_1_1scanner_1_1function__base/>Function_Base</a> objects related to hypercubes.</td></tr><tr><td>struct</td><td><strong><a href=/documentation/code/classes/structgambit_1_1scanner_1_1plugins_1_1scannerpyplugin_1_1like__physical/>Gambit::Scanner::Plugins::ScannerPyPlugin::like_physical</a></strong><br>A derived class of <a href>like_ptr_base</a> for managing <a href=/documentation/code/classes/classgambit_1_1scanner_1_1function__base/>Function_Base</a> objects related to physical properties.</td></tr><tr><td>struct</td><td><strong><a href=/documentation/code/classes/structgambit_1_1scanner_1_1plugins_1_1scannerpyplugin_1_1like__prior__physical/>Gambit::Scanner::Plugins::ScannerPyPlugin::like_prior_physical</a></strong><br>A derived class of <a href>like_ptr_base</a> for managing <a href=/documentation/code/classes/classgambit_1_1scanner_1_1function__base/>Function_Base</a> objects related to physical priors.</td></tr><tr><td>struct</td><td><strong><a href=/documentation/code/classes/structgambit_1_1scanner_1_1plugins_1_1scannerpyplugin_1_1prior__physical/>Gambit::Scanner::Plugins::ScannerPyPlugin::prior_physical</a></strong><br>A derived class of <a href=/documentation/code/classes/classgambit_1_1scanner_1_1plugins_1_1scannerpyplugin_1_1like__ptr__base/>like_ptr_base</a> for managing <a href=/documentation/code/classes/classgambit_1_1scanner_1_1function__base/>Function_Base</a> objects related to physical priors.</td></tr><tr><td>class</td><td><strong><a href=/documentation/code/classes/classgambit_1_1scanner_1_1plugins_1_1scannerpyplugin_1_1scanner__base/>Gambit::Scanner::Plugins::ScannerPyPlugin::scanner_base</a></strong><br>A base class for scanner functionality.</td></tr></tbody></table><h2 id=functions>Functions <a href=#functions class=anchor aria-hidden=true>#</a></h2><table><thead><tr><th></th><th>Name</th></tr></thead><tbody><tr><td></td><td><strong><a href=/documentation/code/files/py__module__scan_8hpp/#function-pybind11-embedded-module>PYBIND11_EMBEDDED_MODULE</a></strong>(<a href=/documentation/code/files/toy__mcmc_8cpp/#function-scanner-plugin>scanner_plugin</a> , m )<br>A pybind11 module named &ldquo;scanner_plugin&rdquo;.</td></tr></tbody></table><h2 id=detailed-description>Detailed Description <a href=#detailed-description class=anchor aria-hidden=true>#</a></h2><p><strong>Author</strong>: Gregory Martinez (<a href=mailto:gregory.david.martinez@gmail.com>gregory.david.martinez@gmail.com</a>)</p><p><strong>Date</strong>: 2023 Dec</p><p>Defines the python scanner_plugin module to be used in the python plugins.</p><hr><p>Authors:</p><hr><h2 id=functions-documentation>Functions Documentation <a href=#functions-documentation class=anchor aria-hidden=true>#</a></h2><h3 id=function-pybind11-embedded-module>function PYBIND11_EMBEDDED_MODULE <a href=#function-pybind11-embedded-module class=anchor aria-hidden=true>#</a></h3><pre><code>PYBIND11_EMBEDDED_MODULE(
    scanner_plugin ,
    m 
)
</code></pre><p>A pybind11 module named &ldquo;scanner_plugin&rdquo;.</p><p><strong>Parameters</strong>:</p><ul><li><strong>m</strong> The pybind11 module to which the bindings are added.</li></ul><p>This module is used to bind Python and C++ code using the pybind11 library. It imports the &ldquo;scannerbit&rdquo; module and defines some functions and attributes for the module.</p><h2 id=source-code>Source code <a href=#source-code class=anchor aria-hidden=true>#</a></h2><pre><code>//   GAMBIT: Global and Modular BSM Inference Tool
//   *********************************************
///  \file
///
///  Defines the python scanner_plugin module to 
///  be used in the python plugins.
///
///  *********************************************
///
///  Authors:
///
///  \author Gregory Martinez
///          (gregory.david.martinez@gmail.com)
///  \date 2023 Dec
///
///  *********************************************

namespace Gambit
{
    
    namespace Scanner 
    {
        
        namespace Plugins
        {
            
            namespace ScannerPyPlugin
            {
                
                /**
                 * @brief A function to export Python plugin data.
                 * 
                 * This function is used to export data related to the Python plugin. It returns a reference to a pointer to the pluginData object.
                 * 
                 * @return Returns a reference to a pointer to the pluginData object.
                 */
                EXPORT_SYMBOLS pluginData*&amp; pythonPluginData()
                {
                    static pluginData *data = nullptr;
                    
                    return data;
                }
                
                /**
                 * @brief A function to retrieve a value from the INI file.
                 * 
                 * This function is used to retrieve a value from the INI file based on a given key. The key is passed as a parameter to the function.
                 * 
                 * @tparam T The type of the value to be retrieved from the INI file.
                 * @param in The key for which the value is to be retrieved from the INI file.
                 * @return Returns the value associated with the given key in the INI file.
                 */
                template &lt;typename T&gt;
                T get_inifile_value(const std::string &amp;in)
                {
                    if (!pythonPluginData()-&gt;node[in])
                    {
                        scan_err &lt;&lt; &quot;Missing iniFile entry \&quot;&quot;&lt;&lt; in &lt;&lt; &quot;\&quot; needed by a gambit plugin:  \n&quot;
                                &lt;&lt; pythonPluginData()-&gt;print() &lt;&lt; scan_end;
                        return T();
                    }

                    return pythonPluginData()-&gt;node[in].template as&lt;T&gt;();
                }
                
                /**
                 * @brief A function to retrieve a value from the INI file.
                 * 
                 * This function is used to retrieve a value from the INI file based on a given key. If the key is not found, a default value is returned.
                 * 
                 * @tparam T The type of the value to be retrieved from the INI file.
                 * @param in The key for which the value is to be retrieved from the INI file.
                 * @param defaults The default value to be returned if the key is not found in the INI file.
                 * @return Returns the value associated with the given key in the INI file, or the default value if the key is not found.
                 */
                template &lt;typename T&gt;
                T get_inifile_value(const std::string &amp;in, const T &amp;defaults)
                {
                    if (!pythonPluginData()-&gt;node[in])
                    {
                        return defaults;
                    }

                    return pythonPluginData()-&gt;node[in].template as&lt;T&gt;();
                }
                
                /**
                 * @brief A function to retrieve a node from the INI file.
                 * 
                 * This function is used to retrieve a YAML::Node from the INI file based on a given key. The key is passed as a parameter to the function.
                 * 
                 * @param in The key for which the node is to be retrieved from the INI file.
                 * @return Returns the YAML::Node associated with the given key in the INI file.
                 */
                inline YAML::Node get_inifile_node(const std::string &amp;in)                                                      
                {
                    return pythonPluginData()-&gt;node[in];
                }

                /**
                 * @brief A function to retrieve the root node from the INI file.
                 * 
                 * This function is used to retrieve the root YAML::Node from the INI file.
                 * 
                 * @return Returns the root YAML::Node of the INI file.
                 */
                inline YAML::Node get_inifile_node()                                                      
                {
                    return pythonPluginData()-&gt;node;
                }
                
                /**
                 * @brief A function to retrieve an input value by index.
                 * 
                 * This function is used to retrieve an input value from a data structure based on the given index.
                 * 
                 * @tparam T The type of the input value to be retrieved.
                 * @param i The index of the input value to be retrieved.
                 * @return Returns a reference to the input value at the given index.
                 */
                template &lt;typename T&gt;
                T &amp;get_input_value(int i)
                {
                    return *static_cast&lt;T*&gt;(pythonPluginData()-&gt;inputData[i]);
                }
                
                /**
                 * @brief A function to retrieve the printer interface.
                 * 
                 * This function is used to retrieve a reference to the printer interface from the Gambit::Scanner namespace.
                 * 
                 * @return Returns a reference to the printer interface.
                 */
                inline Gambit::Scanner::printer_interface &amp;get_printer()
                {
                    return *pythonPluginData()-&gt;printer;
                }

                /**
                 * @brief A function to retrieve the prior interface.
                 * 
                 * This function is used to retrieve a reference to the prior interface from the Gambit::Scanner namespace.
                 * 
                 * @return Returns a reference to the prior interface.
                 */
                inline Gambit::Scanner::prior_interface &amp;get_prior()
                {
                    return *pythonPluginData()-&gt;prior;
                }
                
                /**
                 * @brief A function to retrieve the dimension.
                 * 
                 * This function is used to retrieve a reference to the dimension. The dimension could represent various aspects depending on the context, such as the dimension of a data structure, a mathematical space, etc.
                 * 
                 * @return Returns a reference to the dimension.
                 */
                inline unsigned int &amp;get_dimension() {return get_input_value&lt;unsigned int&gt;(0);}
                
                /**
                 * @brief A function to retrieve a function object based on its purpose.
                 * 
                 * This function is used to retrieve a function object from the Gambit::Scanner namespace based on its purpose. The purpose is passed as a parameter to the function.
                 * 
                 * @param purpose The purpose of the function to be retrieved.
                 * @return Returns a shared pointer to the function object associated with the given purpose.
                 */
                inline std::shared_ptr&lt;Gambit::Scanner::Function_Base&lt;double (std::unordered_map&lt;std::string, double&gt; &amp;)&gt;&gt;
                get_purpose(const std::string &amp;purpose)
                {
                    void *ptr = (get_input_value&lt;Factory_Base&gt;(1))(purpose);
                    static_cast &lt;Function_Base&lt;void(void)&gt;*&gt;(ptr)-&gt;setPurpose(purpose);
                    static_cast &lt;Function_Base&lt;void(void)&gt;*&gt;(ptr)-&gt;setPrinter(get_printer().get_stream());
                    static_cast &lt;Function_Base&lt;void(void)&gt;*&gt;(ptr)-&gt;setPrior(&amp;get_prior());
                    assign_aux_numbers(purpose, &quot;pointID&quot;, &quot;MPIrank&quot;);

                    return Gambit::Scanner::like_ptr(ptr);
                }

                /**
                 * @brief A class that wraps a shared pointer to a Function_Base object.
                 * 
                 * This class is used to manage the lifetime of Function_Base objects and to provide a uniform interface for using them.
                 * 
                 * @tparam T The specific type of the Function_Base object.
                 */
                template &lt;typename T&gt;
                class like_ptr_base : public std::enable_shared_from_this&lt;T&gt;
                {
                protected:
                    typedef std::shared_ptr&lt;Gambit::Scanner::Function_Base&lt;double (std::unordered_map&lt;std::string, double&gt; &amp;)&gt;&gt; s_ptr;
                    typedef Gambit::Scanner::Function_Base&lt;double (std::unordered_map&lt;std::string, double&gt; &amp;)&gt; s_func;
                    s_ptr ptr;
                    
                public:
                    /**
                     * @brief Constructs a like_ptr_base object.
                     * 
                     * @param s A reference to the Function_Base object to be managed.
                     */
                    like_ptr_base(s_func &amp;s) : ptr(s.shared_from_this()) {}
                    
                    /**
                     * @brief Retrieves the underlying shared pointer.
                     * 
                     * @return A reference to the underlying shared pointer.
                     */
                    Gambit::Scanner::like_ptr &amp;get(){return static_cast&lt;Gambit::Scanner::like_ptr&amp;&gt;(ptr);}
                };
                
                /**
                 * @brief A derived class of like_ptr_base for managing Function_Base objects related to hypercubes.
                 * 
                 * This class is specifically designed to manage Function_Base objects that represent hypercubes in a multidimensional space.
                 */
                struct like_hypercube : like_ptr_base&lt;like_hypercube&gt;
                {
                    /**
                     * @brief Constructs a like_hypercube object.
                     * 
                     * @param s A reference to the Function_Base object to be managed.
                     */
                    like_hypercube(s_func &amp;s) : like_ptr_base&lt;like_hypercube&gt;(s) {}
                };
                
                /**
                 * @brief A derived class of like_ptr_base for managing Function_Base objects related to physical properties.
                 * 
                 * This class is specifically designed to manage Function_Base objects that represent physical properties in a system.
                 */
                struct like_physical : like_ptr_base&lt;like_physical&gt;
                {
                    /**
                     * @brief Constructs a like_physical object.
                     * 
                     * @param s A reference to the Function_Base object to be managed.
                     */
                    like_physical(s_func &amp;s) : like_ptr_base&lt;like_physical&gt;(s) {}
                };
                
                /**
                 * @brief A derived class of like_ptr_base for managing Function_Base objects related to physical priors.
                 * 
                 * This class is specifically designed to manage Function_Base objects that represent physical priors and likelihood in a system.
                 */
                struct like_prior_physical : like_ptr_base&lt;like_prior_physical&gt;
                {
                    /**
                     * @brief Constructs a like_prior_physical object.
                     * 
                     * @param s A reference to the Function_Base object to be managed.
                     */
                    like_prior_physical(s_func &amp;s) : like_ptr_base&lt;like_prior_physical&gt;(s) {}
                };
                
                /**
                 * @brief A derived class of like_ptr_base for managing Function_Base objects related to physical priors.
                 * 
                 * This class is specifically designed to manage Function_Base objects that represent physical priors in a system.
                 */
                struct prior_physical : like_ptr_base&lt;prior_physical&gt;
                {
                    /**
                     * @brief Constructs a prior_physical object.
                     * 
                     * @param s A reference to the Function_Base object to be managed.
                     */
                    prior_physical(s_func &amp;s) : like_ptr_base&lt;prior_physical&gt;(s) {}
                };
                
                /**
                 * @class scanner_base
                 * @brief A base class for scanner functionality.
                 * 
                 * This class provides a base for scanner functionality. It defines several types related to the Gambit::Scanner namespace and can be extended by other classes to provide more specific functionality.
                 * 
                 * @typedef s_ptr A shared pointer to a function object in the Gambit::Scanner namespace.
                 * @typedef s_func A function object in the Gambit::Scanner namespace.
                 * @typedef s_hyper_func A hypercube function object in the Gambit::Scanner::Plugins::ScannerPyPlugin namespace.
                 * @typedef s_phys_func A physical function object in the Gambit::Scanner::Plugins::ScannerPyPlugin namespace.
                 * @typedef s_phys_pr_func A physical prior function object in the Gambit::Scanner::Plugins::ScannerPyPlugin namespace.
                 * @typedef s_pr_func A prior physical function object in the Gambit::Scanner::Plugins::ScannerPyPlugin namespace.
                 */     
                class scanner_base
                {
                public:
                    typedef std::shared_ptr&lt;Gambit::Scanner::Function_Base&lt;double (std::unordered_map&lt;std::string, double&gt; &amp;)&gt;&gt; s_ptr;
                    typedef Gambit::Scanner::Function_Base&lt;double (std::unordered_map&lt;std::string, double&gt; &amp;)&gt; s_func;
                    typedef Gambit::Scanner::Plugins::ScannerPyPlugin::like_hypercube s_hyper_func;
                    typedef Gambit::Scanner::Plugins::ScannerPyPlugin::like_physical s_phys_func;
                    typedef Gambit::Scanner::Plugins::ScannerPyPlugin::like_prior_physical s_phys_pr_func;
                    typedef Gambit::Scanner::Plugins::ScannerPyPlugin::prior_physical s_pr_func;
                    
                    /**
                     * @brief A method to run the scanner.
                     * 
                     * This method is intended to be overridden by derived classes. If not overridden, it will print an error message and return 1.
                     * 
                     * @return Returns 1 if the method is not overridden in a derived class.
                     */
                    int run()
                    {
                        scan_err &lt;&lt; &quot;\&quot;run()\&quot; method not defined in python scanner plugin.&quot; &lt;&lt; scan_end;
                        return 1;
                    }

                    /**
                     * @brief Converts a vector to a Python list.
                     * 
                     * This static method is used to convert a standard C++ vector into a Python list. Each element of the vector is appended to the Python list.
                     * 
                     * @tparam T The type of the elements in the vector.
                     * @param vec The vector to be converted.
                     * @return Returns a Python list containing the elements of the input vector.
                     */
                    template&lt;typename T&gt;
                    static py::list to_list(const std::vector&lt;T&gt; &amp;vec)
                    {
                        py::list l;
                        for (auto &amp;&amp;elem : vec)
                            l.append(py::cast(elem));
                        
                        return l;
                    }

                    /**
                     * @brief Retrieves the YAML node.
                     * 
                     * This static method is used to retrieve the YAML node. If the node has not been initialized, it is set to the result of the `get_inifile_node` function.
                     * 
                     * @return Returns a reference to the YAML node.
                     */
                    static YAML::Node &amp;getNode()
                    {
                        static YAML::Node node = get_inifile_node();
                        
                        return node;
                    }
                    
                    /**
                     * @brief Retrieves the likelihood function.
                     * 
                     * This static method is used to retrieve the likelihood function. If the function has not been initialized, it is set to the result of the `get_purpose` function with the &quot;like&quot; node from the YAML node as the argument.
                     * 
                     * @return Returns a shared pointer to the likelihood function.
                     */
                    static std::shared_ptr&lt;s_func&gt; getLike()
                    {
                        static std::shared_ptr&lt;s_func&gt; like = getNode()[&quot;like&quot;] ? get_purpose(getNode()[&quot;like&quot;].template as&lt;std::string&gt;()) : nullptr;
                        
                        return like;
                    }
                    
                #ifdef WITH_MPI
                    /**
                     * @brief Checks if MPI is enabled.
                     * 
                     * This static method is used to check if MPI is enabled.
                     * 
                     * @return Returns true if MPI is enabled.
                     */
                    static bool with_mpi() {return true;}

                    /**
                     * @brief Retrieves the rank of the MPI process.
                     * 
                     * This static method is used to retrieve the rank of the MPI process.
                     * 
                     * @return Returns the rank of the MPI process.
                     */
                    static int rank()
                    {
                        int rank;
                        MPI_Comm_rank(MPI_COMM_WORLD, &amp;rank);
                        
                        return rank;
                    }
                    
                    /**
                     * @brief Retrieves the number of MPI processes.
                     * 
                     * This static method is used to retrieve the number of MPI processes.
                     * 
                     * @return Returns the number of MPI processes.
                     */
                    static int numtasks()
                    {
                        int numtasks;
                        MPI_Comm_size(MPI_COMM_WORLD, &amp;numtasks);
                        
                        return numtasks;
                    }
                #else
                    /**
                     * @brief Checks if MPI is enabled.
                     * 
                     * This static method is used to check if MPI is enabled.
                     * 
                     * @return Returns false if MPI is not enabled.
                     */
                    static bool with_mpi() {return false;}

                    /**
                     * @brief Retrieves the rank of the MPI process.
                     * 
                     * This static method is used to retrieve the rank of the MPI process.
                     * 
                     * @return Returns 0 if MPI is not enabled.
                     */
                    static int rank() {return 0;}

                    /**
                     * @brief Retrieves the number of MPI processes.
                     * 
                     * This static method is used to retrieve the number of MPI processes.
                     * 
                     * @return Returns 1 if MPI is not enabled.
                     */
                    static int numtasks() {return 1;}
                #endif
                };
                
            }
            
        }
        
    }
    
}

/**
 * @brief A pybind11 module named &quot;scanner_plugin&quot;.
 * 
 * This module is used to bind Python and C++ code using the pybind11 library. It imports the &quot;scannerbit&quot; module and defines some functions and attributes for the module.
 * 
 * @param m The pybind11 module to which the bindings are added.
 */
PYBIND11_EMBEDDED_MODULE(scanner_plugin, m) 
{
    
    using namespace Gambit::Scanner::Plugins::ScannerPyPlugin;
    using namespace Gambit::Scanner;
    
    // Import the &quot;scannerbit&quot; module
    m.attr(&quot;scannerbit&quot;) = m.import(&quot;scannerbit&quot;);
    
    // Define the &quot;get_printer&quot; function for the module
    m.def(&quot;get_printer&quot;, []()
    {
        return &amp;get_printer();
    }, &quot;&quot;, py::return_value_policy::reference);
    
    // Define the &quot;get_prior&quot; function for the module
    m.def(&quot;get_prior&quot;, []()
    {
        return &amp;get_prior();
    }, &quot;&quot;, py::return_value_policy::reference);
    
    // Define the &quot;get_inifile_node&quot; function for the module
    m.def(&quot;get_inifile_node&quot;, [](py::args args) -&gt; py::object
    {
        py::object ret = yaml_to_dict(get_inifile_node());
        
        for (auto &amp;&amp;arg : args)
            ret = py::dict(ret)[py::cast(arg.template cast&lt;std::string&gt;())];
        
        return ret;
    });
    
    typedef Gambit::Scanner::Plugins::ScannerPyPlugin::like_hypercube s_hyper_func;
    typedef Gambit::Scanner::Plugins::ScannerPyPlugin::like_physical s_phys_func;
    typedef Gambit::Scanner::Plugins::ScannerPyPlugin::like_prior_physical s_phys_pr_func;
    typedef Gambit::Scanner::Plugins::ScannerPyPlugin::prior_physical s_pr_func;
    using namespace Gambit::Scanner::Plugins::ScannerPyPlugin;
    


    py::class_&lt;s_hyper_func, std::shared_ptr&lt;s_hyper_func&gt;&gt; pylike_hypercube_ptr(m, &quot;like_hypercube_ptr&quot;);
    pylike_hypercube_ptr
    .def(py::init([]()
    {
        return std::shared_ptr&lt;scanner_base::s_hyper_func&gt; (scanner_base::getLike() == nullptr ? nullptr : new scanner_base::s_hyper_func(*scanner_base::getLike().get()));
    }))
    .def(&quot;__reduce__&quot;, [pylike_hypercube_ptr](s_hyper_func &amp;)
    {
        return py::make_tuple(pylike_hypercube_ptr, py::tuple());
    })
    .def(&quot;__call__&quot;, [](s_hyper_func &amp;self, Gambit::Scanner::hyper_cube_ref&lt;double&gt; vec)
    {
        return self.get()(vec);
    })
    .def(&quot;__call__&quot;, [](s_hyper_func &amp;self, Gambit::Scanner::hyper_cube_ref&lt;float&gt; vecf)
    {
        Gambit::Scanner::vector&lt;double&gt; vec = vecf.template cast&lt;double&gt;();
        return self.get()(vec);
    })
    .def(&quot;__call__&quot;, [](s_hyper_func &amp;self, py::dict params)
    {
        auto &amp;like = self.get();
        auto &amp;map = like-&gt;getMap();
        for(auto &amp;&amp;p: params)
            map[p.first.template cast&lt;std::string&gt;()] = p.second.template cast&lt;double&gt;();
        
        return like(map);
    })
    .def(&quot;__call__&quot;, [](s_hyper_func &amp;self, std::unordered_map&lt;std::string, double&gt; &amp;map)
    {
        return self.get()(map);
    });
    


    py::class_&lt;s_phys_func, std::shared_ptr&lt;s_phys_func&gt;&gt; pylike_physical_ptr(m, &quot;like_physical_ptr&quot;);
    pylike_physical_ptr
    .def(py::init([]()
    {
        return std::shared_ptr&lt;scanner_base::s_phys_func&gt; (scanner_base::getLike() == nullptr ? nullptr : new scanner_base::s_phys_func(*scanner_base::getLike().get()));
    }))
    .def(&quot;__reduce__&quot;, [pylike_physical_ptr](s_phys_func &amp;)
    {
        return py::make_tuple(pylike_physical_ptr, py::tuple());
    })
    .def(&quot;__call__&quot;, [](s_phys_func &amp;self, Gambit::Scanner::hyper_cube_ref&lt;double&gt; vec)
    {
        auto &amp;like = self.get();
        auto &amp;map = like-&gt;getMap();
        int i = 0;
        for(auto &amp;&amp;name : like-&gt;getShownParameters())
            map[name] = vec[i++];
        
        return like(map);
    })
    .def(&quot;__call__&quot;, [](s_phys_func &amp;self, Gambit::Scanner::hyper_cube_ref&lt;float&gt; vecf)
    {
        Gambit::Scanner::vector&lt;double&gt; vec = vecf.template cast&lt;double&gt;();
        auto &amp;like = self.get();
        auto &amp;map = like-&gt;getMap();
        int i = 0;
        for(auto &amp;&amp;name : like-&gt;getShownParameters())
            map[name] = vec[i++];
        
        return like(map);
    })
    .def(&quot;__call__&quot;, [](s_phys_func &amp;self, py::dict params)
    {
        auto &amp;like = self.get();
        auto &amp;map = like-&gt;getMap();
        for(auto &amp;&amp;p: params)
            map[p.first.template cast&lt;std::string&gt;()] = p.second.template cast&lt;double&gt;();
        
        return like(map);
    })
    .def(&quot;__call__&quot;, [](s_phys_func &amp;self, std::unordered_map&lt;std::string, double&gt; &amp;map)
    {
        return self.get()(map);
    });
    


    py::class_&lt;s_phys_pr_func, std::shared_ptr&lt;s_phys_pr_func&gt;&gt; pylike_prior_physical_ptr(m, &quot;like_prior_physical_ptr&quot;);
    pylike_prior_physical_ptr
    .def(py::init([]()
    {
        return std::shared_ptr&lt;scanner_base::s_phys_pr_func&gt; (scanner_base::getLike() == nullptr ? nullptr : new scanner_base::s_phys_pr_func(*scanner_base::getLike().get()));
    }))
    .def(&quot;__reduce__&quot;, [pylike_prior_physical_ptr](s_phys_pr_func &amp;)
    {
        return py::make_tuple(pylike_prior_physical_ptr, py::tuple());
    })
    .def(&quot;__call__&quot;, [](s_phys_pr_func &amp;self, Gambit::Scanner::hyper_cube_ref&lt;double&gt; vec)
    {
        auto &amp;like = self.get();
        auto &amp;map = like-&gt;getMap();
        int i = 0;
        for(auto &amp;&amp;name : like-&gt;getShownParameters())
            map[name] = vec[i++];
        
        return like(map, true);
    })
    .def(&quot;__call__&quot;, [](s_phys_pr_func &amp;self, Gambit::Scanner::hyper_cube_ref&lt;float&gt; vecf)
    {
        Gambit::Scanner::vector&lt;double&gt; vec = vecf.template cast&lt;double&gt;();
        auto &amp;like = self.get();
        auto &amp;map = like-&gt;getMap();
        int i = 0;
        for(auto &amp;&amp;name : like-&gt;getShownParameters())
            map[name] = vec[i++];
        
        return like(map, true);
    })
    .def(&quot;__call__&quot;, [](s_phys_pr_func &amp;self, py::dict params)
    {
        auto &amp;like = self.get();
        auto &amp;map = like-&gt;getMap();
        for(auto &amp;&amp;p: params)
            map[p.first.template cast&lt;std::string&gt;()] = p.second.template cast&lt;double&gt;();
        
        return like(map, true);
    })
    .def(&quot;__call__&quot;, [](s_phys_pr_func &amp;self, std::unordered_map&lt;std::string, double&gt; &amp;map)
    {
        return self.get()(map, true);
    });
    


    py::class_&lt;s_pr_func, std::shared_ptr&lt;s_pr_func&gt;&gt; pyprior_physical_ptr(m, &quot;prior_physical_ptr&quot;);
    pyprior_physical_ptr
    .def(py::init([]()
    {
        return std::shared_ptr&lt;scanner_base::s_pr_func&gt; (scanner_base::getLike() == nullptr ? nullptr : new scanner_base::s_pr_func(*scanner_base::getLike().get()));
    }))
    .def(&quot;__reduce__&quot;, [pyprior_physical_ptr](s_pr_func &amp;)
    {
        return py::make_tuple(pyprior_physical_ptr, py::tuple());
    })
    .def(&quot;__call__&quot;, [](s_pr_func &amp;self, Gambit::Scanner::hyper_cube_ref&lt;double&gt; vec)
    {
        auto &amp;like = self.get();
        auto &amp;map = like-&gt;getMap();
        int i = 0;
        for(auto &amp;&amp;name : like-&gt;getShownParameters())
            map[name] = vec[++i];
        
        return like-&gt;getPrior().log_prior_density(map);
    })
    .def(&quot;__call__&quot;, [](s_pr_func &amp;self, Gambit::Scanner::hyper_cube_ref&lt;float&gt; vecf)
    {
        Gambit::Scanner::vector&lt;double&gt; vec = vecf.template cast&lt;double&gt;();
        auto &amp;like = self.get();
        auto &amp;map = like-&gt;getMap();
        int i = 0;
        for(auto &amp;&amp;name : like-&gt;getShownParameters())
            map[name] = vec[++i];
        
        return like-&gt;getPrior().log_prior_density(map);
    })
    .def(&quot;__call__&quot;, [](s_phys_pr_func &amp;self, py::dict params)
    {
        auto &amp;like = self.get();
        auto &amp;map = like-&gt;getMap();
        for(auto &amp;&amp;p: params)
            map[p.first.template cast&lt;std::string&gt;()] = p.second.template cast&lt;double&gt;();
        
        return like-&gt;getPrior().log_prior_density(map);
    })
    .def(&quot;__call__&quot;, [](s_phys_pr_func &amp;self, std::unordered_map&lt;std::string, double&gt; &amp;map)
    {
        return self.get()-&gt;getPrior().log_prior_density(map);
    });
    
    // Define the &quot;get_inifile_value&quot; function for the module
    m.def(&quot;get_inifile_value&quot;, SCAN_PLUGIN_GET_INIFILE_VALUE_FUNC);
    // Define the &quot;get_dimension&quot; function for the module
    m.def(&quot;get_dimension&quot;, get_dimension);
    // Define the &quot;get_purpose&quot; function for the module
    m.def(&quot;get_purpose&quot;, get_purpose);
    
    // Bind the scanner base class to the module
    py::class_&lt;scanner_base, std::shared_ptr&lt;scanner_base&gt;&gt;(m, &quot;scanner&quot;)
    .def(py::init([](bool use_mpi, bool use_resume)
        {
        #ifdef WITH_MPI
            if (!use_mpi)
            {
                int numtasks;
                MPI_Comm_size(MPI_COMM_WORLD, &amp;numtasks);
                if (numtasks != 1)
                {
                    scan_err &lt;&lt; &quot;This scanner does not support MPI.&quot; &lt;&lt; scan_end;
                }
            }
        #endif
        
            if (!use_resume &amp;&amp; Gambit::Scanner::Plugins::ScannerPyPlugin::get_printer().resume_mode())
            {
                scan_err &lt;&lt; &quot;This scanner does not support resuming.&quot; &lt;&lt; scan_end;
            }
                
            return new scanner_base();
        }), py::arg(&quot;use_mpi&quot;)=true, py::arg(&quot;use_resume&quot;)=true)
    .def(&quot;run&quot;, &amp;scanner_base::run)
    .def_static(&quot;print&quot;, [](double val, const std::string &amp;name)
    {
        static int my_rank = scanner_base::rank();
        
        get_printer().get_stream()-&gt;print(val, name, my_rank, scanner_base::getLike()-&gt;getPtID());
    })
    .def_static(&quot;print&quot;, [](double val, const std::string &amp;name, const unsigned int rank, const unsigned long pointID)
    {
        get_printer().get_stream()-&gt;print(val, name, rank, pointID);
    })
    .def_static(&quot;transform&quot;, [](Gambit::Scanner::hyper_cube_ref&lt;double&gt; unit)
    {
        py::dict physical;
        //auto &amp;map = getLike()-&gt;getMap();
        static std::unordered_map&lt;std::string, double&gt; map;
        get_prior().transform(unit, map);
        
        for (auto &amp;&amp;m : map)
            physical[py::cast(m.first)] = py::cast(m.second);
        
        return physical;
    })
    .def_static(&quot;transform&quot;, [](Gambit::Scanner::hyper_cube_ref&lt;double&gt; unit, std::unordered_map&lt;std::string, double&gt; &amp;physical)
    {
        get_prior().transform(unit, physical);
    })
    .def_static(&quot;transform&quot;, [](Gambit::Scanner::hyper_cube_ref&lt;double&gt; unit, py::dict physical)
    {
        //auto &amp;map = getLike()-&gt;getMap();
        static std::unordered_map&lt;std::string, double&gt; map;
        get_prior().transform(unit, map);
        for (auto &amp;&amp;m : map)
            physical[py::cast(m.first)] = py::cast(m.second);
    })
    .def_static(&quot;transform_to_vec&quot;, [](Gambit::Scanner::hyper_cube_ref&lt;double&gt; unit)
    {
        //auto &amp;map = getLike()-&gt;getMap();
        static std::unordered_map&lt;std::string, double&gt; map;
        get_prior().transform(unit, map);
        auto params = get_prior().getShownParameters();
        Gambit::Scanner::vector&lt;double&gt; vec(params.size());
        
        for (size_t i = 0, end = params.size(); i &lt; end; ++i)
            vec[i] = map[params[i]];
        
        return vec;
    })
    .def_static(&quot;transform&quot;, [](Gambit::Scanner::hyper_cube_ref&lt;float&gt; unitf)
    {
        Gambit::Scanner::vector&lt;double&gt; unit = unitf.template cast&lt;double&gt;();
        py::dict physical;
        //auto &amp;map = getLike()-&gt;getMap();
        static std::unordered_map&lt;std::string, double&gt; map;
        get_prior().transform(unit, map);
        
        for (auto &amp;&amp;m : map)
            physical[py::cast(m.first)] = py::cast(m.second);
        
        return physical;
    })
    .def_static(&quot;transform&quot;, [](Gambit::Scanner::hyper_cube_ref&lt;float&gt; unitf, std::unordered_map&lt;std::string, double&gt; &amp;physical)
    {
        Gambit::Scanner::vector&lt;double&gt; unit = unitf.template cast&lt;double&gt;();
        get_prior().transform(unit, physical);
    })
    .def_static(&quot;transform&quot;, [](Gambit::Scanner::hyper_cube_ref&lt;float&gt; unitf, py::dict physical)
    {
        Gambit::Scanner::vector&lt;double&gt; unit = unitf.template cast&lt;double&gt;();
        //auto &amp;map = getLike()-&gt;getMap();
        static std::unordered_map&lt;std::string, double&gt; map;
        get_prior().transform(unit, map);
        for (auto &amp;&amp;m : map)
            physical[py::cast(m.first)] = py::cast(m.second);
    })
    .def_static(&quot;transform_to_vec&quot;, [](Gambit::Scanner::hyper_cube_ref&lt;float&gt; unitf)
    {
        Gambit::Scanner::vector&lt;double&gt; unit = unitf.template cast&lt;double&gt;();
        //auto &amp;map = getLike()-&gt;getMap();
        static std::unordered_map&lt;std::string, double&gt; map;
        get_prior().transform(unit, map);
        auto params = get_prior().getShownParameters();
        Gambit::Scanner::vector&lt;double&gt; vec(params.size());
        
        for (size_t i = 0, end = params.size(); i &lt; end; ++i)
            vec[i] = map[params[i]];
        
        return vec;
    })
    .def_static(&quot;inverse_transform&quot;, [](std::unordered_map&lt;std::string, double&gt; &amp;physical)
    {
        Gambit::Scanner::vector&lt;double&gt; unit(get_prior().size());
        get_prior().inverse_transform(physical, unit);
        
        return unit;
    })
    .def_static(&quot;inverse_transform&quot;, [](py::dict physical)
    {
        Gambit::Scanner::vector&lt;double&gt; unit(get_prior().size());
        std::unordered_map&lt;std::string, double&gt; map;
        for (auto &amp;&amp;m : physical)
            map[m.first.template cast&lt;std::string&gt;()] = m.second.template cast&lt;double&gt;();
        
        get_prior().inverse_transform(map, unit);
        
        return unit;
    })
    .def_static(&quot;inverse_transform&quot;, [](std::unordered_map&lt;std::string, double&gt; &amp;physical, Gambit::Scanner::hyper_cube_ref&lt;double&gt; unit)
    {
        get_prior().inverse_transform(physical, unit);
    })
    .def_static(&quot;inverse_transform&quot;, [](py::dict physical, Gambit::Scanner::hyper_cube_ref&lt;double&gt; unit)
    {
        std::unordered_map&lt;std::string, double&gt; map;
        for (auto &amp;&amp;m : physical)
            map[m.first.template cast&lt;std::string&gt;()] = m.second.template cast&lt;double&gt;();
        
        get_prior().inverse_transform(map, unit);
    })
    .def_property_readonly_static(&quot;point_id&quot;, [](py::object)
    {
        return scanner_base::getLike()-&gt;getPtID();
    })
    .def_property_readonly_static(&quot;printer&quot;, [](py::object)-&gt;Gambit::Printers::BasePrinterManager&amp;
    {
        return get_printer();
    })
    .def_property_readonly_static(&quot;loglike_hypercube&quot;, [](py::object)
    {
        static std::shared_ptr&lt;scanner_base::s_hyper_func&gt; like_hypercube(scanner_base::getLike() == nullptr ? nullptr : new scanner_base::s_hyper_func(*scanner_base::getLike().get()));
                                        
        return like_hypercube;
    })
    .def_property_readonly_static(&quot;loglike_physical&quot;, [](py::object)
    {
        static std::shared_ptr&lt;scanner_base::s_phys_func&gt; like_physical(scanner_base::getLike() == nullptr ? nullptr : new scanner_base::s_phys_func(*scanner_base::getLike().get()));
                                        
        return like_physical;
    })
    .def_property_readonly_static(&quot;log_target_density&quot;, [](py::object)
    {
        static std::shared_ptr&lt;scanner_base::s_phys_pr_func&gt; like_prior_physical(scanner_base::getLike() == nullptr ? nullptr : new scanner_base::s_phys_pr_func(*scanner_base::getLike().get()));
                                        
        return like_prior_physical;
    })
    .def_property_readonly_static(&quot;log_prior_density&quot;, [](py::object)
    {
        static std::shared_ptr&lt;scanner_base::s_pr_func&gt; prior_physical(scanner_base::getLike() == nullptr ? nullptr : new scanner_base::s_pr_func(*scanner_base::getLike().get()));
                                        
        return prior_physical;
    })
    .def_property_readonly_static(&quot;loglike&quot;, [](py::object)
    {
        return scanner_base::getLike();
    })
    .def_property_readonly_static(&quot;args&quot;, [](py::object)
    {
        static py::dict opts = ::Gambit::Scanner::yaml_to_dict(scanner_base::getNode());
        
        return opts;
    })
    .def_property_readonly_static(&quot;init_args&quot;, [](py::object)
    {
        static py::dict init_opts = ::Gambit::Scanner::yaml_to_dict(scanner_base::getNode()[&quot;init&quot;] ? scanner_base::getNode()[&quot;init&quot;] : YAML::Node());
                        
        return init_opts;
    })
    .def_property_readonly_static(&quot;run_args&quot;, [](py::object)
    {
        static py::dict run_opts = ::Gambit::Scanner::yaml_to_dict(scanner_base::getNode()[&quot;run&quot;] ? scanner_base::getNode()[&quot;run&quot;] : YAML::Node());
                        
        return run_opts;
    })
    .def_property_readonly_static(&quot;parameter_names&quot;, [](py::object)
    {
        static py::list names = scanner_base::to_list&lt;std::string&gt;(get_prior().getShownParameters());
        
        return names;
    })
    .def_property_readonly_static(&quot;mpi_rank&quot;, [](py::object)
    {
        static int my_rank = scanner_base::rank();
                        
        return my_rank;
    })
    .def_property_readonly_static(&quot;mpi_size&quot;, [](py::object)
    {
        static int tasks = scanner_base::numtasks();
        
        return tasks;
    })
    .def_property_readonly_static(&quot;dim&quot;, [](py::object)
    {
        static int dim = get_dimension();
                        
        return dim;
    })
    .def_static(&quot;assign_aux_numbers&quot;, [](py::args params)
    {
        for (auto &amp;&amp;param : params)
            ::Gambit::Printers::get_aux_param_id(param.template cast&lt;std::string&gt;());
    });

}
</code></pre><hr><p>Updated on 2025-02-12 at 16:10:33 +0000</p></main></div></div></div><footer class="footer text-muted"><div class=container-xxl><div class=row><div class="col-lg-8 order-last order-lg-first"><ul class=list-inline><li class=list-inline-item>Powered by <a href=https://gohugo.io/>Hugo</a> and <a href=https://getdoks.org/>Doks</a></li></ul></div><div class="col-lg-8 order-first order-lg-last text-lg-end"><ul class=list-inline><li class=list-inline-item><a href=/license/>License</a></li></ul></div></div></div></footer><script src=/js/bootstrap.min.862c9eb8ab97f8c1c8584b21ce31113d8553917669561b040011b0061009a0b6c7a6b61fb659f56eabfa9f45259f001417dba1d65b229f685f3cdbb709482f8e.js integrity="sha512-hiyeuKuX+MHIWEshzjERPYVTkXZpVhsEABGwBhAJoLbHprYftln1bqv6n0UlnwAUF9uh1lsin2hfPNu3CUgvjg==" crossorigin=anonymous defer></script>
<script src=/js/highlight.min.3fa03d1d36ae7a66d6d5d2e19796832d40b4a5417eaaae1dfba8837d033467084e8c051f25aee596d415422573116115ccc5c2b29970d3490dafdce1a920a402.js integrity="sha512-P6A9HTauembW1dLhl5aDLUC0pUF+qq4d+6iDfQM0ZwhOjAUfJa7lltQVQiVzEWEVzMXCsplw00kNr9zhqSCkAg==" crossorigin=anonymous defer></script>
<script src=/main.min.04459eeb2d9d601a3ccc10d2699fb84f0442d5f5d3a16372b023be7564838ed2a755b908598f715d6b42c0be95895835b2e872f4fa4acd028ef3904671a92f1a.js integrity="sha512-BEWe6y2dYBo8zBDSaZ+4TwRC1fXToWNysCO+dWSDjtKnVbkIWY9xXWtCwL6ViVg1suhy9PpKzQKO85BGcakvGg==" crossorigin=anonymous defer></script>
<script src=https://gambitbsm.org/index.min.0e5dc0d6ae6ec888ba8315ccfe8a57589eca2ed96d4f8f38cf8d86f7f044f6c095a7ba5585214148bb74081529bb52082b38e6df07ae8407f0459ca64ac91e87.js integrity="sha512-Dl3A1q5uyIi6gxXM/opXWJ7KLtltT484z42G9/BE9sCVp7pVhSFBSLt0CBUpu1IIKzjm3weuhAfwRZymSskehw==" crossorigin=anonymous defer></script></body></html>