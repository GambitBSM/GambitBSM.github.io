<!doctype html><html lang=en-us><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="ie=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><link rel=preload as=font href=https://gambitbsm.github.io/fonts/vendor/jost/jost-v4-latin-regular.woff2 type=font/woff2 crossorigin><link rel=preload as=font href=https://gambitbsm.github.io/fonts/vendor/jost/jost-v4-latin-500.woff2 type=font/woff2 crossorigin><link rel=preload as=font href=https://gambitbsm.github.io/fonts/vendor/jost/jost-v4-latin-700.woff2 type=font/woff2 crossorigin><script>(()=>{var e=localStorage.getItem("theme");e==="dark"&&document.documentElement.setAttribute("data-dark-mode","")})()</script><link rel=stylesheet href=https://gambitbsm.github.io/main.2b4f179ba5137bf560410d5863d012cb95c0a7504da18190247e40a43544a8252fba5dc321f967a611ca9a4d80dec44fabc75d108c7c0e4e8ed381ec007b7391.css integrity="sha512-K08Xm6UTe/VgQQ1YY9ASy5XAp1BNoYGQJH5ApDVEqCUvul3DIflnphHKmk2A3sRPq8ddEIx8Dk6O04HsAHtzkQ==" crossorigin=anonymous><noscript><style>img.lazyload{display:none}</style></noscript><meta name=robots content="index, follow"><meta name=googlebot content="index, follow, max-snippet:-1, max-image-preview:large, max-video-preview:-1"><meta name=bingbot content="index, follow, max-snippet:-1, max-image-preview:large, max-video-preview:-1"><title>file SimpleSpectra/MSSMSimpleSpec.cpp - GAMBIT</title><meta name=description content="[No description available]"><link rel=canonical href=https://gambitbsm.github.io/documentation/code/files/mssmsimplespec_8cpp/><meta property="og:locale" content="en_US"><meta property="og:type" content="article"><meta property="og:title" content="file SimpleSpectra/MSSMSimpleSpec.cpp"><meta property="og:description" content="[No description available]"><meta property="og:url" content="https://gambitbsm.github.io/documentation/code/files/mssmsimplespec_8cpp/"><meta property="og:site_name" content="GAMBIT"><meta property="og:image" content="https://gambitbsm.github.io/gambit_logo.png"><meta property="og:image:alt" content="GAMBIT"><meta name=twitter:card content="summary_large_image"><meta name=twitter:site content><meta name=twitter:creator content><meta name=twitter:title content="file SimpleSpectra/MSSMSimpleSpec.cpp"><meta name=twitter:description content="[No description available]"><meta name=twitter:image content="https://gambitbsm.github.io/gambit_logo.png"><meta name=twitter:image:alt content="file SimpleSpectra/MSSMSimpleSpec.cpp"><script type=application/ld+json>{"@context":"https://schema.org","@graph":[{"@type":"Organization","@id":"https://gambitbsm.github.io/#/schema/organization/1","name":"Doks","url":"https://gambitbsm.github.io/","sameAs":["https://github.com/GambitBSM"],"logo":{"@type":"ImageObject","@id":"https://gambitbsm.github.io/#/schema/image/1","url":"https://gambitbsm.github.io/logo-doks.png","width":450,"height":416,"caption":"Doks"},"image":{"@id":"https://gambitbsm.github.io/#/schema/image/1"}},{"@type":"WebSite","@id":"https://gambitbsm.github.io/#/schema/website/1","url":"https://gambitbsm.github.io/","name":"GAMBIT","description":"Documentation for the Global And Modular BSM Inference Tool","publisher":{"@id":"https://gambitbsm.github.io/#/schema/organization/1"}},{"@type":"WebPage","@id":"https://gambitbsm.github.io/documentation/code/files/mssmsimplespec_8cpp/","url":"https://gambitbsm.github.io/documentation/code/files/mssmsimplespec_8cpp/","name":"file SimpleSpectra\/MSSMSimpleSpec.cpp","description":"[No description available]","isPartOf":{"@id":"https://gambitbsm.github.io/#/schema/website/1"},"about":{"@id":"https://gambitbsm.github.io/#/schema/organization/1"},"datePublished":"0001-01-01T00:00:00CET","dateModified":"0001-01-01T00:00:00CET","breadcrumb":{"@id":"https://gambitbsm.github.io/documentation/code/files/mssmsimplespec_8cpp/#/schema/breadcrumb/1"},"primaryImageOfPage":{"@id":"https://gambitbsm.github.io/documentation/code/files/mssmsimplespec_8cpp/#/schema/image/2"},"inLanguage":"en-US","potentialAction":[{"@type":"ReadAction","target":["https://gambitbsm.github.io/documentation/code/files/mssmsimplespec_8cpp/"]}]},{"@type":"BreadcrumbList","@id":"https://gambitbsm.github.io/documentation/code/files/mssmsimplespec_8cpp/#/schema/breadcrumb/1","name":"Breadcrumbs","itemListElement":[{"@type":"ListItem","position":1,"item":{"@type":"WebPage","@id":"https://gambitbsm.github.io/","url":"https://gambitbsm.github.io/","name":"Home"}},{"@type":"ListItem","position":2,"item":{"@type":"WebPage","@id":"https://gambitbsm.github.io/documentation/","url":"https://gambitbsm.github.io/documentation/","name":"Documentation"}},{"@type":"ListItem","position":3,"item":{"@type":"WebPage","@id":"https://gambitbsm.github.io/documentation/code/","url":"https://gambitbsm.github.io/documentation/code/","name":"Code"}},{"@type":"ListItem","position":4,"item":{"@type":"WebPage","@id":"https://gambitbsm.github.io/documentation/code/files/","url":"https://gambitbsm.github.io/documentation/code/files/","name":"Files"}},{"@type":"ListItem","position":5,"item":{"@id":"https://gambitbsm.github.io/documentation/code/files/mssmsimplespec_8cpp/"}}]},{"@context":"https://schema.org","@graph":[{"@type":"ImageObject","@id":"https://gambitbsm.github.io/documentation/code/files/mssmsimplespec_8cpp/#/schema/image/2","url":"https://gambitbsm.github.io/gambit_logo.png","contentUrl":"https://gambitbsm.github.io/gambit_logo.png","caption":"file SimpleSpectra\/MSSMSimpleSpec.cpp"}]}]}</script><meta name=theme-color content="#fff"><link rel=icon href=https://gambitbsm.github.io/favicon.ico sizes=any><link rel=icon type=image/svg+xml href=https://gambitbsm.github.io/favicon.svg><link rel=apple-touch-icon sizes=180x180 href=https://gambitbsm.github.io/apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=https://gambitbsm.github.io/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=https://gambitbsm.github.io/favicon-16x16.png><link rel=manifest crossorigin=use-credentials href=https://gambitbsm.github.io/site.webmanifest></head><body class="documentation single light"><div class=sticky-top><div class=header-bar></div><header class="navbar navbar-expand-md navbar-light doks-navbar"><nav class="container-xxl flex-wrap flex-md-nowrap" aria-label="Main navigation"><a class="navbar-brand p-0 me-auto" href=https://gambitbsm.github.io/ aria-label=GAMBIT><img class=logo-light src=https://gambitbsm.github.io//images/gambit_logo.png width=50px>
<img class="logo-dark d-none" src=https://gambitbsm.github.io//images/gambit_logo.png width=50px>
GAMBIT</a>
<button class="btn btn-menu order-2 d-block d-lg-none" type=button data-bs-toggle=offcanvas data-bs-target=#offcanvasDoks aria-controls=offcanvasDoks aria-label="Open main menu"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-menu"><line x1="3" y1="12" x2="21" y2="12"/><line x1="3" y1="6" x2="21" y2="6"/><line x1="3" y1="18" x2="21" y2="18"/></svg></button><div class="offcanvas offcanvas-end border-0 py-lg-1" tabindex=-1 id=offcanvasDoks data-bs-backdrop=true aria-labelledby=offcanvasDoksLabel><div class="header-bar d-lg-none"></div><div class="offcanvas-header d-lg-none"><h2 class="h5 offcanvas-title ps-2" id=offcanvasDoksLabel><a class=text-dark href=/>GAMBIT</a></h2><button type=button class="btn-close text-reset me-2" data-bs-dismiss=offcanvas aria-label="Close main menu"></button></div><div class="offcanvas-body p-4 p-lg-0"><ul class="nav flex-column flex-lg-row align-items-lg-center mt-2 mt-lg-0 ms-lg-2 me-lg-auto"><li class="nav-item dropdown"><a class="nav-link dropdown-toggle ps-0 py-1" href=# id=navbarDropdownMenuLink role=button data-bs-toggle=dropdown aria-expanded=false>Releases
<span class=dropdown-caret><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-chevron-down"><polyline points="6 9 12 15 18 9"/></svg></span></a><ul class="dropdown-menu dropdown-menu-main shadow rounded border-0" aria-labelledby=navbarDropdownMenuLink><li><a class=dropdown-item href=https://github.com/GambitBSM/gambit_2.2>GAMBIT 2-2 ⧉</a></li><li><a class=dropdown-item href=https://github.com/GambitBSM/gambit_2.1>GAMBIT 2-1 ⧉</a></li><li><a class=dropdown-item href=https://github.com/GambitBSM/gambit_2.2/tags>All releases ⧉</a></li></ul></li><li class="nav-item dropdown"><a class="nav-link dropdown-toggle ps-0 py-1" href=# id=navbarDropdownMenuLink role=button data-bs-toggle=dropdown aria-expanded=false>Documentation
<span class=dropdown-caret><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-chevron-down"><polyline points="6 9 12 15 18 9"/></svg></span></a><ul class="dropdown-menu dropdown-menu-main shadow rounded border-0" aria-labelledby=navbarDropdownMenuLink><li><a class=dropdown-item href=/documentation/installation/introduction/>Installation</a></li><li><a class=dropdown-item href=/documentation/examples/colliderbit_example>Examples</a></li><li><a class=dropdown-item href=/documentation/help/common_problems_and_questions/>Help</a></li><li><a class=dropdown-item href=/documentation/code/index_classes>Code Reference</a></li></ul></li><li class="nav-item dropdown"><a class="nav-link dropdown-toggle ps-0 py-1" href=# id=navbarDropdownMenuLink role=button data-bs-toggle=dropdown aria-expanded=false>Community
<span class=dropdown-caret><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-chevron-down"><polyline points="6 9 12 15 18 9"/></svg></span></a><ul class="dropdown-menu dropdown-menu-main shadow rounded border-0" aria-labelledby=navbarDropdownMenuLink><li><a class=dropdown-item href=/community/publications/>Publications</a></li><li><a class=dropdown-item href=/community/talks/>Talks</a></li><li><a class=dropdown-item href=/community/members/>Members</a></li><li><a class=dropdown-item href=/community/code_of_conduct/>Code of Conduct</a></li><li><a class=dropdown-item href=/community/contact/>Contact</a></li></ul></li></ul><hr class="text-black-50 my-4 d-lg-none"><form class="doks-search position-relative flex-grow-1 ms-lg-auto me-lg-2"><input id=search class="form-control is-search" type=search placeholder="Search site..." aria-label="Search site..." autocomplete=off><div id=suggestions class="shadow bg-white rounded d-none"></div></form><hr class="text-black-50 my-4 d-lg-none"><ul class="nav flex-column flex-lg-row"><li class=nav-item><a class="nav-link social-link" href=https://github.com/GambitBSM><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-github"><path d="M9 19c-5 1.5-5-2.5-7-3m14 6v-3.87a3.37 3.37.0 00-.94-2.61c3.14-.35 6.44-1.54 6.44-7A5.44 5.44.0 0020 4.77 5.07 5.07.0 0019.91 1S18.73.65 16 2.48a13.38 13.38.0 00-7 0C6.27.65 5.09 1 5.09 1A5.07 5.07.0 005 4.77 5.44 5.44.0 003.5 8.55c0 5.42 3.3 6.61 6.44 7A3.37 3.37.0 009 18.13V22"/></svg><small class="ms-2 d-lg-none">GitHub</small></a></li></ul><hr class="text-black-50 my-4 d-lg-none"><button id=mode class="btn btn-link" type=button aria-label="Toggle user interface mode">
<span class=toggle-dark><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-moon"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg></span><span class=toggle-light><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-sun"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></span></button></div></div></nav></header></div><div class="wrap container-xxl" role=document><div class=content><div class="row flex-xl-nowrap"><div class="col-lg-5 col-xl-4 docs-sidebar"><nav class=docs-links aria-label="Main navigation"><ul class="list-unstyled collapsible-sidebar"><li class=mb-1><button class="btn btn-toggle align-items-center rounded collapsed" data-bs-toggle=collapse data-bs-target=#section-installation aria-expanded=false>
Installation</button><div class=collapse id=section-installation><ul class="btn-toggle-nav list-unstyled fw-normal pb-1 small"><li><a class="docs-link rounded" href=/documentation/installation/introduction/>Getting Started</a></li><li><a class="docs-link rounded" href=/documentation/installation/docker_usage/>Docker Usage</a></li><li><a class="docs-link rounded" href=/documentation/installation/installation_for_linux/>Installation for Linux</a></li><li><a class="docs-link rounded" href=/documentation/installation/installation_for_windows/>Installation for Windows</a></li><li><a class="docs-link rounded" href=/documentation/installation/installation_for_macos/>Installation for macOS</a></li></ul></div></li><li class=mb-1><button class="btn btn-toggle align-items-center rounded collapsed" data-bs-toggle=collapse data-bs-target=#section-examples aria-expanded=false>
Examples</button><div class=collapse id=section-examples><ul class="btn-toggle-nav list-unstyled fw-normal pb-1 small"><li><a class="docs-link rounded" href=/documentation/examples/colliderbit_example/>ColliderBit Example</a></li><li><a class="docs-link rounded" href=/documentation/examples/anotherbit/>AnotherBit</a></li><li><a class="docs-link rounded" href=/documentation/examples/anotherbit2/>AnotherBit2</a></li></ul></div></li><li class=mb-1><button class="btn btn-toggle align-items-center rounded collapsed" data-bs-toggle=collapse data-bs-target=#section-help aria-expanded=false>
Help</button><div class=collapse id=section-help><ul class="btn-toggle-nav list-unstyled fw-normal pb-1 small"><li><a class="docs-link rounded" href=/documentation/help/common_problems_and_questions/>Common Problems and Questions</a></li><li><a class="docs-link rounded" href=/documentation/help/compiler_matrix/>Compiler Matrix</a></li><li><a class="docs-link rounded" href=/documentation/help/known_issues/>Known Issues</a></li><li><a class="docs-link rounded" href=/documentation/help/configuration_examples/>Configuration Examples</a></li></ul></div></li><li class=mb-1><button class="btn btn-toggle align-items-center rounded collapsed" data-bs-toggle=collapse data-bs-target=#section-code aria-expanded=false>
Code Reference</button><div class=collapse id=section-code><ul class="btn-toggle-nav list-unstyled fw-normal pb-1 small"><li><a class="docs-link rounded" href=/documentation/code/index_classes/>Classes</a></li><li><a class="docs-link rounded" href=/documentation/code/index_files/>Files</a></li><li><a class="docs-link rounded" href=/documentation/code/index_pages/>Pages</a></li><li><a class="docs-link rounded" href=/documentation/code/index_namespaces/>Namespaces</a></li></ul></div></li></ul></nav></div><nav class="docs-toc d-none d-xl-block col-xl-3" aria-label="Secondary navigation"><div class=d-xl-none><button class="btn btn-outline-primary btn-sm doks-toc-toggle collapsed" type=button data-bs-toggle=collapse data-bs-target=#onThisPage aria-controls=doks-docs-nav aria-expanded=false aria-label="Toggle On this page navigation">
<span>On this page</span>
<span><svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24" class="doks doks-expand" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><title>Expand</title><polyline points="7 13 12 18 17 13"/><polyline points="7 6 12 11 17 6"/></svg><svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24" class="doks doks-collapse" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><title>Collapse</title><polyline points="17 11 12 6 7 11"/><polyline points="17 18 12 13 7 18"/></svg></span></button><div class=collapse id=onThisPage><div class="card card-body mt-3 py-1"><div class=page-links><nav id=TableOfContents><ul><li><a href=#namespaces>Namespaces</a></li><li><a href=#source-code>Source code</a></li></ul></nav></div></div></div></div><div class="page-links d-none d-xl-block"><h3>On this page</h3><nav id=TableOfContents><ul><li><a href=#namespaces>Namespaces</a></li><li><a href=#source-code>Source code</a></li></ul></nav></div></nav><main class="docs-content col-lg-11 col-xl-9 mx-xl-auto"><nav aria-label=breadcrumb><ol class=breadcrumb><li class=breadcrumb-item><a href=/>Home</a></li><li class=breadcrumb-item><a href=/documentation/>Documentation</a></li><li class=breadcrumb-item><a href=/documentation/code/>Code Reference</a></li><li class="breadcrumb-item active" aria-current=page>file SimpleSpectra/MSSMSimpleSpec.cpp</li></ol></nav><p class=lead></p><h1 id=file-simplespectra-mssmsimplespec-cpp>file SimpleSpectra/MSSMSimpleSpec.cpp</h1><p>[No description available]</p><h2 id=namespaces>Namespaces <a href=#namespaces class=anchor aria-hidden=true>#</a></h2><table><thead><tr><th>Name</th></tr></thead><tbody><tr><td><strong><a href=/documentation/code/namespaces/namespacegambit/>Gambit</a></strong><br>TODO: see if we can use this one:</td></tr><tr><td><strong><a href=/documentation/code/namespaces/namespaceslhaea/>SLHAea</a></strong></td></tr></tbody></table><h2 id=source-code>Source code <a href=#source-code class=anchor aria-hidden=true>#</a></h2><pre><code>//   GAMBIT: Global and Modular BSM Inference Tool
//   *********************************************
///  \file
///
//
///  *********************************************
///
///  Authors:
///  &lt;!-- add name and date if you modify --&gt;
///
///  \author Ben Farmer
///          (benjamin.farmer@fysik.su.se)
///  \date 2015 Apr
///
///  \author Pat Scott
///          (p.scott@imperial.ac.uk)
///  \date 2016 Oct
///
///  *********************************************

#include &quot;gambit/Models/SimpleSpectra/MSSMSimpleSpec.hpp&quot;
#include &quot;gambit/Elements/mssm_slhahelp.hpp&quot;
#include &quot;gambit/Utils/util_functions.hpp&quot;
#include &quot;gambit/Utils/variadic_functions.hpp&quot;
#include &quot;gambit/Logs/logger.hpp&quot;

#include &lt;math.h&gt;
#include &lt;boost/lexical_cast.hpp&gt;

using namespace SLHAea;

namespace Gambit
{

      /// Helper function for sorting int, double pairs according to the double
      bool orderer (std::pair&lt;int, double&gt; a, std::pair&lt;int, double&gt; b) { return a.second &lt; b.second; }

      /// @{ Member functions for SLHAeaModel class

      /// Default Constructor
      MSSMea::MSSMea()
        : SLHAeaModel()
      {}

      /// Constructor via SLHAea object
      MSSMea::MSSMea(const SLHAea::Coll&amp; input)
        : SLHAeaModel(input)
      {
        std::map&lt;int, int&gt;&amp; slha1to2 = PDG_translation_map;
        str blocks[4] = {&quot;DSQMIX&quot;, &quot;USQMIX&quot;, &quot;SELMIX&quot;, &quot;SNUMIX&quot;};
        str gen3mix[3] = {&quot;SBOTMIX&quot;, &quot;STOPMIX&quot;, &quot;STAUMIX&quot;};
        logger() &lt;&lt; LogTags::utils;

        // Work out if this SLHAea object is SLHA1 or SLHA2
        if (data.find(blocks[0]) == data.end() or
            data.find(blocks[1]) == data.end() or
            data.find(blocks[2]) == data.end() or
            data.find(blocks[3]) == data.end() )
        {
          if (data.find(gen3mix[0]) == data.end() or
              data.find(gen3mix[1]) == data.end() or
              data.find(gen3mix[2]) == data.end() )
          {
            utils_error().raise(LOCAL_INFO, &quot;Input SLHA data appears to be neither SLHA1 nor SLHA2.&quot;);
          }
          logger() &lt;&lt; &quot;Input SLHA for setting up simple spectrum is SLHA1.  You old dog.&quot; &lt;&lt; EOM;

          // Get scale, needed for specifying SLHA2 blocks
          /// TODO: Currently assumes all blocks at same scale. Should check if this
          /// is true.
          double scale = 0.0;
          try
          {
            scale = SLHAea::to&lt;double&gt;(data.at(&quot;GAUGE&quot;).find_block_def()-&gt;at(3));
          }
          catch (const std::out_of_range&amp; e)
          {
            std::ostringstream errmsg;
            errmsg &lt;&lt; &quot;Could not find block \&quot;GAUGE\&quot; in SLHAea object (required to retrieve scale Q). Received out_of_range error with message: &quot; &lt;&lt; e.what();
            utils_error().raise(LOCAL_INFO,errmsg.str());
          }

          //Looks like it is SLHA1, so convert it to SLHA2.
          int lengths[4] = {6, 6, 6, 3};
          str names[4] = {&quot;~d_&quot;, &quot;~u_&quot;, &quot;~l_&quot;, &quot;~nu_&quot;};
          std::vector&lt;int&gt; pdg[4];
          std::vector&lt; std::pair&lt;int, double&gt; &gt; masses[4];
          pdg[0] = initVector&lt;int&gt;(1000001, 1000003, 1000005, 2000001, 2000003, 2000005); // d-type squarks
          pdg[1] = initVector&lt;int&gt;(1000002, 1000004, 1000006, 2000002, 2000004, 2000006); // u-type squarks
          pdg[2] = initVector&lt;int&gt;(1000011, 1000013, 1000015, 2000011, 2000013, 2000015); // sleptons
          pdg[3] = initVector&lt;int&gt;(1000012, 1000014, 1000016);                            // sneutrinos
          for (int j = 0; j &lt; 4; j++)
          {
            // Get the masses
            for (int i = 0; i &lt; lengths[j]; i++) masses[j].push_back(std::pair&lt;int, double&gt;(pdg[j][i], getdata(&quot;MASS&quot;,pdg[j][i])));

            // Sort them
            std::sort(masses[j].begin(), masses[j].end(), orderer);

            // Rewrite them in correct order, and populate the pdg-pdg maps
            for (int i = 0; i &lt; lengths[j]; i++)
            {
              //data[&quot;MASS&quot;][pdg[j][i]][1] = boost::lexical_cast&lt;str&gt;(masses[j][i].second);
              //data[&quot;MASS&quot;][pdg[j][i]][2] = &quot;# &quot;+names[j]+boost::lexical_cast&lt;str&gt;(i+1);
              str masspdg = boost::lexical_cast&lt;str&gt;(masses[j][i].second);
              str comment = &quot;# &quot;+names[j]+boost::lexical_cast&lt;str&gt;(i+1);
              SLHAea_add(data, &quot;MASS&quot;, pdg[j][i], masspdg, comment, true);
              slha1to2[masses[j][i].first] = pdg[j][i];
            }

            // Write the mixing block.  i is the SLHA2 index, k is the SLHA1 index.
            //data[blocks[j]][&quot;&quot;] &lt;&lt; &quot;BLOCK&quot; &lt;&lt; blocks[j];
            SLHAea_check_block(data, blocks[j]);
            for (int i = 0; i &lt; lengths[j]; i++) for (int k = 0; k &lt; lengths[j]; k++)
            {
              double datum;
              if (lengths[j] == 3 or (k != 2 and k != 5)) // first or second generation (or neutrinos)
              {
                datum = (slha1to2.at(pdg[j][k]) == pdg[j][i]) ? 1.0 : 0.0;
              }
              else // third generation =&gt; need to use the 2x2 SLHA1 mixing matrices.
              {
                double family_index = 0;
                if (k == 2)
                {
                  if (slha1to2.at(pdg[j][k]) == pdg[j][i]) family_index = 1;
                  else if (slha1to2.at(pdg[j][5]) == pdg[j][i]) family_index = 2;
                }
                else if (k == 5)
                {
                  if (slha1to2.at(pdg[j][k]) == pdg[j][i]) family_index = 2;
                  else if (slha1to2.at(pdg[j][2]) == pdg[j][i]) family_index = 1;
                }
                if (family_index &gt; 0)
                {
                  datum = getdata(gen3mix[j], family_index, (k+1)/3);
                }
                else datum = 0.0;
              }
              //data[blocks[j]][&quot;&quot;] &lt;&lt; i+1 &lt;&lt; k+1 &lt;&lt; datum &lt;&lt; &quot;# &quot;+blocks[j]+boost::lexical_cast&lt;str&gt;(i*10+k+11);
              SLHAea_add(data, blocks[j], i+1, k+1, datum, &quot;# &quot;+blocks[j]+boost::lexical_cast&lt;str&gt;(i*10+k+11), true);
            }

          }
          // Now deal with MSOFT --&gt; SLHA2 soft mass matrix blocks
          // (inverse of retrieval code in add_MSSM_spectrum_to_SLHAea) 
          sspair M[5] = {sspair(&quot;MSL2&quot;,&quot;ml2&quot;), sspair(&quot;MSE2&quot;,&quot;me2&quot;), sspair(&quot;MSQ2&quot;,&quot;mq2&quot;), sspair(&quot;MSU2&quot;,&quot;mu2&quot;), sspair(&quot;MSD2&quot;,&quot;md2&quot;)};
          for (int k=0;k&lt;5;k++)
          {
            std::string block(M[k].first);
            if(not SLHAea_block_exists(data, block)) SLHAea_add_block(data, block, scale); //TODO: maybe just always delete and replace
            for(int i=1;i&lt;4;i++) for(int j=1;j&lt;4;j++)
            {
              std::ostringstream comment;
              comment &lt;&lt; block &lt;&lt; &quot;(&quot; &lt;&lt; i &lt;&lt; &quot;,&quot; &lt;&lt; j &lt;&lt; &quot;)&quot;;
              double entry;
              if(i==j)
              {
                entry = getdata(&quot;MSOFT&quot;,30+3*k+i+(k&gt;1?4:0)); // black magic to get correct index in MSOFT matching diagonal elements
              }
              else
              {
                // Everything off-diagonal is zero in SLHA1
                entry = 0;
              }
              //data[block][&quot;&quot;] &lt;&lt; i &lt;&lt; j &lt;&lt; entry*entry &lt;&lt; &quot;# &quot;+comment.str();
              SLHAea_add(data, block, i, j, entry*entry, &quot;# &quot;+comment.str(), true);
            }
          }

          // Yukawa and trilinear blocks.  YU, YD and YE, plus [YU, YD and YE; SLHA1 only], or [TU, TD and TE; SLHA2 only].
          sspair A[3] = {sspair(&quot;AU&quot;,&quot;Au&quot;), sspair(&quot;AD&quot;,&quot;Ad&quot;), sspair(&quot;AE&quot;,&quot;Ae&quot;)};
          sspair Y[3] = {sspair(&quot;YU&quot;,&quot;Yu&quot;), sspair(&quot;YD&quot;,&quot;Yd&quot;), sspair(&quot;YE&quot;,&quot;Ye&quot;)};
          sspair T[3] = {sspair(&quot;TU&quot;,&quot;TYu&quot;), sspair(&quot;TD&quot;,&quot;TYd&quot;), sspair(&quot;TE&quot;,&quot;TYe&quot;)};
          for (int k=0;k&lt;3;k++)
          {
            SLHAea_check_block(data, A[k].first);
            SLHAea_check_block(data, Y[k].first);
            SLHAea_check_block(data, T[k].first); // TODO: should delete superceded slha1 &quot;A&quot; blocks?
            for(int i=1;i&lt;4;i++)
            {
              for(int j=1;j&lt;4;j++)
              {
                std::ostringstream comment;
                comment &lt;&lt; &quot;(&quot; &lt;&lt; i &lt;&lt; &quot;,&quot; &lt;&lt; j &lt;&lt; &quot;)&quot;;
                // SLHA1 has only diagonal elements in Y and A. We should fill them out fully.
                // Assume missing diagonal elements are also zero.
                double Yentry;
                double Aentry;
                if(i==j)
                {
                  if(SLHAea_check_block(data,Y[k].first,i,j))
                  {
                    Yentry = getdata(Y[k].first,i,j);
                  }
                  else
                  {
                    Yentry = 0;
                  }

                  if(SLHAea_check_block(data,A[k].first,i,j))
                  {
                    Aentry = getdata(A[k].first,i,j);
                  }
                  else
                  {
                    Aentry = 0;
                  }
                }
                else
                {
                  Yentry = 0;
                  Aentry = 0;
                }
              
                double Tentry = Aentry * Yentry;
                SLHAea_add(data, Y[k].first, i, j, Yentry, &quot;# &quot;+Y[k].first+&quot;_&quot;+comment.str(), true);
                SLHAea_add(data, A[k].first, i, j, Aentry, &quot;# &quot;+A[k].first+&quot;_&quot;+comment.str(), true);
                SLHAea_add(data, T[k].first, i, j, Tentry, &quot;# &quot;+T[k].first+&quot;_&quot;+comment.str(), true);
              }
            }
          }


        }

        else logger() &lt;&lt; &quot;Input SLHA data for setting up simple spectrum is SLHA2.  *living in the future*&quot; &lt;&lt; EOM;
        // In the end, we should always have converted to SLHA2 by now, so set this as the internally-tracked version.
        wrapped_slha_version = 2;
      }

      /// @{ Getters for MSSM information
      double MSSMea::get_Mu()      const{ return getdata(&quot;HMIX&quot;,1); } // mu(Q) DRbar
      double MSSMea::get_tanbeta() const{ return getdata(&quot;HMIX&quot;,2); } // tan beta(Q) DRbar ( = vu/vd)
      double MSSMea::get_tanbeta_mZ() const{ return getdata(&quot;MINPAR&quot;,3); } // tan beta(mZ) DRbar
      double MSSMea::get_v()       const{ return getdata(&quot;HMIX&quot;,3); } // v = sqrt(vd^2 + vu^2) DRbar
      double MSSMea::get_mA2()     const{ return getdata(&quot;HMIX&quot;,4); } // m^2_A=[m3^2/cosBsinB](Q) DRbar, tree
      ////// THESE ARE NOT SLHA! Therefore cannot rely on them being in the SLHAea object.
      ////// But we can compute them instead.
      // double MSSMea::get_BMu()     const { return getdata(&quot;HMIX&quot;,101); }
      // double MSSMea::get_vd()      const { return getdata(&quot;HMIX&quot;,102); }
      // double MSSMea::get_vu()      const { return getdata(&quot;HMIX&quot;,103); }
      ///////
      double MSSMea::get_BMu() const 
      {
        double tb = get_tanbeta();
        double cb = cos(atan(tb));
        double sb = sin(atan(tb));
        return get_mA2() * (sb * cb);
      }
      double MSSMea::get_vd() const 
      {
        double v = get_v();
        double tb = get_tanbeta();
        return sqrt(abs( v*v / ( tb*tb + 1 ) ));
      }
      double MSSMea::get_vu() const
      {
        double v = get_v();
        double itb = 1./get_tanbeta();
        return sqrt(abs( v*v / ( itb*itb + 1 ) )); 
      }

      double MSSMea::get_MassB () const { return getdata(&quot;MSOFT&quot;,1); }
      double MSSMea::get_MassWB() const { return getdata(&quot;MSOFT&quot;,2); }
      double MSSMea::get_MassG () const { return getdata(&quot;MSOFT&quot;,3); }
      double MSSMea::get_mHd2() const { return getdata(&quot;MSOFT&quot;,21); }
      double MSSMea::get_mHu2() const { return getdata(&quot;MSOFT&quot;,22); }

      double MSSMea::get_mq2(int i, int j) const { return getdata(&quot;MSQ2&quot;,i,j); }
      double MSSMea::get_ml2(int i, int j) const { return getdata(&quot;MSL2&quot;,i,j); }
      double MSSMea::get_md2(int i, int j) const { return getdata(&quot;MSD2&quot;,i,j); }
      double MSSMea::get_mu2(int i, int j) const { return getdata(&quot;MSU2&quot;,i,j); }
      double MSSMea::get_me2(int i, int j) const { return getdata(&quot;MSE2&quot;,i,j); }

      double MSSMea::get_TYd(int i, int j) const { return getdata(&quot;Td&quot;,i,j); }
      double MSSMea::get_TYu(int i, int j) const { return getdata(&quot;Tu&quot;,i,j); }
      double MSSMea::get_TYe(int i, int j) const { return getdata(&quot;Te&quot;,i,j); }

      double MSSMea::get_ad(int i, int j) const { return getdata(&quot;Ad&quot;,i,j); }
      double MSSMea::get_au(int i, int j) const { return getdata(&quot;Au&quot;,i,j); }
      double MSSMea::get_ae(int i, int j) const { return getdata(&quot;Ae&quot;,i,j); }

      double MSSMea::get_Yd(int i, int j) const { return getdata(&quot;Yd&quot;,i,j); }
      double MSSMea::get_Yu(int i, int j) const { return getdata(&quot;Yu&quot;,i,j); }
      double MSSMea::get_Ye(int i, int j) const { return getdata(&quot;Ye&quot;,i,j); }

      double MSSMea::get_g1() const { return getdata(&quot;GAUGE&quot;,1)/sqrt(3./5.); } // Convert from gy (in SLHAea object) to g1
      double MSSMea::get_g2() const { return getdata(&quot;GAUGE&quot;,2); }
      double MSSMea::get_g3() const { return getdata(&quot;GAUGE&quot;,3); }
      double MSSMea::get_sinthW2_DRbar() const
      {
        double sg1 = 0.6 * Utils::sqr(get_g1());
        return sg1 / (sg1 + Utils::sqr(get_g2()));
      }

      double MSSMea::get_MGlu_pole() const { return getdata(&quot;MASS&quot;,1000021); }

      double MSSMea::get_Mhh_pole_slha(int i) const
      {
         if      (i==1){ return getdata(&quot;MASS&quot;,25); } // Neutral Higgs(1)
         else if (i==2){ return getdata(&quot;MASS&quot;,35); } // Neutral Higgs(2)
         else { utils_error().raise(LOCAL_INFO,&quot;Invalid index input to get_Mhh_pole_slha! Please check index range limits in wrapper SubSpectrum class!&quot;); return -1; } // Should not return.
      }
      double MSSMea::get_MAh_pole () const { return getdata(&quot;MASS&quot;,36); }
      double MSSMea::get_MHpm_pole() const { return getdata(&quot;MASS&quot;,37); }
      double MSSMea::get_MW_pole()    const { return getdata(&quot;MASS&quot;,24); } // REQUIRED output of MSSM-compatible subspectrum

      double MSSMea::get_MCha_pole_slha(int i) const
      {
         if      (i==1){ return getdata(&quot;MASS&quot;,1000024); } // Chargino(1)
         else if (i==2){ return getdata(&quot;MASS&quot;,1000037); } // Chargino(2)
         else { utils_error().raise(LOCAL_INFO,&quot;Invalid index input to get_MCha_pole_slha! Please check index range limits in wrapper SubSpectrum class!&quot;); return -1; } // Should not return.
      }
      double MSSMea::get_MSd_pole_slha(int i) const
      {
         static std::map&lt;int,int&gt; match;

         if      (i==1){ return getdata(&quot;MASS&quot;,1000001); } // d-type squark(1)
         else if (i==2){ return getdata(&quot;MASS&quot;,1000003); } // d-type squark(2)
         else if (i==3){ return getdata(&quot;MASS&quot;,1000005); } // d-type squark(3)
         else if (i==4){ return getdata(&quot;MASS&quot;,2000001); } // d-type squark(4)
         else if (i==5){ return getdata(&quot;MASS&quot;,2000003); } // d-type squark(5)
         else if (i==6){ return getdata(&quot;MASS&quot;,2000005); } // d-type squark(6)
         else { utils_error().raise(LOCAL_INFO,&quot;Invalid index input to get_MSd_pole_slha! Please check index range limits in wrapper SubSpectrum class!&quot;); return -1; } // Should not return.
      }
      double MSSMea::get_MSu_pole_slha(int i) const
      {
         if      (i==1){ return getdata(&quot;MASS&quot;,1000002); } // u-type squark(1)
         else if (i==2){ return getdata(&quot;MASS&quot;,1000004); } // u-type squark(2)
         else if (i==3){ return getdata(&quot;MASS&quot;,1000006); } // u-type squark(3)
         else if (i==4){ return getdata(&quot;MASS&quot;,2000002); } // u-type squark(4)
         else if (i==5){ return getdata(&quot;MASS&quot;,2000004); } // u-type squark(5)
         else if (i==6){ return getdata(&quot;MASS&quot;,2000006); } // u-type squark(6)
         else { utils_error().raise(LOCAL_INFO,&quot;Invalid index input to get_MSd_pole_slha! Please check index range limits in wrapper SubSpectrum class!&quot;); return -1; } // Should not return.
      }
      double MSSMea::get_MSe_pole_slha(int i) const
      {
         if      (i==1){ return getdata(&quot;MASS&quot;,1000011); } // charged slepton(1)
         else if (i==2){ return getdata(&quot;MASS&quot;,1000013); } // charged slepton(2)
         else if (i==3){ return getdata(&quot;MASS&quot;,1000015); } // charged slepton(3)
         else if (i==4){ return getdata(&quot;MASS&quot;,2000011); } // charged slepton(4)
         else if (i==5){ return getdata(&quot;MASS&quot;,2000013); } // charged slepton(5)
         else if (i==6){ return getdata(&quot;MASS&quot;,2000015); } // charged slepton(6)
         else { utils_error().raise(LOCAL_INFO,&quot;Invalid index input to get_MSd_pole_slha! Please check index range limits in wrapper SubSpectrum class!&quot;); return -1; } // Should not return.
      }
      double MSSMea::get_MSv_pole_slha(int i) const
      {
         if      (i==1){ return getdata(&quot;MASS&quot;,1000012); } // Sneutrino(1)
         else if (i==2){ return getdata(&quot;MASS&quot;,1000014); } // Sneutrino(2)
         else if (i==3){ return getdata(&quot;MASS&quot;,1000016); } // Sneutrino(3)
         else { utils_error().raise(LOCAL_INFO,&quot;Invalid index input to get_MSd_pole_slha! Please check index range limits in wrapper SubSpectrum class!&quot;); return -1; } // Should not return.
      }
      double MSSMea::get_MChi_pole_slha(int i) const
      {
         if      (i==1){ return getdata(&quot;MASS&quot;,1000022); } // Neutralino(1)
         else if (i==2){ return getdata(&quot;MASS&quot;,1000023); } // Neutralino(2)
         else if (i==3){ return getdata(&quot;MASS&quot;,1000025); } // Neutralino(3)
         else if (i==4){ return getdata(&quot;MASS&quot;,1000035); } // Neutralino(4)
         else { utils_error().raise(LOCAL_INFO,&quot;Invalid index input to get_MChi_pole_slha! Please check index range limits in wrapper SubSpectrum class!&quot;); return -1; } // Should not return.
      }

      // Pole Mixings
      double MSSMea::get_ZD_pole_slha(int i, int j) const { return getdata(&quot;DSQMIX&quot;,i,j); }
      double MSSMea::get_ZU_pole_slha(int i, int j) const { return getdata(&quot;USQMIX&quot;,i,j); }

      double MSSMea::get_ZV_pole_slha(int i, int j) const { return getdata(&quot;SNUMIX&quot;,i,j); }
      double MSSMea::get_ZE_pole_slha(int i, int j) const { return getdata(&quot;SELMIX&quot;,i,j); }

      double MSSMea::get_ZH_pole_slha(int i, int j) const { return getdata(&quot;SCALARMIX&quot;,i,j); }
      double MSSMea::get_ZA_pole_slha(int i, int j) const { return getdata(&quot;PSEUDOSCALARMIX&quot;,i,j); }

      double MSSMea::get_ZP_pole_slha(int i, int j) const { return getdata(&quot;CHARGEMIX&quot;,i,j); }
      double MSSMea::get_ZN_pole_slha(int i, int j) const { return getdata(&quot;NMIX&quot;,i,j); }

      double MSSMea::get_UM_pole_slha(int i, int j) const { return getdata(&quot;UMIX&quot;,i,j); }
      double MSSMea::get_UP_pole_slha(int i, int j) const { return getdata(&quot;VMIX&quot;,i,j); }

      /// @}


      /// @{ Member functions for MSSMSimpleSpec class

      /// @{ Constructors

      /// Default Constructor
      MSSMSimpleSpec::MSSMSimpleSpec(double uncert)
      {
        set_pole_mass_uncertainties(uncert);
      }

      /// Constructor via SLHAea object
      MSSMSimpleSpec::MSSMSimpleSpec(const SLHAea::Coll&amp; input, double uncert)
        : SLHASimpleSpec(input)
      {
        set_pole_mass_uncertainties(uncert);
      }

      /// Copy constructor: needed by clone function.
      MSSMSimpleSpec::MSSMSimpleSpec(const MSSMSimpleSpec&amp; other, double uncert)
        : SLHASimpleSpec(other)
      {
        set_pole_mass_uncertainties(uncert);
      }

      /// @}

      /// Ofset from user-input indices (user assumes 1,2,3 indexed, e.g. use offset=-1 for zero-indexing)
      int MSSMSimpleSpec::get_index_offset() const {return 0.;} // we use indices starting from 1 in this file, matching user assumptions. (because Peter is god, he knows user assumptions before they do.)

      /// Retrieve SLHAea object 
      // NOTE! No need to write this function, SubSpectrum base class can handle it if add_to_SLHAea exists.
      //SLHAea::Coll MSSMSimpleSpec::getSLHAea(int slha_version) const 

      /// Add SLHAea object to another
      void MSSMSimpleSpec::add_to_SLHAea(int slha_version, SLHAea::Coll&amp; slha) const
      {
        slha = slhawrap.get_slhaea();

        // Add SPINFO data if not already present
        SLHAea_add_GAMBIT_SPINFO(slha);

        // All MSSM blocks
        slhahelp::add_MSSM_spectrum_to_SLHAea(*this, slha, slha_version);
      }

      /// Retrieve the PDG translation map
      const std::map&lt;int, int&gt;&amp; MSSMSimpleSpec::PDG_translator() const { return slhawrap.PDG_translator(); }

      /// Set pole mass uncertainties
      void MSSMSimpleSpec::set_pole_mass_uncertainties(double uncert)
      {
        const std::vector&lt;int&gt; i12        = initVector(1,2);
        const std::vector&lt;int&gt; i123       = initVector(1,2,3);
        const std::vector&lt;int&gt; i1234      = initVector(1,2,3,4);
        const std::vector&lt;int&gt; i123456    = initVector(1,2,3,4,5,6);
        const std::vector&lt;str&gt; sbosons1   = initVector&lt;str&gt;(&quot;~g&quot;,&quot;A0&quot;,&quot;H+&quot;,&quot;H-&quot;,&quot;W+&quot;,&quot;W-&quot;);
        const std::vector&lt;str&gt; sbosons2   = initVector&lt;str&gt;(&quot;~chi+&quot;,&quot;~chi-&quot;,&quot;h0&quot;);
        const std::vector&lt;str&gt; sfermions1 = initVector&lt;str&gt;(&quot;~u&quot;,&quot;~d&quot;,&quot;~e-&quot;,&quot;~ubar&quot;,&quot;~dbar&quot;,&quot;~e+&quot;);
        const std::vector&lt;str&gt; sfermions2 = initVector&lt;str&gt;(&quot;~nu&quot;,&quot;~nubar&quot;);
        set_override_vector(Par::Pole_Mass_1srd_high, uncert, sfermions1, i123456, true);
        set_override_vector(Par::Pole_Mass_1srd_low,  uncert, sfermions1, i123456, true);
        set_override_vector(Par::Pole_Mass_1srd_high, uncert, sfermions2, i123, true);
        set_override_vector(Par::Pole_Mass_1srd_low,  uncert, sfermions2, i123, true);
        set_override_vector(Par::Pole_Mass_1srd_high, uncert, sbosons1, true);
        set_override_vector(Par::Pole_Mass_1srd_low,  uncert, sbosons1, true);
        set_override_vector(Par::Pole_Mass_1srd_high, uncert, sbosons2, i12, true);
        set_override_vector(Par::Pole_Mass_1srd_low,  uncert, sbosons2, i12, true);
        set_override_vector(Par::Pole_Mass_1srd_high, uncert, &quot;~chi0&quot;, i1234, true);
        set_override_vector(Par::Pole_Mass_1srd_low,  uncert, &quot;~chi0&quot;, i1234, true);
      }

      // Map fillers

      MSSMSimpleSpec::GetterMaps MSSMSimpleSpec::fill_getter_maps()
      {
         GetterMaps map_collection;

         typedef MTget::FInfo1 FInfo1;
         typedef MTget::FInfo2 FInfo2;

         // Can't use c++11 initialiser lists, se have to initialise the index sets like this.
         static const int i12v[] = {1,2};
         static const std::set&lt;int&gt; i12(i12v, Utils::endA(i12v));

         static const int i123v[] = {1,2,3};
         static const std::set&lt;int&gt; i123(i123v, Utils::endA(i123v));

         static const int i1234v[] = {1,2,3,4};
         static const std::set&lt;int&gt; i1234(i1234v, Utils::endA(i1234v));

         static const int i123456v[] = {1,2,3,4,5,6};
         static const std::set&lt;int&gt; i123456(i123456v, Utils::endA(i123456v));

         // Running parameters
         {
            MTget::fmap0 tmp_map;
            tmp_map[&quot;BMu&quot;] = &amp;Model::get_BMu;
            tmp_map[&quot;mA2&quot;] = &amp;Model::get_mA2;
            tmp_map[&quot;mHd2&quot;] = &amp;Model::get_mHd2;
            tmp_map[&quot;mHu2&quot;] = &amp;Model::get_mHu2;
            map_collection[Par::mass2].map0 = tmp_map;
         }
         {
            MTget::fmap2 tmp_map;
            tmp_map[&quot;mq2&quot;] = FInfo2( &amp;Model::get_mq2, i123, i123);
            tmp_map[&quot;ml2&quot;] = FInfo2( &amp;Model::get_ml2, i123, i123);
            tmp_map[&quot;md2&quot;] = FInfo2( &amp;Model::get_md2, i123, i123);
            tmp_map[&quot;mu2&quot;] = FInfo2( &amp;Model::get_mu2, i123, i123);
            tmp_map[&quot;me2&quot;] = FInfo2( &amp;Model::get_me2, i123, i123);
            map_collection[Par::mass2].map2 = tmp_map;
         }
         {
            MTget::fmap0 tmp_map;
            tmp_map[&quot;M1&quot;]= &amp;Model::get_MassB;
            tmp_map[&quot;M2&quot;]= &amp;Model::get_MassWB;
            tmp_map[&quot;M3&quot;]= &amp;Model::get_MassG;
            tmp_map[&quot;Mu&quot;]= &amp;Model::get_Mu;
            tmp_map[&quot;vu&quot;]= &amp;Model::get_vu;
            tmp_map[&quot;vd&quot;]= &amp;Model::get_vd;
            map_collection[Par::mass1].map0 = tmp_map;
         }
         {
            MTget::fmap2 tmp_map;
            tmp_map[&quot;TYd&quot;]= FInfo2( &amp;Model::get_TYd, i123, i123);
            tmp_map[&quot;TYe&quot;]= FInfo2( &amp;Model::get_TYe, i123, i123);
            tmp_map[&quot;TYu&quot;]= FInfo2( &amp;Model::get_TYu, i123, i123);
            tmp_map[&quot;ad&quot;] = FInfo2( &amp;Model::get_ad, i123, i123);
            tmp_map[&quot;ae&quot;] = FInfo2( &amp;Model::get_ae, i123, i123);
            tmp_map[&quot;au&quot;] = FInfo2( &amp;Model::get_au, i123, i123);
            map_collection[Par::mass1].map2 = tmp_map;
         }
         {
            MTget::fmap0 tmp_map;
            tmp_map[&quot;g1&quot;]= &amp;Model::get_g1;
            tmp_map[&quot;g2&quot;]= &amp;Model::get_g2;
            tmp_map[&quot;g3&quot;]= &amp;Model::get_g3;
            tmp_map[&quot;tanbeta&quot;]= &amp;Model::get_tanbeta;
            tmp_map[&quot;tanbeta(mZ)&quot;]= &amp;Model::get_tanbeta_mZ; // Special entry for reproducing MINPAR entry in SLHA
            tmp_map[&quot;sinW2&quot;]= &amp;Model::get_sinthW2_DRbar;
            map_collection[Par::dimensionless].map0 = tmp_map;
         }
         {
            MTget::fmap2 tmp_map;
            tmp_map[&quot;Yd&quot;]= FInfo2( &amp;Model::get_Yd, i123, i123);
            tmp_map[&quot;Yu&quot;]= FInfo2( &amp;Model::get_Yu, i123, i123);
            tmp_map[&quot;Ye&quot;]= FInfo2( &amp;Model::get_Ye, i123, i123);
            map_collection[Par::dimensionless].map2 = tmp_map;
         }

         // &quot;Physical&quot; parameters
         {
            MTget::fmap0 tmp_map;
            tmp_map[&quot;~g&quot;] = &amp;Model::get_MGlu_pole;
            tmp_map[&quot;A0&quot;] = &amp;Model::get_MAh_pole;
            tmp_map[&quot;H+&quot;] = &amp;Model::get_MHpm_pole;
            // Antiparticle label
            tmp_map[&quot;H-&quot;] = &amp;Model::get_MHpm_pole;
            tmp_map[&quot;W+&quot;] = &amp;Model::get_MW_pole;
            map_collection[Par::Pole_Mass].map0 = tmp_map;
         }
         {
            MTget::fmap1 tmp_map;
            tmp_map[&quot;~d&quot;] =    FInfo1( &amp;Model::get_MSd_pole_slha, i123456 );
            tmp_map[&quot;~u&quot;] =    FInfo1( &amp;Model::get_MSu_pole_slha, i123456 );
            tmp_map[&quot;~e-&quot;] =   FInfo1( &amp;Model::get_MSe_pole_slha, i123456 );
            tmp_map[&quot;~nu&quot;] =   FInfo1( &amp;Model::get_MSv_pole_slha, i123 );
            tmp_map[&quot;h0&quot;] =    FInfo1( &amp;Model::get_Mhh_pole_slha, i12 );
            tmp_map[&quot;~chi+&quot;] = FInfo1( &amp;Model::get_MCha_pole_slha, i12 );
            tmp_map[&quot;~chi0&quot;] = FInfo1( &amp;Model::get_MChi_pole_slha, i1234 );

            // Antiparticles (same getters, just different string name)
            tmp_map[&quot;~dbar&quot;] = FInfo1( &amp;Model::get_MSd_pole_slha, i123456 );
            tmp_map[&quot;~ubar&quot;] = FInfo1( &amp;Model::get_MSu_pole_slha, i123456 );
            tmp_map[&quot;~e+&quot;]   = FInfo1( &amp;Model::get_MSe_pole_slha, i123456 );
            tmp_map[&quot;~nubar&quot;]= FInfo1( &amp;Model::get_MSv_pole_slha, i123 );
            tmp_map[&quot;~chi-&quot;] = FInfo1( &amp;Model::get_MCha_pole_slha, i12 );
            map_collection[Par::Pole_Mass].map1 = tmp_map;
         }
         {
            MTget::fmap2 tmp_map;
            tmp_map[&quot;~d&quot;] =    FInfo2( &amp;Model::get_ZD_pole_slha, i123456, i123456);
            tmp_map[&quot;~nu&quot;] =   FInfo2( &amp;Model::get_ZV_pole_slha, i123, i123);
            tmp_map[&quot;~u&quot;] =    FInfo2( &amp;Model::get_ZU_pole_slha, i123456, i123456);
            tmp_map[&quot;~e-&quot;]=    FInfo2( &amp;Model::get_ZE_pole_slha, i123456, i123456);
            tmp_map[&quot;h0&quot;] =    FInfo2( &amp;Model::get_ZH_pole_slha, i12, i12);
            tmp_map[&quot;A0&quot;] =    FInfo2( &amp;Model::get_ZA_pole_slha, i12, i12);
            tmp_map[&quot;H+&quot;] =    FInfo2( &amp;Model::get_ZP_pole_slha, i12, i12);
            tmp_map[&quot;~chi0&quot;] = FInfo2( &amp;Model::get_ZN_pole_slha, i1234, i1234);
            tmp_map[&quot;~chi-&quot;] = FInfo2( &amp;Model::get_UM_pole_slha, i12, i12);
            tmp_map[&quot;~chi+&quot;] = FInfo2( &amp;Model::get_UP_pole_slha, i12, i12);
            map_collection[Par::Pole_Mixing].map2 = tmp_map;
         }

         return map_collection;
      }


} // end Gambit namespace
</code></pre><hr><p>Updated on 2022-09-08 at 02:27:29 +0000</p></main></div></div></div><footer class="footer text-muted"><div class=container-xxl><div class=row><div class="col-lg-8 order-last order-lg-first"><ul class=list-inline><li class=list-inline-item>Powered by <a href=https://gohugo.io/>Hugo</a> and <a href=https://getdoks.org/>Doks</a></li></ul></div><div class="col-lg-8 order-first order-lg-last text-lg-end"><ul class=list-inline><li class=list-inline-item><a href=/license/>License</a></li></ul></div></div></div></footer><script src=/js/bootstrap.min.1da7e648bd316d7b1f1bff21fe81545e73f3c2385908a8c3be87f79a560042318b4b13031e53871d84590710da0df312590e0c60b11a6a1b83dede2f81c30b66.js integrity="sha512-HafmSL0xbXsfG/8h/oFUXnPzwjhZCKjDvof3mlYAQjGLSxMDHlOHHYRZBxDaDfMSWQ4MYLEaahuD3t4vgcMLZg==" crossorigin=anonymous defer></script>
<script src=/js/highlight.min.5b48bc253dc75aeea5fb366ecf700f4925e2b6eb1a1466f2124b722d68148d67bc0a9365d2b8ad9c585161b46372d23b08509a16f1fd518542b894756d4752d0.js integrity="sha512-W0i8JT3HWu6l+zZuz3APSSXitusaFGbyEktyLWgUjWe8CpNl0ritnFhRYbRjctI7CFCaFvH9UYVCuJR1bUdS0A==" crossorigin=anonymous defer></script>
<script src=/main.min.162c56a0426544de0d010e66c56e321579655c400c9aae06a6823e7682de379adadf2165bd416fea191e4e7e410fbf1fd2c35a759aa43ff2e3787067669bf81b.js integrity="sha512-FixWoEJlRN4NAQ5mxW4yFXllXEAMmq4GpoI+doLeN5ra3yFlvUFv6hkeTn5BD78f0sNadZqkP/LjeHBnZpv4Gw==" crossorigin=anonymous defer></script>
<script src=https://gambitbsm.github.io/index.min.fbb6553b7dc60d665ec93413610230d0115e1a7b4973fac0051de5316971543760c7c910a8ad22be671156484cfdc9aa9017fd6dd9c1bc716d967cad3f86572e.js integrity="sha512-+7ZVO33GDWZeyTQTYQIw0BFeGntJc/rABR3lMWlxVDdgx8kQqK0ivmcRVkhM/cmqkBf9bdnBvHFtlnytP4ZXLg==" crossorigin=anonymous defer></script></body></html>