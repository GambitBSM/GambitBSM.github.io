<!doctype html><html lang=en-us><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="ie=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><link rel=preload as=font href=https://gambitbsm.org/fonts/vendor/jost/jost-v4-latin-regular.woff2 type=font/woff2 crossorigin><link rel=preload as=font href=https://gambitbsm.org/fonts/vendor/jost/jost-v4-latin-500.woff2 type=font/woff2 crossorigin><link rel=preload as=font href=https://gambitbsm.org/fonts/vendor/jost/jost-v4-latin-700.woff2 type=font/woff2 crossorigin><script>(()=>{var e=localStorage.getItem("theme");e==="dark"&&document.documentElement.setAttribute("data-dark-mode","")})()</script><link rel=stylesheet href=https://gambitbsm.org/main.f8151591b2672085f0933fc9a990f490d47a5bae835eba13e592ae582ffe5e3a9177998e140a75a274da31357b8222d58a74d4a9f10720e05b02bc2a37e6f0ec.css integrity="sha512-+BUVkbJnIIXwkz/JqZD0kNR6W66DXroT5ZKuWC/+XjqRd5mOFAp1onTaMTV7giLVinTUqfEHIOBbArwqN+bw7A==" crossorigin=anonymous><noscript><style>img.lazyload{display:none}</style></noscript><meta name=robots content="index, follow"><meta name=googlebot content="index, follow, max-snippet:-1, max-image-preview:large, max-video-preview:-1"><meta name=bingbot content="index, follow, max-snippet:-1, max-image-preview:large, max-video-preview:-1"><title>file Elements/module_macros_incore_defs.hpp - GAMBIT</title><meta name=description content="[No description available]"><link rel=canonical href=https://gambitbsm.org/documentation/code/files/module__macros__incore__defs_8hpp/><meta property="og:locale" content="en_US"><meta property="og:type" content="article"><meta property="og:title" content="file Elements/module_macros_incore_defs.hpp"><meta property="og:description" content="[No description available]"><meta property="og:url" content="https://gambitbsm.org/documentation/code/files/module__macros__incore__defs_8hpp/"><meta property="og:site_name" content="GAMBIT"><meta property="og:image" content="https://gambitbsm.org/gambit_logo.png"><meta property="og:image:alt" content="GAMBIT"><meta name=twitter:card content="summary_large_image"><meta name=twitter:site content><meta name=twitter:creator content><meta name=twitter:title content="file Elements/module_macros_incore_defs.hpp"><meta name=twitter:description content="[No description available]"><meta name=twitter:image content="https://gambitbsm.org/gambit_logo.png"><meta name=twitter:image:alt content="file Elements/module_macros_incore_defs.hpp"><script type=application/ld+json>{"@context":"https://schema.org","@graph":[{"@type":"Organization","@id":"https://gambitbsm.org/#/schema/organization/1","name":"Doks","url":"https://gambitbsm.org/","sameAs":["https://github.com/GambitBSM"],"logo":{"@type":"ImageObject","@id":"https://gambitbsm.org/#/schema/image/1","url":"https://gambitbsm.org/logo-doks.png","width":450,"height":416,"caption":"Doks"},"image":{"@id":"https://gambitbsm.org/#/schema/image/1"}},{"@type":"WebSite","@id":"https://gambitbsm.org/#/schema/website/1","url":"https://gambitbsm.org/","name":"GAMBIT","description":"Documentation for GAMBIT, the Global And Modular BSM Inference Tool","publisher":{"@id":"https://gambitbsm.org/#/schema/organization/1"}},{"@type":"WebPage","@id":"https://gambitbsm.org/documentation/code/files/module__macros__incore__defs_8hpp/","url":"https://gambitbsm.org/documentation/code/files/module__macros__incore__defs_8hpp/","name":"file Elements\/module_macros_incore_defs.hpp","description":"[No description available]","isPartOf":{"@id":"https://gambitbsm.org/#/schema/website/1"},"about":{"@id":"https://gambitbsm.org/#/schema/organization/1"},"datePublished":"0001-01-01T00:00:00CET","dateModified":"0001-01-01T00:00:00CET","breadcrumb":{"@id":"https://gambitbsm.org/documentation/code/files/module__macros__incore__defs_8hpp/#/schema/breadcrumb/1"},"primaryImageOfPage":{"@id":"https://gambitbsm.org/documentation/code/files/module__macros__incore__defs_8hpp/#/schema/image/2"},"inLanguage":"en-US","potentialAction":[{"@type":"ReadAction","target":["https://gambitbsm.org/documentation/code/files/module__macros__incore__defs_8hpp/"]}]},{"@type":"BreadcrumbList","@id":"https://gambitbsm.org/documentation/code/files/module__macros__incore__defs_8hpp/#/schema/breadcrumb/1","name":"Breadcrumbs","itemListElement":[{"@type":"ListItem","position":1,"item":{"@type":"WebPage","@id":"https://gambitbsm.org/","url":"https://gambitbsm.org/","name":"Home"}},{"@type":"ListItem","position":2,"item":{"@type":"WebPage","@id":"https://gambitbsm.org/documentation/","url":"https://gambitbsm.org/documentation/","name":"Documentation"}},{"@type":"ListItem","position":3,"item":{"@type":"WebPage","@id":"https://gambitbsm.org/documentation/code/","url":"https://gambitbsm.org/documentation/code/","name":"Code"}},{"@type":"ListItem","position":4,"item":{"@type":"WebPage","@id":"https://gambitbsm.org/documentation/code/files/","url":"https://gambitbsm.org/documentation/code/files/","name":"Files"}},{"@type":"ListItem","position":5,"item":{"@id":"https://gambitbsm.org/documentation/code/files/module__macros__incore__defs_8hpp/"}}]},{"@context":"https://schema.org","@graph":[{"@type":"ImageObject","@id":"https://gambitbsm.org/documentation/code/files/module__macros__incore__defs_8hpp/#/schema/image/2","url":"https://gambitbsm.org/gambit_logo.png","contentUrl":"https://gambitbsm.org/gambit_logo.png","caption":"file Elements\/module_macros_incore_defs.hpp"}]}]}</script><meta name=theme-color content="#fff"><link rel=icon href=https://gambitbsm.org/favicon.ico sizes=any><link rel=icon type=image/svg+xml href=https://gambitbsm.org/favicon.svg><link rel=apple-touch-icon sizes=180x180 href=https://gambitbsm.org/apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=https://gambitbsm.org/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=https://gambitbsm.org/favicon-16x16.png><link rel=manifest crossorigin=use-credentials href=https://gambitbsm.org/site.webmanifest></head><body class="documentation single light"><div class=sticky-top><div class=header-bar></div><header class="navbar navbar-expand-md navbar-light doks-navbar"><nav class="container-xxl flex-wrap flex-md-nowrap" aria-label="Main navigation"><a class="navbar-brand p-0 me-auto" href=https://gambitbsm.org/ aria-label=GAMBIT><img class=logo-light src=https://gambitbsm.org/gambit_logo.png width=50px>
<img class="logo-dark d-none" src=https://gambitbsm.org/gambit_logo.png width=50px>
GAMBIT</a>
<button class="btn btn-menu order-2 d-block d-lg-none" type=button data-bs-toggle=offcanvas data-bs-target=#offcanvasDoks aria-controls=offcanvasDoks aria-label="Open main menu"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-menu"><line x1="3" y1="12" x2="21" y2="12"/><line x1="3" y1="6" x2="21" y2="6"/><line x1="3" y1="18" x2="21" y2="18"/></svg></button><div class="offcanvas offcanvas-end border-0 py-lg-1" tabindex=-1 id=offcanvasDoks data-bs-backdrop=true aria-labelledby=offcanvasDoksLabel><div class="header-bar d-lg-none"></div><div class="offcanvas-header d-lg-none"><h2 class="h5 offcanvas-title ps-2" id=offcanvasDoksLabel><a class=text-dark href=/>GAMBIT</a></h2><button type=button class="btn-close text-reset me-2" data-bs-dismiss=offcanvas aria-label="Close main menu"></button></div><div class="offcanvas-body p-4 p-lg-0"><ul class="nav flex-column flex-lg-row align-items-lg-center mt-2 mt-lg-0 ms-lg-2 me-lg-auto"><li class="nav-item dropdown"><a class="nav-link dropdown-toggle ps-0 py-1" href=# id=navbarDropdownMenuLink role=button data-bs-toggle=dropdown aria-expanded=false>Releases
<span class=dropdown-caret><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-chevron-down"><polyline points="6 9 12 15 18 9"/></svg></span></a><ul class="dropdown-menu dropdown-menu-main shadow rounded border-0" aria-labelledby=navbarDropdownMenuLink><li><a class=dropdown-item href=https://github.com/GambitBSM/gambit_2.4>GAMBIT 2-4 ⧉</a></li><li><a class=dropdown-item href=https://github.com/GambitBSM/gambit_2.3>GAMBIT 2-3 ⧉</a></li><li><a class=dropdown-item href=https://github.com/GambitBSM/gambit_2.2>GAMBIT 2-2 ⧉</a></li><li><a class=dropdown-item href=https://github.com/GambitBSM/gambit_2.1>GAMBIT 2-1 ⧉</a></li><li><a class=dropdown-item href=https://github.com/GambitBSM/gambit_2.4/tags>All releases ⧉</a></li></ul></li><li class="nav-item dropdown"><a class="nav-link dropdown-toggle ps-0 py-1" href=# id=navbarDropdownMenuLink role=button data-bs-toggle=dropdown aria-expanded=false>Documentation
<span class=dropdown-caret><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-chevron-down"><polyline points="6 9 12 15 18 9"/></svg></span></a><ul class="dropdown-menu dropdown-menu-main shadow rounded border-0" aria-labelledby=navbarDropdownMenuLink><li><a class=dropdown-item href=/documentation/installation/introduction/>Installation</a></li><li><a class=dropdown-item href=/documentation/tutorials/the_gambit_interface>Tutorials</a></li><li><a class=dropdown-item href=/documentation/help/common_problems_and_questions/>Help</a></li><li><a class=dropdown-item href=/documentation/code/index_classes>Code Reference</a></li></ul></li><li class="nav-item dropdown"><a class="nav-link dropdown-toggle ps-0 py-1" href=# id=navbarDropdownMenuLink role=button data-bs-toggle=dropdown aria-expanded=false>Community
<span class=dropdown-caret><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-chevron-down"><polyline points="6 9 12 15 18 9"/></svg></span></a><ul class="dropdown-menu dropdown-menu-main shadow rounded border-0" aria-labelledby=navbarDropdownMenuLink><li><a class=dropdown-item href=/community/publications/>Publications</a></li><li><a class=dropdown-item href=/community/talks/>Talks</a></li><li><a class=dropdown-item href=/community/members/>Members</a></li><li><a class="dropdown-item active" href=/community/code_of_conduct/ aria-current=true>Code of Conduct</a></li><li><a class=dropdown-item href=/community/contact/>Contact</a></li></ul></li></ul><hr class="text-black-50 my-4 d-lg-none"><form class="doks-search position-relative flex-grow-1 ms-lg-auto me-lg-2"><input id=search class="form-control is-search" type=search placeholder="Search site..." aria-label="Search site..." autocomplete=off><div id=suggestions class="shadow bg-white rounded d-none"></div></form><hr class="text-black-50 my-4 d-lg-none"><ul class="nav flex-column flex-lg-row"><li class=nav-item><a class="nav-link social-link" href=https://github.com/GambitBSM><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-github"><path d="M9 19c-5 1.5-5-2.5-7-3m14 6v-3.87a3.37 3.37.0 00-.94-2.61c3.14-.35 6.44-1.54 6.44-7A5.44 5.44.0 0020 4.77 5.07 5.07.0 0019.91 1S18.73.65 16 2.48a13.38 13.38.0 00-7 0C6.27.65 5.09 1 5.09 1A5.07 5.07.0 005 4.77 5.44 5.44.0 003.5 8.55c0 5.42 3.3 6.61 6.44 7A3.37 3.37.0 009 18.13V22"/></svg><small class="ms-2 d-lg-none">GitHub</small></a></li></ul><hr class="text-black-50 my-4 d-lg-none"><button id=mode class="btn btn-link" type=button aria-label="Toggle user interface mode">
<span class=toggle-dark><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-moon"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg></span><span class=toggle-light><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-sun"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></span></button></div></div></nav></header></div><div class="wrap container-xxl" role=document><div class=content><div class="row flex-xl-nowrap"><div class="col-lg-5 col-xl-4 docs-sidebar"><nav class=docs-links aria-label="Main navigation"><ul class="list-unstyled collapsible-sidebar"><li class=mb-1><button class="btn btn-toggle align-items-center rounded collapsed" data-bs-toggle=collapse data-bs-target=#section-installation aria-expanded=false>
Installation</button><div class=collapse id=section-installation><ul class="btn-toggle-nav list-unstyled fw-normal pb-1 small"><li><a class="docs-link rounded" href=/documentation/installation/introduction/>Getting Started</a></li><li><a class="docs-link rounded" href=/documentation/installation/docker_usage/>Docker Usage</a></li><li><a class="docs-link rounded" href=/documentation/installation/installation_for_linux/>Installation for Linux</a></li><li><a class="docs-link rounded" href=/documentation/installation/installation_for_windows/>Installation for Windows</a></li><li><a class="docs-link rounded" href=/documentation/installation/installation_for_macos/>Installation for macOS</a></li></ul></div></li><li class=mb-1><button class="btn btn-toggle align-items-center rounded collapsed" data-bs-toggle=collapse data-bs-target=#section-tutorials aria-expanded=false>
Tutorials</button><div class=collapse id=section-tutorials><ul class="btn-toggle-nav list-unstyled fw-normal pb-1 small"><li><a class="docs-link rounded" href=/documentation/tutorials/the_gambit_interface/>1 - The GAMBIT Interface</a></li><li><a class="docs-link rounded" href=/documentation/tutorials/in_person_tutorials/>In person tutorials</a></li></ul></div></li><li class=mb-1><button class="btn btn-toggle align-items-center rounded collapsed" data-bs-toggle=collapse data-bs-target=#section-help aria-expanded=false>
Help</button><div class=collapse id=section-help><ul class="btn-toggle-nav list-unstyled fw-normal pb-1 small"><li><a class="docs-link rounded" href=/documentation/help/common_problems_and_questions/>Common Problems and Questions</a></li><li><a class="docs-link rounded" href=/documentation/help/compiler_matrix/>Compiler Matrix</a></li><li><a class="docs-link rounded" href=/documentation/help/known_issues/>Known Issues</a></li><li><a class="docs-link rounded" href=/documentation/help/configuration_examples/>Configuration Examples</a></li><li><a class="docs-link rounded" href=/documentation/help/support/>Support</a></li></ul></div></li><li class=mb-1><button class="btn btn-toggle align-items-center rounded collapsed" data-bs-toggle=collapse data-bs-target=#section-code aria-expanded=false>
Code Reference</button><div class=collapse id=section-code><ul class="btn-toggle-nav list-unstyled fw-normal pb-1 small"><li><a class="docs-link rounded" href=/documentation/code/index_classes/>Classes</a></li><li><a class="docs-link rounded" href=/documentation/code/index_files/>Files</a></li><li><a class="docs-link rounded" href=/documentation/code/index_pages/>Pages</a></li><li><a class="docs-link rounded" href=/documentation/code/index_namespaces/>Namespaces</a></li></ul></div></li></ul></nav></div><nav class="docs-toc d-none d-xl-block col-xl-3" aria-label="Secondary navigation"><div class=d-xl-none><button class="btn btn-outline-primary btn-sm doks-toc-toggle collapsed" type=button data-bs-toggle=collapse data-bs-target=#onThisPage aria-controls=doks-docs-nav aria-expanded=false aria-label="Toggle On this page navigation">
<span>On this page</span>
<span><svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24" class="doks doks-expand" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><title>Expand</title><polyline points="7 13 12 18 17 13"/><polyline points="7 6 12 11 17 6"/></svg><svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24" class="doks doks-collapse" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><title>Collapse</title><polyline points="17 11 12 6 7 11"/><polyline points="17 18 12 13 7 18"/></svg></span></button><div class=collapse id=onThisPage><div class="card card-body mt-3 py-1"><div class=page-links><nav id=TableOfContents><ul><li><a href=#defines>Defines</a></li><li><a href=#detailed-description>Detailed Description</a></li><li><a href=#macros-documentation>Macros Documentation</a><ul><li><a href=#define-add-tag-in-current-namespace>define ADD_TAG_IN_CURRENT_NAMESPACE</a></li><li><a href=#define-add-betag-in-current-namespace>define ADD_BETAG_IN_CURRENT_NAMESPACE</a></li><li><a href=#define-add-model-tag-in-current-namespace>define ADD_MODEL_TAG_IN_CURRENT_NAMESPACE</a></li><li><a href=#define-core-start-module-common>define CORE_START_MODULE_COMMON</a></li><li><a href=#define-core-start-module>define CORE_START_MODULE</a></li><li><a href=#define-core-start-module-common-main>define CORE_START_MODULE_COMMON_MAIN</a></li><li><a href=#define-core-start-capability>define CORE_START_CAPABILITY</a></li><li><a href=#define-core-declare-function>define CORE_DECLARE_FUNCTION</a></li><li><a href=#define-make-functor>define MAKE_FUNCTOR</a></li><li><a href=#define-make-functor-main>define MAKE_FUNCTOR_MAIN</a></li><li><a href=#define-core-needs-manager>define CORE_NEEDS_MANAGER</a></li><li><a href=#define-core-needs-manager-redirect-2>define CORE_NEEDS_MANAGER_REDIRECT_2</a></li><li><a href=#define-core-needs-manager-redirect-1>define CORE_NEEDS_MANAGER_REDIRECT_1</a></li><li><a href=#define-core-needs-manager-redirect>define CORE_NEEDS_MANAGER_REDIRECT</a></li><li><a href=#define-allow-duplicates-in-params-map>define ALLOW_DUPLICATES_IN_PARAMS_MAP</a></li><li><a href=#define-core-needs-manager-1>define CORE_NEEDS_MANAGER_1</a></li><li><a href=#define-core-needs-manager-2>define CORE_NEEDS_MANAGER_2</a></li><li><a href=#define-core-needs-manager-main>define CORE_NEEDS_MANAGER_MAIN</a></li><li><a href=#define-dependency-common>define DEPENDENCY_COMMON</a></li><li><a href=#define-core-dependency>define CORE_DEPENDENCY</a></li><li><a href=#define-core-allowed-model>define CORE_ALLOWED_MODEL</a></li><li><a href=#define-core-allow-model-dependence>define CORE_ALLOW_MODEL_DEPENDENCE</a></li><li><a href=#define-core-allowed-model-arrange-dep>define CORE_ALLOWED_MODEL_ARRANGE_DEP</a></li><li><a href=#define-core-allow-model>define CORE_ALLOW_MODEL</a></li><li><a href=#define-core-allow-model-combination>define CORE_ALLOW_MODEL_COMBINATION</a></li><li><a href=#define-core-model-group>define CORE_MODEL_GROUP</a></li><li><a href=#define-core-be-group>define CORE_BE_GROUP</a></li><li><a href=#define-core-backend-req>define CORE_BACKEND_REQ</a></li><li><a href=#define-core-backend-option>define CORE_BACKEND_OPTION</a></li><li><a href=#define-core-force-same-backend>define CORE_FORCE_SAME_BACKEND</a></li><li><a href=#define-core-start-conditional-dependency>define CORE_START_CONDITIONAL_DEPENDENCY</a></li><li><a href=#define-core-activate-dep-be>define CORE_ACTIVATE_DEP_BE</a></li><li><a href=#define-core-be-model-rule>define CORE_BE_MODEL_RULE</a></li><li><a href=#define-activate-dep-model>define ACTIVATE_DEP_MODEL</a></li><li><a href=#define-core-classload-needed>define CORE_CLASSLOAD_NEEDED</a></li></ul></li><li><a href=#source-code>Source code</a></li></ul></nav></div></div></div></div><div class="page-links d-none d-xl-block"><h3>On this page</h3><nav id=TableOfContents><ul><li><a href=#defines>Defines</a></li><li><a href=#detailed-description>Detailed Description</a></li><li><a href=#macros-documentation>Macros Documentation</a><ul><li><a href=#define-add-tag-in-current-namespace>define ADD_TAG_IN_CURRENT_NAMESPACE</a></li><li><a href=#define-add-betag-in-current-namespace>define ADD_BETAG_IN_CURRENT_NAMESPACE</a></li><li><a href=#define-add-model-tag-in-current-namespace>define ADD_MODEL_TAG_IN_CURRENT_NAMESPACE</a></li><li><a href=#define-core-start-module-common>define CORE_START_MODULE_COMMON</a></li><li><a href=#define-core-start-module>define CORE_START_MODULE</a></li><li><a href=#define-core-start-module-common-main>define CORE_START_MODULE_COMMON_MAIN</a></li><li><a href=#define-core-start-capability>define CORE_START_CAPABILITY</a></li><li><a href=#define-core-declare-function>define CORE_DECLARE_FUNCTION</a></li><li><a href=#define-make-functor>define MAKE_FUNCTOR</a></li><li><a href=#define-make-functor-main>define MAKE_FUNCTOR_MAIN</a></li><li><a href=#define-core-needs-manager>define CORE_NEEDS_MANAGER</a></li><li><a href=#define-core-needs-manager-redirect-2>define CORE_NEEDS_MANAGER_REDIRECT_2</a></li><li><a href=#define-core-needs-manager-redirect-1>define CORE_NEEDS_MANAGER_REDIRECT_1</a></li><li><a href=#define-core-needs-manager-redirect>define CORE_NEEDS_MANAGER_REDIRECT</a></li><li><a href=#define-allow-duplicates-in-params-map>define ALLOW_DUPLICATES_IN_PARAMS_MAP</a></li><li><a href=#define-core-needs-manager-1>define CORE_NEEDS_MANAGER_1</a></li><li><a href=#define-core-needs-manager-2>define CORE_NEEDS_MANAGER_2</a></li><li><a href=#define-core-needs-manager-main>define CORE_NEEDS_MANAGER_MAIN</a></li><li><a href=#define-dependency-common>define DEPENDENCY_COMMON</a></li><li><a href=#define-core-dependency>define CORE_DEPENDENCY</a></li><li><a href=#define-core-allowed-model>define CORE_ALLOWED_MODEL</a></li><li><a href=#define-core-allow-model-dependence>define CORE_ALLOW_MODEL_DEPENDENCE</a></li><li><a href=#define-core-allowed-model-arrange-dep>define CORE_ALLOWED_MODEL_ARRANGE_DEP</a></li><li><a href=#define-core-allow-model>define CORE_ALLOW_MODEL</a></li><li><a href=#define-core-allow-model-combination>define CORE_ALLOW_MODEL_COMBINATION</a></li><li><a href=#define-core-model-group>define CORE_MODEL_GROUP</a></li><li><a href=#define-core-be-group>define CORE_BE_GROUP</a></li><li><a href=#define-core-backend-req>define CORE_BACKEND_REQ</a></li><li><a href=#define-core-backend-option>define CORE_BACKEND_OPTION</a></li><li><a href=#define-core-force-same-backend>define CORE_FORCE_SAME_BACKEND</a></li><li><a href=#define-core-start-conditional-dependency>define CORE_START_CONDITIONAL_DEPENDENCY</a></li><li><a href=#define-core-activate-dep-be>define CORE_ACTIVATE_DEP_BE</a></li><li><a href=#define-core-be-model-rule>define CORE_BE_MODEL_RULE</a></li><li><a href=#define-activate-dep-model>define ACTIVATE_DEP_MODEL</a></li><li><a href=#define-core-classload-needed>define CORE_CLASSLOAD_NEEDED</a></li></ul></li><li><a href=#source-code>Source code</a></li></ul></nav></div></nav><main class="docs-content col-lg-11 col-xl-9 mx-xl-auto"><nav aria-label=breadcrumb><ol class=breadcrumb><li class=breadcrumb-item><a href=/>Home</a></li><li class=breadcrumb-item><a href=/documentation/>Documentation</a></li><li class=breadcrumb-item><a href=/documentation/code/>Code Reference</a></li><li class="breadcrumb-item active" aria-current=page>file Elements/module_macros_incore_defs.hpp</li></ol></nav><p class=lead></p><h1 id=file-elements-module-macros-incore-defs-hpp>file Elements/module_macros_incore_defs.hpp <a href=#file-elements-module-macros-incore-defs-hpp class=anchor aria-hidden=true>#</a></h1><p>[No description available] <a href=#detailed-description>More&mldr;</a></p><h2 id=defines>Defines <a href=#defines class=anchor aria-hidden=true>#</a></h2><table><thead><tr><th></th><th>Name</th></tr></thead><tbody><tr><td></td><td><strong><a href=/documentation/code/files/module__macros__incore__defs_8hpp/#define-add-tag-in-current-namespace>ADD_TAG_IN_CURRENT_NAMESPACE</a></strong>(TAG)</td></tr><tr><td></td><td><strong><a href=/documentation/code/files/module__macros__incore__defs_8hpp/#define-add-betag-in-current-namespace>ADD_BETAG_IN_CURRENT_NAMESPACE</a></strong>(TAG)<br>Add a backend tag to the current namespace.</td></tr><tr><td></td><td><strong><a href=/documentation/code/files/module__macros__incore__defs_8hpp/#define-add-model-tag-in-current-namespace>ADD_MODEL_TAG_IN_CURRENT_NAMESPACE</a></strong>(TAG)<br>Add a backend tag to the current namespace.</td></tr><tr><td></td><td><strong><a href=/documentation/code/files/module__macros__incore__defs_8hpp/#define-core-start-module-common>CORE_START_MODULE_COMMON</a></strong>(MODULE)</td></tr><tr><td></td><td><strong><a href=/documentation/code/files/module__macros__incore__defs_8hpp/#define-core-start-module>CORE_START_MODULE</a></strong></td></tr><tr><td></td><td><strong><a href=/documentation/code/files/module__macros__incore__defs_8hpp/#define-core-start-module-common-main>CORE_START_MODULE_COMMON_MAIN</a></strong>(MODULE)<br>Central module definition macro, used by modules and models.</td></tr><tr><td></td><td><strong><a href=/documentation/code/files/module__macros__incore__defs_8hpp/#define-core-start-capability>CORE_START_CAPABILITY</a></strong>(MODULE, CAPABILITY, IS_MODEL)</td></tr><tr><td></td><td><strong><a href=/documentation/code/files/module__macros__incore__defs_8hpp/#define-core-declare-function>CORE_DECLARE_FUNCTION</a></strong>(MODULE, CAPABILITY, FUNCTION, TYPE, FLAG, IS_MODEL)</td></tr><tr><td></td><td><strong><a href=/documentation/code/files/module__macros__incore__defs_8hpp/#define-make-functor>MAKE_FUNCTOR</a></strong>(FUNCTION, TYPE, CAPABILITY, ORIGIN, CAN_MANAGE)</td></tr><tr><td></td><td><strong><a href=/documentation/code/files/module__macros__incore__defs_8hpp/#define-make-functor-main>MAKE_FUNCTOR_MAIN</a></strong>(FUNCTION, TYPE, CAPABILITY, ORIGIN, CAN_MANAGE)<br>Main parts of the functor creation.</td></tr><tr><td></td><td><strong><a href=/documentation/code/files/module__macros__incore__defs_8hpp/#define-core-needs-manager>CORE_NEEDS_MANAGER</a></strong>(&mldr;)</td></tr><tr><td></td><td><strong><a href=/documentation/code/files/module__macros__incore__defs_8hpp/#define-core-needs-manager-redirect-2>CORE_NEEDS_MANAGER_REDIRECT_2</a></strong>(_1, _2)</td></tr><tr><td></td><td><strong><a href=/documentation/code/files/module__macros__incore__defs_8hpp/#define-core-needs-manager-redirect-1>CORE_NEEDS_MANAGER_REDIRECT_1</a></strong>(_1)</td></tr><tr><td></td><td><strong><a href=/documentation/code/files/module__macros__incore__defs_8hpp/#define-core-needs-manager-redirect>CORE_NEEDS_MANAGER_REDIRECT</a></strong>(&mldr;)</td></tr><tr><td></td><td><strong><a href=/documentation/code/files/module__macros__incore__defs_8hpp/#define-allow-duplicates-in-params-map>ALLOW_DUPLICATES_IN_PARAMS_MAP</a></strong><br>Change this to 1 if you really don&rsquo;t care about parameter clashes.</td></tr><tr><td></td><td><strong><a href=/documentation/code/files/module__macros__incore__defs_8hpp/#define-core-needs-manager-1>CORE_NEEDS_MANAGER_1</a></strong>(LOOPMAN)<br>Redirection of <a href=/documentation/code/files/module__macros__incore_8hpp/#define-needs-manager>NEEDS_MANAGER(LOOPMAN)</a> when invoked from within the Core.</td></tr><tr><td></td><td><strong><a href=/documentation/code/files/module__macros__incore__defs_8hpp/#define-core-needs-manager-2>CORE_NEEDS_MANAGER_2</a></strong>(LOOPMAN, TYPE)<br>Redirection of <a href=/documentation/code/files/module__macros__incore_8hpp/#define-needs-manager>NEEDS_MANAGER(LOOPMAN,TYPE)</a> when invoked from within the Core.</td></tr><tr><td></td><td><strong><a href=/documentation/code/files/module__macros__incore__defs_8hpp/#define-core-needs-manager-main>CORE_NEEDS_MANAGER_MAIN</a></strong>(LOOPMAN, TYPE)<br>Main redirection of <a href=/documentation/code/files/module__macros__incore_8hpp/#define-needs-manager>NEEDS_MANAGER(LOOPMAN,TYPE)</a> when invoked from within the Core.</td></tr><tr><td></td><td><strong><a href=/documentation/code/files/module__macros__incore__defs_8hpp/#define-dependency-common>DEPENDENCY_COMMON</a></strong>(DEP, TYPE, MODULE, FUNCTION)</td></tr><tr><td></td><td><strong><a href=/documentation/code/files/module__macros__incore__defs_8hpp/#define-core-dependency>CORE_DEPENDENCY</a></strong>(DEP, TYPE, MODULE, FUNCTION, IS_MODEL_DEP)<br>Redirection of <a href=/documentation/code/files/module__macros__incore_8hpp/#define-dependency>DEPENDENCY(DEP, TYPE)</a> when invoked from within the core.</td></tr><tr><td></td><td><strong><a href=/documentation/code/files/module__macros__incore__defs_8hpp/#define-core-allowed-model>CORE_ALLOWED_MODEL</a></strong>(MODULE, FUNCTION, MODEL, IS_MODEL)<br>Redirection of ALLOW_MODEL when invoked from within the core.</td></tr><tr><td></td><td><strong><a href=/documentation/code/files/module__macros__incore__defs_8hpp/#define-core-allow-model-dependence>CORE_ALLOW_MODEL_DEPENDENCE</a></strong>(MODULE, FUNCTION, MODEL, IS_MODEL)<br>Redirection of ALLOW_MODEL_DEPENDENCE when invoked from within the core.</td></tr><tr><td></td><td><strong><a href=/documentation/code/files/module__macros__incore__defs_8hpp/#define-core-allowed-model-arrange-dep>CORE_ALLOWED_MODEL_ARRANGE_DEP</a></strong>(MODULE, FUNCTION, MODEL)<br>Set up the dependency on the parameters object of a given model.</td></tr><tr><td></td><td><strong><a href=/documentation/code/files/module__macros__incore__defs_8hpp/#define-core-allow-model>CORE_ALLOW_MODEL</a></strong>(MODULE, FUNCTION, MODEL)<br>Tell the functor that a single model is enough for it to be allowed to run.</td></tr><tr><td></td><td><strong><a href=/documentation/code/files/module__macros__incore__defs_8hpp/#define-core-allow-model-combination>CORE_ALLOW_MODEL_COMBINATION</a></strong>(MODULE, FUNCTION, IS_MODEL, COMBO)<br>Redirection of ALLOW_MODEL_COMBINATION when invoked from the Core.</td></tr><tr><td></td><td><strong><a href=/documentation/code/files/module__macros__incore__defs_8hpp/#define-core-model-group>CORE_MODEL_GROUP</a></strong>(MODULE, FUNCTION, GROUPNAME, GROUP, IS_MODEL)<br>Redirection of MODEL_GROUP when invoked from within the Core.</td></tr><tr><td></td><td><strong><a href=/documentation/code/files/module__macros__incore__defs_8hpp/#define-core-be-group>CORE_BE_GROUP</a></strong>(GROUP, IS_MODEL)<br>Redirection of <a href=/documentation/code/files/module__macros__common_8hpp/#define-backend-group>BACKEND_GROUP(GROUP)</a> when invoked from within the Core.</td></tr><tr><td></td><td><strong><a href=/documentation/code/files/module__macros__incore__defs_8hpp/#define-core-backend-req>CORE_BACKEND_REQ</a></strong>(MODULE, CAPABILITY, FUNCTION, GROUP, REQUIREMENT, TAGS, TYPE, ARGS, IS_VARIABLE, IS_MODEL)</td></tr><tr><td></td><td><strong><a href=/documentation/code/files/module__macros__incore__defs_8hpp/#define-core-backend-option>CORE_BACKEND_OPTION</a></strong>(MODULE, CAPABILITY, FUNCTION, BE_AND_VER, TAGS, IS_MODEL)</td></tr><tr><td></td><td><strong><a href=/documentation/code/files/module__macros__incore__defs_8hpp/#define-core-force-same-backend>CORE_FORCE_SAME_BACKEND</a></strong>(IS_MODEL, &mldr;)<br>Redirection of <a href=/documentation/code/files/module__macros__incore_8hpp/#define-force-same-backend>FORCE_SAME_BACKEND(TAGS)</a> when invoked from within the core.</td></tr><tr><td></td><td><strong><a href=/documentation/code/files/module__macros__incore__defs_8hpp/#define-core-start-conditional-dependency>CORE_START_CONDITIONAL_DEPENDENCY</a></strong>(MODULE, CAPABILITY, FUNCTION, CONDITIONAL_DEPENDENCY, TYPE, IS_MODEL)</td></tr><tr><td></td><td><strong><a href=/documentation/code/files/module__macros__incore__defs_8hpp/#define-core-activate-dep-be>CORE_ACTIVATE_DEP_BE</a></strong>(BACKEND_REQ, BACKEND, VERSTRING, IS_MODEL)</td></tr><tr><td></td><td><strong><a href=/documentation/code/files/module__macros__incore__defs_8hpp/#define-core-be-model-rule>CORE_BE_MODEL_RULE</a></strong>(MODELS, TAGS, IS_MODEL)<br>Redirection of ACTIVATE_BACKEND_REQ_FOR_MODELS when invoked from the Core.</td></tr><tr><td></td><td><strong><a href=/documentation/code/files/module__macros__incore__defs_8hpp/#define-activate-dep-model>ACTIVATE_DEP_MODEL</a></strong>(MODULE, CAPABILITY, FUNCTION, CONDITIONAL_DEPENDENCY, IS_MODEL, MODELSTRING)</td></tr><tr><td></td><td><strong><a href=/documentation/code/files/module__macros__incore__defs_8hpp/#define-core-classload-needed>CORE_CLASSLOAD_NEEDED</a></strong>(BACKEND, VERSTRING, IS_MODEL)<br>Redirection of NEEDS_CLASSES_FROM when invoked from within the Core.</td></tr></tbody></table><h2 id=detailed-description>Detailed Description <a href=#detailed-description class=anchor aria-hidden=true>#</a></h2><p><strong>Author</strong>:</p><ul><li>Pat Scott (<a href=mailto:patscott@physics.mcgill.ca>patscott@physics.mcgill.ca</a>)</li><li>Abram Krislock (<a href=mailto:abram.krislock@fysik.su.se>abram.krislock@fysik.su.se</a>)</li><li>Christoph Weniger (<a href=mailto:c.weniger@uva.nl>c.weniger@uva.nl</a>)</li><li>Anders Kvellestad (<a href=mailto:anders.kvellestad@fys.uio.no>anders.kvellestad@fys.uio.no</a>)</li><li>Ben Farmer (<a href=mailto:b.farmer@imperial.ac.uk>b.farmer@imperial.ac.uk</a>)</li><li>Tomas Gonzalo (<a href=mailto:gonzalo@physik.rwth-aachen.de>gonzalo@physik.rwth-aachen.de</a>)</li></ul><p><strong>Date</strong>:</p><ul><li>2012 Nov</li><li>2013,14 Foreverrrrr</li><li>2013 Jan, Feb</li><li>2013 Jan, Feb, 2014 Jan</li><li>2013 Nov</li><li>2019 Jul</li><li>2021 Sep</li></ul><p>Redirection macros for generic observable and likelihood function macro definitions, for inclusion from the Core.</p><p>Note here that [FUNCTION ] is the actual module function name, whereas both [CAPABILITY ] and all <em>DEPs</em> refer to the abstract physical quantities that functions may provide or require. Thus, the provides() methods expect a quantity input (i.e. corresponding to a [CAPABILITY]), the requires() methods expect a quantity input for the dependency but a function name input (i.e. corresponding to a [FUNCTION]) for the actual dependent function, and all other things operate on the basis of the function name, not the quantity that is calculated.</p><hr><p>Authors (add name and date if you modify):</p><hr><h2 id=macros-documentation>Macros Documentation <a href=#macros-documentation class=anchor aria-hidden=true>#</a></h2><h3 id=define-add-tag-in-current-namespace>define ADD_TAG_IN_CURRENT_NAMESPACE <a href=#define-add-tag-in-current-namespace class=anchor aria-hidden=true>#</a></h3><pre><code>#define ADD_TAG_IN_CURRENT_NAMESPACE(
    TAG
)
namespace Tags { struct TAG; }
</code></pre><h3 id=define-add-betag-in-current-namespace>define ADD_BETAG_IN_CURRENT_NAMESPACE <a href=#define-add-betag-in-current-namespace class=anchor aria-hidden=true>#</a></h3><pre><code>#define ADD_BETAG_IN_CURRENT_NAMESPACE(
    TAG
)
namespace BETags { struct TAG; }
</code></pre><p>Add a backend tag to the current namespace.</p><h3 id=define-add-model-tag-in-current-namespace>define ADD_MODEL_TAG_IN_CURRENT_NAMESPACE <a href=#define-add-model-tag-in-current-namespace class=anchor aria-hidden=true>#</a></h3><pre><code>#define ADD_MODEL_TAG_IN_CURRENT_NAMESPACE(
    TAG
)
namespace ModelTags { struct TAG; }
</code></pre><p>Add a backend tag to the current namespace.</p><h3 id=define-core-start-module-common>define CORE_START_MODULE_COMMON <a href=#define-core-start-module-common class=anchor aria-hidden=true>#</a></h3><pre><code>#define CORE_START_MODULE_COMMON(
    MODULE
)
CORE_START_MODULE_COMMON_MAIN(MODULE)                                \
          const int module_registered =                                        \
            register_module(STRINGIFY(MODULE), SAFE_STRINGIFY(REFERENCE));
</code></pre><h3 id=define-core-start-module>define CORE_START_MODULE <a href=#define-core-start-module class=anchor aria-hidden=true>#</a></h3><pre><code>#define CORE_START_MODULE 
</code></pre><p>Redirection of <a href=/documentation/code/files/module__macros__incore_8hpp/#define-start-module>START_MODULE</a> when invoked from within the core.</p><h3 id=define-core-start-module-common-main>define CORE_START_MODULE_COMMON_MAIN <a href=#define-core-start-module-common-main class=anchor aria-hidden=true>#</a></h3><pre><code>#define CORE_START_MODULE_COMMON_MAIN(
    MODULE
)

</code></pre><p>Central module definition macro, used by modules and models.</p><h3 id=define-core-start-capability>define CORE_START_CAPABILITY <a href=#define-core-start-capability class=anchor aria-hidden=true>#</a></h3><pre><code>#define CORE_START_CAPABILITY(
    MODULE,
    CAPABILITY,
    IS_MODEL
)
                                                                               \
  IF_TOKEN_UNDEFINED(MODULE,FAIL(&quot;You must define MODULE before calling &quot;      \
   &quot;START_CAPABILITY.&quot;))                                                       \
  IF_TOKEN_UNDEFINED(CAPABILITY,FAIL(&quot;You must define CAPABILITY before &quot;      \
   &quot;calling START_CAPABILITY. Please check the rollcall header for &quot;           \
   STRINGIFY(MODULE) &quot;.&quot;))                                                     \
                                                                               \
  namespace Gambit                                                             \
  {                                                                            \
    /* Add CAPABILITY to the global set of things that can be calculated*/     \
    ADD_TAG_IN_CURRENT_NAMESPACE(CAPABILITY)                                   \
                                                                               \
  }                                                                            \
</code></pre><p>Redirection of <a href=/documentation/code/files/module__macros__incore_8hpp/#define-start-capability>START_CAPABILITY</a> when invoked from within the core.</p><h3 id=define-core-declare-function>define CORE_DECLARE_FUNCTION <a href=#define-core-declare-function class=anchor aria-hidden=true>#</a></h3><pre><code>#define CORE_DECLARE_FUNCTION(
    MODULE,
    CAPABILITY,
    FUNCTION,
    TYPE,
    FLAG,
    IS_MODEL
)

</code></pre><p>Redirection of [START_FUNCTION] when invoked from within the core.</p><h3 id=define-make-functor>define MAKE_FUNCTOR <a href=#define-make-functor class=anchor aria-hidden=true>#</a></h3><pre><code>#define MAKE_FUNCTOR(
    FUNCTION,
    TYPE,
    CAPABILITY,
    ORIGIN,
    CAN_MANAGE
)
MAKE_FUNCTOR_MAIN(FUNCTION,TYPE,CAPABILITY,ORIGIN,CAN_MANAGE)        \
          const int CAT(FUNCTION,_registered2) =                               \
           register_module_functor_core(Functown::FUNCTION);
</code></pre><h3 id=define-make-functor-main>define MAKE_FUNCTOR_MAIN <a href=#define-make-functor-main class=anchor aria-hidden=true>#</a></h3><pre><code>#define MAKE_FUNCTOR_MAIN(
    FUNCTION,
    TYPE,
    CAPABILITY,
    ORIGIN,
    CAN_MANAGE
)

</code></pre><p>Main parts of the functor creation.</p><h3 id=define-core-needs-manager>define CORE_NEEDS_MANAGER <a href=#define-core-needs-manager class=anchor aria-hidden=true>#</a></h3><pre><code>#define CORE_NEEDS_MANAGER(
    ...
)
          CORE_NEEDS_MANAGER_REDIRECT(__VA_ARGS__)                             \
          namespace Gambit { namespace MODULE { const int CAT(FUNCTION,        \
           _registered3) = register_management_req(Functown::FUNCTION); } }
</code></pre><h3 id=define-core-needs-manager-redirect-2>define CORE_NEEDS_MANAGER_REDIRECT_2 <a href=#define-core-needs-manager-redirect-2 class=anchor aria-hidden=true>#</a></h3><pre><code>#define CORE_NEEDS_MANAGER_REDIRECT_2(
    _1,
    _2
)
CORE_NEEDS_MANAGER_2(_1,  _2)
</code></pre><p>Variadic redirection for NEEDS_MANAGER when invoked within the Core</p><h3 id=define-core-needs-manager-redirect-1>define CORE_NEEDS_MANAGER_REDIRECT_1 <a href=#define-core-needs-manager-redirect-1 class=anchor aria-hidden=true>#</a></h3><pre><code>#define CORE_NEEDS_MANAGER_REDIRECT_1(
    _1
)
CORE_NEEDS_MANAGER_1(_1)
</code></pre><h3 id=define-core-needs-manager-redirect>define CORE_NEEDS_MANAGER_REDIRECT <a href=#define-core-needs-manager-redirect class=anchor aria-hidden=true>#</a></h3><pre><code>#define CORE_NEEDS_MANAGER_REDIRECT(
    ...
)
VARARG(CORE_NEEDS_MANAGER_REDIRECT, __VA_ARGS__)
</code></pre><h3 id=define-allow-duplicates-in-params-map>define ALLOW_DUPLICATES_IN_PARAMS_MAP <a href=#define-allow-duplicates-in-params-map class=anchor aria-hidden=true>#</a></h3><pre><code>#define ALLOW_DUPLICATES_IN_PARAMS_MAP 0
</code></pre><p>Change this to 1 if you really don&rsquo;t care about parameter clashes.</p><h3 id=define-core-needs-manager-1>define CORE_NEEDS_MANAGER_1 <a href=#define-core-needs-manager-1 class=anchor aria-hidden=true>#</a></h3><pre><code>#define CORE_NEEDS_MANAGER_1(
    LOOPMAN
)
CORE_NEEDS_MANAGER_MAIN(LOOPMAN, any)
</code></pre><p>Redirection of <a href=/documentation/code/files/module__macros__incore_8hpp/#define-needs-manager>NEEDS_MANAGER(LOOPMAN)</a> when invoked from within the Core.</p><h3 id=define-core-needs-manager-2>define CORE_NEEDS_MANAGER_2 <a href=#define-core-needs-manager-2 class=anchor aria-hidden=true>#</a></h3><pre><code>#define CORE_NEEDS_MANAGER_2(
    LOOPMAN,
    TYPE
)
CORE_NEEDS_MANAGER_MAIN(LOOPMAN,TYPE)                                        \
  DEPENDENCY(LOOPMAN,TYPE)
</code></pre><p>Redirection of <a href=/documentation/code/files/module__macros__incore_8hpp/#define-needs-manager>NEEDS_MANAGER(LOOPMAN,TYPE)</a> when invoked from within the Core.</p><h3 id=define-core-needs-manager-main>define CORE_NEEDS_MANAGER_MAIN <a href=#define-core-needs-manager-main class=anchor aria-hidden=true>#</a></h3><pre><code>#define CORE_NEEDS_MANAGER_MAIN(
    LOOPMAN,
    TYPE
)

</code></pre><p>Main redirection of <a href=/documentation/code/files/module__macros__incore_8hpp/#define-needs-manager>NEEDS_MANAGER(LOOPMAN,TYPE)</a> when invoked from within the Core.</p><h3 id=define-dependency-common>define DEPENDENCY_COMMON <a href=#define-dependency-common class=anchor aria-hidden=true>#</a></h3><pre><code>#define DEPENDENCY_COMMON(
    DEP,
    TYPE,
    MODULE,
    FUNCTION
)

</code></pre><p>Common components of <a href=/documentation/code/files/module__macros__incore__defs_8hpp/#define-core-dependency>CORE_DEPENDENCY(DEP, TYPE, MODULE, FUNCTION)</a> and <a href=/documentation/code/files/module__macros__incore__defs_8hpp/#define-core-start-conditional-dependency>CORE_START_CONDITIONAL_DEPENDENCY(TYPE)</a>.</p><h3 id=define-core-dependency>define CORE_DEPENDENCY <a href=#define-core-dependency class=anchor aria-hidden=true>#</a></h3><pre><code>#define CORE_DEPENDENCY(
    DEP,
    TYPE,
    MODULE,
    FUNCTION,
    IS_MODEL_DEP
)
                                                                               \
  namespace Gambit                                                             \
  {                                                                            \
                                                                               \
    /* Add DEP to global set of tags of recognised module capabilities/deps */ \
    ADD_TAG_IN_CURRENT_NAMESPACE(DEP)                                          \
                                                                               \
    /* Put everything inside the Models namespace if this is a model dep */    \
    BOOST_PP_IIF(IS_MODEL_DEP, namespace Models {, )                           \
                                                                               \
    namespace MODULE                                                           \
    {                                                                          \
      DEPENDENCY_COMMON(DEP, TYPE, MODULE, FUNCTION)                           \
                                                                               \
      const int CAT_3(DEP,_for_,FUNCTION) = register_dependency(               \
       Functown::FUNCTION, STRINGIFY(DEP), STRINGIFY(TYPE),                    \
       &amp;resolve_dependency&lt;Gambit::Tags::DEP, Tags::FUNCTION&gt;);                \
    }                                                                          \
                                                                               \
    /* Close the Models namespace if this is a model dep */                    \
    BOOST_PP_IIF(IS_MODEL_DEP, }, )                                            \
                                                                               \
  }                                                                            \
</code></pre><p>Redirection of <a href=/documentation/code/files/module__macros__incore_8hpp/#define-dependency>DEPENDENCY(DEP, TYPE)</a> when invoked from within the core.</p><h3 id=define-core-allowed-model>define CORE_ALLOWED_MODEL <a href=#define-core-allowed-model class=anchor aria-hidden=true>#</a></h3><pre><code>#define CORE_ALLOWED_MODEL(
    MODULE,
    FUNCTION,
    MODEL,
    IS_MODEL
)
                                                                               \
  IF_TOKEN_UNDEFINED(MODULE,FAIL(&quot;You must define MODULE before calling &quot;      \
   &quot;ALLOW_MODEL(S).&quot;))                                                         \
  IF_TOKEN_UNDEFINED(FUNCTION,FAIL(&quot;You must define FUNCTION before calling &quot;  \
   &quot;ALLOW_MODEL(S). Please check the rollcall header for &quot;                     \
   STRINGIFY(MODULE) &quot;.&quot;))                                                     \
                                                                               \
  namespace Gambit                                                             \
  {                                                                            \
    /* Put everything inside the Models namespace if this is a model-module */ \
    BOOST_PP_IIF(IS_MODEL, namespace Models {, )                               \
                                                                               \
    /* Add MODEL to global set of tags of recognised models */                 \
    ADD_MODEL_TAG_IN_CURRENT_NAMESPACE(MODEL)                                  \
    CORE_ALLOWED_MODEL_ARRANGE_DEP(MODULE,FUNCTION,MODEL)                      \
    CORE_ALLOW_MODEL(MODULE,FUNCTION,MODEL)                                    \
                                                                               \
    /* End Models namespace */                                                 \
    BOOST_PP_IIF(IS_MODEL, }, )                                                \
 }                                                                             \
</code></pre><p>Redirection of ALLOW_MODEL when invoked from within the core.</p><h3 id=define-core-allow-model-dependence>define CORE_ALLOW_MODEL_DEPENDENCE <a href=#define-core-allow-model-dependence class=anchor aria-hidden=true>#</a></h3><pre><code>#define CORE_ALLOW_MODEL_DEPENDENCE(
    MODULE,
    FUNCTION,
    MODEL,
    IS_MODEL
)
                                                                               \
  IF_TOKEN_UNDEFINED(MODULE,FAIL(&quot;You must define MODULE before calling &quot;      \
   &quot;ALLOW_MODEL_DEPENDENCE.&quot;))                                                 \
  IF_TOKEN_UNDEFINED(FUNCTION,FAIL(&quot;You must define FUNCTION before calling &quot;  \
   &quot;ALLOW_MODEL_DEPENDENCE. Please check the rollcall header for &quot;             \
   STRINGIFY(MODULE) &quot;.&quot;))                                                     \
                                                                               \
  namespace Gambit                                                             \
  {                                                                            \
    /* Put everything inside the Models namespace if this is a model-module */ \
    BOOST_PP_IIF(IS_MODEL, namespace Models {, )                               \
                                                                               \
    /* Add MODEL to global set of tags of recognised models */                 \
    ADD_MODEL_TAG_IN_CURRENT_NAMESPACE(MODEL)                                  \
    CORE_ALLOWED_MODEL_ARRANGE_DEP(MODULE,FUNCTION,MODEL)                      \
                                                                               \
    /* End Models namespace */                                                 \
    BOOST_PP_IIF(IS_MODEL, }, )                                                \
 }                                                                             \
</code></pre><p>Redirection of ALLOW_MODEL_DEPENDENCE when invoked from within the core.</p><h3 id=define-core-allowed-model-arrange-dep>define CORE_ALLOWED_MODEL_ARRANGE_DEP <a href=#define-core-allowed-model-arrange-dep class=anchor aria-hidden=true>#</a></h3><pre><code>#define CORE_ALLOWED_MODEL_ARRANGE_DEP(
    MODULE,
    FUNCTION,
    MODEL
)

</code></pre><p>Set up the dependency on the parameters object of a given model.</p><h3 id=define-core-allow-model>define CORE_ALLOW_MODEL <a href=#define-core-allow-model class=anchor aria-hidden=true>#</a></h3><pre><code>#define CORE_ALLOW_MODEL(
    MODULE,
    FUNCTION,
    MODEL
)
                                                                               \
    namespace MODULE                                                           \
    {                                                                          \
      /* Register the compatibility of the model with the functor */           \
      const int CAT_3(MODEL,_allowed_for_,FUNCTION) = register_model_singly(   \
        Functown::FUNCTION, STRINGIFY(MODEL));                                 \
    }                                                                          \
</code></pre><p>Tell the functor that a single model is enough for it to be allowed to run.</p><h3 id=define-core-allow-model-combination>define CORE_ALLOW_MODEL_COMBINATION <a href=#define-core-allow-model-combination class=anchor aria-hidden=true>#</a></h3><pre><code>#define CORE_ALLOW_MODEL_COMBINATION(
    MODULE,
    FUNCTION,
    IS_MODEL,
    COMBO
)
  IF_TOKEN_UNDEFINED(MODULE,FAIL(&quot;You must define MODULE before calling &quot;      \
   &quot;ALLOW_MODEL_COMBINATION.&quot;))                                                \
  IF_TOKEN_UNDEFINED(FUNCTION,FAIL(&quot;You must define FUNCTION before calling &quot;  \
   &quot;ALLOW_MODEL_COMBINATION. Please check the rollcall header for &quot;            \
   STRINGIFY(MODULE) &quot;.&quot;))                                                     \
                                                                               \
  namespace Gambit                                                             \
  {                                                                            \
    /* Put everything inside the Models namespace if this is a model-module */ \
    BOOST_PP_IIF(IS_MODEL, namespace Models {, )                               \
                                                                               \
    namespace MODULE                                                           \
    {                                                                          \
      /* Register the combination as allowed with the functor */               \
      const int CAT_3(FUNCTION,_,BOOST_PP_SEQ_CAT(BOOST_PP_TUPLE_TO_SEQ((      \
       STRIP_PARENS(COMBO))))) = register_model_combination(Functown::FUNCTION,\
       STRINGIFY(COMBO));                                                      \
    }                                                                          \
                                                                               \
    /* End Models namespace */                                                 \
    BOOST_PP_IIF(IS_MODEL, }, )                                                \
 }                                                                             \
</code></pre><p>Redirection of ALLOW_MODEL_COMBINATION when invoked from the Core.</p><h3 id=define-core-model-group>define CORE_MODEL_GROUP <a href=#define-core-model-group class=anchor aria-hidden=true>#</a></h3><pre><code>#define CORE_MODEL_GROUP(
    MODULE,
    FUNCTION,
    GROUPNAME,
    GROUP,
    IS_MODEL
)
  IF_TOKEN_UNDEFINED(MODULE,FAIL(&quot;You must define MODULE before calling &quot;      \
   &quot;MODEL_GROUP.&quot;))                                                            \
  IF_TOKEN_UNDEFINED(FUNCTION,FAIL(&quot;You must define FUNCTION before calling &quot;  \
   &quot;MODEL_GROUP. Please check the rollcall header for &quot;                        \
   STRINGIFY(MODULE) &quot;.&quot;))                                                     \
                                                                               \
  /* Register the group with the functor */                                    \
  namespace Gambit                                                             \
  {                                                                            \
    /* Put everything inside the Models namespace if this is a model-module */ \
    BOOST_PP_IIF(IS_MODEL, namespace Models {, )                               \
                                                                               \
    namespace MODULE                                                           \
    {                                                                          \
      /* Register the model group with the functor */                          \
      const int CAT_3(GROUPNAME,_model_group_in_,FUNCTION) =                   \
       register_model_group(Functown::FUNCTION, STRINGIFY(GROUPNAME),          \
       STRINGIFY(GROUP));                                                      \
    }                                                                          \
                                                                               \
    /* End Models namespace */                                                 \
    BOOST_PP_IIF(IS_MODEL, }, )                                                \
 }                                                                             \
</code></pre><p>Redirection of MODEL_GROUP when invoked from within the Core.</p><h3 id=define-core-be-group>define CORE_BE_GROUP <a href=#define-core-be-group class=anchor aria-hidden=true>#</a></h3><pre><code>#define CORE_BE_GROUP(
    GROUP,
    IS_MODEL
)

</code></pre><p>Redirection of <a href=/documentation/code/files/module__macros__common_8hpp/#define-backend-group>BACKEND_GROUP(GROUP)</a> when invoked from within the Core.</p><h3 id=define-core-backend-req>define CORE_BACKEND_REQ <a href=#define-core-backend-req class=anchor aria-hidden=true>#</a></h3><pre><code>#define CORE_BACKEND_REQ(
    MODULE,
    CAPABILITY,
    FUNCTION,
    GROUP,
    REQUIREMENT,
    TAGS,
    TYPE,
    ARGS,
    IS_VARIABLE,
    IS_MODEL
)

</code></pre><p>Redirection of BACKEND_REQ(GROUP, REQUIREMENT, (TAGS), TYPE, [(ARGS)]) for declaring backend requirements when invoked from within the Core.</p><h3 id=define-core-backend-option>define CORE_BACKEND_OPTION <a href=#define-core-backend-option class=anchor aria-hidden=true>#</a></h3><pre><code>#define CORE_BACKEND_OPTION(
    MODULE,
    CAPABILITY,
    FUNCTION,
    BE_AND_VER,
    TAGS,
    IS_MODEL
)
                                                                               \
  IF_TOKEN_UNDEFINED(MODULE,FAIL(&quot;You must define MODULE before calling &quot;      \
   &quot;BACKEND_OPTION.&quot;))                                                         \
  IF_TOKEN_UNDEFINED(CAPABILITY,FAIL(&quot;You must define CAPABILITY before &quot;      \
   &quot;calling BACKEND_OPTION. Please check the rollcall header &quot;                 \
   &quot;for &quot; STRINGIFY(MODULE) &quot;.&quot;))                                              \
  IF_TOKEN_UNDEFINED(FUNCTION,FAIL(&quot;You must define FUNCTION before calling &quot;  \
   &quot;BACKEND_OPTION. Please check the rollcall header for &quot;                     \
   STRINGIFY(MODULE) &quot;.&quot;))                                                     \
                                                                               \
  namespace Gambit                                                             \
  {                                                                            \
    /* Put everything inside the Models namespace if this is a model-module */ \
    BOOST_PP_IIF(IS_MODEL, namespace Models {, )                               \
                                                                               \
    namespace MODULE                                                           \
    {                                                                          \
      /* Apply the rule */                                                     \
      const int CAT_5(FUNCTION,_,BOOST_PP_TUPLE_ELEM(0,(STRIP_PARENS           \
       (BE_AND_VER))),_,BOOST_PP_SEQ_CAT(BOOST_PP_TUPLE_TO_SEQ((               \
       STRIP_PARENS(TAGS))))) = apply_backend_option_rule(Functown::FUNCTION,  \
       STRINGIFY(BE_AND_VER), STRINGIFY(TAGS));                                \
    }                                                                          \
                                                                               \
    /* End Models namespace */                                                 \
    BOOST_PP_IIF(IS_MODEL, }, )                                                \
                                                                               \
  }                                                                            \
</code></pre><p>Redirection of <a href=/documentation/code/files/module__macros__incore_8hpp/#define-backend-option>BACKEND_OPTION(BACKEND_AND_VERSIONS, TAGS)</a> when invoked from within the core.</p><h3 id=define-core-force-same-backend>define CORE_FORCE_SAME_BACKEND <a href=#define-core-force-same-backend class=anchor aria-hidden=true>#</a></h3><pre><code>#define CORE_FORCE_SAME_BACKEND(
    IS_MODEL,
    ...
)
                                                                               \
  IF_TOKEN_UNDEFINED(MODULE,FAIL(&quot;You must define MODULE before calling &quot;      \
   &quot;FORCE_SAME_BACKEND.&quot;))                                                     \
  IF_TOKEN_UNDEFINED(CAPABILITY,FAIL(&quot;You must define CAPABILITY before &quot;      \
   &quot;calling FORCE_SAME_BACKEND. Please check the rollcall header &quot;             \
   &quot;for &quot; STRINGIFY(MODULE) &quot;.&quot;))                                              \
  IF_TOKEN_UNDEFINED(FUNCTION,FAIL(&quot;You must define FUNCTION before calling &quot;  \
   &quot;FORCE_SAME_BACKEND. Please check the rollcall header for &quot;                 \
   STRINGIFY(MODULE) &quot;.&quot;))                                                     \
                                                                               \
  namespace Gambit                                                             \
  {                                                                            \
    /* Put everything inside the Models namespace if this is a model-module */ \
    BOOST_PP_IIF(IS_MODEL, namespace Models {, )                               \
                                                                               \
    namespace MODULE                                                           \
    {                                                                          \
      const int CAT_3(FUNCTION,_,BOOST_PP_SEQ_CAT(BOOST_PP_TUPLE_TO_SEQ((      \
       STRIP_PARENS(__VA_ARGS__))))) =                                         \
       apply_backend_matching_rule(Functown::FUNCTION, #__VA_ARGS__);          \
    }                                                                          \
                                                                               \
    /* End Models namespace */                                                 \
    BOOST_PP_IIF(IS_MODEL, }, )                                                \
                                                                               \
  }                                                                            \
</code></pre><p>Redirection of <a href=/documentation/code/files/module__macros__incore_8hpp/#define-force-same-backend>FORCE_SAME_BACKEND(TAGS)</a> when invoked from within the core.</p><h3 id=define-core-start-conditional-dependency>define CORE_START_CONDITIONAL_DEPENDENCY <a href=#define-core-start-conditional-dependency class=anchor aria-hidden=true>#</a></h3><pre><code>#define CORE_START_CONDITIONAL_DEPENDENCY(
    MODULE,
    CAPABILITY,
    FUNCTION,
    CONDITIONAL_DEPENDENCY,
    TYPE,
    IS_MODEL
)

</code></pre><p>Redirection of <a href=/documentation/code/files/module__macros__incore_8hpp/#define-start-conditional-dependency>START_CONDITIONAL_DEPENDENCY(TYPE)</a> when invoked from within the core.</p><h3 id=define-core-activate-dep-be>define CORE_ACTIVATE_DEP_BE <a href=#define-core-activate-dep-be class=anchor aria-hidden=true>#</a></h3><pre><code>#define CORE_ACTIVATE_DEP_BE(
    BACKEND_REQ,
    BACKEND,
    VERSTRING,
    IS_MODEL
)

</code></pre><p>Redirection of <a href=/documentation/code/files/module__macros__incore_8hpp/#define-activate-dep-be>ACTIVATE_DEP_BE(BACKEND_REQ, BACKEND, VERSTRING)</a> when invoked from within the core.</p><h3 id=define-core-be-model-rule>define CORE_BE_MODEL_RULE <a href=#define-core-be-model-rule class=anchor aria-hidden=true>#</a></h3><pre><code>#define CORE_BE_MODEL_RULE(
    MODELS,
    TAGS,
    IS_MODEL
)
                                                                               \
  IF_TOKEN_UNDEFINED(MODULE,FAIL(&quot;You must define MODULE before calling &quot;      \
   &quot;ACTIVATE_BACKEND_REQ_FOR_MODEL(S).&quot;))                                      \
  IF_TOKEN_UNDEFINED(CAPABILITY,FAIL(&quot;You must define CAPABILITY before &quot;      \
   &quot;calling ACTIVATE_BACKEND_REQ_FOR_MODEL(S). Please check the rollcall heade&quot;\
   &quot;r for &quot; STRINGIFY(MODULE) &quot;.&quot;))                                            \
  IF_TOKEN_UNDEFINED(FUNCTION,FAIL(&quot;You must define FUNCTION before calling &quot;  \
   &quot;ACTIVATE_BACKEND_REQ_FOR_MODEL(S). Please check the rollcall header for &quot;  \
   STRINGIFY(MODULE) &quot;.&quot;))                                                     \
                                                                               \
  namespace Gambit                                                             \
  {                                                                            \
    /* Put everything inside the Models namespace if this is a model-module */ \
    BOOST_PP_IIF(IS_MODEL, namespace Models {, )                               \
                                                                               \
    namespace MODULE                                                           \
    {                                                                          \
                                                                               \
      /* Apply the rule.*/                                                     \
      const int CAT_6(apply_rule_,FUNCTION,_,                                  \
       BOOST_PP_SEQ_CAT(BOOST_PP_TUPLE_TO_SEQ((STRIP_PARENS(MODELS)))),_,      \
       BOOST_PP_SEQ_CAT(BOOST_PP_TUPLE_TO_SEQ((STRIP_PARENS(TAGS)))) ) =       \
       set_backend_rule_for_model(Functown::FUNCTION,#MODELS,#TAGS);           \
                                                                               \
    }                                                                          \
    /* End Models namespace */                                                 \
    BOOST_PP_IIF(IS_MODEL, }, )                                                \
  }                                                                            \
</code></pre><p>Redirection of ACTIVATE_BACKEND_REQ_FOR_MODELS when invoked from the Core.</p><h3 id=define-activate-dep-model>define ACTIVATE_DEP_MODEL <a href=#define-activate-dep-model class=anchor aria-hidden=true>#</a></h3><pre><code>#define ACTIVATE_DEP_MODEL(
    MODULE,
    CAPABILITY,
    FUNCTION,
    CONDITIONAL_DEPENDENCY,
    IS_MODEL,
    MODELSTRING
)

</code></pre><p>Redirection of <a href=/documentation/code/files/module__macros__incore_8hpp/#define-activate-for-models>ACTIVATE_FOR_MODELS(MODELSTRING)</a> when invoked from within the core, inside a CONDITIONAL_DEPENDENCY definition.</p><h3 id=define-core-classload-needed>define CORE_CLASSLOAD_NEEDED <a href=#define-core-classload-needed class=anchor aria-hidden=true>#</a></h3><pre><code>#define CORE_CLASSLOAD_NEEDED(
    BACKEND,
    VERSTRING,
    IS_MODEL
)
                                                                               \
  IF_TOKEN_UNDEFINED(MODULE,FAIL(&quot;You must define MODULE before calling &quot;      \
   &quot;NEEDS_CLASSES_FROM.&quot;))                                                     \
  IF_TOKEN_UNDEFINED(CAPABILITY,FAIL(&quot;You must define CAPABILITY before &quot;      \
   &quot;calling NEEDS_CLASSES_FROM. Please check the rollcall header &quot;             \
   &quot;for &quot; STRINGIFY(MODULE) &quot;.&quot;))                                              \
  IF_TOKEN_UNDEFINED(FUNCTION,FAIL(&quot;You must define FUNCTION before calling &quot;  \
   &quot;NEEDS_CLASSES_FROM. Please check the rollcall header for &quot;                 \
   STRINGIFY(MODULE) &quot;.&quot;))                                                     \
                                                                               \
  namespace Gambit                                                             \
  {                                                                            \
    /* Put everything inside the Models namespace if this is a model-module */ \
    BOOST_PP_IIF(IS_MODEL, namespace Models {, )                               \
                                                                               \
    namespace MODULE                                                           \
    {                                                                          \
                                                                               \
      const int CAT_4(classloading_from_,BACKEND,_for_,FUNCTION) =             \
       set_classload_requirements(Functown::FUNCTION, STRINGIFY(BACKEND),      \
       VERSTRING, STRINGIFY(CAT(Default_,BACKEND)));                           \
                                                                               \
    }                                                                          \
                                                                               \
    /* End Models namespace */                                                 \
    BOOST_PP_IIF(IS_MODEL, }, )                                                \
                                                                               \
  }                                                                            \
</code></pre><p>Redirection of NEEDS_CLASSES_FROM when invoked from within the Core.</p><h2 id=source-code>Source code <a href=#source-code class=anchor aria-hidden=true>#</a></h2><pre><code>//   GAMBIT: Global and Modular BSM Inference Tool
//   *********************************************
///  \file
///
///  Redirection macros for generic observable and
///  likelihood function macro definitions, for
///  inclusion from the Core.
///
///
///  Note here that \link FUNCTION() FUNCTION
///  \endlink is the actual module function name,
///  whereas both \link CAPABILITY() CAPABILITY
///  \endlink and all \em DEPs refer to the
///  abstract physical quantities that functions
///  may provide or require.  Thus, the provides()
///  methods expect a quantity input (i.e.
///  corresponding to a \link CAPABILITY()
///  CAPABILITY\endlink), the requires() methods
///  expect a quantity input for the dependency but a
///  function name input (i.e. corresponding to a
///  \link FUNCTION() FUNCTION\endlink) for
///  the actual dependent function, and all other
///  things operate on the basis of the function
///  name, not the quantity that is calculated.
///
///  *********************************************
///
///  Authors (add name and date if you modify):
///
///  \author Pat Scott
///          (patscott@physics.mcgill.ca)
///  \date 2012 Nov
///  \date 2013,14 Foreverrrrr
///
///  \author Abram Krislock
///          (abram.krislock@fysik.su.se)
///  \date 2013 Jan, Feb
///
///  \author Christoph Weniger
///          (c.weniger@uva.nl)
///  \date 2013 Jan, Feb, 2014 Jan
///
///  \author Anders Kvellestad
///          (anders.kvellestad@fys.uio.no)
///  \date 2013 Nov
///
///  \author Ben Farmer
///          (b.farmer@imperial.ac.uk)
///  \date 2019 Jul
///
///  \author Tomas Gonzalo
///          (gonzalo@physik.rwth-aachen.de)
///  \date 2021 Sep
///
///  *********************************************

#ifndef __module_macros_incore_defs_hpp__
#define __module_macros_incore_defs_hpp__

/// Change this to 1 if you really don't care about parameter clashes.
#define ALLOW_DUPLICATES_IN_PARAMS_MAP 0

#include &lt;map&gt;

#include &quot;gambit/Elements/functors.hpp&quot;
#include &quot;gambit/Elements/types_rollcall.hpp&quot;
#include &quot;gambit/Elements/module_macros_common.hpp&quot;
#include &quot;gambit/Elements/safety_bucket.hpp&quot;
#include &quot;gambit/Elements/ini_functions.hpp&quot;
#include &quot;gambit/Elements/elements_extras.hpp&quot;
#include &quot;gambit/Elements/terminator.hpp&quot;
#include &quot;gambit/Utils/static_members.hpp&quot;
#include &quot;gambit/Utils/exceptions.hpp&quot;
#include &quot;gambit/Backends/backend_singleton.hpp&quot;
#include &quot;gambit/Models/claw_singleton.hpp&quot;
#include &quot;gambit/Models/safe_param_map.hpp&quot;
#ifndef STANDALONE
  #include &quot;gambit/Core/ini_functions.hpp&quot;
#endif

#include &lt;boost/preprocessor/logical/bitand.hpp&gt;
#include &lt;boost/preprocessor/tuple/to_seq.hpp&gt;
#include &lt;boost/preprocessor/tuple/elem.hpp&gt;
#include &lt;boost/preprocessor/seq/cat.hpp&gt;


/// \name Tag-registration macros
/// @{
/// Add a regular tag to the current namespace
#define ADD_TAG_IN_CURRENT_NAMESPACE(TAG) namespace Tags { struct TAG; }
/// Add a backend tag to the current namespace
#define ADD_BETAG_IN_CURRENT_NAMESPACE(TAG) namespace BETags { struct TAG; }
/// Add a backend tag to the current namespace
#define ADD_MODEL_TAG_IN_CURRENT_NAMESPACE(TAG) namespace ModelTags { struct TAG; }
/// @}


//  *******************************************************************************
/// \name Actual in-core rollcall macros
/// These macros do the actual heavy lifting within the rollcall system.
/// @{

// Determine whether to make registration calls to the Core in the START_MODULE
// macro, depending on STANDALONE flag
#ifdef STANDALONE
  #define CORE_START_MODULE_COMMON(MODULE)                                     \
          CORE_START_MODULE_COMMON_MAIN(MODULE)
#else
  #define CORE_START_MODULE_COMMON(MODULE)                                     \
          CORE_START_MODULE_COMMON_MAIN(MODULE)                                \
          const int module_registered =                                        \
            register_module(STRINGIFY(MODULE), SAFE_STRINGIFY(REFERENCE));
#endif

/// Redirection of \link START_MODULE() START_MODULE\endlink when invoked from
/// within the core.
#define CORE_START_MODULE                                                      \
                                                                               \
  IF_TOKEN_UNDEFINED(MODULE,FAIL(&quot;You must define MODULE before calling &quot;      \
   &quot;START_MODULE.&quot;))                                                           \
                                                                               \
  namespace Gambit                                                             \
  {                                                                            \
                                                                               \
    namespace MODULE                                                           \
    {                                                                          \
                                                                               \
      /* Module errors */                                                      \
      error&amp; CAT(MODULE,_error)()                                              \
      {                                                                        \
        static error local(&quot;A problem has been raised by &quot; STRINGIFY(MODULE)   \
                           &quot;.&quot;, STRINGIFY(MODULE) &quot;_error&quot;);                   \
        return local;                                                          \
      }                                                                        \
                                                                               \
      /* Module warnings */                                                    \
      warning&amp; CAT(MODULE,_warning)()                                          \
      {                                                                        \
        static warning local(&quot;A problem has been raised by &quot; STRINGIFY(MODULE) \
                           &quot;.&quot;, STRINGIFY(MODULE) &quot;_warning&quot;);                 \
        return local;                                                          \
      }                                                                        \
                                                                               \
      /* Register the module error and warning objects by calling the          \
         above functions. */                                                   \
      error&amp; temp_error_reference = CAT(MODULE,_error)();                      \
      warning&amp; temp_warning_reference = CAT(MODULE,_warning)();                \
                                                                               \
      /* Register the module with the log system.  Not done for models. */     \
      const int log_registered = register_module_with_log(STRINGIFY(MODULE));  \
                                                                               \
                                                                               \
      CORE_START_MODULE_COMMON(MODULE)                                         \
                                                                               \
    }                                                                          \
                                                                               \
  }                                                                            \


/// Central module definition macro, used by modules and models.
#define CORE_START_MODULE_COMMON_MAIN(MODULE)                                  \
                                                                               \
      /* Resolve dependency DEP_TAG in function TAG */                         \
      template &lt;typename DEP_TAG, typename TAG&gt;                                \
      void resolve_dependency(functor*, module_functor_common*)                \
      {                                                                        \
        cout&lt;&lt;STRINGIFY(MODULE)&lt;&lt;&quot; does not&quot;&lt;&lt;endl;                            \
        cout&lt;&lt;&quot;have this dependency for this function.&quot;;                       \
      }                                                                        \
                                                                               \
      /* Resolve backend requirement BE_REQ in function TAG */                 \
      template &lt;typename BE_REQ, typename TAG&gt;                                 \
      void resolve_backendreq(functor*)                                        \
      {                                                                        \
        cout&lt;&lt;STRINGIFY(MODULE)&lt;&lt;&quot; does not&quot;&lt;&lt;endl;                            \
        cout&lt;&lt;&quot;have this backend requirement for this function.&quot;;              \
      }                                                                        \
                                                                               \
      /* Runtime registration function for dependency DEP_TAG of function TAG*/\
      template &lt;typename DEP_TAG, typename TAG&gt;                                \
      void rt_register_dependency ()                                           \
      {                                                                        \
        cout&lt;&lt;STRINGIFY(MODULE)&lt;&lt;&quot; does not&quot;&lt;&lt;endl;                            \
        cout&lt;&lt;&quot;have this dependency for this function.&quot;;                       \
      }                                                                        \
                                                                               \
      /* Runtime registration of conditional dependency DEP_TAG of function    \
      TAG, where dependency exists if TAG requires backend function BE_REQ,    \
      and BE_REQ is provided by backend BE.*/                                  \
      template &lt;typename DEP_TAG, typename TAG, typename BE_REQ, typename BE&gt;  \
      void rt_register_conditional_dependency ()                               \
      {                                                                        \
        rt_register_conditional_dependency&lt;DEP_TAG, TAG&gt;();                    \
      }                                                                        \
      template &lt;typename DEP_TAG, typename TAG&gt;                                \
      void rt_register_conditional_dependency ()                               \
      {                                                                        \
        cout&lt;&lt;STRINGIFY(MODULE)&lt;&lt;&quot; does not&quot;&lt;&lt;endl;                            \
        cout&lt;&lt;&quot;have any matching conditional dependency.&quot;;                     \
      }                                                                        \
                                                                               \
      /* Runtime registration function for backend req BE_REQ of               \
      function TAG*/                                                           \
      template &lt;typename BE_REQ, typename TAG&gt;                                 \
      void rt_register_req ()                                                  \
      {                                                                        \
        cout&lt;&lt;STRINGIFY(MODULE)&lt;&lt;&quot; does not&quot;&lt;&lt;endl;                            \
        cout&lt;&lt;&quot;have this backend requirement for this function.&quot;;              \
      }                                                                        \


/// Redirection of \link START_CAPABILITY() START_CAPABILITY\endlink when
/// invoked from within the core.
#define CORE_START_CAPABILITY(MODULE, CAPABILITY, IS_MODEL)                    \
                                                                               \
  IF_TOKEN_UNDEFINED(MODULE,FAIL(&quot;You must define MODULE before calling &quot;      \
   &quot;START_CAPABILITY.&quot;))                                                       \
  IF_TOKEN_UNDEFINED(CAPABILITY,FAIL(&quot;You must define CAPABILITY before &quot;      \
   &quot;calling START_CAPABILITY. Please check the rollcall header for &quot;           \
   STRINGIFY(MODULE) &quot;.&quot;))                                                     \
                                                                               \
  namespace Gambit                                                             \
  {                                                                            \
    /* Add CAPABILITY to the global set of things that can be calculated*/     \
    ADD_TAG_IN_CURRENT_NAMESPACE(CAPABILITY)                                   \
                                                                               \
  }                                                                            \


/// Redirection of \link START_FUNCTION() START_FUNCTION\endlink when invoked
/// from within the core.
#define CORE_DECLARE_FUNCTION(MODULE, CAPABILITY, FUNCTION, TYPE, FLAG, IS_MODEL)\
                                                                               \
  IF_TOKEN_UNDEFINED(MODULE,FAIL(&quot;You must define MODULE before calling &quot;      \
   &quot;START_FUNCTION.&quot;))                                                         \
  IF_TOKEN_UNDEFINED(CAPABILITY,FAIL(&quot;You must define CAPABILITY before &quot;      \
   &quot;calling START_FUNCTION. Please check the rollcall header for &quot;             \
   STRINGIFY(MODULE) &quot;.&quot;))                                                     \
  IF_TOKEN_UNDEFINED(FUNCTION,FAIL(&quot;You must define FUNCTION before calling &quot;  \
   &quot;START_FUNCTION. Please check the rollcall header for &quot;                     \
   STRINGIFY(MODULE) &quot;.&quot;))                                                     \
                                                                               \
  namespace Gambit                                                             \
  {                                                                            \
    /* Put everything inside the Models namespace if this is a model-module */ \
    BOOST_PP_IIF(IS_MODEL, namespace Models {, )                               \
                                                                               \
    /* Fail if a void-type function is declared, unless it can manage loops or \
       is an initialisation function. */                                       \
    BOOST_PP_IIF(BOOST_PP_BITAND(IS_TYPE(void,TYPE), BOOST_PP_EQUAL(FLAG, 0)), \
      FAIL(&quot;Module functions cannot have void results, unless they manage &quot;    \
       &quot;loops or are initialisation functions.  Loop managers are declared &quot;   \
       &quot;by adding CAN_MANAGE_LOOPS as the second argument of START_FUNCTION.&quot;  \
       &quot;Initialisation functions are declared from frontend headers by using &quot; \
       &quot;the BE_INI_FUNCTION macro.  Please check the header file for module &quot;  \
       STRINGIFY(MODULE) &quot;, function &quot; STRINGIFY(FUNCTION) &quot;.&quot;)                \
    ,)                                                                         \
                                                                               \
    BOOST_PP_IIF(BOOST_PP_BITAND(BOOST_PP_NOT(IS_TYPE(void,TYPE)),             \
                                 BOOST_PP_EQUAL(FLAG, 2) ),                    \
      /* Fail if an initialisation function has a non-void return type */      \
      FAIL(&quot;Initialisation functions must have void results. This is &quot;         \
       &quot;indicated by using the BE_INI_FUNCTION macro in a frontend header.&quot;)   \
    ,)                                                                         \
                                                                               \
    namespace MODULE                                                           \
    {                                                                          \
      /* Add FUNCTION to the module's set of recognised functions. */          \
      ADD_TAG_IN_CURRENT_NAMESPACE(FUNCTION)                                   \
                                                                               \
      /* Register (prototype) the function */                                  \
      BOOST_PP_IIF(IS_TYPE(void,TYPE),                                         \
        void FUNCTION();                                                       \
      ,                                                                        \
        void FUNCTION (TYPE &amp;);                                                \
      )                                                                        \
                                                                               \
      /* Wrap it in a functor */                                               \
      MAKE_FUNCTOR(FUNCTION,TYPE,CAPABILITY,MODULE,BOOST_PP_EQUAL(FLAG, 1))    \
    }                                                                          \
                                                                               \
    /* End Models namespace */                                                 \
    BOOST_PP_IIF(IS_MODEL, }, )                                                \
                                                                               \
  }                                                                            \


// Determine whether to make registration calls to the Core in the MAKE_FUNCTOR
// macro, depending on STANDALONE flag
#ifdef STANDALONE
  #define MAKE_FUNCTOR(FUNCTION,TYPE,CAPABILITY,ORIGIN,CAN_MANAGE)             \
          MAKE_FUNCTOR_MAIN(FUNCTION,TYPE,CAPABILITY,ORIGIN,CAN_MANAGE)
#else
  #define MAKE_FUNCTOR(FUNCTION,TYPE,CAPABILITY,ORIGIN,CAN_MANAGE)             \
          MAKE_FUNCTOR_MAIN(FUNCTION,TYPE,CAPABILITY,ORIGIN,CAN_MANAGE)        \
          const int CAT(FUNCTION,_registered2) =                               \
           register_module_functor_core(Functown::FUNCTION);
#endif


/// Main parts of the functor creation
#define MAKE_FUNCTOR_MAIN(FUNCTION,TYPE,CAPABILITY,ORIGIN,CAN_MANAGE)          \
                                                                               \
  namespace Functown                                                           \
  {                                                                            \
    /* Create the function wrapper object (functor) */                         \
    BOOST_PP_IIF(IS_TYPE(ModelParameters,TYPE),                                \
      model_functor                                                            \
    ,                                                                          \
      module_functor&lt;TYPE&gt;                                                     \
    )                                                                          \
    FUNCTION (&amp;ORIGIN::FUNCTION, STRINGIFY(FUNCTION), STRINGIFY(CAPABILITY),   \
     STRINGIFY(TYPE), STRINGIFY(ORIGIN), Models::ModelDB());                   \
    /* Set up a helper function to call the iterate method if the functor is   \
    able to manage loops. */                                                   \
    BOOST_PP_IIF(BOOST_PP_EQUAL(CAN_MANAGE, 1),                                \
     void CAT(FUNCTION,_iterate)(long long it) { FUNCTION.iterate(it); }       \
    ,)                                                                         \
    /* Create a helper function to indicate whether a given model is in use. */\
    BOOST_PP_IIF(IS_TYPE(ModelParameters,TYPE), ,                              \
     bool CAT(FUNCTION,_modelInUse)(str model)                                 \
     {                                                                         \
       return FUNCTION.getActiveModelFlag(model);                              \
     }                                                                         \
    )                                                                          \
  }                                                                            \
                                                                               \
  namespace Pipes                                                              \
  {                                                                            \
                                                                               \
    namespace FUNCTION                                                         \
    {                                                                          \
      /* Create a map to hold pointers to all the model parameters accessible  \
      to this functor */                                                       \
      Models::safe_param_map&lt;safe_ptr&lt;const double&gt; &gt; Param;                   \
      /* Pointer to function indicating whether a given model is in use.*/     \
      BOOST_PP_IIF(IS_TYPE(ModelParameters,TYPE), ,                            \
       bool (*ModelInUse)(str) = &amp;Functown::CAT(FUNCTION,_modelInUse); )       \
      /* Declare a safe pointer to the functor's run options. */               \
      safe_ptr&lt;Options&gt; runOptions;                                            \
      /* Set up Downstream pipes */                                            \
      namespace Downstream                                                     \
      {                                                                        \
         /* Create a pipe to hold a vector of all capability,type pairs of     \
         functors that get connected downstream of this one. */                \
         safe_ptr&lt;std::set&lt;sspair&gt;&gt; dependees;                                 \
         /* Create a pipe to hold all subcaps given for downstream functors */ \
         safe_ptr&lt;Options&gt; subcaps;                                            \
      }                                                                        \
      /* Set up Loop pipes */                                                  \
      namespace Loop                                                           \
      {                                                                        \
        BOOST_PP_IIF(CAN_MANAGE,                                               \
         /* Create a pointer to the single iteration of the loop that can      \
         be executed by this functor */                                        \
         void (*executeIteration)(long long)=&amp;Functown::CAT(FUNCTION,_iterate);\
         /* Declare a safe pointer to the flag indicating that a managed loop  \
         is ready for breaking. */                                             \
         safe_ptr&lt;bool&gt; done;                                                  \
         /* Declare a function that is used to reset the done flag. */         \
         void reset() { Functown::FUNCTION.resetLoop(); }                      \
        ,)                                                                     \
      }                                                                        \
    }                                                                          \
                                                                               \
  }                                                                            \
                                                                               \
  /* Register the function */                                                  \
  const int UNUSED_OK CAT(FUNCTION,_registered1) =                             \
   register_function(Functown::FUNCTION,                                       \
   CAN_MANAGE,                                                                 \
   BOOST_PP_IIF(CAN_MANAGE, &amp;Pipes::FUNCTION::Loop::done, NULL),               \
   Pipes::FUNCTION::runOptions,                                                \
   Pipes::FUNCTION::Downstream::dependees,                                     \
   Pipes::FUNCTION::Downstream::subcaps);                                      \

// Determine whether to make registration calls to the Core in the
// CORE_NEEDS_MANAGER macro, depending on STANDALONE flag
#ifdef STANDALONE
  #define CORE_NEEDS_MANAGER(...)                                              \
          CORE_NEEDS_MANAGER_REDIRECT(__VA_ARGS__)
#else
  #define CORE_NEEDS_MANAGER(...)                                              \
          CORE_NEEDS_MANAGER_REDIRECT(__VA_ARGS__)                             \
          namespace Gambit { namespace MODULE { const int CAT(FUNCTION,        \
           _registered3) = register_management_req(Functown::FUNCTION); } }
#endif

/// Variadic redirection for NEEDS_MANAGER when invoked within the Core
/// @{
#define CORE_NEEDS_MANAGER_REDIRECT_2(_1, _2) CORE_NEEDS_MANAGER_2(_1,  _2)
#define CORE_NEEDS_MANAGER_REDIRECT_1(_1)     CORE_NEEDS_MANAGER_1(_1)
#define CORE_NEEDS_MANAGER_REDIRECT(...)      VARARG(CORE_NEEDS_MANAGER_REDIRECT, __VA_ARGS__)
/// @}

/// Redirection of NEEDS_MANAGER(LOOPMAN) when invoked from within the Core.
#define CORE_NEEDS_MANAGER_1(LOOPMAN)                                          \
  CORE_NEEDS_MANAGER_MAIN(LOOPMAN, any)

/// Redirection of NEEDS_MANAGER(LOOPMAN,TYPE) when invoked from within the Core.
#define CORE_NEEDS_MANAGER_2(LOOPMAN,TYPE)                                     \
  CORE_NEEDS_MANAGER_MAIN(LOOPMAN,TYPE)                                        \
  DEPENDENCY(LOOPMAN,TYPE)

/// Main redirection of NEEDS_MANAGER(LOOPMAN,TYPE) when invoked from within the Core.
#define CORE_NEEDS_MANAGER_MAIN(LOOPMAN,TYPE)                                  \
                                                                               \
  IF_TOKEN_UNDEFINED(MODULE,FAIL(&quot;You must define MODULE before calling &quot;      \
   &quot;NEEDS_MANAGER_WITH_CAPABILITY.&quot;))                                          \
  IF_TOKEN_UNDEFINED(CAPABILITY,FAIL(&quot;You must define CAPABILITY before &quot;      \
   &quot;calling NEEDS_MANAGER_WITH_CAPABILITY. Please check the rollcall header &quot;  \
   &quot;for &quot; STRINGIFY(MODULE) &quot;.&quot;))                                              \
  IF_TOKEN_UNDEFINED(FUNCTION,FAIL(&quot;You must define FUNCTION before calling &quot;  \
   &quot;NEEDS_MANAGER_WITH_CAPABILITY. Please check the rollcall header for &quot;      \
   STRINGIFY(MODULE) &quot;.&quot;))                                                     \
                                                                               \
  namespace Gambit                                                             \
  {                                                                            \
    namespace MODULE                                                           \
    {                                                                          \
      namespace Pipes                                                          \
      {                                                                        \
        namespace FUNCTION                                                     \
        {                                                                      \
          namespace Loop                                                       \
          {                                                                    \
            /* Create a safe pointer to the iteration number of the loop this  \
            functor is running within. */                                      \
            omp_safe_ptr&lt;long long&gt; iteration;                                 \
            /* Create a loop-breaking function that can be called to tell the  \
            functor's loop manager that it is time to break. */                \
            void wrapup() { Functown::FUNCTION.breakLoopFromManagedFunctor(); }\
            /* Create a function that can be called to break a loop            \
            immediately,, without finishing the current iteration. */          \
            void halt() { throw halt_loop_exception(); }                       \
            /* Create an iteration-skipping function that can be called to skip\
            on to the next iteration. */                                       \
            void cycle() { throw invalid_loop_iteration_exception(); }         \
          }                                                                    \
          /* Register the fact that this FUNCTION must be run by a manager with\
          capability LOOPMAN. */                                               \
          const int nest_reg = register_function_nesting(Functown::FUNCTION,   \
           Loop::iteration, STRINGIFY(LOOPMAN), STRINGIFY(TYPE));              \
        }                                                                      \
      }                                                                        \
    }                                                                          \
  }                                                                            \


/// Common components of CORE_DEPENDENCY(DEP, TYPE, MODULE, FUNCTION) and
/// CORE_START_CONDITIONAL_DEPENDENCY(TYPE).
#define DEPENDENCY_COMMON(DEP, TYPE, MODULE, FUNCTION)                         \
                                                                               \
      /* Given that TYPE is not void, create a safety_bucket for the           \
      dependency result. To be initialized automatically at runtime            \
      when the dependency is resolved. */                                      \
      namespace Pipes                                                          \
      {                                                                        \
        namespace FUNCTION                                                     \
        {                                                                      \
          BOOST_PP_IIF(IS_TYPE(void,TYPE), ,                                   \
           namespace Dep {dep_bucket&lt;TYPE&gt; DEP(STRINGIFY(MODULE),              \
           STRINGIFY(FUNCTION),STRINGIFY(DEP));})                              \
        }                                                                      \
      }                                                                        \
                                                                               \
      /* Resolve dependency DEP in FUNCTION */                                 \
      template &lt;&gt;                                                              \
      void resolve_dependency&lt;Gambit::Tags::DEP, Tags::FUNCTION&gt;(functor*      \
       dep_functor, module_functor_common* BOOST_PP_IIF(IS_TYPE(void,TYPE), ,  \
       this_functor))                                                          \
      {                                                                        \
        /* First try casting the dep pointer passed in to a module_functor */  \
        module_functor&lt;TYPE&gt; * ptr =                                           \
         dynamic_cast&lt;module_functor&lt;TYPE&gt;*&gt;(dep_functor);                     \
                                                                               \
        /* Now test if that cast worked */                                     \
        if (ptr == 0)  /* It didn't; throw an error. */                        \
        {                                                                      \
          str errmsg = &quot;Null returned from dynamic cast of&quot;;                   \
          errmsg +=  &quot;\ndependency functor in MODULE::resolve_dependency, for&quot; \
                     &quot;\ndependency DEP of function FUNCTION.  Attempt was to&quot;  \
                     &quot;\nresolve to &quot; + dep_functor-&gt;name() + &quot; in &quot; +          \
                     dep_functor-&gt;origin() + &quot;.&quot;;                              \
          utils_error().raise(LOCAL_INFO,errmsg);                              \
        }                                                                      \
                                                                               \
        /* It did! Now initialize the safety_bucket using the functors.*/      \
        BOOST_PP_IIF(IS_TYPE(void,TYPE), ,                                     \
          Pipes::FUNCTION::Dep::DEP.initialize(ptr,this_functor);              \
        )                                                                      \
                                                                               \
      }                                                                        \


/// Redirection of DEPENDENCY(DEP, TYPE) when invoked from within the core.
#define CORE_DEPENDENCY(DEP, TYPE, MODULE, FUNCTION, IS_MODEL_DEP)             \
                                                                               \
  namespace Gambit                                                             \
  {                                                                            \
                                                                               \
    /* Add DEP to global set of tags of recognised module capabilities/deps */ \
    ADD_TAG_IN_CURRENT_NAMESPACE(DEP)                                          \
                                                                               \
    /* Put everything inside the Models namespace if this is a model dep */    \
    BOOST_PP_IIF(IS_MODEL_DEP, namespace Models {, )                           \
                                                                               \
    namespace MODULE                                                           \
    {                                                                          \
      DEPENDENCY_COMMON(DEP, TYPE, MODULE, FUNCTION)                           \
                                                                               \
      const int CAT_3(DEP,_for_,FUNCTION) = register_dependency(               \
       Functown::FUNCTION, STRINGIFY(DEP), STRINGIFY(TYPE),                    \
       &amp;resolve_dependency&lt;Gambit::Tags::DEP, Tags::FUNCTION&gt;);                \
    }                                                                          \
                                                                               \
    /* Close the Models namespace if this is a model dep */                    \
    BOOST_PP_IIF(IS_MODEL_DEP, }, )                                            \
                                                                               \
  }                                                                            \

/// Redirection of ALLOW_MODEL when invoked from within the core.
#define CORE_ALLOWED_MODEL(MODULE,FUNCTION,MODEL,IS_MODEL)                     \
                                                                               \
  IF_TOKEN_UNDEFINED(MODULE,FAIL(&quot;You must define MODULE before calling &quot;      \
   &quot;ALLOW_MODEL(S).&quot;))                                                         \
  IF_TOKEN_UNDEFINED(FUNCTION,FAIL(&quot;You must define FUNCTION before calling &quot;  \
   &quot;ALLOW_MODEL(S). Please check the rollcall header for &quot;                     \
   STRINGIFY(MODULE) &quot;.&quot;))                                                     \
                                                                               \
  namespace Gambit                                                             \
  {                                                                            \
    /* Put everything inside the Models namespace if this is a model-module */ \
    BOOST_PP_IIF(IS_MODEL, namespace Models {, )                               \
                                                                               \
    /* Add MODEL to global set of tags of recognised models */                 \
    ADD_MODEL_TAG_IN_CURRENT_NAMESPACE(MODEL)                                  \
    CORE_ALLOWED_MODEL_ARRANGE_DEP(MODULE,FUNCTION,MODEL)                      \
    CORE_ALLOW_MODEL(MODULE,FUNCTION,MODEL)                                    \
                                                                               \
    /* End Models namespace */                                                 \
    BOOST_PP_IIF(IS_MODEL, }, )                                                \
 }                                                                             \

/// Redirection of ALLOW_MODEL_DEPENDENCE when invoked from within the core.
#define CORE_ALLOW_MODEL_DEPENDENCE(MODULE,FUNCTION,MODEL,IS_MODEL)            \
                                                                               \
  IF_TOKEN_UNDEFINED(MODULE,FAIL(&quot;You must define MODULE before calling &quot;      \
   &quot;ALLOW_MODEL_DEPENDENCE.&quot;))                                                 \
  IF_TOKEN_UNDEFINED(FUNCTION,FAIL(&quot;You must define FUNCTION before calling &quot;  \
   &quot;ALLOW_MODEL_DEPENDENCE. Please check the rollcall header for &quot;             \
   STRINGIFY(MODULE) &quot;.&quot;))                                                     \
                                                                               \
  namespace Gambit                                                             \
  {                                                                            \
    /* Put everything inside the Models namespace if this is a model-module */ \
    BOOST_PP_IIF(IS_MODEL, namespace Models {, )                               \
                                                                               \
    /* Add MODEL to global set of tags of recognised models */                 \
    ADD_MODEL_TAG_IN_CURRENT_NAMESPACE(MODEL)                                  \
    CORE_ALLOWED_MODEL_ARRANGE_DEP(MODULE,FUNCTION,MODEL)                      \
                                                                               \
    /* End Models namespace */                                                 \
    BOOST_PP_IIF(IS_MODEL, }, )                                                \
 }                                                                             \

/// Set up the dependency on the parameters object of a given model.
#define CORE_ALLOWED_MODEL_ARRANGE_DEP(MODULE,FUNCTION,MODEL)                  \
                                                                               \
    namespace MODULE                                                           \
    {                                                                          \
                                                                               \
      /* Create a safety bucket to the model parameter values. To be filled    \
      automatically at runtime when the dependency is resolved. */             \
      namespace Pipes                                                          \
      {                                                                        \
        namespace FUNCTION                                                     \
        {                                                                      \
          namespace Dep                                                        \
          {                                                                    \
            dep_bucket&lt;ModelParameters&gt; CAT(MODEL,_parameters)                 \
             (STRINGIFY(MODULE),STRINGIFY(FUNCTION),                           \
             STRINGIFY(CAT(MODEL,_parameters)));                               \
          }                                                                    \
        }                                                                      \
      }                                                                        \
                                                                               \
      /* Resolve dependency on parameters of MODEL in FUNCTION */              \
      template &lt;&gt;                                                              \
      void resolve_dependency&lt;ModelTags::MODEL, Tags::FUNCTION&gt;                \
       (functor* params_functor, module_functor_common* this_functor)          \
      {                                                                        \
        /* First try casting the pointer passed in to a module_functor */      \
        module_functor&lt;ModelParameters&gt;* ptr =                                 \
         dynamic_cast&lt;module_functor&lt;ModelParameters&gt;*&gt;(params_functor);       \
                                                                               \
        /* Now test if that cast worked */                                     \
        if (ptr == 0)  /* It didn't; throw an error. */                        \
        {                                                                      \
          str errmsg = &quot;Null returned from dynamic cast in&quot;;                   \
          errmsg +=  &quot;\nMODULE::resolve_dependency, for model&quot;                 \
                     &quot;\nMODEL with function FUNCTION.  Attempt was to&quot;         \
                     &quot;\nresolve to &quot; + params_functor-&gt;name() + &quot; in &quot; +       \
                     params_functor-&gt;origin() + &quot;.&quot;;                           \
          utils_error().raise(LOCAL_INFO,errmsg);                              \
        }                                                                      \
                                                                               \
        /* It did! Now initialize the safety_bucket using the functors.*/      \
        Pipes::FUNCTION::Dep::CAT(MODEL,_parameters).initialize(ptr,           \
         this_functor);                                                        \
        /* Get a pointer to the parameter map provided by this MODEL */        \
        safe_ptr&lt;ModelParameters&gt; model_safe_ptr =                             \
         Pipes::FUNCTION::Dep::CAT(MODEL,_parameters).safe_pointer();          \
        /* Use that to add the parameters provided by this MODEL to the map    \
        of safe pointers to model parameters. */                               \
        for (std::map&lt;str,double&gt;::const_iterator it = model_safe_ptr-&gt;begin();\
         it != model_safe_ptr-&gt;end(); ++it)                                    \
        {                                                                      \
          BOOST_PP_IIF(ALLOW_DUPLICATES_IN_PARAMS_MAP, ,                       \
          if (Pipes::FUNCTION::Param.find(it-&gt;first) ==                        \
              Pipes::FUNCTION::Param.end())                                    \
          )                                                                    \
          {                                                                    \
            /* Add a safe pointer to the value of this parameter to the map*/  \
            Pipes::FUNCTION::Param.insert(                                     \
             std::pair&lt;str,safe_ptr&lt;const double&gt; &gt;(it-&gt;first,                 \
             safe_ptr&lt;const double&gt;(&amp;(it-&gt;second)))                            \
            );                                                                 \
          }                                                                    \
          BOOST_PP_IIF(ALLOW_DUPLICATES_IN_PARAMS_MAP, ,                       \
          else                                                                 \
          {                                                                    \
            /* This parameter already exists in the map! Fail. */              \
            str errmsg = &quot;Problem in &quot; STRINGIFY(MODULE) &quot;::resolve_&quot;;         \
            errmsg +=    &quot;dependency, for model &quot; STRINGIFY(MODEL)             \
                         &quot; with function\n&quot; STRINGIFY(FUNCTION) &quot;.  Attempt &quot;  \
                         &quot;was to resolve to\n&quot; + params_functor-&gt;name() +      \
                         &quot; in &quot; + params_functor-&gt;origin()                     \
                         + &quot;.\nYou have tried to scan two models &quot;             \
                         &quot;simultaneously that have one or more\n parameters &quot;  \
                         &quot;in common.\nProblem parameter: &quot; + it-&gt;first;        \
            utils_error().raise(LOCAL_INFO,errmsg);                            \
          }                                                                    \
          )                                                                    \
        }                                                                      \
      }                                                                        \
                                                                               \
      /* Register the dependency of the functor on the model parameters */     \
      const int CAT_3(MODEL,_params_for_,FUNCTION) =                           \
       register_model_parameter_dependency(Functown::FUNCTION,                 \
        STRINGIFY(MODEL), STRINGIFY(CAT(MODEL,_parameters)),                   \
         &amp;resolve_dependency&lt;ModelTags::MODEL, Tags::FUNCTION&gt;);               \
                                                                               \
    }                                                                          \


/// Tell the functor that a single model is enough for it to be allowed to run.
#define CORE_ALLOW_MODEL(MODULE,FUNCTION,MODEL)                                \
                                                                               \
    namespace MODULE                                                           \
    {                                                                          \
      /* Register the compatibility of the model with the functor */           \
      const int CAT_3(MODEL,_allowed_for_,FUNCTION) = register_model_singly(   \
        Functown::FUNCTION, STRINGIFY(MODEL));                                 \
    }                                                                          \


/// Redirection of ALLOW_MODEL_COMBINATION when invoked from the Core.
#define CORE_ALLOW_MODEL_COMBINATION(MODULE,FUNCTION,IS_MODEL,COMBO)           \
  IF_TOKEN_UNDEFINED(MODULE,FAIL(&quot;You must define MODULE before calling &quot;      \
   &quot;ALLOW_MODEL_COMBINATION.&quot;))                                                \
  IF_TOKEN_UNDEFINED(FUNCTION,FAIL(&quot;You must define FUNCTION before calling &quot;  \
   &quot;ALLOW_MODEL_COMBINATION. Please check the rollcall header for &quot;            \
   STRINGIFY(MODULE) &quot;.&quot;))                                                     \
                                                                               \
  namespace Gambit                                                             \
  {                                                                            \
    /* Put everything inside the Models namespace if this is a model-module */ \
    BOOST_PP_IIF(IS_MODEL, namespace Models {, )                               \
                                                                               \
    namespace MODULE                                                           \
    {                                                                          \
      /* Register the combination as allowed with the functor */               \
      const int CAT_3(FUNCTION,_,BOOST_PP_SEQ_CAT(BOOST_PP_TUPLE_TO_SEQ((      \
       STRIP_PARENS(COMBO))))) = register_model_combination(Functown::FUNCTION,\
       STRINGIFY(COMBO));                                                      \
    }                                                                          \
                                                                               \
    /* End Models namespace */                                                 \
    BOOST_PP_IIF(IS_MODEL, }, )                                                \
 }                                                                             \


/// Redirection of MODEL_GROUP when invoked from within the Core.
#define CORE_MODEL_GROUP(MODULE,FUNCTION,GROUPNAME,GROUP,IS_MODEL)             \
  IF_TOKEN_UNDEFINED(MODULE,FAIL(&quot;You must define MODULE before calling &quot;      \
   &quot;MODEL_GROUP.&quot;))                                                            \
  IF_TOKEN_UNDEFINED(FUNCTION,FAIL(&quot;You must define FUNCTION before calling &quot;  \
   &quot;MODEL_GROUP. Please check the rollcall header for &quot;                        \
   STRINGIFY(MODULE) &quot;.&quot;))                                                     \
                                                                               \
  /* Register the group with the functor */                                    \
  namespace Gambit                                                             \
  {                                                                            \
    /* Put everything inside the Models namespace if this is a model-module */ \
    BOOST_PP_IIF(IS_MODEL, namespace Models {, )                               \
                                                                               \
    namespace MODULE                                                           \
    {                                                                          \
      /* Register the model group with the functor */                          \
      const int CAT_3(GROUPNAME,_model_group_in_,FUNCTION) =                   \
       register_model_group(Functown::FUNCTION, STRINGIFY(GROUPNAME),          \
       STRINGIFY(GROUP));                                                      \
    }                                                                          \
                                                                               \
    /* End Models namespace */                                                 \
    BOOST_PP_IIF(IS_MODEL, }, )                                                \
 }                                                                             \

/// Redirection of BACKEND_GROUP(GROUP) when invoked from within the Core.
#define CORE_BE_GROUP(GROUP,IS_MODEL)                                          \
                                                                               \
  IF_TOKEN_UNDEFINED(MODULE,FAIL(&quot;You must define MODULE before calling &quot;      \
   &quot;BACKEND_GROUP.&quot;))                                                          \
  IF_TOKEN_UNDEFINED(CAPABILITY,FAIL(&quot;You must define CAPABILITY before &quot;      \
   &quot;calling BACKEND_GROUP. Please check the rollcall header &quot;                  \
   &quot;for &quot; STRINGIFY(MODULE) &quot;.&quot;))                                              \
  IF_TOKEN_UNDEFINED(FUNCTION,FAIL(&quot;You must define FUNCTION before calling &quot;  \
   &quot;BACKEND_GROUP. Please check the rollcall header for &quot;                      \
   STRINGIFY(MODULE) &quot;.&quot;))                                                     \
                                                                               \
  namespace Gambit                                                             \
  {                                                                            \
    /* Put everything inside the Models namespace if this is a model-module */ \
    BOOST_PP_IIF(IS_MODEL, namespace Models {, )                               \
                                                                               \
    namespace MODULE                                                           \
    {                                                                          \
      namespace Pipes                                                          \
      {                                                                        \
        namespace FUNCTION                                                     \
        {                                                                      \
          namespace BEgroup                                                    \
          {                                                                    \
            /* Declare a safe pointer to the functor's internal register of    \
            which backend requirement is activated from this group. */         \
            safe_ptr&lt;str&gt; GROUP =                                              \
             Functown::FUNCTION.getChosenReqFromGroup(STRINGIFY(GROUP));       \
          }                                                                    \
        }                                                                      \
      }                                                                        \
    }                                                                          \
    /* End Models namespace */                                                 \
    BOOST_PP_IIF(IS_MODEL, }, )                                                \
 }                                                                             \


/// Redirection of BACKEND_REQ(GROUP, REQUIREMENT, (TAGS), TYPE, [(ARGS)])
/// for declaring backend requirements when invoked from within the Core.
#define CORE_BACKEND_REQ(MODULE, CAPABILITY, FUNCTION, GROUP, REQUIREMENT,     \
                         TAGS, TYPE, ARGS, IS_VARIABLE, IS_MODEL)              \
                                                                               \
  IF_TOKEN_UNDEFINED(MODULE,FAIL(&quot;You must define MODULE before calling &quot;      \
   &quot;BACKEND_REQ.&quot;))                                                            \
  IF_TOKEN_UNDEFINED(CAPABILITY,FAIL(&quot;You must define CAPABILITY before &quot;      \
   &quot;calling BACKEND_REQ. Please check the rollcall header &quot;                    \
   &quot;for &quot; STRINGIFY(MODULE) &quot;.&quot;))                                              \
  IF_TOKEN_UNDEFINED(FUNCTION,FAIL(&quot;You must define FUNCTION before calling &quot;  \
   &quot;BACKEND_REQ. Please check the rollcall header for &quot;                        \
   STRINGIFY(MODULE) &quot;.&quot;))                                                     \
                                                                               \
  namespace Gambit                                                             \
  {                                                                            \
    /* Put everything inside the Models namespace if this is a model-module */ \
    BOOST_PP_IIF(IS_MODEL, namespace Models {, )                               \
                                                                               \
    /* If scan-level initialisation functions are implemented, the macro should\
    fail here if the user has tried to declare that a scan-level initialisation\
    function has a backend requirement. */                                     \
                                                                               \
    /* Add REQUIREMENT to global set of recognised backend func tags */        \
    ADD_BETAG_IN_CURRENT_NAMESPACE(REQUIREMENT)                                \
                                                                               \
    namespace MODULE                                                           \
    {                                                                          \
      namespace Pipes                                                          \
      {                                                                        \
        namespace FUNCTION                                                     \
        {                                                                      \
          namespace BEreq                                                      \
          {                                                                    \
            /* Create a safety_bucket for the backend variable/function.       \
            To be initialized by the dependency resolver at runtime. */        \
            typedef BEvariable_bucket&lt;TYPE&gt; CAT(REQUIREMENT,var);              \
            typedef BEfunction_bucket&lt;BOOST_PP_IIF(IS_VARIABLE,int,TYPE(*)     \
             CONVERT_VARIADIC_ARG(ARGS)), TYPE                                 \
             INSERT_NONEMPTY(STRIP_VARIADIC_ARG(ARGS))&gt;                        \
             CAT(REQUIREMENT,func);                                            \
            CAT(REQUIREMENT,BOOST_PP_IIF(IS_VARIABLE,var,func)) REQUIREMENT    \
             (STRINGIFY(MODULE),STRINGIFY(FUNCTION),STRINGIFY(REQUIREMENT));   \
          }                                                                    \
        }                                                                      \
      }                                                                        \
                                                                               \
      /* Resolve REQUIREMENT in FUNCTION */                                    \
      template &lt;&gt;                                                              \
      void resolve_backendreq&lt;BETags::REQUIREMENT, Tags::FUNCTION&gt;             \
       (functor* be_functor)                                                   \
      {                                                                        \
        /* First try casting the pointer passed in to a backend_functor*/      \
        typedef UNUSED_OK backend_functor&lt;TYPE*(*)(), TYPE*&gt;* var;             \
        typedef UNUSED_OK backend_functor&lt;BOOST_PP_IIF(IS_VARIABLE,int,TYPE(*) \
         CONVERT_VARIADIC_ARG(ARGS)), TYPE                                     \
         INSERT_NONEMPTY(STRIP_VARIADIC_ARG(ARGS))&gt;* func;                     \
        auto ptr =                                                             \
          dynamic_cast&lt;BOOST_PP_IIF(IS_VARIABLE,var,func)&gt;(be_functor);        \
                                                                               \
        /* Now test if that cast worked */                                     \
        if (ptr == 0)  /* It didn't; throw an error. */                        \
        {                                                                      \
          str errmsg = &quot;Null returned from dynamic cast in&quot;;                   \
          errmsg +=  &quot;\n&quot; STRINGIFY(MODULE) &quot;::resolve_backendreq, for backend&quot;\
                     &quot; requirement\n&quot; STRINGIFY(REQUIREMENT) &quot; of function &quot;   \
                     STRINGIFY(FUNCTION) &quot;.  Attempt was to&quot;                   \
                     &quot;\nresolve to &quot; + be_functor-&gt;name() + &quot; in &quot; +           \
                     be_functor-&gt;origin() + &quot;.&quot;;                               \
          utils_error().raise(LOCAL_INFO,errmsg);                              \
        }                                                                      \
                                                                               \
        /* It did! Now use the cast functor pointer to initialize              \
        the safety_bucket Pipes::FUNCTION::BEreq::REQUIREMENT. */              \
        Pipes::FUNCTION::BEreq::REQUIREMENT.initialize(ptr);                   \
      }                                                                        \
                                                                               \
      /* Register the backend requirement with the functor */                  \
      const int CAT_3(REQUIREMENT,_backend_for_,FUNCTION) =                    \
       register_backend_requirement(Functown::FUNCTION, STRINGIFY(GROUP),      \
       STRINGIFY(REQUIREMENT), STRINGIFY(TAGS), BOOST_PP_IIF(IS_VARIABLE,      \
       true, false), STRINGIFY(TYPE), STRINGIFY(CONVERT_VARIADIC_ARG(ARGS)),   \
       &amp;resolve_backendreq&lt;BETags::REQUIREMENT,Tags::FUNCTION&gt;);               \
                                                                               \
    }                                                                          \
                                                                               \
    /* End Models namespace */                                                 \
    BOOST_PP_IIF(IS_MODEL, }, )                                                \
                                                                               \
  }                                                                            \


/// Redirection of BACKEND_OPTION(BACKEND_AND_VERSIONS, TAGS) when invoked from
/// within the core.
#define CORE_BACKEND_OPTION(MODULE, CAPABILITY, FUNCTION, BE_AND_VER, TAGS,    \
 IS_MODEL)                                                                     \
                                                                               \
  IF_TOKEN_UNDEFINED(MODULE,FAIL(&quot;You must define MODULE before calling &quot;      \
   &quot;BACKEND_OPTION.&quot;))                                                         \
  IF_TOKEN_UNDEFINED(CAPABILITY,FAIL(&quot;You must define CAPABILITY before &quot;      \
   &quot;calling BACKEND_OPTION. Please check the rollcall header &quot;                 \
   &quot;for &quot; STRINGIFY(MODULE) &quot;.&quot;))                                              \
  IF_TOKEN_UNDEFINED(FUNCTION,FAIL(&quot;You must define FUNCTION before calling &quot;  \
   &quot;BACKEND_OPTION. Please check the rollcall header for &quot;                     \
   STRINGIFY(MODULE) &quot;.&quot;))                                                     \
                                                                               \
  namespace Gambit                                                             \
  {                                                                            \
    /* Put everything inside the Models namespace if this is a model-module */ \
    BOOST_PP_IIF(IS_MODEL, namespace Models {, )                               \
                                                                               \
    namespace MODULE                                                           \
    {                                                                          \
      /* Apply the rule */                                                     \
      const int CAT_5(FUNCTION,_,BOOST_PP_TUPLE_ELEM(0,(STRIP_PARENS           \
       (BE_AND_VER))),_,BOOST_PP_SEQ_CAT(BOOST_PP_TUPLE_TO_SEQ((               \
       STRIP_PARENS(TAGS))))) = apply_backend_option_rule(Functown::FUNCTION,  \
       STRINGIFY(BE_AND_VER), STRINGIFY(TAGS));                                \
    }                                                                          \
                                                                               \
    /* End Models namespace */                                                 \
    BOOST_PP_IIF(IS_MODEL, }, )                                                \
                                                                               \
  }                                                                            \


/// Redirection of FORCE_SAME_BACKEND(TAGS) when invoked from within the core.
#define CORE_FORCE_SAME_BACKEND(IS_MODEL,...)                                  \
                                                                               \
  IF_TOKEN_UNDEFINED(MODULE,FAIL(&quot;You must define MODULE before calling &quot;      \
   &quot;FORCE_SAME_BACKEND.&quot;))                                                     \
  IF_TOKEN_UNDEFINED(CAPABILITY,FAIL(&quot;You must define CAPABILITY before &quot;      \
   &quot;calling FORCE_SAME_BACKEND. Please check the rollcall header &quot;             \
   &quot;for &quot; STRINGIFY(MODULE) &quot;.&quot;))                                              \
  IF_TOKEN_UNDEFINED(FUNCTION,FAIL(&quot;You must define FUNCTION before calling &quot;  \
   &quot;FORCE_SAME_BACKEND. Please check the rollcall header for &quot;                 \
   STRINGIFY(MODULE) &quot;.&quot;))                                                     \
                                                                               \
  namespace Gambit                                                             \
  {                                                                            \
    /* Put everything inside the Models namespace if this is a model-module */ \
    BOOST_PP_IIF(IS_MODEL, namespace Models {, )                               \
                                                                               \
    namespace MODULE                                                           \
    {                                                                          \
      const int CAT_3(FUNCTION,_,BOOST_PP_SEQ_CAT(BOOST_PP_TUPLE_TO_SEQ((      \
       STRIP_PARENS(__VA_ARGS__))))) =                                         \
       apply_backend_matching_rule(Functown::FUNCTION, #__VA_ARGS__);          \
    }                                                                          \
                                                                               \
    /* End Models namespace */                                                 \
    BOOST_PP_IIF(IS_MODEL, }, )                                                \
                                                                               \
  }                                                                            \



/// Redirection of START_CONDITIONAL_DEPENDENCY(TYPE) when invoked from within
/// the core.
#define CORE_START_CONDITIONAL_DEPENDENCY(MODULE, CAPABILITY, FUNCTION,        \
 CONDITIONAL_DEPENDENCY, TYPE, IS_MODEL)                                       \
                                                                               \
  IF_TOKEN_UNDEFINED(MODULE,FAIL(&quot;You must define MODULE before calling &quot;      \
   &quot;START_CONDITIONAL_DEPENDENCY.&quot;))                                           \
  IF_TOKEN_UNDEFINED(CAPABILITY,FAIL(&quot;You must define CAPABILITY before &quot;      \
   &quot;calling START_CONDITIONAL_DEPENDENCY. Please check the rollcall header &quot;   \
   &quot;for &quot; STRINGIFY(MODULE) &quot;.&quot;))                                              \
  IF_TOKEN_UNDEFINED(FUNCTION,FAIL(&quot;You must define FUNCTION before calling &quot;  \
   &quot;START_CONDITIONAL_DEPENDENCY. Please check the rollcall header for &quot;       \
   STRINGIFY(MODULE) &quot;.&quot;))                                                     \
  IF_TOKEN_UNDEFINED(CONDITIONAL_DEPENDENCY,FAIL(&quot;You must define &quot;            \
   &quot;CONDITIONAL_DEPENDENCY before calling START_CONDITIONAL_DEPENDENCY. Please&quot;\
   &quot; check the rollcall header for &quot; STRINGIFY(MODULE) &quot;.&quot;))                   \
                                                                               \
  namespace Gambit                                                             \
  {                                                                            \
    /* Add dep to global set of tags of recognised module capabilities/deps */ \
    ADD_TAG_IN_CURRENT_NAMESPACE(CONDITIONAL_DEPENDENCY)                       \
                                                                               \
    /* Put everything inside the Models namespace if this is a model-module */ \
    BOOST_PP_IIF(IS_MODEL, namespace Models {, )                               \
                                                                               \
    namespace MODULE                                                           \
    {                                                                          \
      DEPENDENCY_COMMON(CONDITIONAL_DEPENDENCY, TYPE, MODULE, FUNCTION)        \
                                                                               \
      const int CAT_3(CONDITIONAL_DEPENDENCY,_for_,FUNCTION) =                 \
       register_conditional_dependency(Functown::FUNCTION,                     \
       STRINGIFY(CONDITIONAL_DEPENDENCY), STRINGIFY(TYPE));                    \
    }                                                                          \
                                                                               \
    /* End Models namespace */                                                 \
    BOOST_PP_IIF(IS_MODEL, }, )                                                \
                                                                               \
  }                                                                            \


/// Redirection of ACTIVATE_DEP_BE(BACKEND_REQ, BACKEND, VERSTRING) when
/// invoked from within the core.
#define CORE_ACTIVATE_DEP_BE(BACKEND_REQ, BACKEND, VERSTRING, IS_MODEL)        \
                                                                               \
  IF_TOKEN_UNDEFINED(MODULE,FAIL(&quot;You must define MODULE before calling &quot;      \
   &quot;ACTIVATE_FOR_BACKEND.&quot;))                                                   \
  IF_TOKEN_UNDEFINED(CAPABILITY,FAIL(&quot;You must define CAPABILITY before &quot;      \
   &quot;calling ACTIVATE_FOR_BACKEND. Please check the rollcall header &quot;           \
   &quot;for &quot; STRINGIFY(MODULE) &quot;.&quot;))                                              \
  IF_TOKEN_UNDEFINED(FUNCTION,FAIL(&quot;You must define FUNCTION before calling &quot;  \
   &quot;ACTIVATE_FOR_BACKEND. Please check the rollcall header for &quot;               \
   STRINGIFY(MODULE) &quot;.&quot;))                                                     \
  IF_TOKEN_UNDEFINED(CONDITIONAL_DEPENDENCY,FAIL(&quot;You must define &quot;            \
   &quot;CONDITIONAL_DEPENDENCY before calling ACTIVATE_FOR_BACKEND. Please&quot;        \
   &quot; check the rollcall header for &quot; STRINGIFY(MODULE) &quot;.&quot;))                   \
                                                                               \
  namespace Gambit                                                             \
  {                                                                            \
    /* Put everything inside the Models namespace if this is a model-module */ \
    BOOST_PP_IIF(IS_MODEL, namespace Models {, )                               \
                                                                               \
    /* Add BACKEND to global set of recognised backend tags */                 \
    ADD_BETAG_IN_CURRENT_NAMESPACE(BACKEND)                                    \
                                                                               \
    namespace MODULE                                                           \
    {                                                                          \
      /* Register the backend conditional dependency with the functor */       \
      const int CAT_7(CONDITIONAL_DEPENDENCY,_for_,FUNCTION,_with_,BACKEND_REQ,\
       _provided_by_,BACKEND) = register_backend_conditional_dependency(       \
       Functown::FUNCTION, STRINGIFY(BACKEND_REQ), STRINGIFY(BACKEND),         \
       VERSTRING, STRINGIFY(CONDITIONAL_DEPENDENCY), &amp;resolve_dependency       \
       &lt;Gambit::Tags::CONDITIONAL_DEPENDENCY, Tags::FUNCTION&gt;);                \
    }                                                                          \
                                                                               \
    /* End Models namespace */                                                 \
    BOOST_PP_IIF(IS_MODEL, }, )                                                \
                                                                               \
  }                                                                            \


/// Redirection of ACTIVATE_BACKEND_REQ_FOR_MODELS when invoked from the Core.
#define CORE_BE_MODEL_RULE(MODELS,TAGS,IS_MODEL)                               \
                                                                               \
  IF_TOKEN_UNDEFINED(MODULE,FAIL(&quot;You must define MODULE before calling &quot;      \
   &quot;ACTIVATE_BACKEND_REQ_FOR_MODEL(S).&quot;))                                      \
  IF_TOKEN_UNDEFINED(CAPABILITY,FAIL(&quot;You must define CAPABILITY before &quot;      \
   &quot;calling ACTIVATE_BACKEND_REQ_FOR_MODEL(S). Please check the rollcall heade&quot;\
   &quot;r for &quot; STRINGIFY(MODULE) &quot;.&quot;))                                            \
  IF_TOKEN_UNDEFINED(FUNCTION,FAIL(&quot;You must define FUNCTION before calling &quot;  \
   &quot;ACTIVATE_BACKEND_REQ_FOR_MODEL(S). Please check the rollcall header for &quot;  \
   STRINGIFY(MODULE) &quot;.&quot;))                                                     \
                                                                               \
  namespace Gambit                                                             \
  {                                                                            \
    /* Put everything inside the Models namespace if this is a model-module */ \
    BOOST_PP_IIF(IS_MODEL, namespace Models {, )                               \
                                                                               \
    namespace MODULE                                                           \
    {                                                                          \
                                                                               \
      /* Apply the rule.*/                                                     \
      const int CAT_6(apply_rule_,FUNCTION,_,                                  \
       BOOST_PP_SEQ_CAT(BOOST_PP_TUPLE_TO_SEQ((STRIP_PARENS(MODELS)))),_,      \
       BOOST_PP_SEQ_CAT(BOOST_PP_TUPLE_TO_SEQ((STRIP_PARENS(TAGS)))) ) =       \
       set_backend_rule_for_model(Functown::FUNCTION,#MODELS,#TAGS);           \
                                                                               \
    }                                                                          \
    /* End Models namespace */                                                 \
    BOOST_PP_IIF(IS_MODEL, }, )                                                \
  }                                                                            \


/// Redirection of ACTIVATE_FOR_MODELS(MODELSTRING) when invoked from within
/// the core, inside a CONDITIONAL_DEPENDENCY definition.
#define ACTIVATE_DEP_MODEL(MODULE, CAPABILITY, FUNCTION,                       \
 CONDITIONAL_DEPENDENCY,IS_MODEL,MODELSTRING)                                  \
                                                                               \
  IF_TOKEN_UNDEFINED(MODULE,FAIL(&quot;You must define MODULE before calling &quot;      \
   &quot;ACTIVATE_FOR_MODEL(S).&quot;))                                                  \
  IF_TOKEN_UNDEFINED(CAPABILITY,FAIL(&quot;You must define CAPABILITY before &quot;      \
   &quot;calling ACTIVATE_FOR_MODEL(S). Please check the rollcall header &quot;          \
   &quot;for &quot; STRINGIFY(MODULE) &quot;.&quot;))                                              \
  IF_TOKEN_UNDEFINED(FUNCTION,FAIL(&quot;You must define FUNCTION before calling &quot;  \
   &quot;ACTIVATE_FOR_MODEL(S). Please check the rollcall header for &quot;              \
   STRINGIFY(MODULE) &quot;.&quot;))                                                     \
  IF_TOKEN_UNDEFINED(CONDITIONAL_DEPENDENCY,FAIL(&quot;You must define &quot;            \
  &quot;CONDITIONAL_DEPENDENCY before calling ACTIVATE_FOR_MODEL(S).&quot;               \
  &quot; Please check the rollcall header for &quot; STRINGIFY(MODULE) &quot;.&quot;))             \
                                                                               \
  namespace Gambit                                                             \
  {                                                                            \
    /* Put everything inside the Models namespace if this is a model-module */ \
    BOOST_PP_IIF(IS_MODEL, namespace Models {, )                               \
                                                                               \
    namespace MODULE                                                           \
    {                                                                          \
      /* Register the conditional dependency. */                               \
      const int CAT_4(CONDITIONAL_DEPENDENCY,_for_,FUNCTION,_with_models) =    \
       register_model_conditional_dependency(Functown::FUNCTION,               \
       MODELSTRING, STRINGIFY(CONDITIONAL_DEPENDENCY),                         \
       &amp;resolve_dependency&lt;Gambit::Tags::CONDITIONAL_DEPENDENCY,               \
         Tags::FUNCTION&gt;);                                                     \
    }                                                                          \
                                                                               \
    /* End Models namespace */                                                 \
    BOOST_PP_IIF(IS_MODEL, }, )                                                \
                                                                               \
  }                                                                            \


/// Redirection of NEEDS_CLASSES_FROM when invoked from within the Core.
#define CORE_CLASSLOAD_NEEDED(BACKEND, VERSTRING, IS_MODEL)                    \
                                                                               \
  IF_TOKEN_UNDEFINED(MODULE,FAIL(&quot;You must define MODULE before calling &quot;      \
   &quot;NEEDS_CLASSES_FROM.&quot;))                                                     \
  IF_TOKEN_UNDEFINED(CAPABILITY,FAIL(&quot;You must define CAPABILITY before &quot;      \
   &quot;calling NEEDS_CLASSES_FROM. Please check the rollcall header &quot;             \
   &quot;for &quot; STRINGIFY(MODULE) &quot;.&quot;))                                              \
  IF_TOKEN_UNDEFINED(FUNCTION,FAIL(&quot;You must define FUNCTION before calling &quot;  \
   &quot;NEEDS_CLASSES_FROM. Please check the rollcall header for &quot;                 \
   STRINGIFY(MODULE) &quot;.&quot;))                                                     \
                                                                               \
  namespace Gambit                                                             \
  {                                                                            \
    /* Put everything inside the Models namespace if this is a model-module */ \
    BOOST_PP_IIF(IS_MODEL, namespace Models {, )                               \
                                                                               \
    namespace MODULE                                                           \
    {                                                                          \
                                                                               \
      const int CAT_4(classloading_from_,BACKEND,_for_,FUNCTION) =             \
       set_classload_requirements(Functown::FUNCTION, STRINGIFY(BACKEND),      \
       VERSTRING, STRINGIFY(CAT(Default_,BACKEND)));                           \
                                                                               \
    }                                                                          \
                                                                               \
    /* End Models namespace */                                                 \
    BOOST_PP_IIF(IS_MODEL, }, )                                                \
                                                                               \
  }                                                                            \

/// @}

#endif // defined __core_module_macros_incore_defs_hpp__
</code></pre><hr><p>Updated on 2023-06-26 at 21:36:55 +0000</p></main></div></div></div><footer class="footer text-muted"><div class=container-xxl><div class=row><div class="col-lg-8 order-last order-lg-first"><ul class=list-inline><li class=list-inline-item>Powered by <a href=https://gohugo.io/>Hugo</a> and <a href=https://getdoks.org/>Doks</a></li></ul></div><div class="col-lg-8 order-first order-lg-last text-lg-end"><ul class=list-inline><li class=list-inline-item><a href=/license/>License</a></li></ul></div></div></div></footer><script src=/js/bootstrap.min.a08b5ca912a508bc013bbd939befee438a0d2f798076e860e42147c7c0e2a01cf714847f7f5a2824876ce72867b0182df10e3537711faff352dd1ef41550be7c.js integrity="sha512-oItcqRKlCLwBO72Tm+/uQ4oNL3mAduhg5CFHx8DioBz3FIR/f1ooJIds5yhnsBgt8Q41N3Efr/NS3R70FVC+fA==" crossorigin=anonymous defer></script>
<script src=/js/highlight.min.ce91dadbce67e8eef36fa222c1c74c99f623c836cf6a316dffa1aeb390ab659d9a20d8145ceac39e049c555414fc360d31315e7980535dc6c03eb5374b7d559d.js integrity="sha512-zpHa285n6O7zb6IiwcdMmfYjyDbPajFt/6Gus5CrZZ2aINgUXOrDngScVVQU/DYNMTFeeYBTXcbAPrU3S31VnQ==" crossorigin=anonymous defer></script>
<script src=/main.min.57d9a84956f7d60008c47938c7fdd2f75e8618ff1d09c5a5e2b32f91debaf7681f7ceca8b51aded60067c2136172134a91ebc0674487c76a04e3244d927ebdde.js integrity="sha512-V9moSVb31gAIxHk4x/3S916GGP8dCcWl4rMvkd6692gffOyotRre1gBnwhNhchNKkevAZ0SHx2oE4yRNkn693g==" crossorigin=anonymous defer></script>
<script src=https://gambitbsm.org/index.min.7c5a3f3fba4b44d78b43610b0839d08e269d3130c488a2a07886c879fc495d527b0258c7ac2641a1752112d7fd7ff2b0fbd2a0ae427762583c612e7e7736b31d.js integrity="sha512-fFo/P7pLRNeLQ2ELCDnQjiadMTDEiKKgeIbIefxJXVJ7AljHrCZBoXUhEtf9f/Kw+9KgrkJ3Ylg8YS5+dzazHQ==" crossorigin=anonymous defer></script></body></html>