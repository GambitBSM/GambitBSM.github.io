<!doctype html><html lang=en><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="ie=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><link rel=preload as=font href=https://gambitbsm.org/fonts/vendor/jost/jost-v4-latin-regular.woff2 type=font/woff2 crossorigin><link rel=preload as=font href=https://gambitbsm.org/fonts/vendor/jost/jost-v4-latin-500.woff2 type=font/woff2 crossorigin><link rel=preload as=font href=https://gambitbsm.org/fonts/vendor/jost/jost-v4-latin-700.woff2 type=font/woff2 crossorigin><script>(()=>{var e=localStorage.getItem("theme");e==="dark"&&document.documentElement.setAttribute("data-dark-mode","")})()</script><link rel=stylesheet href=https://gambitbsm.org/main.e0ef67572fa591316dbb2b276e1aed52fd04025355d700a37b20ae76eb126fadbe7ceaddbb47632a2f1bf66c490a69e0cd1f1a0dc12b2980ae4b5ffc6d257d62.css integrity="sha512-4O9nVy+lkTFtuysnbhrtUv0EAlNV1wCjeyCudusSb62+fOrdu0djKi8b9mxJCmngzR8aDcErKYCuS1/8bSV9Yg==" crossorigin=anonymous><noscript><style>img.lazyload{display:none}</style></noscript><meta name=robots content="index, follow"><meta name=googlebot content="index, follow, max-snippet:-1, max-image-preview:large, max-video-preview:-1"><meta name=bingbot content="index, follow, max-snippet:-1, max-image-preview:large, max-video-preview:-1"><title>file sqliteprinter/sqliteprinter.cpp - GAMBIT</title><meta name=description content="[No description available]"><link rel=canonical href=https://gambitbsm.org/documentation/code/files/sqliteprinter_8cpp/><meta property="og:locale" content="en_US"><meta property="og:type" content="article"><meta property="og:title" content="file sqliteprinter/sqliteprinter.cpp"><meta property="og:description" content="[No description available]"><meta property="og:url" content="https://gambitbsm.org/documentation/code/files/sqliteprinter_8cpp/"><meta property="og:site_name" content="GAMBIT"><meta property="og:image" content="https://gambitbsm.org/gambit_logo.png"><meta property="og:image:alt" content="GAMBIT"><meta name=twitter:card content="summary_large_image"><meta name=twitter:site content><meta name=twitter:creator content><meta name=twitter:title content="file sqliteprinter/sqliteprinter.cpp"><meta name=twitter:description content="[No description available]"><meta name=twitter:image content="https://gambitbsm.org/gambit_logo.png"><meta name=twitter:image:alt content="file sqliteprinter/sqliteprinter.cpp"><script type=application/ld+json>{"@context":"https://schema.org","@graph":[{"@type":"Organization","@id":"https://gambitbsm.org/#/schema/organization/1","name":"Doks","url":"https://gambitbsm.org/","sameAs":["https://github.com/GambitBSM"],"logo":{"@type":"ImageObject","@id":"https://gambitbsm.org/#/schema/image/1","url":"https://gambitbsm.org/logo-doks.png","width":450,"height":416,"caption":"Doks"},"image":{"@id":"https://gambitbsm.org/#/schema/image/1"}},{"@type":"WebSite","@id":"https://gambitbsm.org/#/schema/website/1","url":"https://gambitbsm.org/","name":"GAMBIT","description":"Documentation for GAMBIT, the Global And Modular BSM Inference Tool","publisher":{"@id":"https://gambitbsm.org/#/schema/organization/1"}},{"@type":"WebPage","@id":"https://gambitbsm.org/documentation/code/files/sqliteprinter_8cpp/","url":"https://gambitbsm.org/documentation/code/files/sqliteprinter_8cpp/","name":"file sqliteprinter\/sqliteprinter.cpp","description":"[No description available]","isPartOf":{"@id":"https://gambitbsm.org/#/schema/website/1"},"about":{"@id":"https://gambitbsm.org/#/schema/organization/1"},"datePublished":"0001-01-01T00:00:00CET","dateModified":"0001-01-01T00:00:00CET","breadcrumb":{"@id":"https://gambitbsm.org/documentation/code/files/sqliteprinter_8cpp/#/schema/breadcrumb/1"},"primaryImageOfPage":{"@id":"https://gambitbsm.org/documentation/code/files/sqliteprinter_8cpp/#/schema/image/2"},"inLanguage":"en-US","potentialAction":[{"@type":"ReadAction","target":["https://gambitbsm.org/documentation/code/files/sqliteprinter_8cpp/"]}]},{"@type":"BreadcrumbList","@id":"https://gambitbsm.org/documentation/code/files/sqliteprinter_8cpp/#/schema/breadcrumb/1","name":"Breadcrumbs","itemListElement":[{"@type":"ListItem","position":1,"item":{"@type":"WebPage","@id":"https://gambitbsm.org/","url":"https://gambitbsm.org/","name":"Home"}},{"@type":"ListItem","position":2,"item":{"@type":"WebPage","@id":"https://gambitbsm.org/documentation/","url":"https://gambitbsm.org/documentation/","name":"Documentation"}},{"@type":"ListItem","position":3,"item":{"@type":"WebPage","@id":"https://gambitbsm.org/documentation/code/","url":"https://gambitbsm.org/documentation/code/","name":"Code"}},{"@type":"ListItem","position":4,"item":{"@type":"WebPage","@id":"https://gambitbsm.org/documentation/code/files/","url":"https://gambitbsm.org/documentation/code/files/","name":"Files"}},{"@type":"ListItem","position":5,"item":{"@id":"https://gambitbsm.org/documentation/code/files/sqliteprinter_8cpp/"}}]},{"@context":"https://schema.org","@graph":[{"@type":"ImageObject","@id":"https://gambitbsm.org/documentation/code/files/sqliteprinter_8cpp/#/schema/image/2","url":"https://gambitbsm.org/gambit_logo.png","contentUrl":"https://gambitbsm.org/gambit_logo.png","caption":"file sqliteprinter\/sqliteprinter.cpp"}]}]}</script><meta name=theme-color content="#fff"><link rel=icon href=https://gambitbsm.org/favicon.ico sizes=any><link rel=icon type=image/svg+xml href=https://gambitbsm.org/favicon.svg><link rel=apple-touch-icon sizes=180x180 href=https://gambitbsm.org/apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=https://gambitbsm.org/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=https://gambitbsm.org/favicon-16x16.png><link rel=manifest crossorigin=use-credentials href=https://gambitbsm.org/site.webmanifest></head><body class="documentation single light"><div class=sticky-top><div class=header-bar></div><header class="navbar navbar-expand-md navbar-light doks-navbar"><nav class="container-xxl flex-wrap flex-md-nowrap" aria-label="Main navigation"><a class="navbar-brand p-0 me-auto" href=https://gambitbsm.org/ aria-label=GAMBIT><img class=logo-light src=https://gambitbsm.org/gambit_logo.png width=50px>
<img class="logo-dark d-none" src=https://gambitbsm.org/gambit_logo.png width=50px>
GAMBIT</a>
<button class="btn btn-menu order-2 d-block d-lg-none" type=button data-bs-toggle=offcanvas data-bs-target=#offcanvasDoks aria-controls=offcanvasDoks aria-label="Open main menu"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-menu"><line x1="3" y1="12" x2="21" y2="12"/><line x1="3" y1="6" x2="21" y2="6"/><line x1="3" y1="18" x2="21" y2="18"/></svg></button><div class="offcanvas offcanvas-end border-0 py-lg-1" tabindex=-1 id=offcanvasDoks data-bs-backdrop=true aria-labelledby=offcanvasDoksLabel><div class="header-bar d-lg-none"></div><div class="offcanvas-header d-lg-none"><h2 class="h5 offcanvas-title ps-2" id=offcanvasDoksLabel><a class=text-dark href=/>GAMBIT</a></h2><button type=button class="btn-close text-reset me-2" data-bs-dismiss=offcanvas aria-label="Close main menu"></button></div><div class="offcanvas-body p-4 p-lg-0"><ul class="nav flex-column flex-lg-row align-items-lg-center mt-2 mt-lg-0 ms-lg-2 me-lg-auto"><li class="nav-item dropdown"><a class="nav-link dropdown-toggle ps-0 py-1" href=# id=navbarDropdownMenuLink role=button data-bs-toggle=dropdown aria-expanded=false>Releases
<span class=dropdown-caret><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-chevron-down"><polyline points="6 9 12 15 18 9"/></svg></span></a><ul class="dropdown-menu dropdown-menu-main shadow rounded border-0" aria-labelledby=navbarDropdownMenuLink><li><a class=dropdown-item href=https://github.com/GambitBSM/gambit_2.6>GAMBIT 2-6 ⧉</a></li><li><a class=dropdown-item href=https://github.com/GambitBSM/gambit_2.5>GAMBIT 2-5 ⧉</a></li><li><a class=dropdown-item href=https://github.com/GambitBSM/gambit_2.4>GAMBIT 2-4 ⧉</a></li><li><a class=dropdown-item href=https://github.com/GambitBSM/gambit_2.3>GAMBIT 2-3 ⧉</a></li><li><a class=dropdown-item href=https://github.com/GambitBSM/gambit_2.2>GAMBIT 2-2 ⧉</a></li><li><a class=dropdown-item href=https://github.com/GambitBSM/gambit_2.1>GAMBIT 2-1 ⧉</a></li><li><a class=dropdown-item href=https://github.com/GambitBSM/gambit_light_1.0>GAMBIT Light ⧉</a></li><li><a class=dropdown-item href=https://github.com/GambitBSM/gambit_2.6/tags>All releases ⧉</a></li></ul></li><li class="nav-item dropdown"><a class="nav-link dropdown-toggle ps-0 py-1" href=# id=navbarDropdownMenuLink role=button data-bs-toggle=dropdown aria-expanded=false>Documentation
<span class=dropdown-caret><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-chevron-down"><polyline points="6 9 12 15 18 9"/></svg></span></a><ul class="dropdown-menu dropdown-menu-main shadow rounded border-0" aria-labelledby=navbarDropdownMenuLink><li><a class=dropdown-item href=/documentation/installation/introduction/>Installation</a></li><li><a class=dropdown-item href=/documentation/physics/analyses>Physics</a></li><li><a class=dropdown-item href=/documentation/tutorials/the_gambit_interface>Tutorials</a></li><li><a class=dropdown-item href=/documentation/help/common_problems_and_questions/>Help</a></li><li><a class=dropdown-item href=/documentation/code/index_classes>Code Reference</a></li></ul></li><li class="nav-item dropdown"><a class="nav-link dropdown-toggle ps-0 py-1" href=# id=navbarDropdownMenuLink role=button data-bs-toggle=dropdown aria-expanded=false>Community
<span class=dropdown-caret><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-chevron-down"><polyline points="6 9 12 15 18 9"/></svg></span></a><ul class="dropdown-menu dropdown-menu-main shadow rounded border-0" aria-labelledby=navbarDropdownMenuLink><li><a class=dropdown-item href=https://github.com/GambitBSM/wiki>Wiki</a></li><li><a class=dropdown-item href=/community/publications/>Publications</a></li><li><a class=dropdown-item href=/community/talks/>Talks</a></li><li><a class=dropdown-item href=/community/members/>Members</a></li><li><a class=dropdown-item href=/community/code_of_conduct/>Code of Conduct</a></li><li><a class=dropdown-item href=/community/contact/>Contact</a></li></ul></li></ul><hr class="text-black-50 my-4 d-lg-none"><form class="doks-search position-relative flex-grow-1 ms-lg-auto me-lg-2"><input id=search class="form-control is-search" type=search placeholder="Search site..." aria-label="Search site..." autocomplete=off><div id=suggestions class="shadow bg-white rounded d-none"></div></form><hr class="text-black-50 my-4 d-lg-none"><ul class="nav flex-column flex-lg-row"><li class=nav-item><a class="nav-link social-link" href=https://github.com/GambitBSM><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-github"><path d="M9 19c-5 1.5-5-2.5-7-3m14 6v-3.87a3.37 3.37.0 00-.94-2.61c3.14-.35 6.44-1.54 6.44-7A5.44 5.44.0 0020 4.77 5.07 5.07.0 0019.91 1S18.73.65 16 2.48a13.38 13.38.0 00-7 0C6.27.65 5.09 1 5.09 1A5.07 5.07.0 005 4.77 5.44 5.44.0 003.5 8.55c0 5.42 3.3 6.61 6.44 7A3.37 3.37.0 009 18.13V22"/></svg><small class="ms-2 d-lg-none">GitHub</small></a></li></ul><hr class="text-black-50 my-4 d-lg-none"><button id=mode class="btn btn-link" type=button aria-label="Toggle user interface mode">
<span class=toggle-dark><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-moon"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg></span><span class=toggle-light><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-sun"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></span></button></div></div></nav></header></div><div class="wrap container-xxl" role=document><div class=content><div class="row flex-xl-nowrap"><div class="col-lg-5 col-xl-4 docs-sidebar"><nav class=docs-links aria-label="Main navigation"><ul class="list-unstyled collapsible-sidebar"><li class=mb-1><button class="btn btn-toggle align-items-center rounded collapsed" data-bs-toggle=collapse data-bs-target=#section-installation aria-expanded=false>
Installation</button><div class=collapse id=section-installation><ul class="btn-toggle-nav list-unstyled fw-normal pb-1 small"><li><a class="docs-link rounded" href=/documentation/installation/introduction/>Getting Started</a></li><li><a class="docs-link rounded" href=/documentation/installation/docker_usage/>Docker Usage</a></li><li><a class="docs-link rounded" href=/documentation/installation/installation_for_linux/>Installation for Linux</a></li><li><a class="docs-link rounded" href=/documentation/installation/installation_for_windows/>Installation for Windows</a></li><li><a class="docs-link rounded" href=/documentation/installation/installation_for_macos/>Installation for macOS</a></li></ul></div></li><li class=mb-1><button class="btn btn-toggle align-items-center rounded collapsed" data-bs-toggle=collapse data-bs-target=#section-tutorials aria-expanded=false>
Tutorials</button><div class=collapse id=section-tutorials><ul class="btn-toggle-nav list-unstyled fw-normal pb-1 small"><li><a class="docs-link rounded" href=/documentation/tutorials/the_gambit_interface/>1 - The GAMBIT Interface</a></li><li><a class="docs-link rounded" href=/documentation/tutorials/in_person_tutorials/>In person tutorials</a></li></ul></div></li><li class=mb-1><button class="btn btn-toggle align-items-center rounded collapsed" data-bs-toggle=collapse data-bs-target=#section-physics aria-expanded=false>
Physics</button><div class=collapse id=section-physics><ul class="btn-toggle-nav list-unstyled fw-normal pb-1 small"><li><a class="docs-link rounded" href=/documentation/physics/analyses/>ColliderBit analysis</a></li></ul></div></li><li class=mb-1><button class="btn btn-toggle align-items-center rounded collapsed" data-bs-toggle=collapse data-bs-target=#section-help aria-expanded=false>
Help</button><div class=collapse id=section-help><ul class="btn-toggle-nav list-unstyled fw-normal pb-1 small"><li><a class="docs-link rounded" href=/documentation/help/common_problems_and_questions/>Common Problems and Questions</a></li><li><a class="docs-link rounded" href=/documentation/help/compiler_matrix/>Compiler Matrix</a></li><li><a class="docs-link rounded" href=/documentation/help/known_issues/>Known Issues</a></li><li><a class="docs-link rounded" href=/documentation/help/configuration_examples/>Configuration Examples</a></li><li><a class="docs-link rounded" href=/documentation/help/support/>Support</a></li></ul></div></li><li class=mb-1><button class="btn btn-toggle align-items-center rounded collapsed" data-bs-toggle=collapse data-bs-target=#section-code aria-expanded=false>
Code Reference</button><div class=collapse id=section-code><ul class="btn-toggle-nav list-unstyled fw-normal pb-1 small"><li><a class="docs-link rounded" href=/documentation/code/index_classes/>Classes</a></li><li><a class="docs-link rounded" href=/documentation/code/index_files/>Files</a></li><li><a class="docs-link rounded" href=/documentation/code/index_pages/>Pages</a></li><li><a class="docs-link rounded" href=/documentation/code/index_namespaces/>Namespaces</a></li></ul></div></li></ul></nav></div><nav class="docs-toc d-none d-xl-block col-xl-3" aria-label="Secondary navigation"><div class=d-xl-none><button class="btn btn-outline-primary btn-sm doks-toc-toggle collapsed" type=button data-bs-toggle=collapse data-bs-target=#onThisPage aria-controls=doks-docs-nav aria-expanded=false aria-label="Toggle On this page navigation">
<span>On this page</span>
<span><svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24" class="doks doks-expand" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><title>Expand</title><polyline points="7 13 12 18 17 13"/><polyline points="7 6 12 11 17 6"/></svg><svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24" class="doks doks-collapse" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><title>Collapse</title><polyline points="17 11 12 6 7 11"/><polyline points="17 18 12 13 7 18"/></svg></span></button><div class=collapse id=onThisPage><div class="card card-body mt-3 py-1"><div class=page-links><nav id=TableOfContents><ul><li><a href=#namespaces>Namespaces</a></li><li><a href=#defines>Defines</a></li><li><a href=#detailed-description>Detailed Description</a></li><li><a href=#macros-documentation>Macros Documentation</a><ul><li><a href=#define-sql-debug>define SQL_DEBUG</a></li></ul></li><li><a href=#source-code>Source code</a></li></ul></nav></div></div></div></div><div class="page-links d-none d-xl-block"><h3>On this page</h3><nav id=TableOfContents><ul><li><a href=#namespaces>Namespaces</a></li><li><a href=#defines>Defines</a></li><li><a href=#detailed-description>Detailed Description</a></li><li><a href=#macros-documentation>Macros Documentation</a><ul><li><a href=#define-sql-debug>define SQL_DEBUG</a></li></ul></li><li><a href=#source-code>Source code</a></li></ul></nav></div></nav><main class="docs-content col-lg-11 col-xl-9 mx-xl-auto"><nav aria-label=breadcrumb><ol class=breadcrumb><li class=breadcrumb-item><a href=/>Home</a></li><li class=breadcrumb-item><a href=/documentation/>Documentation</a></li><li class=breadcrumb-item><a href=/documentation/code/>Code Reference</a></li><li class="breadcrumb-item active" aria-current=page>file sqliteprinter/sqliteprinter.cpp</li></ol></nav><p class=lead></p><h1 id=file-sqliteprinter-sqliteprinter-cpp>file sqliteprinter/sqliteprinter.cpp <a href=#file-sqliteprinter-sqliteprinter-cpp class=anchor aria-hidden=true>#</a></h1><p>[No description available] <a href=#detailed-description>More&mldr;</a></p><h2 id=namespaces>Namespaces <a href=#namespaces class=anchor aria-hidden=true>#</a></h2><table><thead><tr><th>Name</th></tr></thead><tbody><tr><td><strong><a href=/documentation/code/namespaces/namespacegambit/>Gambit</a></strong><br>TODO: see if we can use this one:</td></tr><tr><td><strong><a href=/documentation/code/namespaces/namespacegambit_1_1printers/>Gambit::Printers</a></strong><br>Forward declaration.</td></tr></tbody></table><h2 id=defines>Defines <a href=#defines class=anchor aria-hidden=true>#</a></h2><table><thead><tr><th></th><th>Name</th></tr></thead><tbody><tr><td></td><td><strong><a href=/documentation/code/files/sqliteprinter_8cpp/#define-sql-debug>SQL_DEBUG</a></strong></td></tr></tbody></table><h2 id=detailed-description>Detailed Description <a href=#detailed-description class=anchor aria-hidden=true>#</a></h2><p><strong>Author</strong>: Ben Farmer (<a href=mailto:b.farmer@imperial.ac.uk>b.farmer@imperial.ac.uk</a>)</p><p><strong>Date</strong>: 2018 Dec</p><p>SQLite printer class member function definitions</p><hr><p>Authors (add name and date if you modify):</p><hr><p>TODO: Turns out SQLite is case-insensitive, so need to change various string comparisons here to also be case-insensitive.</p><h2 id=macros-documentation>Macros Documentation <a href=#macros-documentation class=anchor aria-hidden=true>#</a></h2><h3 id=define-sql-debug>define SQL_DEBUG <a href=#define-sql-debug class=anchor aria-hidden=true>#</a></h3><pre><code>#define SQL_DEBUG 
</code></pre><h2 id=source-code>Source code <a href=#source-code class=anchor aria-hidden=true>#</a></h2><pre><code>//   GAMBIT: Global and Modular BSM Inference Tool
//   *********************************************
///  \file
///
///  SQLite printer class member function definitions
///
///  *********************************************
///
///  Authors (add name and date if you modify):
///
///  \author Ben Farmer
///          (b.farmer@imperial.ac.uk)
///  \date 2018 Dec
///
///  *********************************************
///
///  TODO: Turns out SQLite is case-insensitive, so need
///  to change various string comparisons here to also be
///  case-insensitive.

#include &lt;iostream&gt;
#include &lt;sstream&gt;
#include &lt;chrono&gt;
#include &lt;thread&gt;

// SQLite3 C interface
#include &lt;sqlite3.h&gt;

// Gambit
#include &quot;gambit/Printers/printers/sqliteprinter.hpp&quot;
#include &quot;gambit/Logs/logger.hpp&quot;

// Define this macro to dump attempted SQL statements during exceptions
#define SQL_DEBUG

namespace Gambit
{
  namespace Printers
  {

    // Constructor
    SQLitePrinter::SQLitePrinter(const Options&amp; options, BasePrinter* const primary)
    : BasePrinter(primary,options.getValueOrDef&lt;bool&gt;(false,&quot;auxilliary&quot;))
    , SQLiteBase()
#ifdef WITH_MPI
    , myComm() // initially attaches to MPI_COMM_WORLD
#endif
    , mpiRank(0)
    , mpiSize(1)
    , primary_printer(NULL)
    , column_record()
    , lastMetadataID(0)
    , lastPointID(nullpoint)
    , max_buffer_length(options.getValueOrDef&lt;std::size_t&gt;(1,&quot;buffer_length&quot;))
    , buffer_info()
    , buffer_header()
    , transaction_data_buffer()
    , synchronised(!options.getValueOrDef&lt;bool&gt;(false,&quot;auxilliary&quot;))
    {
        std::string database_file;
        std::string table_name;
        std::string metadata_table_name;

        if(is_auxilliary_printer())
        {
            // If this is an &quot;auxilliary&quot; printer then we need to get some
            // of our options from the primary printer
            primary_printer     = dynamic_cast&lt;SQLitePrinter*&gt;(this-&gt;get_primary_printer());
            database_file       = primary_printer-&gt;get_database_file();
            table_name          = primary_printer-&gt;get_table_name();
            metadata_table_name = primary_printer-&gt;get_metadata_table_name();
            max_buffer_length   = primary_printer-&gt;get_max_buffer_length();
        }
        else
        {
            // MPI setup
#ifdef WITH_MPI
            this-&gt;setRank(myComm.Get_rank()); // tells base class about rank
            mpiRank = myComm.Get_rank();
            mpiSize = myComm.Get_size();
#endif

            // Register dataset names that this printer needs to use itself
            // (&quot;MPIrank&quot; and &quot;pointID&quot; are always automatically registered)
            addToPrintList(&quot;pairID&quot;);

            // Tell scannerbit if we are resuming
            set_resume(options.getValue&lt;bool&gt;(&quot;resume&quot;));

            // Get path of database file where results should ultimately end up
            std::ostringstream ff;
            if(options.hasKey(&quot;output_path&quot;))
            {
                ff &lt;&lt; options.getValue&lt;std::string&gt;(&quot;output_path&quot;) &lt;&lt; &quot;/&quot;;
            }
            else
            {
                ff &lt;&lt; options.getValue&lt;std::string&gt;(&quot;default_output_path&quot;) &lt;&lt; &quot;/&quot;;
            }

            if(options.hasKey(&quot;output_file&quot;))
            {
                ff &lt;&lt; options.getValue&lt;std::string&gt;(&quot;output_file&quot;);
            }
            else
            {
                printer_error().raise(LOCAL_INFO, &quot;No 'output_file' entry specified in the options section of the Printer category of the input YAML file. Please add a name there for the output sqlite database file of the scan.&quot;);
            }

            database_file = ff.str();

            // Get the name of the data table for this run
            table_name = options.getValueOrDef&lt;std::string&gt;(&quot;results&quot;,&quot;table_name&quot;);
            metadata_table_name = options.getValueOrDef&lt;std::string&gt;(&quot;metadata&quot;, &quot;metadata_table_name&quot;);

            // Delete final target file if one with same name already exists? (and if we are restarting the run)
            // Mostly for convenience during testing. Recommend to use 'false' for serious runs to avoid
            // accidentally deleting valuable output.
            bool overwrite_file  = options.getValueOrDef&lt;bool&gt;(false,&quot;delete_file_on_restart&quot;);

            if(getRank()==0 and overwrite_file and not get_resume())
            {
                // Note: &quot;not resume&quot; means &quot;start or restart&quot;
                // Delete existing output file
                std::ostringstream command;
                command &lt;&lt; &quot;rm -f &quot;&lt;&lt;database_file;
                logger() &lt;&lt; LogTags::printers &lt;&lt; LogTags::info &lt;&lt; &quot;Running shell command: &quot; &lt;&lt; command.str() &lt;&lt; EOM;
                FILE* fp = popen(command.str().c_str(), &quot;r&quot;);
                if(fp==NULL)
                {
                    // Error running popen
                    std::ostringstream errmsg;
                    errmsg &lt;&lt; &quot;rank &quot;&lt;&lt;getRank()&lt;&lt;&quot;: Error deleting existing output file (requested by 'delete_file_on_restart' printer option; target filename is &quot;&lt;&lt;database_file&lt;&lt;&quot;)! popen failed to run the command (command was '&quot;&lt;&lt;command.str()&lt;&lt;&quot;')&quot;;
                    printer_error().raise(LOCAL_INFO, errmsg.str());
                }
                else if(pclose(fp)!=0)
                {
                    // Command returned exit code!=0, or pclose failed
                    std::ostringstream errmsg;
                    errmsg &lt;&lt; &quot;rank &quot;&lt;&lt;getRank()&lt;&lt;&quot;: Error deleting existing output file (requested by 'delete_file_on_restart' printer option; target filename is &quot;&lt;&lt;database_file&lt;&lt;&quot;)! Shell command failed to executed successfully, see stderr (command was '&quot;&lt;&lt;command.str()&lt;&lt;&quot;').&quot;;
                    printer_error().raise(LOCAL_INFO, errmsg.str());
                }
            }

#ifdef WITH_MPI
            // Make sure no processes try to open database until we are sure it won't be deleted and replaced
            myComm.Barrier();
#endif
        }

        // Create/open the database file
        open_db(database_file,'+');

        // Create the results table in the database (if it doesn't already exist)
        make_table(table_name);
        make_metadata_table(metadata_table_name);
        set_table_name(table_name); // Inform base class of table name
        set_metadata_table_name(metadata_table_name);

        // If we are resuming and this is the primary printer, need to read the database and find the previous
        // highest pointID numbers used for this rank
        std::size_t my_highest_pointID=0;
        if(not is_auxilliary_printer() and get_resume())
        {
            // Construct the SQLite3 statement to retrieve highest existing pointID in the database for this rank
            std::stringstream sql;
            sql &lt;&lt; &quot;SELECT MAX(pointID) FROM &quot;&lt;&lt;get_table_name()&lt;&lt;&quot; WHERE MPIrank=&quot;&lt;&lt;mpiRank;

            /* Execute SQL statement and iterate through results*/
            sqlite3_stmt *stmt;
            int rc = sqlite3_prepare_v2(get_db(), sql.str().c_str(), -1, &amp;stmt, NULL);
            if (rc != SQLITE_OK)
            {
                std::stringstream err;
                err&lt;&lt;&quot;Encountered SQLite error while preparing to retrieve previous pointIDs: &quot;&lt;&lt;sqlite3_errmsg(get_db());
                printer_error().raise(LOCAL_INFO, err.str());
            }
            int colcount=0;
            while ((rc = sqlite3_step(stmt)) == SQLITE_ROW)
            {
                my_highest_pointID = sqlite3_column_int64(stmt, 0);
                colcount++;
                if(colcount&gt;1)
                {
                    std::stringstream err;
                    err&lt;&lt;&quot;SQLite statement to retrieve highest existing pointID returned more than one result! This doesn't make sense, so there is probably a bug in the statement that was used. Statement was: &quot;&lt;&lt;sql.str();
                    printer_error().raise(LOCAL_INFO, err.str());
                }
            }
            if (rc != SQLITE_DONE) {
                std::stringstream err;
                err&lt;&lt;&quot;Encountered SQLite error while retrieving previous pointIDs: &quot;&lt;&lt;sqlite3_errmsg(get_db());
                printer_error().raise(LOCAL_INFO, err.str());
            }
            sqlite3_finalize(stmt);

            // Read off last metadata entry
            std::stringstream sql2;
            sql2 &lt;&lt; &quot;SELECT MAX(metadataID) FROM &quot; &lt;&lt; get_metadata_table_name() &lt;&lt; &quot;;&quot;;
            sqlite3_stmt *stmt2;
            rc = sqlite3_prepare_v2(get_db(), sql2.str().c_str(), -1, &amp;stmt2, NULL);
            if (rc != SQLITE_OK)
            {
                std::stringstream err;
                err&lt;&lt;&quot;Encountered SQLite error while preparing to retrieve previous metadataIDs: &quot;&lt;&lt;sqlite3_errmsg(get_db());
                printer_error().raise(LOCAL_INFO, err.str());
            }
            colcount=0;
            while ((rc = sqlite3_step(stmt2)) == SQLITE_ROW)
            {
                lastMetadataID = sqlite3_column_int64(stmt2, 0);
                lastMetadataID++;
                colcount++;
                if(colcount&gt;1)
                {
                    std::stringstream err;
                    err&lt;&lt;&quot;SQLite statement to retrieve highest existing metadataID returned more than one result! This doesn't make sense, so there is probably a bug in the statement that was used. Statement was: &quot;&lt;&lt;sql.str();
                    printer_error().raise(LOCAL_INFO, err.str());
                }
            }
            if (rc != SQLITE_DONE)
            {
                std::stringstream err;
                err&lt;&lt;&quot;Encountered SQLite error while retrieving previous pointIDs: &quot;&lt;&lt;sqlite3_errmsg(get_db());
                printer_error().raise(LOCAL_INFO, err.str());
            }
            sqlite3_finalize(stmt2);

            // Need to make sure no other processes start adding new stuff before everyone has figured out
            // their next unused pointID
#ifdef WITH_MPI
            myComm.Barrier();
#endif
            if (get_resume())
            {
                get_point_id() = my_highest_pointID;
            }

            // DEBUG
            //std::cout&lt;&lt;&quot;Highest pointID retrieved for rank &quot;&lt;&lt;mpiRank&lt;&lt;&quot; was: &quot;&lt;&lt;get_point_id();
        }
    }

    std::size_t SQLitePrinter::get_max_buffer_length() {return max_buffer_length;}

    void SQLitePrinter::initialise(const std::vector&lt;int&gt;&amp;)
    {
        // Don't need to initialise anything for this printer
    }

    void SQLitePrinter::reset(bool force)
    {
        // This is needed by e.g. MultiNest to delete old weights and replace them
        // with new ones.

        lastPointID = nullpoint;

        // Primary printers aren't allowed to delete stuff unless 'force' is set to true
        if((is_auxilliary_printer() or force) and (buffer_header.size()&gt;0))
        {
            // Read through header to see what columns this printer has been touching. These are
            // the ones that we will reset/delete.
            // (a more nuanced reset might be required in the future?)
            std::stringstream sql;
            sql&lt;&lt;&quot;UPDATE &quot;&lt;&lt;get_table_name()&lt;&lt;&quot; SET &quot;;
            for(auto col_name_it=buffer_header.begin(); col_name_it!=buffer_header.end(); ++col_name_it)
            {
                sql&lt;&lt;&quot;`&quot;&lt;&lt;(*col_name_it)&lt;&lt;&quot;`=null&quot;&lt;&lt;comma_unless_last(col_name_it,buffer_header);
            }
            sql&lt;&lt;&quot;;&quot;;

            /* Execute SQL statement */
            submit_sql(LOCAL_INFO, sql.str());
        }
    }

    // Print metadata info to file
    void SQLitePrinter::_print_metadata(map_str_str metadata)
    {

      std::stringstream sql;

      // Create columns first
      for (auto key_value : metadata)
      {
        str col_type;
        if (key_value.first == &quot;YAML&quot;)
          col_type = &quot;LONGTEXT&quot;;
        else
          col_type = &quot;MEDIUMTEXT&quot;;

        ensure_column_exists(get_metadata_table_name(), key_value.first, col_type);
      }

      // Now add data
      sql &lt;&lt; &quot; INSERT INTO &quot; &lt;&lt; get_metadata_table_name() &lt;&lt;&quot; (\nmetadataID,\n&quot;;
      for(auto col_name_it=metadata.begin(); col_name_it!=metadata.end(); ++col_name_it)
      {
          sql&lt;&lt;&quot;`&quot;&lt;&lt; col_name_it-&gt;first &lt;&lt;&quot;`&quot;&lt;&lt;comma_unless_last(col_name_it,metadata)&lt;&lt;&quot;\n&quot;;
      }
      sql &lt;&lt; &quot;) VALUES (\n&quot;;
      size_t metadataID = lastMetadataID;
      sql &lt;&lt; metadataID &lt;&lt; &quot;,&quot;;
      for(auto row_it=metadata.begin(); row_it!=metadata.end(); ++row_it)
      {
        sql &lt;&lt; &quot;\&quot;&quot; &lt;&lt; row_it-&gt;second &lt;&lt; &quot;\&quot;&quot; &lt;&lt; comma_unless_last(row_it,metadata);
      }
      sql&lt;&lt;&quot;);&quot;; // End statement

      /* Execute SQL statement */
      int rc;
      char *zErrMsg = 0;
      // Need allow_fail=true for this case
      rc = submit_sql(LOCAL_INFO, sql.str(), true, NULL, NULL, &amp;zErrMsg);

      if( rc != SQLITE_OK )
      {
        std::stringstream err;
        err &lt;&lt; &quot;Failed to add metadata to output SQL table! The SQL error was: &quot; &lt;&lt; zErrMsg &lt;&lt; std::endl;
//#ifdef SQL_DEBUG
        err &lt;&lt; &quot;The attempted SQL statement was:&quot;&lt;&lt;std::endl;
        err &lt;&lt; sql.str() &lt;&lt; std::endl;
//#endif
        sqlite3_free(zErrMsg);
        printer_error().raise(LOCAL_INFO,err.str());
      }
    }


    void SQLitePrinter::finalise(bool /*abnormal*/)
    {
      // Dump buffer to disk. Nothing special needed for early shutdown.
      dump_buffer();

      // Add last point ID to metadata
      if (get_output_metadata())
      {
        std::stringstream ssPPID;
        ssPPID &lt;&lt; lastPointID;

        std::stringstream sql;
        ensure_column_exists(get_metadata_table_name(), &quot;lastPointID&quot;, &quot;MEDIUMTEXT&quot;);
        sql &lt;&lt; &quot; UPDATE &quot; &lt;&lt; get_metadata_table_name() &lt;&lt; &quot; SET lastPointID = \&quot;&quot; &lt;&lt; ssPPID.str() &lt;&lt; &quot;\&quot; WHERE metadataID = &quot; &lt;&lt; lastMetadataID &lt;&lt; &quot;;\n&quot;;

        /* Execute SQL statement */
        int rc;
        char *zErrMsg = 0;
        // Need allow_fail=true for this case
        rc = submit_sql(LOCAL_INFO, sql.str(), true, NULL, NULL, &amp;zErrMsg);

        if( rc != SQLITE_OK )
        {
          std::stringstream err;
          err &lt;&lt; &quot;Failed to add metadata to output SQL table! The SQL error was: &quot; &lt;&lt; zErrMsg &lt;&lt; std::endl;
//#ifdef SQL_DEBUG
          err &lt;&lt; &quot;The attempted SQL statement was:&quot;&lt;&lt;std::endl;
          err &lt;&lt; sql.str() &lt;&lt; std::endl;
//#endif
          sqlite3_free(zErrMsg);
          printer_error().raise(LOCAL_INFO,err.str());
        }

      }

    }

    void SQLitePrinter::flush()
    {
        dump_buffer();
    }

    // Reader construction options for constructing a reader
    // object that can read the output we are printing
    Options SQLitePrinter::resume_reader_options()
    {
        Options options;
        // Set options that we need later to construct a reader object for
        // previous output, if required.
        options.setValue(&quot;type&quot;, &quot;sqlite&quot;);
        options.setValue(&quot;file&quot;, get_database_file());
        options.setValue(&quot;table&quot;, get_table_name());
        return options;
    }

    // Create results table
    void SQLitePrinter::make_table(const std::string&amp; name)
    {
        // Construct the SQLite3 statement
        std::stringstream sql;
        sql &lt;&lt; &quot;CREATE TABLE IF NOT EXISTS &quot;&lt;&lt;name&lt;&lt;&quot;(&quot;
            &lt;&lt; &quot;pairID   INT PRIMARY KEY NOT NULL,&quot;
            &lt;&lt; &quot;MPIrank  INT,&quot;
            &lt;&lt; &quot;pointID  INT&quot;
            &lt;&lt; &quot;);&quot;;

        /* Execute SQL statement */
        submit_sql(LOCAL_INFO, sql.str());

        // Flag the results table as existing
        set_table_exists();
    }

    // Create the metadata table
    void SQLitePrinter::make_metadata_table(const std::string&amp; name)
    {
        // Construct the SQLite3 statement
        std::stringstream sql;
        sql &lt;&lt; &quot;CREATE TABLE IF NOT EXISTS &quot;&lt;&lt;name&lt;&lt;&quot;(&quot;
            &lt;&lt; &quot;metadataID   INT PRIMARY KEY NOT NULL);&quot;;

        /* Execute SQL statement */
        submit_sql(LOCAL_INFO, sql.str());

        // Flag the results table as existing
        set_table_exists();
    }


    // Check that a table column exists with the correct type, and create it if needed
    void SQLitePrinter::ensure_column_exists(const std::string&amp; sql_table_name, const std::string&amp; sql_col_name, const std::string&amp; sql_col_type)
    {
        require_output_ready();
        auto it = column_record.find(sql_col_name);
        if(it == column_record.end())
        {
            // Column not marked as existing. But it might have been
            // created by another process, so we need to check the
            // database directly. It seems like the best way to do
            // this is to just attempt to add the column. If it fails
            // we can then explicitly check the column names to
            // make sure that the reason for failure was because
            // the column already existed, and not some other reason.

            std::stringstream sql;
            sql&lt;&lt;&quot;ALTER TABLE &quot;&lt;&lt;sql_table_name&lt;&lt;&quot; ADD COLUMN `&quot;&lt;&lt;sql_col_name&lt;&lt;&quot;` &quot;&lt;&lt;sql_col_type&lt;&lt;&quot;;&quot;;

            /* Execute SQL statement */
            int rc;
            char *zErrMsg = 0;
            // Need allow_fail=true for this case
            rc = submit_sql(LOCAL_INFO, sql.str(), true, NULL, NULL, &amp;zErrMsg);

            if( rc != SQLITE_OK ){
                // Operation failed for some reason. Probably because the column already
                // exists, but we better make sure.

                std::stringstream sql2;
                sql2&lt;&lt;&quot;PRAGMA table_info(&quot;&lt;&lt;sql_table_name&lt;&lt;&quot;);&quot;;

                /* Execute SQL statement */
                int rc2;
                char *zErrMsg2 = 0;
                std::map&lt;std::string, std::string, Utils::ci_less&gt; colnames; // Will be passed to and filled by the callback function
                rc2 = submit_sql(LOCAL_INFO, sql2.str(), true, &amp;col_name_callback, &amp;colnames, &amp;zErrMsg2);

                if( rc2 != SQLITE_OK ){
                    std::stringstream err;
                    err &lt;&lt; &quot;Failed to check SQL column names in output table, after failing to add a new column '&quot;&lt;&lt;sql_col_name&lt;&lt;&quot;' to that table.&quot;&lt;&lt;std::endl;
                    err &lt;&lt; &quot;  First SQL error was: &quot; &lt;&lt; zErrMsg &lt;&lt; std::endl;
#ifdef SQL_DEBUG
                    err &lt;&lt; &quot;  The attempted SQL statement was:&quot;&lt;&lt;std::endl;
                    err &lt;&lt; sql.str() &lt;&lt; std::endl;
#endif
                    err &lt;&lt; &quot;  Second SQL error was: &quot; &lt;&lt; zErrMsg2 &lt;&lt; std::endl;
#ifdef SQL_DEBUG
                    err &lt;&lt; &quot;  The attempted SQL statement was:&quot;&lt;&lt;std::endl;
                    err &lt;&lt; sql2.str() &lt;&lt; std::endl;
#endif
                    sqlite3_free(zErrMsg);
                    sqlite3_free(zErrMsg2);
                    printer_error().raise(LOCAL_INFO,err.str());
                }

                // Operation successful, check if our column name exists and has the correct type
                auto jt = colnames.find(sql_col_name);
                if(jt==colnames.end())
                {
                    // Column not found
                    std::stringstream err;
                    err &lt;&lt; &quot;Failed to add new column '&quot;&lt;&lt;sql_col_name&lt;&lt;&quot;' to output SQL table! The ALTER TABLE operation failed, however it was not because the column already existed (we successfully checked and the column was not found). The SQL error was: &quot; &lt;&lt; zErrMsg &lt;&lt; std::endl;
#ifdef SQL_DEBUG
                    err &lt;&lt; &quot;The attempted SQL statement was:&quot;&lt;&lt;std::endl;
                    err &lt;&lt; sql.str() &lt;&lt; std::endl;
#endif
                    sqlite3_free(zErrMsg);
                    printer_error().raise(LOCAL_INFO,err.str());
                }
                else if(!Utils::iequals(jt-&gt;second,sql_col_type))
                {
                    // NOTE: All sorts of type names are equivalent, so this simple string checking is
                    // totally unreliable!

                    // // Column found, but has the wrong type
                    // std::stringstream err;
                    // err &lt;&lt; &quot;Failed to add new column '&quot;&lt;&lt;sql_col_name&lt;&lt;&quot;' to output SQL table! The column already exists, but it has the wrong type (existing column has type '&quot;&lt;&lt;jt-&gt;second&lt;&lt;&quot;', but we expected it to have type '&quot;&lt;&lt;sql_col_type&lt;&lt;&quot;'!&quot;;
                    // sqlite3_free(zErrMsg);
                    // printer_error().raise(LOCAL_INFO,err.str());
                }

                // Column exists and has the right type! So everything is ok after all.
            }

            // Column should exist now. Need to add the fact of this columns existence to our internal record.
            column_record[sql_col_name] = sql_col_type;
        }
        else if(!Utils::iequals(it-&gt;second,sql_col_type))
        {
            // // Records say column exists, but not with the type requested!
            // NOTE: All sorts of type names are equivalent, so this simple string checking is
            // totally unreliable!

            // std::stringstream err;
            // err &lt;&lt; &quot;SQLitePrinter records indicated that the column '&quot;&lt;&lt;sql_col_name&lt;&lt;&quot;' already exists in the output table, but with a different type than has been requested (existing type is '&quot;&lt;&lt;it-&gt;second&lt;&lt;&quot;', requested type was '&quot;&lt;&lt;sql_col_type&lt;&lt;&quot;'). This indicates either duplicate names in the printer output, or an inconsistency in how the print commands have been issued.&quot;;
            // printer_error().raise(LOCAL_INFO,err.str());
        }
        // else column exists and type matches, proceed!
    }

    // Queue data for a table insert operation into the SQLitePrinter internal buffer
    void SQLitePrinter::insert_data(const unsigned int mpirank, const unsigned long pointID, const std::string&amp; col_name, const std::string&amp; col_type, const std::string&amp; data)
    {
        // Get the pairID for this rank/pointID combination
        std::size_t rowID = pairfunc(mpirank,pointID);

        // Last point ID
        lastPointID = PPIDpair(pointID,mpirank);

        // Make sure we have a record of this column existing in the output table
        // Create it if needed.
        ensure_column_exists(get_table_name(), col_name, col_type);

        // Check if a row for this data exists in the transaction buffer
        auto buf_it=transaction_data_buffer.find(rowID);
        if(buf_it==transaction_data_buffer.end())
        {
            // Nope, no row yet for this rowID. Add it.
            // But we should first dump the buffer if it was full

            // If the buffer is full, execute a transaction to write
            // data to disk, and clear the buffer
            if(transaction_data_buffer.size()&gt;=max_buffer_length)
            {
                dump_buffer();
            }

            // Data is set to 'null' until we add some.
            std::size_t current_row_size=buffer_info.size();
            transaction_data_buffer.emplace(rowID,std::vector&lt;std::string&gt;(current_row_size,&quot;null&quot;));
        }

        // Check if this column exists in the current output buffer
        // Create it if needed
        auto it=buffer_info.find(col_name);
        if(it==buffer_info.end())
        {
            // Column doesn't exist in buffer. Add it.
            std::size_t next_col_index = buffer_info.size();
            buffer_info[col_name] = std::make_pair(next_col_index,col_type);

            // Add header data
            //std::cout&lt;&lt;&quot;Adding column to buffer: &quot;&lt;&lt;col_name&lt;&lt;std::endl;
            buffer_header.push_back(col_name);
            if(buffer_info.size()!=buffer_header.size())
            {
                std::stringstream err;
                err&lt;&lt;&quot;Size of buffer_header (&quot;&lt;&lt;buffer_header.size()&lt;&lt;&quot;) does not match buffer_info (&quot;&lt;&lt;buffer_info.size()&lt;&lt;&quot;). This is a bug, please report it.&quot;;
                printer_error().raise(LOCAL_INFO,err.str());
            }

            // Add buffer space
            for(auto jt=transaction_data_buffer.begin();
                     jt!=transaction_data_buffer.end(); ++jt)
            {
               std::vector&lt;std::string&gt;&amp; row = jt-&gt;second;

               // Add new empty column to every row
               // Values are null until we add them
               row.push_back(&quot;null&quot;);

               // Make sure size is correct
               if(row.size()!=buffer_header.size())
               {
                   std::stringstream err;
                   err&lt;&lt;&quot;Size of a row in the transaction_data_buffer (&quot;&lt;&lt;row.size()&lt;&lt;&quot;) does not match buffer_header (&quot;&lt;&lt;buffer_info.size()&lt;&lt;&quot;). This is a bug, please report it.&quot;;
                   printer_error().raise(LOCAL_INFO,err.str());
               }
            }

            // Now point the map iterator to the right place

            it=buffer_info.find(col_name);
        }
        else
        {
            // Column exists in buffer, but we should also make sure the
            // type is consistent with the new data we are adding
            std::string buffer_col_type = it-&gt;second.second;
            if(!Utils::iequals(buffer_col_type,col_type))
            {
                std::stringstream err;
                err&lt;&lt;&quot;Attempted to add data for column '&quot;&lt;&lt;col_name&lt;&lt;&quot;' to SQLitePrinter transaction buffer, but the type of the new data (&quot;&lt;&lt;col_type&lt;&lt;&quot;) does not match the type already recorded for this column in the buffer (&quot;&lt;&lt;buffer_col_type&lt;&lt;&quot;).&quot;;
                printer_error().raise(LOCAL_INFO,err.str());
            }
        }

        // Add the data to the transaction buffer
        std::size_t col_index = it-&gt;second.first;
        transaction_data_buffer.at(rowID).at(col_index) = data;
    }

    // Delete all buffer data. Leaves the header intact so that we know what columns
    // this printer has been working with (needed so we can reset them if needed!)
    void SQLitePrinter::clear_buffer()
    {
        transaction_data_buffer.clear();
    }

    // Create an SQL table insert operation for the current transaction_data_buffer
    // Modifies 'sql' stringstream in-place
    void SQLitePrinter::turn_buffer_into_insert(std::stringstream&amp; sql, const std::string&amp; table)
    {
        sql&lt;&lt;&quot;INSERT INTO &quot;&lt;&lt;table&lt;&lt;&quot; (\npairID,\n&quot;;
        for(auto col_name_it=buffer_header.begin(); col_name_it!=buffer_header.end(); ++col_name_it)
        {
            sql&lt;&lt;&quot;`&quot;&lt;&lt;(*col_name_it)&lt;&lt;&quot;`&quot;&lt;&lt;comma_unless_last(col_name_it,buffer_header)&lt;&lt;&quot;\n&quot;;
        }
        sql&lt;&lt;&quot;) VALUES &quot;;
        for(auto row_it=transaction_data_buffer.begin();
                 row_it!=transaction_data_buffer.end(); ++row_it)
        {
            sql&lt;&lt;&quot;(\n&quot;;
            std::size_t pairID = row_it-&gt;first;
            std::vector&lt;std::string&gt;&amp; row = row_it-&gt;second;
            sql&lt;&lt;pairID&lt;&lt;&quot;,\n&quot;;
            for(auto col_it=row.begin(); col_it!=row.end(); ++col_it)
            {
                sql&lt;&lt;(*col_it)&lt;&lt;comma_unless_last(col_it,row)&lt;&lt;&quot;\n&quot;;
            }
            sql&lt;&lt;&quot;)\n&quot;&lt;&lt;comma_unless_last(row_it,transaction_data_buffer);
        }
        sql&lt;&lt;&quot;;&quot;; // End statement
    }

    // Execute an SQLite transaction to write the buffer to the output table
    void SQLitePrinter::dump_buffer_as_INSERT()
    {
        // Add the table INSERT operation to a stream
        std::stringstream sql;
        turn_buffer_into_insert(sql,get_table_name());

        //std::cout&lt;&lt;sql.str(); // DEBUG

        /* Execute SQL statement */
        submit_sql(LOCAL_INFO,sql.str());
    }

    void SQLitePrinter::dump_buffer_as_UPDATE()
    {
        std::stringstream sql;
        // So for this is seems like the best thing to do is create a temporary
        // table with this new data, and then update the main output table from
        // this. Otherwise we have to write tonnes of separate 'update' statements,
        // which is probably not very fast.
        // So first we need to create the temporary table.
        sql &lt;&lt; &quot;DROP TABLE IF EXISTS temp_table;\n&quot;
            &lt;&lt; &quot;CREATE TEMPORARY TABLE temp_table(&quot;
            &lt;&lt; &quot;pairID   INT PRIMARY KEY NOT NULL,\n&quot;;
        for(auto col_it=buffer_info.begin(); col_it!=buffer_info.end(); ++col_it)
        {
            const std::string&amp; col_name(col_it-&gt;first);
            const std::string&amp; col_type(col_it-&gt;second.second);
            sql&lt;&lt;&quot;`&quot;&lt;&lt;col_name&lt;&lt;&quot;`   &quot;&lt;&lt;col_type&lt;&lt;comma_unless_last(col_it,buffer_info)&lt;&lt;&quot;\n&quot;;
        }
        sql &lt;&lt;&quot;);\n&quot;;

        // Insert data into the temporary table
        turn_buffer_into_insert(sql,&quot;temp_table&quot;);

        // Update the primary output table using the temporary table
        // Following: https://stackoverflow.com/a/47753166/1447953
        sql&lt;&lt;&quot;UPDATE &quot;&lt;&lt;get_table_name()&lt;&lt;&quot; SET (\n&quot;;
        for(auto col_name_it=buffer_header.begin(); col_name_it!=buffer_header.end(); ++col_name_it)
        {
            sql&lt;&lt;*col_name_it&lt;&lt;comma_unless_last(col_name_it,buffer_header)&lt;&lt;&quot;\n&quot;;
        }
        sql&lt;&lt;&quot;) = (SELECT \n&quot;;
        for(auto col_name_it=buffer_header.begin(); col_name_it!=buffer_header.end(); ++col_name_it)
        {
            sql&lt;&lt;&quot;temp_table.&quot;&lt;&lt;*col_name_it&lt;&lt;comma_unless_last(col_name_it,buffer_header)&lt;&lt;&quot;\n&quot;;
        }
        sql&lt;&lt;&quot; FROM temp_table WHERE temp_table.pairID = &quot;&lt;&lt;get_table_name()&lt;&lt;&quot;.pairID)\n&quot;;
        sql&lt;&lt;&quot; WHERE EXISTS ( SELECT * FROM temp_table WHERE temp_table.pairID = &quot;&lt;&lt;get_table_name()&lt;&lt;&quot;.pairID);\n&quot;;

        /* Execute SQL statement */
        submit_sql(LOCAL_INFO,sql.str());
    }

    void SQLitePrinter::dump_buffer()
    {
        require_output_ready();
        // Don't try to dump the buffer if it is empty!
        if(transaction_data_buffer.size()&gt;0)
        {
            if(synchronised)
            {
                // Primary dataset writes can be performed as INSERT operations
                dump_buffer_as_INSERT();
            }
            else
            {
                // Asynchronous ('auxilliary') writes need to be performed as UPDATE operations
                dump_buffer_as_UPDATE();
            }
            // Clear all the buffer data
            clear_buffer();
        }
    }

  }
}
</code></pre><hr><p>Updated on 2025-02-12 at 16:10:34 +0000</p></main></div></div></div><footer class="footer text-muted"><div class=container-xxl><div class=row><div class="col-lg-8 order-last order-lg-first"><ul class=list-inline><li class=list-inline-item>Powered by <a href=https://gohugo.io/>Hugo</a> and <a href=https://getdoks.org/>Doks</a></li></ul></div><div class="col-lg-8 order-first order-lg-last text-lg-end"><ul class=list-inline><li class=list-inline-item><a href=/license/>License</a></li></ul></div></div></div></footer><script src=/js/bootstrap.min.862c9eb8ab97f8c1c8584b21ce31113d8553917669561b040011b0061009a0b6c7a6b61fb659f56eabfa9f45259f001417dba1d65b229f685f3cdbb709482f8e.js integrity="sha512-hiyeuKuX+MHIWEshzjERPYVTkXZpVhsEABGwBhAJoLbHprYftln1bqv6n0UlnwAUF9uh1lsin2hfPNu3CUgvjg==" crossorigin=anonymous defer></script>
<script src=/js/highlight.min.3fa03d1d36ae7a66d6d5d2e19796832d40b4a5417eaaae1dfba8837d033467084e8c051f25aee596d415422573116115ccc5c2b29970d3490dafdce1a920a402.js integrity="sha512-P6A9HTauembW1dLhl5aDLUC0pUF+qq4d+6iDfQM0ZwhOjAUfJa7lltQVQiVzEWEVzMXCsplw00kNr9zhqSCkAg==" crossorigin=anonymous defer></script>
<script src=/main.min.04459eeb2d9d601a3ccc10d2699fb84f0442d5f5d3a16372b023be7564838ed2a755b908598f715d6b42c0be95895835b2e872f4fa4acd028ef3904671a92f1a.js integrity="sha512-BEWe6y2dYBo8zBDSaZ+4TwRC1fXToWNysCO+dWSDjtKnVbkIWY9xXWtCwL6ViVg1suhy9PpKzQKO85BGcakvGg==" crossorigin=anonymous defer></script>
<script src=https://gambitbsm.org/index.min.6e75ad5de87f9de13477329c91f2828b7a6165cda3776163215c41d318947a632f2bc707d59cafebe5a9def6bbf76329e12a440163187aa7a775768315d92f3f.js integrity="sha512-bnWtXeh/neE0dzKckfKCi3phZc2jd2FjIVxB0xiUemMvK8cH1Zyv6+Wp3va792Mp4SpEAWMYeqendXaDFdkvPw==" crossorigin=anonymous defer></script></body></html>