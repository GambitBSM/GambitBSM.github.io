<!doctype html><html lang=en-us><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="ie=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><link rel=preload as=font href=https://gambitbsm.github.io/fonts/vendor/jost/jost-v4-latin-regular.woff2 type=font/woff2 crossorigin><link rel=preload as=font href=https://gambitbsm.github.io/fonts/vendor/jost/jost-v4-latin-500.woff2 type=font/woff2 crossorigin><link rel=preload as=font href=https://gambitbsm.github.io/fonts/vendor/jost/jost-v4-latin-700.woff2 type=font/woff2 crossorigin><script>(()=>{var e=localStorage.getItem("theme");e==="dark"&&document.documentElement.setAttribute("data-dark-mode","")})()</script><link rel=stylesheet href=https://gambitbsm.github.io/main.2b4f179ba5137bf560410d5863d012cb95c0a7504da18190247e40a43544a8252fba5dc321f967a611ca9a4d80dec44fabc75d108c7c0e4e8ed381ec007b7391.css integrity="sha512-K08Xm6UTe/VgQQ1YY9ASy5XAp1BNoYGQJH5ApDVEqCUvul3DIflnphHKmk2A3sRPq8ddEIx8Dk6O04HsAHtzkQ==" crossorigin=anonymous><noscript><style>img.lazyload{display:none}</style></noscript><meta name=robots content="index, follow"><meta name=googlebot content="index, follow, max-snippet:-1, max-image-preview:large, max-video-preview:-1"><meta name=bingbot content="index, follow, max-snippet:-1, max-image-preview:large, max-video-preview:-1"><title>file printers/hdf5printer.hpp - GAMBIT</title><meta name=description content="[No description available]"><link rel=canonical href=https://gambitbsm.github.io/documentation/code/files/hdf5printer_8hpp/><meta property="og:locale" content="en_US"><meta property="og:type" content="article"><meta property="og:title" content="file printers/hdf5printer.hpp"><meta property="og:description" content="[No description available]"><meta property="og:url" content="https://gambitbsm.github.io/documentation/code/files/hdf5printer_8hpp/"><meta property="og:site_name" content="GAMBIT"><meta property="og:image" content="https://gambitbsm.github.io/gambit_logo.png"><meta property="og:image:alt" content="GAMBIT"><meta name=twitter:card content="summary_large_image"><meta name=twitter:site content><meta name=twitter:creator content><meta name=twitter:title content="file printers/hdf5printer.hpp"><meta name=twitter:description content="[No description available]"><meta name=twitter:image content="https://gambitbsm.github.io/gambit_logo.png"><meta name=twitter:image:alt content="file printers/hdf5printer.hpp"><script type=application/ld+json>{"@context":"https://schema.org","@graph":[{"@type":"Organization","@id":"https://gambitbsm.github.io/#/schema/organization/1","name":"Doks","url":"https://gambitbsm.github.io/","sameAs":["https://github.com/GambitBSM"],"logo":{"@type":"ImageObject","@id":"https://gambitbsm.github.io/#/schema/image/1","url":"https://gambitbsm.github.io/logo-doks.png","width":450,"height":416,"caption":"Doks"},"image":{"@id":"https://gambitbsm.github.io/#/schema/image/1"}},{"@type":"WebSite","@id":"https://gambitbsm.github.io/#/schema/website/1","url":"https://gambitbsm.github.io/","name":"GAMBIT","description":"Documentation for the Global And Modular BSM Inference Tool","publisher":{"@id":"https://gambitbsm.github.io/#/schema/organization/1"}},{"@type":"WebPage","@id":"https://gambitbsm.github.io/documentation/code/files/hdf5printer_8hpp/","url":"https://gambitbsm.github.io/documentation/code/files/hdf5printer_8hpp/","name":"file printers\/hdf5printer.hpp","description":"[No description available]","isPartOf":{"@id":"https://gambitbsm.github.io/#/schema/website/1"},"about":{"@id":"https://gambitbsm.github.io/#/schema/organization/1"},"datePublished":"0001-01-01T00:00:00CET","dateModified":"0001-01-01T00:00:00CET","breadcrumb":{"@id":"https://gambitbsm.github.io/documentation/code/files/hdf5printer_8hpp/#/schema/breadcrumb/1"},"primaryImageOfPage":{"@id":"https://gambitbsm.github.io/documentation/code/files/hdf5printer_8hpp/#/schema/image/2"},"inLanguage":"en-US","potentialAction":[{"@type":"ReadAction","target":["https://gambitbsm.github.io/documentation/code/files/hdf5printer_8hpp/"]}]},{"@type":"BreadcrumbList","@id":"https://gambitbsm.github.io/documentation/code/files/hdf5printer_8hpp/#/schema/breadcrumb/1","name":"Breadcrumbs","itemListElement":[{"@type":"ListItem","position":1,"item":{"@type":"WebPage","@id":"https://gambitbsm.github.io/","url":"https://gambitbsm.github.io/","name":"Home"}},{"@type":"ListItem","position":2,"item":{"@type":"WebPage","@id":"https://gambitbsm.github.io/documentation/","url":"https://gambitbsm.github.io/documentation/","name":"Documentation"}},{"@type":"ListItem","position":3,"item":{"@type":"WebPage","@id":"https://gambitbsm.github.io/documentation/code/","url":"https://gambitbsm.github.io/documentation/code/","name":"Code"}},{"@type":"ListItem","position":4,"item":{"@type":"WebPage","@id":"https://gambitbsm.github.io/documentation/code/files/","url":"https://gambitbsm.github.io/documentation/code/files/","name":"Files"}},{"@type":"ListItem","position":5,"item":{"@id":"https://gambitbsm.github.io/documentation/code/files/hdf5printer_8hpp/"}}]},{"@context":"https://schema.org","@graph":[{"@type":"ImageObject","@id":"https://gambitbsm.github.io/documentation/code/files/hdf5printer_8hpp/#/schema/image/2","url":"https://gambitbsm.github.io/gambit_logo.png","contentUrl":"https://gambitbsm.github.io/gambit_logo.png","caption":"file printers\/hdf5printer.hpp"}]}]}</script><meta name=theme-color content="#fff"><link rel=icon href=https://gambitbsm.github.io/favicon.ico sizes=any><link rel=icon type=image/svg+xml href=https://gambitbsm.github.io/favicon.svg><link rel=apple-touch-icon sizes=180x180 href=https://gambitbsm.github.io/apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=https://gambitbsm.github.io/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=https://gambitbsm.github.io/favicon-16x16.png><link rel=manifest crossorigin=use-credentials href=https://gambitbsm.github.io/site.webmanifest></head><body class="documentation single light"><div class=sticky-top><div class=header-bar></div><header class="navbar navbar-expand-md navbar-light doks-navbar"><nav class="container-xxl flex-wrap flex-md-nowrap" aria-label="Main navigation"><a class="navbar-brand p-0 me-auto" href=https://gambitbsm.github.io/ aria-label=GAMBIT><img class=logo-light src=https://gambitbsm.github.io//images/gambit_logo.png width=50px>
<img class="logo-dark d-none" src=https://gambitbsm.github.io//images/gambit_logo.png width=50px>
GAMBIT</a>
<button class="btn btn-menu order-2 d-block d-lg-none" type=button data-bs-toggle=offcanvas data-bs-target=#offcanvasDoks aria-controls=offcanvasDoks aria-label="Open main menu"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-menu"><line x1="3" y1="12" x2="21" y2="12"/><line x1="3" y1="6" x2="21" y2="6"/><line x1="3" y1="18" x2="21" y2="18"/></svg></button><div class="offcanvas offcanvas-end border-0 py-lg-1" tabindex=-1 id=offcanvasDoks data-bs-backdrop=true aria-labelledby=offcanvasDoksLabel><div class="header-bar d-lg-none"></div><div class="offcanvas-header d-lg-none"><h2 class="h5 offcanvas-title ps-2" id=offcanvasDoksLabel><a class=text-dark href=/>GAMBIT</a></h2><button type=button class="btn-close text-reset me-2" data-bs-dismiss=offcanvas aria-label="Close main menu"></button></div><div class="offcanvas-body p-4 p-lg-0"><ul class="nav flex-column flex-lg-row align-items-lg-center mt-2 mt-lg-0 ms-lg-2 me-lg-auto"><li class="nav-item dropdown"><a class="nav-link dropdown-toggle ps-0 py-1" href=# id=navbarDropdownMenuLink role=button data-bs-toggle=dropdown aria-expanded=false>Releases
<span class=dropdown-caret><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-chevron-down"><polyline points="6 9 12 15 18 9"/></svg></span></a><ul class="dropdown-menu dropdown-menu-main shadow rounded border-0" aria-labelledby=navbarDropdownMenuLink><li><a class=dropdown-item href=https://github.com/GambitBSM/gambit_2.2>GAMBIT 2-2 ⧉</a></li><li><a class=dropdown-item href=https://github.com/GambitBSM/gambit_2.1>GAMBIT 2-1 ⧉</a></li><li><a class=dropdown-item href=https://github.com/GambitBSM/gambit_2.2/tags>All releases ⧉</a></li></ul></li><li class="nav-item dropdown"><a class="nav-link dropdown-toggle ps-0 py-1" href=# id=navbarDropdownMenuLink role=button data-bs-toggle=dropdown aria-expanded=false>Documentation
<span class=dropdown-caret><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-chevron-down"><polyline points="6 9 12 15 18 9"/></svg></span></a><ul class="dropdown-menu dropdown-menu-main shadow rounded border-0" aria-labelledby=navbarDropdownMenuLink><li><a class=dropdown-item href=/documentation/installation/introduction/>Installation</a></li><li><a class=dropdown-item href=/documentation/examples/colliderbit_example>Examples</a></li><li><a class=dropdown-item href=/documentation/help/common_problems_and_questions/>Help</a></li><li><a class=dropdown-item href=/documentation/code/index_classes>Code Reference</a></li></ul></li><li class="nav-item dropdown"><a class="nav-link dropdown-toggle ps-0 py-1" href=# id=navbarDropdownMenuLink role=button data-bs-toggle=dropdown aria-expanded=false>Community
<span class=dropdown-caret><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-chevron-down"><polyline points="6 9 12 15 18 9"/></svg></span></a><ul class="dropdown-menu dropdown-menu-main shadow rounded border-0" aria-labelledby=navbarDropdownMenuLink><li><a class=dropdown-item href=/community/publications/>Publications</a></li><li><a class=dropdown-item href=/community/talks/>Talks</a></li><li><a class=dropdown-item href=/community/members/>Members</a></li><li><a class=dropdown-item href=/community/code_of_conduct/>Code of Conduct</a></li><li><a class=dropdown-item href=/community/contact/>Contact</a></li></ul></li></ul><hr class="text-black-50 my-4 d-lg-none"><form class="doks-search position-relative flex-grow-1 ms-lg-auto me-lg-2"><input id=search class="form-control is-search" type=search placeholder="Search site..." aria-label="Search site..." autocomplete=off><div id=suggestions class="shadow bg-white rounded d-none"></div></form><hr class="text-black-50 my-4 d-lg-none"><ul class="nav flex-column flex-lg-row"><li class=nav-item><a class="nav-link social-link" href=https://github.com/GambitBSM><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-github"><path d="M9 19c-5 1.5-5-2.5-7-3m14 6v-3.87a3.37 3.37.0 00-.94-2.61c3.14-.35 6.44-1.54 6.44-7A5.44 5.44.0 0020 4.77 5.07 5.07.0 0019.91 1S18.73.65 16 2.48a13.38 13.38.0 00-7 0C6.27.65 5.09 1 5.09 1A5.07 5.07.0 005 4.77 5.44 5.44.0 003.5 8.55c0 5.42 3.3 6.61 6.44 7A3.37 3.37.0 009 18.13V22"/></svg><small class="ms-2 d-lg-none">GitHub</small></a></li></ul><hr class="text-black-50 my-4 d-lg-none"><button id=mode class="btn btn-link" type=button aria-label="Toggle user interface mode">
<span class=toggle-dark><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-moon"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg></span><span class=toggle-light><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-sun"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></span></button></div></div></nav></header></div><div class="wrap container-xxl" role=document><div class=content><div class="row flex-xl-nowrap"><div class="col-lg-5 col-xl-4 docs-sidebar"><nav class=docs-links aria-label="Main navigation"><ul class="list-unstyled collapsible-sidebar"><li class=mb-1><button class="btn btn-toggle align-items-center rounded collapsed" data-bs-toggle=collapse data-bs-target=#section-installation aria-expanded=false>
Installation</button><div class=collapse id=section-installation><ul class="btn-toggle-nav list-unstyled fw-normal pb-1 small"><li><a class="docs-link rounded" href=/documentation/installation/introduction/>Getting Started</a></li><li><a class="docs-link rounded" href=/documentation/installation/docker_usage/>Docker Usage</a></li><li><a class="docs-link rounded" href=/documentation/installation/installation_for_linux/>Installation for Linux</a></li><li><a class="docs-link rounded" href=/documentation/installation/installation_for_windows/>Installation for Windows</a></li><li><a class="docs-link rounded" href=/documentation/installation/installation_for_macos/>Installation for macOS</a></li></ul></div></li><li class=mb-1><button class="btn btn-toggle align-items-center rounded collapsed" data-bs-toggle=collapse data-bs-target=#section-examples aria-expanded=false>
Examples</button><div class=collapse id=section-examples><ul class="btn-toggle-nav list-unstyled fw-normal pb-1 small"><li><a class="docs-link rounded" href=/documentation/examples/colliderbit_example/>ColliderBit Example</a></li><li><a class="docs-link rounded" href=/documentation/examples/anotherbit/>AnotherBit</a></li><li><a class="docs-link rounded" href=/documentation/examples/anotherbit2/>AnotherBit2</a></li></ul></div></li><li class=mb-1><button class="btn btn-toggle align-items-center rounded collapsed" data-bs-toggle=collapse data-bs-target=#section-help aria-expanded=false>
Help</button><div class=collapse id=section-help><ul class="btn-toggle-nav list-unstyled fw-normal pb-1 small"><li><a class="docs-link rounded" href=/documentation/help/common_problems_and_questions/>Common Problems and Questions</a></li><li><a class="docs-link rounded" href=/documentation/help/compiler_matrix/>Compiler Matrix</a></li><li><a class="docs-link rounded" href=/documentation/help/known_issues/>Known Issues</a></li><li><a class="docs-link rounded" href=/documentation/help/configuration_examples/>Configuration Examples</a></li></ul></div></li><li class=mb-1><button class="btn btn-toggle align-items-center rounded collapsed" data-bs-toggle=collapse data-bs-target=#section-code aria-expanded=false>
Code Reference</button><div class=collapse id=section-code><ul class="btn-toggle-nav list-unstyled fw-normal pb-1 small"><li><a class="docs-link rounded" href=/documentation/code/index_classes/>Classes</a></li><li><a class="docs-link rounded" href=/documentation/code/index_files/>Files</a></li><li><a class="docs-link rounded" href=/documentation/code/index_pages/>Pages</a></li><li><a class="docs-link rounded" href=/documentation/code/index_namespaces/>Namespaces</a></li></ul></div></li></ul></nav></div><nav class="docs-toc d-none d-xl-block col-xl-3" aria-label="Secondary navigation"><div class=d-xl-none><button class="btn btn-outline-primary btn-sm doks-toc-toggle collapsed" type=button data-bs-toggle=collapse data-bs-target=#onThisPage aria-controls=doks-docs-nav aria-expanded=false aria-label="Toggle On this page navigation">
<span>On this page</span>
<span><svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24" class="doks doks-expand" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><title>Expand</title><polyline points="7 13 12 18 17 13"/><polyline points="7 6 12 11 17 6"/></svg><svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24" class="doks doks-collapse" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><title>Collapse</title><polyline points="17 11 12 6 7 11"/><polyline points="17 18 12 13 7 18"/></svg></span></button><div class=collapse id=onThisPage><div class="card card-body mt-3 py-1"><div class=page-links><nav id=TableOfContents><ul><li><a href=#namespaces>Namespaces</a></li><li><a href=#classes>Classes</a></li><li><a href=#defines>Defines</a></li><li><a href=#detailed-description>Detailed Description</a></li><li><a href=#macros-documentation>Macros Documentation</a><ul><li><a href=#define-declare-print>define DECLARE_PRINT</a></li><li><a href=#define-bt>define BT</a></li><li><a href=#define-define-buffman-getter>define DEFINE_BUFFMAN_GETTER</a></li></ul></li><li><a href=#source-code>Source code</a></li></ul></nav></div></div></div></div><div class="page-links d-none d-xl-block"><h3>On this page</h3><nav id=TableOfContents><ul><li><a href=#namespaces>Namespaces</a></li><li><a href=#classes>Classes</a></li><li><a href=#defines>Defines</a></li><li><a href=#detailed-description>Detailed Description</a></li><li><a href=#macros-documentation>Macros Documentation</a><ul><li><a href=#define-declare-print>define DECLARE_PRINT</a></li><li><a href=#define-bt>define BT</a></li><li><a href=#define-define-buffman-getter>define DEFINE_BUFFMAN_GETTER</a></li></ul></li><li><a href=#source-code>Source code</a></li></ul></nav></div></nav><main class="docs-content col-lg-11 col-xl-9 mx-xl-auto"><nav aria-label=breadcrumb><ol class=breadcrumb><li class=breadcrumb-item><a href=/>Home</a></li><li class=breadcrumb-item><a href=/documentation/>Documentation</a></li><li class=breadcrumb-item><a href=/documentation/code/>Code Reference</a></li><li class="breadcrumb-item active" aria-current=page>file printers/hdf5printer.hpp</li></ol></nav><p class=lead></p><h1 id=file-printers-hdf5printer-hpp>file printers/hdf5printer.hpp</h1><p>[No description available] <a href=#detailed-description>More&mldr;</a></p><h2 id=namespaces>Namespaces <a href=#namespaces class=anchor aria-hidden=true>#</a></h2><table><thead><tr><th>Name</th></tr></thead><tbody><tr><td><strong><a href=/documentation/code/namespaces/namespacegambit/>Gambit</a></strong><br>TODO: see if we can use this one:</td></tr><tr><td><strong><a href=/documentation/code/namespaces/namespacegambit_1_1printers/>Gambit::Printers</a></strong><br>Forward declaration.</td></tr></tbody></table><h2 id=classes>Classes <a href=#classes class=anchor aria-hidden=true>#</a></h2><table><thead><tr><th></th><th>Name</th></tr></thead><tbody><tr><td>class</td><td><strong><a href=/documentation/code/classes/classgambit_1_1printers_1_1h5p__localbuffermanager/>Gambit::Printers::H5P_LocalBufferManager</a></strong><br>Keeps track of vertex buffers local to a print function.</td></tr><tr><td>class</td><td><strong><a href=/documentation/code/classes/classgambit_1_1printers_1_1hdf5printer/>Gambit::Printers::HDF5Printer</a></strong><br>The main printer class for output to HDF5 format.</td></tr></tbody></table><h2 id=defines>Defines <a href=#defines class=anchor aria-hidden=true>#</a></h2><table><thead><tr><th></th><th>Name</th></tr></thead><tbody><tr><td></td><td><strong><a href=/documentation/code/files/hdf5printer_8hpp/#define-declare-print>DECLARE_PRINT</a></strong>(r, data, i, elem)</td></tr><tr><td></td><td><strong><a href=/documentation/code/files/hdf5printer_8hpp/#define-bt>BT</a></strong>(TYPE)<br>Buffer manager objects.</td></tr><tr><td></td><td><strong><a href=/documentation/code/files/hdf5printer_8hpp/#define-define-buffman-getter>DEFINE_BUFFMAN_GETTER</a></strong>(TYPE)<br>Macro to help define the buffer manager getter functions.</td></tr></tbody></table><h2 id=detailed-description>Detailed Description <a href=#detailed-description class=anchor aria-hidden=true>#</a></h2><p><strong>Author</strong>: Ben Farmer (<a href=mailto:benjamin.farmer@fysik.su.se>benjamin.farmer@fysik.su.se</a>)</p><p><strong>Date</strong>: 2015 May</p><p>HDF5 interface printer class declaration</p><hr><p>Authors (add name and date if you modify):</p><hr><h2 id=macros-documentation>Macros Documentation <a href=#macros-documentation class=anchor aria-hidden=true>#</a></h2><h3 id=define-declare-print>define DECLARE_PRINT <a href=#define-declare-print class=anchor aria-hidden=true>#</a></h3><pre><code>#define DECLARE_PRINT(
    r,
    data,
    i,
    elem
)
void _print(elem const&amp;, const std::string&amp;, const int, const uint, const ulong);
</code></pre><h3 id=define-bt>define BT <a href=#define-bt class=anchor aria-hidden=true>#</a></h3><pre><code>#define BT(
    TYPE
)
VertexBufferNumeric1D_HDF5&lt;TYPE,BUFFERLENGTH&gt;
</code></pre><p>Buffer manager objects.</p><h3 id=define-define-buffman-getter>define DEFINE_BUFFMAN_GETTER <a href=#define-define-buffman-getter class=anchor aria-hidden=true>#</a></h3><pre><code>#define DEFINE_BUFFMAN_GETTER(
    TYPE
)
      template&lt;&gt;                                                               \
      inline H5P_LocalBufferManager&lt;VertexBufferNumeric1D_HDF5&lt;TYPE,BUFFERLENGTH&gt;&gt;&amp; \
       HDF5Printer::get_mybuffermanager&lt;TYPE&gt;(ulong pointID, uint mpirank) \
      {                                                                        \
         /* If the buffermanger hasn't been initialised, do so now */          \
         if( not CAT(hdf5_localbufferman_,TYPE).ready() )                      \
         {                                                                     \
            CAT(hdf5_localbufferman_,TYPE).init(this,synchronised);            \
         }                                                                     \
                                                                               \
         /* While we are at it, check if the buffers need to be                \
            synchronised to a new point. But only if this printer is running   \
            in &quot;synchronised&quot; mode. */                                         \
         if(synchronised)                                                      \
         {                                                                     \
           check_for_new_point(PPIDpair(pointID, mpirank));                    \
         }                                                                     \
         return CAT(hdf5_localbufferman_,TYPE);                                \
      }
</code></pre><p>Macro to help define the buffer manager getter functions.</p><h2 id=source-code>Source code <a href=#source-code class=anchor aria-hidden=true>#</a></h2><pre><code>//   GAMBIT: Global and Modular BSM Inference Tool
//   *********************************************
///  \file
///
///  HDF5 interface printer class declaration
///
///  *********************************************
///
///  Authors (add name and date if you modify):
///
///  \author Ben Farmer
///          (benjamin.farmer@fysik.su.se)
///  \date 2015 May
///
///  *********************************************


#ifndef __hdf5printer_hpp__
#define __hdf5printer_hpp__

// Standard libraries
#include &lt;map&gt;
#include &lt;vector&gt;
#include &lt;algorithm&gt;
#include &lt;sstream&gt;
#include &lt;iostream&gt;
#include &lt;fstream&gt;
#include &lt;iomanip&gt;

// Gambit
#include &quot;gambit/Printers/baseprinter.hpp&quot;
#include &quot;gambit/Printers/VertexBufferBase.hpp&quot;
#include &quot;gambit/Printers/VertexBuffer_mpitags.hpp&quot;
#include &quot;gambit/Printers/printers/hdf5types.hpp&quot;
#include &quot;gambit/Printers/printers/hdf5printer/hdf5tools.hpp&quot;
#include &quot;gambit/Printers/printers/hdf5printer/VertexBufferNumeric1D_HDF5.hpp&quot;
#include &quot;gambit/Printers/printers/hdf5printer/DataSetInterfaceScalar.hpp&quot;
#include &quot;gambit/Utils/yaml_options.hpp&quot;
#include &quot;gambit/Utils/cats.hpp&quot;
#include &quot;gambit/Logs/logger.hpp&quot;

// MPI bindings
#include &quot;gambit/Utils/mpiwrapper.hpp&quot;
#include &quot;gambit/Utils/new_mpi_datatypes.hpp&quot;

// BOOST_PP
#include &lt;boost/preprocessor/seq/for_each_i.hpp&gt;


//#define DEBUG_MODE
//#define HDEBUG_MODE // &quot;High output&quot; debug mode (info with every single print command)

// Code!
namespace Gambit
{
  namespace Printers
  {

    // Parameter controlling the length of all the standard buffers
    static const std::size_t BUFFERLENGTH = 100; // Change to 10000 or something. Currently cannot change this dynamically though, sorry.

    /// Max number of PPIDpairs to be tracked
    /// i.e. chunks of RA output longer than this can potentially contain multiple writes to the same point.
    /// It is up to the combine script to apply the last scheduled write preferentially.
    static const unsigned long MAX_PPIDPAIRS = 10*BUFFERLENGTH;

    /// @{ Helpful typedefs

    /// Type of the global buffer map
    typedef std::map&lt;VBIDpair, VertexBufferBase*&gt; BaseBufferMap;

    /// Helper function to check if a VertexBuffer key already exists in a map
    template&lt;class T, class U&gt;
    void error_if_key_exists(const std::map&lt;T,U&gt;&amp; m, const T&amp; key, const std::string&amp; tag)
    {
       typename std::map&lt;T,U&gt;::const_iterator it = m.find(key);
       if ( it == m.end() ) {
          return;
       }
       else {
          std::ostringstream errmsg;
          errmsg &lt;&lt; &quot;Error! Supplied key for a VertexBuffer already exists in map (tag=&quot;&lt;&lt;tag&lt;&lt;&quot;)! This is a bug in the HDF5Printer (or Reader) class, please report it.&quot;;
          printer_error().raise(LOCAL_INFO, errmsg.str());
       }
    }

    // foward declaration
    class HDF5Printer;

    /// Keeps track of vertex buffers local to a print function
    template&lt;class BuffType&gt;
    class H5P_LocalBufferManager
    {
      private:
        // Buffers local to a print function. Access whichever ones match the IDcode.
        std::map&lt;VBIDpair, BuffType&gt; local_buffers;

        // Pointer to &quot;parent&quot; HDF5Printer object
        // Need to use two-stage initialisation because the automated
        // declaration of new buffer managers requires a default
        // constructor
        HDF5Printer* printer;

        /// Flag to check if a print function has been run before
        // (map is from IDcodes to flags)
        std::map&lt;VBIDpair,bool&gt; first_print;

        /// Flag to trigger treatment of buffers as synchronised or not
        /// i.e. couples buffers to the scanner iteration synchronisation.
        bool synchronised;

        /// Buffer access mode ('r'/'w')
        char access;

      public:
        /// Constructor
        H5P_LocalBufferManager()
          : printer(NULL)
          , synchronised(true)
          , access('w')
        {}

        /// Initialise the buffer (attach it to a printer and set its behaviour)
        void init(HDF5Printer* p, bool synchronised);

        /// Signal whether initialisation has occured
        bool ready() { if(printer==NULL){return false;}else{return true;} }

        /// Retrieve a buffer for an IDcode/auxilliary-index pair
        BuffType&amp; get_buffer(const int vID, const unsigned int i, const std::string&amp; label);

    };


    /// The main printer class for output to HDF5 format
    class HDF5Printer : public BasePrinter
    {
      public:
        /// Constructor (for construction via inifile options)
        HDF5Printer(const Options&amp;, BasePrinter* const primary = NULL);

        /// Tasks common to the various constructors
        void common_constructor(const Options&amp;);

        /// Destructor
        // Overload the base class virtual destructor
        ~HDF5Printer();

        /// Virtual function overloads:
        ///@{

        // Initialisation function
        // Run by dependency resolver, which supplies the functors with a vector of VertexIDs whose requiresPrinting flags are set to true.
        void initialise(const std::vector&lt;int&gt;&amp;);
        void flush();
        void reset(bool force=false);
        void finalise(bool abnormal=false);

        // Get options required to construct a reader object that can read
        // the previous output of this printer.
        Options resume_reader_options();

        ///@}

        ///@{ Print functions
        using BasePrinter::_print; // Tell compiler we are using some of the base class overloads of this on purpose.
        #define DECLARE_PRINT(r,data,i,elem) void _print(elem const&amp;, const std::string&amp;, const int, const uint, const ulong);
        BOOST_PP_SEQ_FOR_EACH_I(DECLARE_PRINT, , HDF5_TYPES)
        #ifndef SCANNER_STANDALONE
          BOOST_PP_SEQ_FOR_EACH_I(DECLARE_PRINT, , HDF5_BACKEND_TYPES)
        #endif
        #undef DECLARE_PRINT
        ///@}

        /// @{ HDF5Printer-specific functions

        /// Check if an output stream is already managed by some buffer in some printer
        bool is_stream_managed(VBIDpair&amp; key) const;

        /// Retrieve pointer to HDF5 location to which datasets are added
        hid_t get_location() const;
        hid_t get_RA_location() const;

        /// Add a pointer to a new buffer to the global list
        void insert_buffer(VBIDpair&amp; key, VertexBufferBase&amp; newbuffer);

        /// Get the number of pointIDs know to this printer
        /// (should correspond to the number of &quot;appends&quot; each active buffer has received)
        unsigned long get_sync_pos() const { return sync_pos; }

     private:

        /// Buffer manager objects
        //  Need one for every directly retrievable type, and a specialisation
        //  of 'get_mybuffermanager' to access it. But the latter have to be
        //  defined outside the class declaration, so they can be found below.
        //  Could create all these with a macro, but I am sick of macros so
        //  will just do it the &quot;old-fashioned&quot; way.
        #define BT(TYPE) VertexBufferNumeric1D_HDF5&lt;TYPE,BUFFERLENGTH&gt;
        H5P_LocalBufferManager&lt;BT(int      )&gt; hdf5_localbufferman_int;
        H5P_LocalBufferManager&lt;BT(uint     )&gt; hdf5_localbufferman_uint;
        H5P_LocalBufferManager&lt;BT(long     )&gt; hdf5_localbufferman_long;
        H5P_LocalBufferManager&lt;BT(ulong    )&gt; hdf5_localbufferman_ulong;
        H5P_LocalBufferManager&lt;BT(longlong )&gt; hdf5_localbufferman_longlong;
        H5P_LocalBufferManager&lt;BT(ulonglong)&gt; hdf5_localbufferman_ulonglong;
        H5P_LocalBufferManager&lt;BT(float    )&gt; hdf5_localbufferman_float;
        H5P_LocalBufferManager&lt;BT(double   )&gt; hdf5_localbufferman_double;

        /// Function used by print functions to retrieve their local buffer manager object
        template&lt;class T&gt;
        H5P_LocalBufferManager&lt;BT(T)&gt;&amp; get_mybuffermanager(ulong, uint);
        #undef BT

        /// Add PPIDpair to global index list
        void add_PPID_to_list(const PPIDpair&amp;);

        /// Completely reset the PPIDlists (e.g. used when printer is reset)
        void reset_PPID_lists();

        /// Ask the printer for the highest ID number known for a given rank
        /// process (needed for resuming, so the scanner can resume assigning
        /// point ID from this value.
        // TODO: DEPRECATED
        //unsigned long getHighestPointID(const int rank);

        /// Check if PPIDpair exists in global index list
        bool seen_PPID_before(const PPIDpair&amp; ppid);

        /// Function to ensure buffers are all synchronised to the same absolute position
        void synchronise_buffers();

        /// For debugging: check that buffers are synced correctly
        /// Flag sets whether &quot;perfect&quot; sync is required, or whether
        /// some buffers can be ahead by one slot (due to having
        /// performed prints that other buffers have not yet done)
        void check_sync(const std::string&amp; label, const int sync_type, bool checkall);

        #ifdef WITH_MPI

        /// Retrieve MPI communicator object used by this printer
        GMPI::Comm&amp; get_Comm() { return myComm; }
        #endif

        /// Check if the buffers are full and waiting to be emptied
        /// By default this only empties buffers if they are full. Use
        /// flag to force the flush for the finalise buffer dumps.
        void empty_sync_buffers(bool force=false);

        /// Check whether printing to a new parameter space point is about to occur
        /// and perform adjustments needed to prepare the printer.
        void check_for_new_point(const PPIDpair&amp;);

        /// Retrieve index from global lookup table, with error checking
        unsigned long get_global_index(const ulong pointID, const uint mpirank);

        /// Get the name of this printer
        std::string get_printer_name() { return printer_name; }

        /// Get the number of RA write locations known to the primary printer
        /// NOTE: the meaning of this has changed slightly; it is the number of queued
        /// up RA write commands that should exist in the output datasets. The primary
        /// printer no longer tracks all of the IDs for every RA write command.
        unsigned long get_N_RApointIDs() { return primary_printer-&gt;reverse_global_index_lookup.size() + primary_printer-&gt;RA_dset_offset; }

        /// Move head dataset sync position
        void increment_sync_pos() { sync_pos+=1; }

        /// Clear previous points list
        void clear_previous_points() { std::vector&lt;PPIDpair&gt;().swap(previous_points); } // This technique also shrinks the capacity of the vector, which 'clear' does not do.

        /// Scan for existing temporary files, in preparation for combining them
        /// Should only do this if scan is resuming, and if we are process rank 0.
        void prepare_and_combine_tmp_files();

        //PPIDpair get_highest_PPID_from_HDF5(hid_t group_id);
        std::map&lt;unsigned long, unsigned long long int&gt; get_highest_PPID_from_HDF5(hid_t group_id);

        /// Search the output directory for temporary files (pre-combination)
        std::vector&lt;std::string&gt; find_temporary_files(const bool error_if_inconsistent=false);

        /// Combine temporary hdf5 output files from each process into a single coherent hdf5 file.
        void combine_output_py(const std::vector&lt;std::string&gt; tmp_files, const bool finalcombine); // Python version
        void combine_output(const std::vector&lt;std::string&gt; tmp_files, const bool finalcombine); // Greg version

        /// @}


        /// Helper print functions
        // Used to reduce repetition in definitions of virtual function overloads
        // (useful since there is no automatic type conversion possible)
        template&lt;class T&gt;
        void template_print(T const&amp; value, const std::string&amp; label, const int IDcode, const unsigned int mpirank, const unsigned long pointID)
        {
           // Retrieve the buffer manager for buffers with this type
           auto&amp; buffer_manager = get_mybuffermanager&lt;T&gt;(pointID,mpirank);

           // Extract a buffer from the manager corresponding to this
           auto&amp; selected_buffer = buffer_manager.get_buffer(IDcode, 0, label);

           #ifdef HDEBUG_MODE
             std::cout&lt;&lt;&quot;rank &quot;&lt;&lt;myRank&lt;&lt;&quot;, printer &quot;&lt;&lt;this-&gt;get_printer_name()&lt;&lt;&quot;: printing &quot;&lt;&lt;typeid(T).name()&lt;&lt;&quot;, &quot;&lt;&lt;label&lt;&lt;&quot; = &quot;&lt;&lt;value&lt;&lt;std::endl;
             std::cout&lt;&lt;&quot;rank &quot;&lt;&lt;myRank&lt;&lt;&quot;, printer &quot;&lt;&lt;this-&gt;get_printer_name()&lt;&lt;&quot;: pointID=&quot;&lt;&lt;pointID&lt;&lt;&quot;, mpirank=&quot;&lt;&lt;mpirank&lt;&lt;std::endl;
           #endif

           PPIDpair ppid(pointID,mpirank);
           if(synchronised)
           {
             // Write the data to the selected buffer (&quot;just works&quot; for simple numeric types)
             selected_buffer.append(value,ppid);
           }
           else
           {
             // Queue up a desynchronised (&quot;random access&quot;) dataset write to previous scan iteration
             if(not seen_PPID_before(ppid))
             {
               add_PPID_to_list(ppid);
             }
             selected_buffer.RA_write(value,ppid,primary_printer-&gt;global_index_lookup);
           }
        }

      private:
        // String names for output file and group
        std::string tmp_comb_file; // temporary combined output filename
        std::string tmpfile;   // temporary filename (unique to each process)
        std::string finalfile; // Combined results moved here only upon successful scan completion
        std::string group;     // HDF5 group location to store datasets

        // Handles for HDF5 files and groups containing the datasets
        hid_t file_id;
        hid_t group_id;
        hid_t RA_group_id;

        // Handle to a location in a HDF5 to which the datasets will be written
        // i.e. a file or a group.
        hid_t location_id;
        hid_t RA_location_id;

        /// Pointer to the primary printer object
        // (if this is an auxilliary printer, else it is &quot;this&quot; //NULL)
        HDF5Printer* primary_printer = this; //NULL;

        /// Flag to specify if this is the primary printer or not
        bool is_primary_printer = false;

        /// Flag to disable combination of hdf5 output (user will have to run the combination routines manually)
        bool disable_combine_routines = false;

        /// Map containing pointers to all VertexBuffers contained in this printer
        // Note: Each buffer contains a bool to indicate whether it has done an &quot;append&quot; for the point &quot;lastPointID&quot;
        BaseBufferMap all_my_buffers;

        /// ID of the point that this printer is currently working on.
        // Need this so that we can compute when (at least initial) writing to a model point has ceased
        PPIDpair lastPointID;

        /// Current absolute dataset index
        // i.e. this location in the output dataset is currently the target of print functions
        unsigned long current_dset_position;

        /// Map from pointID,thread pairs to absolute dataset indices
        //  Needed for dataset writes which return to old points.
        std::map&lt;PPIDpair, unsigned long&gt; global_index_lookup;

        // Matching vector for the above, for reverse lookup
        std::vector&lt;PPIDpair&gt; reverse_global_index_lookup;

        /// Offset needed to be added to the reverse lookup in
        /// order for it to match the output dataset position correctly
        unsigned long RA_dset_offset = 0;

        /// Label for printer, mostly for more helpful error messages
        std::string printer_name;

        /// MPI rank and size
        unsigned int myRank;  // Needed even without MPI available, for some default behaviour.
        unsigned int mpiSize; //            &quot;                           &quot;
        #ifdef WITH_MPI
        // Gambit MPI communicator context for use within the hdf5 printer system
        GMPI::Comm myComm;
        #endif

        /// Flag to specify whether all buffers created by this printer
        /// should be synchronised and iterated along with the Gambit
        /// scanner iterations.
        bool synchronised = true;

        /// Flag to trigger &quot;global&quot; write mode for printer
        // i.e. print data will not be associated with parameter space points,
        // but will be &quot;global&quot; data about the whole scan (e.g. max log likelihood
        // found, scan statistics, etc.)
        bool global = false;

        /// Position to start writing new output. Should be zero unless we are in
        /// resume mode.
        //unsigned long startpos = 0; // OBSOLETE

        /// Write position to which output buffers should be synchronised
        unsigned long sync_pos = 0;

        /// In resume mode: storage for PPIDpairs harvested from previous scan data
        std::vector&lt;PPIDpair&gt; previous_points;

      protected:
        /// Things which other printers need access to

        /// Map containing pointers to all VertexBuffers, across all printers
        // Note: Each buffer contains a bool to indicate whether it has done an &quot;append&quot; for the point &quot;lastPointID&quot;
        BaseBufferMap all_buffers;

    };

    /// Macro to help define the buffer manager getter functions
    // Need to use it outside the class body, and be sure to typedef
    // types which can not form part of a valid variable name.
    #define DEFINE_BUFFMAN_GETTER(TYPE)                                        \
      template&lt;&gt;                                                               \
      inline H5P_LocalBufferManager&lt;VertexBufferNumeric1D_HDF5&lt;TYPE,BUFFERLENGTH&gt;&gt;&amp; \
       HDF5Printer::get_mybuffermanager&lt;TYPE&gt;(ulong pointID, uint mpirank) \
      {                                                                        \
         /* If the buffermanger hasn't been initialised, do so now */          \
         if( not CAT(hdf5_localbufferman_,TYPE).ready() )                      \
         {                                                                     \
            CAT(hdf5_localbufferman_,TYPE).init(this,synchronised);            \
         }                                                                     \
                                                                               \
         /* While we are at it, check if the buffers need to be                \
            synchronised to a new point. But only if this printer is running   \
            in &quot;synchronised&quot; mode. */                                         \
         if(synchronised)                                                      \
         {                                                                     \
           check_for_new_point(PPIDpair(pointID, mpirank));                    \
         }                                                                     \
         return CAT(hdf5_localbufferman_,TYPE);                                \
      }

    DEFINE_BUFFMAN_GETTER(int      )
    DEFINE_BUFFMAN_GETTER(uint     )
    DEFINE_BUFFMAN_GETTER(long     )
    DEFINE_BUFFMAN_GETTER(ulong    )
    DEFINE_BUFFMAN_GETTER(longlong )
    DEFINE_BUFFMAN_GETTER(ulonglong)
    DEFINE_BUFFMAN_GETTER(float    )
    DEFINE_BUFFMAN_GETTER(double   )


    /// @{ Templated H5P_LocalBufferManager member functions

    template&lt;class BuffType&gt;
    void H5P_LocalBufferManager&lt;BuffType&gt;::init(HDF5Printer* p, bool sync)
    {
      /* Set global behaviour flag */
      synchronised = sync;

      /* Attempt to attach to printer */
      if(p==NULL)
      {
        std::ostringstream errmsg;
        errmsg &lt;&lt; &quot;Error! Tried to initialise a H5P_LocalBufferManager with a null pointer! Need an actual HDF5Printer object in order to work. This is a bug in the HDF5Printer class, please report it.&quot;;
        printer_error().raise(LOCAL_INFO, errmsg.str());
      }
      if(not ready()) {
        printer = p;
      } else {
        std::ostringstream errmsg;
        errmsg &lt;&lt; &quot;Error! Tried to initialise a H5P_LocalBufferManager twice! This is a bug in the HDF5Printer class, please report it.&quot;;
        printer_error().raise(LOCAL_INFO, errmsg.str());
      }
    }

    template&lt;class BuffType&gt;
    BuffType&amp; H5P_LocalBufferManager&lt;BuffType&gt;::get_buffer(const int vertexID, const unsigned int aux_i, const std::string&amp; label)
    {
      if(not ready()) {
        std::ostringstream errmsg;
        errmsg &lt;&lt; &quot;Error! Tried to retrieve a buffer from a buffer manager without first initialising it! This is a bug in the HDF5Printer class, please report it.&quot;;
        printer_error().raise(LOCAL_INFO, errmsg.str());
      }

      VBIDpair key;
      key.vertexID = vertexID;
      key.index    = aux_i;

      typename std::map&lt;VBIDpair, BuffType&gt;::iterator it = local_buffers.find(key);

      if( it == local_buffers.end() )
      {
        error_if_key_exists(local_buffers, key, &quot;local_buffers&quot;);
        // No local buffer exists for this output stream yet, so make one
        // But check first if another printer manager is already handling this
        // output stream. If so, we relinquish control over it and silence the
        // new output stream.
        bool silence = false;
        #ifdef DEBUG_MODE
          std::cout&lt;&lt;&quot;Preparing to create new print output stream...&quot;&lt;&lt;std::endl;
          std::cout&lt;&lt;&quot;...label = &quot;&lt;&lt;label&lt;&lt;std::endl;
          std::cout&lt;&lt;&quot;...is stream already managed? &quot;&lt;&lt;printer-&gt;is_stream_managed(key)&lt;&lt;std::endl;
          std::cout&lt;&lt;&quot;...from printer with name = &quot;&lt;&lt;printer-&gt;get_printer_name()&lt;&lt;std::endl;
          std::cout&lt;&lt;&quot;...from printer with name = &quot;&lt;&lt;printer-&gt;get_printer_name()&lt;&lt;std::endl;
        #endif
        if( printer-&gt;is_stream_managed(key) )
        {
          silence = true;
        }
        #ifdef DEBUG_MODE
          std::cout&lt;&lt;&quot;...is silenced? &quot;&lt;&lt;silence&lt;&lt;std::endl;
        #endif

        // Create the new buffer object
        hid_t loc(-1);
        if(synchronised)
        {
          loc = printer-&gt;get_location();
        }
        else // write to the RA group
        {
          loc = printer-&gt;get_RA_location();
        }

        local_buffers[key] = BuffType( loc
                                      , label/*deconstruct?*/
                                      , vertexID
                                      , aux_i
                                      , synchronised
                                      , silence
                                      , false /*printer-&gt;get_resume() -- In this new version of the HDF5Printer we write temporary files and then combine them at the end of the scan, so each individual buffer no longer needs to be in 'resume' mode, it can just start anew and be combined with the old data later on */
                                      , access /* r/w mode. Buffers can now be used for reading also. */
                                      );

        // Get the new (possibly silenced) buffer back out of the map
        it = local_buffers.find(key);

        // Add a pointer to the new buffer to the full list as well
        if(not silence) printer-&gt;insert_buffer( key, it-&gt;second );

        // Force increment the buffer to &quot;catch it up&quot; to the current sync
        // position, in case it has been created &quot;late&quot;.
        // We subtract one because another increment will happen after
        // the print statement (that triggered the creation of the new
        // buffer) completes.
        if(synchronised) it-&gt;second.fast_forward(printer-&gt;get_sync_pos()-1);
      }

      if( it == local_buffers.end() )
      {
        std::ostringstream errmsg;
        errmsg &lt;&lt; &quot;Error! Failed to retrieve newly created buffer (label=&quot;&lt;&lt;label&lt;&lt;&quot;) from local_buffers map! Key was: (&quot;&lt;&lt;vertexID&lt;&lt;&quot;,&quot;&lt;&lt;aux_i&lt;&lt;&quot;)&quot;&lt;&lt;std::endl;
        printer_error().raise(LOCAL_INFO, errmsg.str());
      }

      return it-&gt;second;
    }

    /// @}


    // Avoid cluttering up &quot;macro namespace&quot;
    #undef DEFINE_BUFFMAN_GETTER
    #undef BT

    // Register printer so it can be constructed via inifile instructions
    // First argument is string label for inifile access, second is class from which to construct printer
    LOAD_PRINTER(hdf5_v1, HDF5Printer)

  } // end namespace Printers

} // end namespace Gambit

#ifdef DEBUG_MODE
  #undef DEBUG_MODE
#endif

#endif
</code></pre><hr><p>Updated on 2022-09-08 at 00:43:03 +0000</p></main></div></div></div><footer class="footer text-muted"><div class=container-xxl><div class=row><div class="col-lg-8 order-last order-lg-first"><ul class=list-inline><li class=list-inline-item>Powered by <a href=https://gohugo.io/>Hugo</a> and <a href=https://getdoks.org/>Doks</a></li></ul></div><div class="col-lg-8 order-first order-lg-last text-lg-end"><ul class=list-inline><li class=list-inline-item><a href=/license/>License</a></li></ul></div></div></div></footer><script src=/js/bootstrap.min.1da7e648bd316d7b1f1bff21fe81545e73f3c2385908a8c3be87f79a560042318b4b13031e53871d84590710da0df312590e0c60b11a6a1b83dede2f81c30b66.js integrity="sha512-HafmSL0xbXsfG/8h/oFUXnPzwjhZCKjDvof3mlYAQjGLSxMDHlOHHYRZBxDaDfMSWQ4MYLEaahuD3t4vgcMLZg==" crossorigin=anonymous defer></script>
<script src=/js/highlight.min.5b48bc253dc75aeea5fb366ecf700f4925e2b6eb1a1466f2124b722d68148d67bc0a9365d2b8ad9c585161b46372d23b08509a16f1fd518542b894756d4752d0.js integrity="sha512-W0i8JT3HWu6l+zZuz3APSSXitusaFGbyEktyLWgUjWe8CpNl0ritnFhRYbRjctI7CFCaFvH9UYVCuJR1bUdS0A==" crossorigin=anonymous defer></script>
<script src=/main.min.162c56a0426544de0d010e66c56e321579655c400c9aae06a6823e7682de379adadf2165bd416fea191e4e7e410fbf1fd2c35a759aa43ff2e3787067669bf81b.js integrity="sha512-FixWoEJlRN4NAQ5mxW4yFXllXEAMmq4GpoI+doLeN5ra3yFlvUFv6hkeTn5BD78f0sNadZqkP/LjeHBnZpv4Gw==" crossorigin=anonymous defer></script>
<script src=https://gambitbsm.github.io/index.min.fc32c4e913dc047fd492ee5652ef28633a5bb660d5c1a2a69d8dcaa733a80928e745f3c857c87d7f8111b26a9de25d7f86ff437fc9457fc0ef0db092a6d00bdd.js integrity="sha512-/DLE6RPcBH/Uku5WUu8oYzpbtmDVwaKmnY3KpzOoCSjnRfPIV8h9f4ERsmqd4l1/hv9Df8lFf8DvDbCSptAL3Q==" crossorigin=anonymous defer></script></body></html>