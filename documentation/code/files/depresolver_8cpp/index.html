<!doctype html><html lang=en><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="ie=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><link rel=preload as=font href=https://gambitbsm.org/fonts/vendor/jost/jost-v4-latin-regular.woff2 type=font/woff2 crossorigin><link rel=preload as=font href=https://gambitbsm.org/fonts/vendor/jost/jost-v4-latin-500.woff2 type=font/woff2 crossorigin><link rel=preload as=font href=https://gambitbsm.org/fonts/vendor/jost/jost-v4-latin-700.woff2 type=font/woff2 crossorigin><script>(()=>{var e=localStorage.getItem("theme");e==="dark"&&document.documentElement.setAttribute("data-dark-mode","")})()</script><link rel=stylesheet href=https://gambitbsm.org/main.e0ef67572fa591316dbb2b276e1aed52fd04025355d700a37b20ae76eb126fadbe7ceaddbb47632a2f1bf66c490a69e0cd1f1a0dc12b2980ae4b5ffc6d257d62.css integrity="sha512-4O9nVy+lkTFtuysnbhrtUv0EAlNV1wCjeyCudusSb62+fOrdu0djKi8b9mxJCmngzR8aDcErKYCuS1/8bSV9Yg==" crossorigin=anonymous><noscript><style>img.lazyload{display:none}</style></noscript><meta name=robots content="index, follow"><meta name=googlebot content="index, follow, max-snippet:-1, max-image-preview:large, max-video-preview:-1"><meta name=bingbot content="index, follow, max-snippet:-1, max-image-preview:large, max-video-preview:-1"><title>file src/depresolver.cpp - GAMBIT</title><meta name=description content="[No description available]"><link rel=canonical href=https://gambitbsm.org/documentation/code/files/depresolver_8cpp/><meta property="og:locale" content="en_US"><meta property="og:type" content="article"><meta property="og:title" content="file src/depresolver.cpp"><meta property="og:description" content="[No description available]"><meta property="og:url" content="https://gambitbsm.org/documentation/code/files/depresolver_8cpp/"><meta property="og:site_name" content="GAMBIT"><meta property="og:image" content="https://gambitbsm.org/gambit_logo.png"><meta property="og:image:alt" content="GAMBIT"><meta name=twitter:card content="summary_large_image"><meta name=twitter:site content><meta name=twitter:creator content><meta name=twitter:title content="file src/depresolver.cpp"><meta name=twitter:description content="[No description available]"><meta name=twitter:image content="https://gambitbsm.org/gambit_logo.png"><meta name=twitter:image:alt content="file src/depresolver.cpp"><script type=application/ld+json>{"@context":"https://schema.org","@graph":[{"@type":"Organization","@id":"https://gambitbsm.org/#/schema/organization/1","name":"Doks","url":"https://gambitbsm.org/","sameAs":["https://github.com/GambitBSM"],"logo":{"@type":"ImageObject","@id":"https://gambitbsm.org/#/schema/image/1","url":"https://gambitbsm.org/logo-doks.png","width":450,"height":416,"caption":"Doks"},"image":{"@id":"https://gambitbsm.org/#/schema/image/1"}},{"@type":"WebSite","@id":"https://gambitbsm.org/#/schema/website/1","url":"https://gambitbsm.org/","name":"GAMBIT","description":"Documentation for GAMBIT, the Global And Modular BSM Inference Tool","publisher":{"@id":"https://gambitbsm.org/#/schema/organization/1"}},{"@type":"WebPage","@id":"https://gambitbsm.org/documentation/code/files/depresolver_8cpp/","url":"https://gambitbsm.org/documentation/code/files/depresolver_8cpp/","name":"file src\/depresolver.cpp","description":"[No description available]","isPartOf":{"@id":"https://gambitbsm.org/#/schema/website/1"},"about":{"@id":"https://gambitbsm.org/#/schema/organization/1"},"datePublished":"0001-01-01T00:00:00CET","dateModified":"0001-01-01T00:00:00CET","breadcrumb":{"@id":"https://gambitbsm.org/documentation/code/files/depresolver_8cpp/#/schema/breadcrumb/1"},"primaryImageOfPage":{"@id":"https://gambitbsm.org/documentation/code/files/depresolver_8cpp/#/schema/image/2"},"inLanguage":"en-US","potentialAction":[{"@type":"ReadAction","target":["https://gambitbsm.org/documentation/code/files/depresolver_8cpp/"]}]},{"@type":"BreadcrumbList","@id":"https://gambitbsm.org/documentation/code/files/depresolver_8cpp/#/schema/breadcrumb/1","name":"Breadcrumbs","itemListElement":[{"@type":"ListItem","position":1,"item":{"@type":"WebPage","@id":"https://gambitbsm.org/","url":"https://gambitbsm.org/","name":"Home"}},{"@type":"ListItem","position":2,"item":{"@type":"WebPage","@id":"https://gambitbsm.org/documentation/","url":"https://gambitbsm.org/documentation/","name":"Documentation"}},{"@type":"ListItem","position":3,"item":{"@type":"WebPage","@id":"https://gambitbsm.org/documentation/code/","url":"https://gambitbsm.org/documentation/code/","name":"Code"}},{"@type":"ListItem","position":4,"item":{"@type":"WebPage","@id":"https://gambitbsm.org/documentation/code/files/","url":"https://gambitbsm.org/documentation/code/files/","name":"Files"}},{"@type":"ListItem","position":5,"item":{"@id":"https://gambitbsm.org/documentation/code/files/depresolver_8cpp/"}}]},{"@context":"https://schema.org","@graph":[{"@type":"ImageObject","@id":"https://gambitbsm.org/documentation/code/files/depresolver_8cpp/#/schema/image/2","url":"https://gambitbsm.org/gambit_logo.png","contentUrl":"https://gambitbsm.org/gambit_logo.png","caption":"file src\/depresolver.cpp"}]}]}</script><meta name=theme-color content="#fff"><link rel=icon href=https://gambitbsm.org/favicon.ico sizes=any><link rel=icon type=image/svg+xml href=https://gambitbsm.org/favicon.svg><link rel=apple-touch-icon sizes=180x180 href=https://gambitbsm.org/apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=https://gambitbsm.org/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=https://gambitbsm.org/favicon-16x16.png><link rel=manifest crossorigin=use-credentials href=https://gambitbsm.org/site.webmanifest></head><body class="documentation single light"><div class=sticky-top><div class=header-bar></div><header class="navbar navbar-expand-md navbar-light doks-navbar"><nav class="container-xxl flex-wrap flex-md-nowrap" aria-label="Main navigation"><a class="navbar-brand p-0 me-auto" href=https://gambitbsm.org/ aria-label=GAMBIT><img class=logo-light src=https://gambitbsm.org/gambit_logo.png width=50px>
<img class="logo-dark d-none" src=https://gambitbsm.org/gambit_logo.png width=50px>
GAMBIT</a>
<button class="btn btn-menu order-2 d-block d-lg-none" type=button data-bs-toggle=offcanvas data-bs-target=#offcanvasDoks aria-controls=offcanvasDoks aria-label="Open main menu"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-menu"><line x1="3" y1="12" x2="21" y2="12"/><line x1="3" y1="6" x2="21" y2="6"/><line x1="3" y1="18" x2="21" y2="18"/></svg></button><div class="offcanvas offcanvas-end border-0 py-lg-1" tabindex=-1 id=offcanvasDoks data-bs-backdrop=true aria-labelledby=offcanvasDoksLabel><div class="header-bar d-lg-none"></div><div class="offcanvas-header d-lg-none"><h2 class="h5 offcanvas-title ps-2" id=offcanvasDoksLabel><a class=text-dark href=/>GAMBIT</a></h2><button type=button class="btn-close text-reset me-2" data-bs-dismiss=offcanvas aria-label="Close main menu"></button></div><div class="offcanvas-body p-4 p-lg-0"><ul class="nav flex-column flex-lg-row align-items-lg-center mt-2 mt-lg-0 ms-lg-2 me-lg-auto"><li class="nav-item dropdown"><a class="nav-link dropdown-toggle ps-0 py-1" href=# id=navbarDropdownMenuLink role=button data-bs-toggle=dropdown aria-expanded=false>Releases
<span class=dropdown-caret><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-chevron-down"><polyline points="6 9 12 15 18 9"/></svg></span></a><ul class="dropdown-menu dropdown-menu-main shadow rounded border-0" aria-labelledby=navbarDropdownMenuLink><li><a class=dropdown-item href=https://github.com/GambitBSM/gambit_2.6>GAMBIT 2-6 ⧉</a></li><li><a class=dropdown-item href=https://github.com/GambitBSM/gambit_2.5>GAMBIT 2-5 ⧉</a></li><li><a class=dropdown-item href=https://github.com/GambitBSM/gambit_2.4>GAMBIT 2-4 ⧉</a></li><li><a class=dropdown-item href=https://github.com/GambitBSM/gambit_2.3>GAMBIT 2-3 ⧉</a></li><li><a class=dropdown-item href=https://github.com/GambitBSM/gambit_2.2>GAMBIT 2-2 ⧉</a></li><li><a class=dropdown-item href=https://github.com/GambitBSM/gambit_2.1>GAMBIT 2-1 ⧉</a></li><li><a class=dropdown-item href=https://github.com/GambitBSM/gambit_2.6/tags>All releases ⧉</a></li></ul></li><li class="nav-item dropdown"><a class="nav-link dropdown-toggle ps-0 py-1" href=# id=navbarDropdownMenuLink role=button data-bs-toggle=dropdown aria-expanded=false>Documentation
<span class=dropdown-caret><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-chevron-down"><polyline points="6 9 12 15 18 9"/></svg></span></a><ul class="dropdown-menu dropdown-menu-main shadow rounded border-0" aria-labelledby=navbarDropdownMenuLink><li><a class=dropdown-item href=/documentation/installation/introduction/>Installation</a></li><li><a class=dropdown-item href=/documentation/tutorials/the_gambit_interface>Tutorials</a></li><li><a class=dropdown-item href=/documentation/help/common_problems_and_questions/>Help</a></li><li><a class=dropdown-item href=/documentation/code/index_classes>Code Reference</a></li></ul></li><li class="nav-item dropdown"><a class="nav-link dropdown-toggle ps-0 py-1" href=# id=navbarDropdownMenuLink role=button data-bs-toggle=dropdown aria-expanded=false>Community
<span class=dropdown-caret><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-chevron-down"><polyline points="6 9 12 15 18 9"/></svg></span></a><ul class="dropdown-menu dropdown-menu-main shadow rounded border-0" aria-labelledby=navbarDropdownMenuLink><li><a class=dropdown-item href=https://github.com/GambitBSM/wiki>Wiki</a></li><li><a class=dropdown-item href=/community/publications/>Publications</a></li><li><a class=dropdown-item href=/community/talks/>Talks</a></li><li><a class=dropdown-item href=/community/members/>Members</a></li><li><a class=dropdown-item href=/community/code_of_conduct/>Code of Conduct</a></li><li><a class=dropdown-item href=/community/contact/>Contact</a></li></ul></li></ul><hr class="text-black-50 my-4 d-lg-none"><form class="doks-search position-relative flex-grow-1 ms-lg-auto me-lg-2"><input id=search class="form-control is-search" type=search placeholder="Search site..." aria-label="Search site..." autocomplete=off><div id=suggestions class="shadow bg-white rounded d-none"></div></form><hr class="text-black-50 my-4 d-lg-none"><ul class="nav flex-column flex-lg-row"><li class=nav-item><a class="nav-link social-link" href=https://github.com/GambitBSM><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-github"><path d="M9 19c-5 1.5-5-2.5-7-3m14 6v-3.87a3.37 3.37.0 00-.94-2.61c3.14-.35 6.44-1.54 6.44-7A5.44 5.44.0 0020 4.77 5.07 5.07.0 0019.91 1S18.73.65 16 2.48a13.38 13.38.0 00-7 0C6.27.65 5.09 1 5.09 1A5.07 5.07.0 005 4.77 5.44 5.44.0 003.5 8.55c0 5.42 3.3 6.61 6.44 7A3.37 3.37.0 009 18.13V22"/></svg><small class="ms-2 d-lg-none">GitHub</small></a></li></ul><hr class="text-black-50 my-4 d-lg-none"><button id=mode class="btn btn-link" type=button aria-label="Toggle user interface mode">
<span class=toggle-dark><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-moon"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg></span><span class=toggle-light><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-sun"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></span></button></div></div></nav></header></div><div class="wrap container-xxl" role=document><div class=content><div class="row flex-xl-nowrap"><div class="col-lg-5 col-xl-4 docs-sidebar"><nav class=docs-links aria-label="Main navigation"><ul class="list-unstyled collapsible-sidebar"><li class=mb-1><button class="btn btn-toggle align-items-center rounded collapsed" data-bs-toggle=collapse data-bs-target=#section-installation aria-expanded=false>
Installation</button><div class=collapse id=section-installation><ul class="btn-toggle-nav list-unstyled fw-normal pb-1 small"><li><a class="docs-link rounded" href=/documentation/installation/introduction/>Getting Started</a></li><li><a class="docs-link rounded" href=/documentation/installation/docker_usage/>Docker Usage</a></li><li><a class="docs-link rounded" href=/documentation/installation/installation_for_linux/>Installation for Linux</a></li><li><a class="docs-link rounded" href=/documentation/installation/installation_for_windows/>Installation for Windows</a></li><li><a class="docs-link rounded" href=/documentation/installation/installation_for_macos/>Installation for macOS</a></li></ul></div></li><li class=mb-1><button class="btn btn-toggle align-items-center rounded collapsed" data-bs-toggle=collapse data-bs-target=#section-tutorials aria-expanded=false>
Tutorials</button><div class=collapse id=section-tutorials><ul class="btn-toggle-nav list-unstyled fw-normal pb-1 small"><li><a class="docs-link rounded" href=/documentation/tutorials/the_gambit_interface/>1 - The GAMBIT Interface</a></li><li><a class="docs-link rounded" href=/documentation/tutorials/in_person_tutorials/>In person tutorials</a></li></ul></div></li><li class=mb-1><button class="btn btn-toggle align-items-center rounded collapsed" data-bs-toggle=collapse data-bs-target=#section-help aria-expanded=false>
Help</button><div class=collapse id=section-help><ul class="btn-toggle-nav list-unstyled fw-normal pb-1 small"><li><a class="docs-link rounded" href=/documentation/help/common_problems_and_questions/>Common Problems and Questions</a></li><li><a class="docs-link rounded" href=/documentation/help/compiler_matrix/>Compiler Matrix</a></li><li><a class="docs-link rounded" href=/documentation/help/known_issues/>Known Issues</a></li><li><a class="docs-link rounded" href=/documentation/help/configuration_examples/>Configuration Examples</a></li><li><a class="docs-link rounded" href=/documentation/help/support/>Support</a></li></ul></div></li><li class=mb-1><button class="btn btn-toggle align-items-center rounded collapsed" data-bs-toggle=collapse data-bs-target=#section-code aria-expanded=false>
Code Reference</button><div class=collapse id=section-code><ul class="btn-toggle-nav list-unstyled fw-normal pb-1 small"><li><a class="docs-link rounded" href=/documentation/code/index_classes/>Classes</a></li><li><a class="docs-link rounded" href=/documentation/code/index_files/>Files</a></li><li><a class="docs-link rounded" href=/documentation/code/index_pages/>Pages</a></li><li><a class="docs-link rounded" href=/documentation/code/index_namespaces/>Namespaces</a></li></ul></div></li></ul></nav></div><nav class="docs-toc d-none d-xl-block col-xl-3" aria-label="Secondary navigation"><div class=d-xl-none><button class="btn btn-outline-primary btn-sm doks-toc-toggle collapsed" type=button data-bs-toggle=collapse data-bs-target=#onThisPage aria-controls=doks-docs-nav aria-expanded=false aria-label="Toggle On this page navigation">
<span>On this page</span>
<span><svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24" class="doks doks-expand" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><title>Expand</title><polyline points="7 13 12 18 17 13"/><polyline points="7 6 12 11 17 6"/></svg><svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24" class="doks doks-collapse" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><title>Collapse</title><polyline points="17 11 12 6 7 11"/><polyline points="17 18 12 13 7 18"/></svg></span></button><div class=collapse id=onThisPage><div class="card card-body mt-3 py-1"><div class=page-links><nav id=TableOfContents><ul><li><a href=#namespaces>Namespaces</a></li><li><a href=#classes>Classes</a></li><li><a href=#defines>Defines</a></li><li><a href=#detailed-description>Detailed Description</a></li><li><a href=#macros-documentation>Macros Documentation</a><ul><li><a href=#define-normal-dependency>define NORMAL_DEPENDENCY</a></li><li><a href=#define-loop-manager-dependency>define LOOP_MANAGER_DEPENDENCY</a></li></ul></li><li><a href=#source-code>Source code</a></li></ul></nav></div></div></div></div><div class="page-links d-none d-xl-block"><h3>On this page</h3><nav id=TableOfContents><ul><li><a href=#namespaces>Namespaces</a></li><li><a href=#classes>Classes</a></li><li><a href=#defines>Defines</a></li><li><a href=#detailed-description>Detailed Description</a></li><li><a href=#macros-documentation>Macros Documentation</a><ul><li><a href=#define-normal-dependency>define NORMAL_DEPENDENCY</a></li><li><a href=#define-loop-manager-dependency>define LOOP_MANAGER_DEPENDENCY</a></li></ul></li><li><a href=#source-code>Source code</a></li></ul></nav></div></nav><main class="docs-content col-lg-11 col-xl-9 mx-xl-auto"><nav aria-label=breadcrumb><ol class=breadcrumb><li class=breadcrumb-item><a href=/>Home</a></li><li class=breadcrumb-item><a href=/documentation/>Documentation</a></li><li class=breadcrumb-item><a href=/documentation/code/>Code Reference</a></li><li class="breadcrumb-item active" aria-current=page>file src/depresolver.cpp</li></ol></nav><p class=lead></p><h1 id=file-src-depresolver-cpp>file src/depresolver.cpp <a href=#file-src-depresolver-cpp class=anchor aria-hidden=true>#</a></h1><p>[No description available] <a href=#detailed-description>More&mldr;</a></p><h2 id=namespaces>Namespaces <a href=#namespaces class=anchor aria-hidden=true>#</a></h2><table><thead><tr><th>Name</th></tr></thead><tbody><tr><td><strong><a href=/documentation/code/namespaces/namespacegambit/>Gambit</a></strong><br>TODO: see if we can use this one:</td></tr><tr><td><strong><a href=/documentation/code/namespaces/namespacegambit_1_1dres/>Gambit::DRes</a></strong><br>Forward declaration of <a href>Rule</a> and Observables classes for saving pointers to ignored and matched examples.</td></tr></tbody></table><h2 id=classes>Classes <a href=#classes class=anchor aria-hidden=true>#</a></h2><table><thead><tr><th></th><th>Name</th></tr></thead><tbody><tr><td>class</td><td><strong><a href=/documentation/code/classes/classgambit_1_1dres_1_1edgewriter/>Gambit::DRes::edgeWriter</a></strong><br>Graphviz output for edges/dependencies.</td></tr><tr><td>class</td><td><strong><a href=/documentation/code/classes/classgambit_1_1dres_1_1labelwriter/>Gambit::DRes::labelWriter</a></strong><br>Graphviz output for individual vertices/nodes/module functions.</td></tr></tbody></table><h2 id=defines>Defines <a href=#defines class=anchor aria-hidden=true>#</a></h2><table><thead><tr><th></th><th>Name</th></tr></thead><tbody><tr><td></td><td><strong><a href=/documentation/code/files/depresolver_8cpp/#define-normal-dependency>NORMAL_DEPENDENCY</a></strong></td></tr><tr><td></td><td><strong><a href=/documentation/code/files/depresolver_8cpp/#define-loop-manager-dependency>LOOP_MANAGER_DEPENDENCY</a></strong></td></tr></tbody></table><h2 id=detailed-description>Detailed Description <a href=#detailed-description class=anchor aria-hidden=true>#</a></h2><p><strong>Author</strong>:</p><ul><li>Christoph Weniger (<a href=mailto:c.weniger@uva.nl>c.weniger@uva.nl</a>)</li><li>Pat Scott (<a href=mailto:patrickcolinscott@gmail.com>patrickcolinscott@gmail.com</a>)</li><li>Ben Farmer (<a href=mailto:benjamin.farmer@monash.edu>benjamin.farmer@monash.edu</a>)</li><li>Tomas Gonzalo (<a href=mailto:gonzalo@physik.rwth-aachen.de>gonzalo@physik.rwth-aachen.de</a>)</li><li>Patrick Stoecker (<a href=mailto:stoecker@physik.rwth-aachen.de>stoecker@physik.rwth-aachen.de</a>)</li></ul><p><strong>Date</strong>:</p><ul><li>2013 May, Jun, Jul, Sep</li><li>2014 Feb, Mar, Apr</li><li>2013 May, Jul, Aug, Nov 2014 Jan, Mar, Apr, Dec 2018 Sep, Nov 2022 Nov, Dec 2023 Jan</li><li>2013 Sep</li><li>2017 June 2019 May 2020 June 2021 Sep</li><li>2020 May, Nov</li></ul><p>Dependency resolution with boost graph library</p><pre><code>    unravels the un-unravelable
</code></pre><hr><p>Authors (add name and date if you modify):</p><hr><h2 id=macros-documentation>Macros Documentation <a href=#macros-documentation class=anchor aria-hidden=true>#</a></h2><h3 id=define-normal-dependency>define NORMAL_DEPENDENCY <a href=#define-normal-dependency class=anchor aria-hidden=true>#</a></h3><pre><code>#define NORMAL_DEPENDENCY 1
</code></pre><h3 id=define-loop-manager-dependency>define LOOP_MANAGER_DEPENDENCY <a href=#define-loop-manager-dependency class=anchor aria-hidden=true>#</a></h3><pre><code>#define LOOP_MANAGER_DEPENDENCY 2
</code></pre><h2 id=source-code>Source code <a href=#source-code class=anchor aria-hidden=true>#</a></h2><pre><code>//   GAMBIT: Global and Modular BSM Inference Tool
//   *********************************************
///  \file
///
///  Dependency resolution with boost graph library
///
///          unravels the un-unravelable
///
///  *********************************************
///
///  Authors (add name and date if you modify):
///
///  \author Christoph Weniger
///          (c.weniger@uva.nl)
///  \date 2013 May, Jun, Jul, Sep
///  \date 2014 Feb, Mar, Apr
///
///  \author Pat Scott
///          (patrickcolinscott@gmail.com)
///  \date 2013 May, Jul, Aug, Nov
///        2014 Jan, Mar, Apr, Dec
///        2018 Sep, Nov
///        2022 Nov, Dec
///        2023 Jan
///
///  \author Ben Farmer
///          (benjamin.farmer@monash.edu)
///  \date 2013 Sep
///
///  \author Tomas Gonzalo
///          (gonzalo@physik.rwth-aachen.de)
///  \date 2017 June
///        2019 May
///        2020 June
///        2021 Sep
///
///  \author Patrick Stoecker
///          (stoecker@physik.rwth-aachen.de)
///  \date 2020 May, Nov
///
///  *********************************************

#include &quot;gambit/Core/depresolver.hpp&quot;
#include &quot;gambit/Core/observable.hpp&quot;
#include &quot;gambit/Core/rule.hpp&quot;
#include &quot;gambit/Models/models.hpp&quot;
#include &quot;gambit/Utils/stream_overloads.hpp&quot;
#include &quot;gambit/Utils/util_functions.hpp&quot;
#include &quot;gambit/Utils/version.hpp&quot;
#include &quot;gambit/Utils/bibtex_functions.hpp&quot;
#include &quot;gambit/Utils/citation_keys.hpp&quot;
#include &quot;gambit/Logs/logger.hpp&quot;
#include &quot;gambit/Backends/backend_singleton.hpp&quot;
#include &quot;gambit/cmake/cmake_variables.hpp&quot;

#include &lt;sstream&gt;
#include &lt;fstream&gt;
#include &lt;iomanip&gt;
#include &lt;regex&gt;
#include &lt;utility&gt;

#include &lt;boost/format.hpp&gt;
#include &lt;boost/algorithm/string/replace.hpp&gt;
#ifdef HAVE_GRAPHVIZ
  #include &lt;boost/graph/graphviz.hpp&gt;
#endif

// Dependency types
#define NORMAL_DEPENDENCY 1
#define LOOP_MANAGER_DEPENDENCY 2

// Debug flag
//#define DEPRES_DEBUG

// Verbose flag (not debug per se, just basic dependency resolution information)
//#define VERBOSE_DEP_RES

namespace Gambit
{

  namespace DRes
  {
    using namespace LogTags;

    ///////////////////////
    // Auxiliary classes
    //////////////////////

    /// Default constructor for QueueEntry
    QueueEntry::QueueEntry()
    : toVertex(0),
      obslike(NULL)
    {}

    /// Alternative constructor for QueueEntry
    QueueEntry::QueueEntry(sspair a, VertexID b, int c, bool d)
    : quantity(a),
      toVertex(b),
      dependency_type(c),
      printme(d),
      obslike(NULL)
    {}


    ///////////////////////
    // Auxiliary functions
    ///////////////////////

    //
    // Functions that act on a resolved dependency graph
    //

    /// Collect parent vertices recursively (excluding root vertex)
    void getParentVertices(const VertexID &amp; vertex, const
        MasterGraphType &amp; graph, std::set&lt;VertexID&gt; &amp; myVertexList)
    {
      graph_traits&lt;MasterGraphType&gt;::in_edge_iterator it, iend;

      for (std::tie(it, iend) = in_edges(vertex, graph);
          it != iend; ++it)
      {
        if (std::find(myVertexList.begin(), myVertexList.end(), source(*it, graph)) == myVertexList.end() )
        {
          myVertexList.insert(source(*it, graph));
          getParentVertices(source(*it, graph), graph, myVertexList);
        }
      }
    }

    /// Sort given list of vertices (according to topological sort result)
    std::vector&lt;VertexID&gt; sortVertices(const std::set&lt;VertexID&gt; &amp; set,
        const std::list&lt;VertexID&gt; &amp; topoOrder)
    {
      std::vector&lt;VertexID&gt; result;
      for(const VertexID&amp; v : topoOrder)
      {
        if (set.find(v) != set.end()) result.push_back(v);
      }
      return result;
    }

    /// Get sorted list of parent vertices
    std::vector&lt;VertexID&gt; getSortedParentVertices(const VertexID &amp; vertex, const
        MasterGraphType &amp; graph, const std::list&lt;VertexID&gt; &amp; topoOrder)
    {
      std::set&lt;VertexID&gt; set;
      getParentVertices(vertex, graph, set);
      set.insert(vertex);
      return sortVertices(set, topoOrder);
    }

    //
    // Graphviz output
    //

    /// Graphviz output for edges/dependencies
    class edgeWriter
    {
      public:
        edgeWriter(const MasterGraphType*) {};
        void operator()(std::ostream&amp;, const EdgeID&amp;) const
        {
          //out &lt;&lt; &quot;[style=\&quot;dotted\&quot;]&quot;;
        }
    };

    /// Graphviz output for individual vertices/nodes/module functions
    class labelWriter
    {
      private:
        const MasterGraphType * myGraph;
      public:
        labelWriter(const MasterGraphType * masterGraph) : myGraph(masterGraph) {};
        void operator()(std::ostream&amp; out, const VertexID&amp; v) const
        {
          str type = Utils::fix_type((*myGraph)[v]-&gt;type());
          boost::replace_all(type, str(&quot;&amp;&quot;), str(&quot;&amp;amp;&quot;));
          boost::replace_all(type, str(&quot;&lt;&quot;), str(&quot;&amp;lt;&quot;));
          boost::replace_all(type, str(&quot;&gt;&quot;), str(&quot;&amp;gt;&quot;));
          out &lt;&lt; &quot;[fillcolor=\&quot;#F0F0D0\&quot;, style=\&quot;rounded,filled\&quot;, shape=box,&quot;;
          out &lt;&lt; &quot;label=&lt; &quot;;
          out &lt;&lt; &quot;&lt;font point-size=\&quot;20\&quot; color=\&quot;red\&quot;&gt;&quot; &lt;&lt; (*myGraph)[v]-&gt;capability() &lt;&lt; &quot;&lt;/font&gt;&lt;br/&gt;&quot;;
          out &lt;&lt;  &quot;Type: &quot; &lt;&lt; type &lt;&lt; &quot;&lt;br/&gt;&quot;;
          out &lt;&lt;  &quot;Function: &quot; &lt;&lt; (*myGraph)[v]-&gt;name() &lt;&lt; &quot;&lt;br/&gt;&quot;;
          out &lt;&lt;  &quot;Module: &quot; &lt;&lt; (*myGraph)[v]-&gt;origin();
          out &lt;&lt; &quot;&gt;]&quot;;
        }
    };


    //
    // Misc
    //

    /// Return runtime estimate for a set of nodes
    double getTimeEstimate(const std::set&lt;VertexID&gt; &amp; vertexList, const MasterGraphType &amp;graph)
    {
      double result = 0;
      for (const VertexID&amp; v : vertexList)
      {
        result += graph[v]-&gt;getRuntimeAverage();
      }
      return result;
    }



    ///////////////////////////////////////////////////
    // Public definitions of DependencyResolver class
    ///////////////////////////////////////////////////

    /// Constructor
    DependencyResolver::DependencyResolver(const gambit_core &amp;core,
                                           const Models::ModelFunctorClaw &amp;claw,
                                           const IniParser::IniFile &amp;iniFile,
                                           const Utils::type_equivalency &amp;equiv_classes,
                                                 Printers::BasePrinter &amp;printer)
     : boundCore(&amp;core),
       boundClaw(&amp;claw),
       boundTEs(&amp;equiv_classes),
       boundPrinter(&amp;printer),
       boundIniFile(&amp;iniFile),
       obslikes(boundIniFile-&gt;getObservables()),
       module_rules(boundIniFile-&gt;getModuleRules()),
       backend_rules(boundIniFile-&gt;getBackendRules()),
       index(get(vertex_index,masterGraph)),
       activeFunctorGraphFile(Utils::runtime_scratch()+&quot;GAMBIT_active_functor_graph.gv&quot;)
    {
      addFunctors();
      logger() &lt;&lt; LogTags::dependency_resolver &lt;&lt; endl;
      logger() &lt;&lt; &quot;#######################################&quot;   &lt;&lt; endl;
      logger() &lt;&lt; &quot;#  List of Type Equivalency Classes   #&quot;   &lt;&lt; endl;
      logger() &lt;&lt; &quot;#######################################&quot;;
      for (const auto&amp; equiv_class : boundTEs-&gt;equivalency_classes) logger() &lt;&lt; endl &lt;&lt; equiv_class;
      logger() &lt;&lt; EOM;
    }


    //
    // Initialization stage
    //

    /// Main dependency resolution
    void DependencyResolver::doResolution()
    {
      // Queue of dependencies to be resolved
      std::queue&lt;QueueEntry&gt; resolutionQueue;

      // Set up list of target ObsLikes
      logger() &lt;&lt; LogTags::dependency_resolver &lt;&lt; endl;
      logger() &lt;&lt; &quot;#######################################&quot;   &lt;&lt; endl;
      logger() &lt;&lt; &quot;#        List of Target ObsLikes      #&quot;   &lt;&lt; endl;
      logger() &lt;&lt; &quot;#                                     #&quot;   &lt;&lt; endl;
      logger() &lt;&lt; &quot;# format: Capability (Type) [Purpose] #&quot;   &lt;&lt; endl;
      logger() &lt;&lt; &quot;#######################################&quot;;
      for (const Observable&amp; obslike : obslikes)
      {
        // Format output
        logger() &lt;&lt; LogTags::dependency_resolver &lt;&lt; endl &lt;&lt; obslike.capability &lt;&lt; &quot; (&quot; &lt;&lt; obslike.type &lt;&lt; &quot;) [&quot; &lt;&lt; obslike.purpose &lt;&lt; &quot;]&quot;;
        QueueEntry target;
        target.quantity.first = obslike.capability;
        target.quantity.second = obslike.type;
        target.obslike = &amp;obslike;
        target.printme = obslike.printme;
        resolutionQueue.push(target);
      }
      logger() &lt;&lt; EOM;

      // Activate functors compatible with model we scan over (and deactivate the rest)
      makeFunctorsModelCompatible();

      // Generate dependency tree (the core of the dependency resolution)
      generateTree(resolutionQueue);

      // Find one execution order for activated vertices that is compatible
      // with dependency structure
      function_order = run_topological_sort();

      // Loop manager initialization: Notify them about their nested functions
      for (const std::pair&lt;const VertexID, std::set&lt;VertexID&gt;&gt;&amp; keyvalpair : loopManagerMap)
      {
        // Generate topologically sorted list of vertex IDs that are nested
        // within loop manager keyvalpair ...
        std::vector&lt;VertexID&gt; vertexList = sortVertices(keyvalpair.second, function_order);
        // ... convert that list into functor pointers...
        std::vector&lt;functor*&gt; functorList;
        for (const VertexID&amp; v : vertexList)
        {
          functorList.push_back(masterGraph[v]);
        }
        // ...and store it into loop manager functor
        masterGraph[keyvalpair.first]-&gt;setNestedList(functorList);
      }

      // Initialise the printer object with a list of functors that are set to print
      initialisePrinter();

      #ifdef HAVE_GRAPHVIZ
        // Generate graphviz plot if running in dry-run mode.
        if (boundCore-&gt;show_runorder)
        {
          std::ofstream outf(activeFunctorGraphFile);
          write_graphviz(outf, masterGraph, labelWriter(&amp;masterGraph), edgeWriter(&amp;masterGraph));
        }
      #endif

      // Pre-compute the individually ordered vertex lists for each of the ObsLike entries.
      std::vector&lt;VertexID&gt; order = getObsLikeOrder();
      for(const auto&amp; v : order)
      {
        SortedParentVertices[v] = getSortedParentVertices(v, masterGraph, function_order);
      }

      // Print list of backends required
      if (boundCore-&gt;show_backends)
      {
        printRequiredBackends();
      }

      // Get BibTeX key entries for backends, modules, etc
      getCitationKeys();

      // Get the scanID
      set_scanID();

      // Done
    }

    /// List of masterGraph content
    void DependencyResolver::printFunctorList()
    {
      // Activate functors compatible with model we scan over (and deactivate the rest)
      makeFunctorsModelCompatible();

      graph_traits&lt;MasterGraphType&gt;::vertex_iterator vi, vi_end;
      const str formatString = &quot;%-20s %-32s %-32s %-32s %-15s %-7i %-5i %-5i\n&quot;;
      logger() &lt;&lt; LogTags::dependency_resolver &lt;&lt; endl &lt;&lt; &quot;Vertices registered in masterGraph&quot; &lt;&lt; endl;
      logger() &lt;&lt; &quot;----------------------------------&quot; &lt;&lt; endl;
      logger() &lt;&lt; boost::format(formatString)%
       &quot;MODULE&quot;% &quot;FUNCTION&quot;% &quot;CAPABILITY&quot;% &quot;TYPE&quot;% &quot;PURPOSE&quot;% &quot;STATUS&quot;% &quot;#DEPs&quot;% &quot;#BE_REQs&quot;;
      for (std::tie(vi, vi_end) = vertices(masterGraph); vi != vi_end; ++vi)
      {
        logger() &lt;&lt; boost::format(formatString)%
         (*masterGraph[*vi]).origin()%
         (*masterGraph[*vi]).name()%
         (*masterGraph[*vi]).capability()%
         (*masterGraph[*vi]).type()%
         (*masterGraph[*vi]).purpose()%
         (*masterGraph[*vi]).status()%
         (*masterGraph[*vi]).dependencies().size()%
         (*masterGraph[*vi]).backendreqs().size();
      }
      logger() &lt;&lt;  &quot;Registered Backend vertices&quot; &lt;&lt; endl;
      logger() &lt;&lt;  &quot;---------------------------&quot; &lt;&lt; endl;
      logger() &lt;&lt; printGenericFunctorList(boundCore-&gt;getBackendFunctors(), true);
      logger() &lt;&lt; EOM;
    }

    /// Pretty print function evaluation order
    void DependencyResolver::printFunctorEvalOrder(bool toterminal)
    {
      // Running this lets us check the order of execution. Also helps
      // to verify that we actually have pointers to all the required
      // functors.

      // Get order of evaluation
      std::set&lt;VertexID&gt; parents;
      std::set&lt;VertexID&gt; done; //set of vertices already accounted for
      std::vector&lt;VertexID&gt; order = getObsLikeOrder();

      str formatString  = &quot;%-5s %-25s %-25s %-25s\n&quot;;
      // Might need to check if terminal supports unicode characters...
      str formatString0 = &quot;%-7s %-23s %-25s %-25s %-25s %-6s\n&quot;;  // header
      str formatString1a= &quot;%-9s %-21s %-25s %-25s %-25s %-6s\n&quot;;  // target functors
      str formatString1b= &quot;%-4s \u2514\u2500\u2500&gt; %-21s %-25s %-25s %-25s %-6s\n&quot;;  // target functors
      str formatString2a= &quot;     \u250C\u2500 %-23s %-25s %-25s %-25s %-6s\n&quot;;  // parents
      str formatString2b= &quot;     \u251C\u2500 %-23s %-25s %-25s %-25s %-6s\n&quot;;
      str formatString3a= &quot;     \u250CX %-23s %-25s %-25s %-25s %-6s\n&quot;; // &quot;already done&quot; parents
      str formatString3b= &quot;     \u251CX %-23s %-25s %-25s %-25s %-6s\n&quot;;

      int i = 0;

      // Show the order in which the target functors will be attacked.
      std::ostringstream ss;
      ss &lt;&lt; endl &lt;&lt; &quot;Initial target functor evaluation order&quot; &lt;&lt; endl;
      ss &lt;&lt; &quot;----------------------------------&quot; &lt;&lt; endl;
      ss &lt;&lt; boost::format(formatString)% &quot;#&quot;% &quot;FUNCTION&quot;% &quot;CAPABILITY&quot;% &quot;ORIGIN&quot;;

      for (const VertexID&amp; v : order)
      {
        ss &lt;&lt; boost::format(formatString)%
         i%
         masterGraph[v]-&gt;name()%
         masterGraph[v]-&gt;capability()%
         masterGraph[v]-&gt;origin();
        i++;
      }

      ss &lt;&lt; endl;

      i = 0; // Reset counter
      // Do another loop to show the full initial sequence of functor evaluation
      // This doesn't figure out the sequence within each target functor group; I'm not 100% sure where that is determined. This does, however, show which groups get evaluated first, and which functors are already evaluated.
      ss &lt;&lt; endl &lt;&lt; &quot;Full initial functor evaluation order&quot; &lt;&lt; endl;
      ss &lt;&lt; &quot;----------------------------------&quot; &lt;&lt; endl;
      ss &lt;&lt; boost::format(formatString0)% &quot;#&quot;% &quot;FUNCTION&quot;% &quot;CAPABILITY&quot;% &quot;TYPE&quot;% &quot;ORIGIN&quot;% &quot;PRINT?&quot;;

      for (const VertexID&amp; v : order)
      {
        // loop through parents of each target functor
        parents.clear();
        getParentVertices(v, masterGraph, parents);
        parents.insert(v);
        bool first = true;
        for (const VertexID&amp; v2 : parents)
        {
            str formatstr;
            bool dowrite = false;
            // Check if parent functor has been ticked off the list
            bool is_done = done.find(v2) != done.end();
            if( (not is_done) and (v != v2) )
            {
                formatstr = formatString2b;
                if (first) formatstr = formatString2a;
                dowrite = true;
            }
            else if( v != v2)
            {
                // Might be better to just do nothing here, i.e. set dowrite=false. For now just flagging functor as done with a special format string.
                formatstr = formatString3b;
                if (first) formatstr = formatString3a;
                dowrite = true;
            }

            if (dowrite)
            {
              ss &lt;&lt; boost::format(formatstr)%
                masterGraph[v2]-&gt;name()%
                masterGraph[v2]-&gt;capability()%
                masterGraph[v2]-&gt;type()%
                masterGraph[v2]-&gt;origin()%
                masterGraph[v2]-&gt;requiresPrinting();
            }
            done.insert(v2); // tick parent functor off the list
            first = false;
        }

        // Now show target functor info
        str formatstr;
        if(parents.size()==1) { formatstr = formatString1a; }
        else { formatstr = formatString1b; }
        ss &lt;&lt; boost::format(formatstr)%
         i%
         masterGraph[v]-&gt;name()%
         masterGraph[v]-&gt;capability()%
         masterGraph[v]-&gt;type()%
         masterGraph[v]-&gt;origin()%
         masterGraph[v]-&gt;requiresPrinting();
        i++;

        done.insert(v); // tick this target functor off the list

      }
      ss &lt;&lt; &quot;(\&quot;X\&quot; indicates that the functor is pre-evaluated before the marked position)&quot; &lt;&lt; endl &lt;&lt; endl;

      if (toterminal)
      {
        // There is a command line flag to get this information, since it is very
        // handy to check before launching a full job. It can always be checked via
        // the logs, but this feature is more convenient.
        cout &lt;&lt; ss.str();
        #ifdef HAVE_GRAPHVIZ
          cout &lt;&lt; &quot;To get postscript plot of active functors, please run: &quot; &lt;&lt; endl;
          cout &lt;&lt; GAMBIT_DIR &lt;&lt; &quot;/Core/scripts/./graphviz.sh &quot; &lt;&lt; activeFunctorGraphFile &lt;&lt; &quot; no-loners&quot; &lt;&lt; endl;
        #else
          cout &lt;&lt; &quot;To get postscript plot of active functors, please install graphviz, rerun cmake and remake GAMBIT.&quot; &lt;&lt; endl &lt;&lt; endl;
        #endif
      }

      logger() &lt;&lt; LogTags::dependency_resolver &lt;&lt; ss.str() &lt;&lt; EOM;
    }

    /// Print the list of required backends
    void DependencyResolver::printRequiredBackends()
    {
      // Lists the required backends, indicating where several backends
      // can fulfil the same requirement
      std::stringstream ss;

      ss &lt;&lt; endl &lt;&lt; &quot;Required backends to run file &quot; &lt;&lt; boundIniFile-&gt;filename() &lt;&lt; std::endl;
      ss &lt;&lt; &quot;At least one backend candidate per row is required&quot; &lt;&lt; std::endl;
      ss &lt;&lt; &quot;--------------------------------------------------&quot; &lt;&lt; std::endl &lt;&lt; std::endl;

      for(auto reqs : backendsRequired)
      {
        for(auto backend : reqs)
        {
          ss &lt;&lt; boost::format(&quot;%-25s&quot;)%(&quot;(&quot;+backend.first+&quot;, &quot;+backend.second+&quot;)&quot;);
        }
        ss &lt;&lt; std::endl;
      }
      ss &lt;&lt; std::endl;

      // Print to terminal
      std::cout &lt;&lt; ss.str();

      // Print to logs
      logger() &lt;&lt; LogTags::dependency_resolver &lt;&lt; ss.str() &lt;&lt; EOM;
    }

    /// Print the BibTeX citation keys
    void DependencyResolver::printCitationKeys()
    {

      // If the list is empty do not print anything
      if(citationKeys.empty()) return;

      std::stringstream ss;

      // Location of the bibtex file
      str bibtex_file_location = boundIniFile-&gt;getValueOrDef&lt;str&gt;(GAMBIT_DIR &quot;/config/bibtex_entries.bib&quot;, &quot;dependency_resolution&quot;, &quot;bibtex_file_location&quot;);

      ss &lt;&lt; &quot;The scan you are about to run uses backends. Please make sure to cite all of them in your work.&quot; &lt;&lt; std::endl;

      // Create a list of entries in the bibtex file
      BibTeX bibtex_file(bibtex_file_location);
      std::vector&lt;str&gt; entries = bibtex_file.getBibTeXEntries();

      // Make sure that each key has an entry on the bibtex file
      for(const auto&amp; key : citationKeys)
      {
        // Now find each key in the list of entries
        if(std::find(entries.begin(), entries.end(), key) == entries.end())
        {
          std::ostringstream errmsg;
          errmsg &lt;&lt; &quot;The reference with key &quot; &lt;&lt; key &lt;&lt; &quot; cannot be found in the bibtex file &quot; &lt;&lt; bibtex_file_location &lt;&lt; endl;
          errmsg &lt;&lt; &quot;Please make sure that the bibtex file contains the relevant bibtex entries.&quot; &lt;&lt; endl;
          dependency_resolver_error().raise(LOCAL_INFO,errmsg.str());
        }
      }

      // Drop a bibtex file with the citation entries
      str bibtex_output_file = boundIniFile-&gt;getValueOrDef&lt;str&gt;(&quot;GAMBIT.bib&quot;, &quot;dependency_resolution&quot;, &quot;bibtex_output_file&quot;);
      bibtex_file.dropBibTeXFile(citationKeys, bibtex_output_file);

      // Drop a sample TeX file citing all backens
      str tex_output_file = boundIniFile-&gt;getValueOrDef&lt;str&gt;(&quot;GAMBIT.tex&quot;, &quot;dependency_resolution&quot;, &quot;tex_output_file&quot;);
      bibtex_file.dropTeXFile(citationKeys, tex_output_file, bibtex_output_file);

      ss &lt;&lt; &quot;You can find the list of references to include in &quot; &lt;&lt; bibtex_output_file &lt;&lt; &quot; and an example TeX file in &quot; &lt;&lt; tex_output_file &lt;&lt; std::endl &lt;&lt; std::endl;

      // Print to terminal
      std::cout &lt;&lt; ss.str();

      // Print to logs
      logger() &lt;&lt; LogTags::dependency_resolver &lt;&lt; ss.str() &lt;&lt; EOM;

    }

    //
    // Runtime
    //

    /// Returns list of ObsLike vertices in order of runtime
    std::vector&lt;VertexID&gt; DependencyResolver::getObsLikeOrder()
    {
      std::vector&lt;VertexID&gt; unsorted;
      std::vector&lt;VertexID&gt; sorted;
      std::set&lt;VertexID&gt; parents, colleagues, colleagues_min;
      // Copy unsorted vertexIDs --&gt; unsorted
      for (const OutputVertex&amp; ov : outputVertices)
      {
        unsorted.push_back(ov.vertex);
      }
      // Sort iteratively (unsorted --&gt; sorted)
      while (unsorted.size() &gt; 0)
      {
        double t2p_now;
        double t2p_min = -1;
        std::vector&lt;VertexID&gt;::iterator it_min;
        for (std::vector&lt;VertexID&gt;::iterator it = unsorted.begin(); it !=
            unsorted.end(); ++it)
        {
          parents.clear();
          getParentVertices(*it, masterGraph, parents);
          parents.insert(*it);
          // Remove vertices that were already calculated from the ist
          for (const auto&amp; colleague : colleagues) parents.erase(colleague);
          t2p_now = (double) getTimeEstimate(parents, masterGraph);
          t2p_now /= masterGraph[*it]-&gt;getInvalidationRate();
          if (t2p_min &lt; 0 or t2p_now &lt; t2p_min)
          {
            t2p_min = t2p_now;
            it_min = it;
            colleagues_min = parents;
          }
        }
        // Extent list of calculated vertices
        colleagues.insert(colleagues_min.begin(), colleagues_min.end());
        double prop = masterGraph[*it_min]-&gt;getInvalidationRate();
        logger() &lt;&lt; LogTags::dependency_resolver &lt;&lt; &quot;Estimated T [s]: &quot; &lt;&lt; t2p_min*prop &lt;&lt; EOM;
        logger() &lt;&lt; LogTags::dependency_resolver &lt;&lt; &quot;Estimated p: &quot; &lt;&lt; prop &lt;&lt; EOM;
        sorted.push_back(*it_min);
        unsorted.erase(it_min);
      }
      return sorted;
    }

    /// Evaluates ObsLike vertex, and everything it depends on, and prints results
    void DependencyResolver::calcObsLike(VertexID vertex)
    {
      if (SortedParentVertices.find(vertex) == SortedParentVertices.end())
        core_error().raise(LOCAL_INFO, &quot;Tried to calculate a function not in or not at top of dependency graph.&quot;);
      std::vector&lt;VertexID&gt; order = SortedParentVertices.at(vertex);

      for (const VertexID&amp; v : order)
      {
        std::ostringstream ss;
        ss &lt;&lt; &quot;Calling &quot; &lt;&lt; masterGraph[v]-&gt;name() &lt;&lt; &quot; from &quot; &lt;&lt; masterGraph[v]-&gt;origin() &lt;&lt; &quot;...&quot;;
        logger() &lt;&lt; LogTags::dependency_resolver &lt;&lt; LogTags::info &lt;&lt; LogTags::debug &lt;&lt; ss.str() &lt;&lt; EOM;
        masterGraph[v]-&gt;calculate();
        if (boundIniFile-&gt;getValueOrDef&lt;bool&gt;(
              false, &quot;dependency_resolution&quot;, &quot;log_runtime&quot;) )
        {
          double T = masterGraph[v]-&gt;getRuntimeAverage();
          logger() &lt;&lt; LogTags::dependency_resolver &lt;&lt; LogTags::info &lt;&lt;
            &quot;Runtime, averaged over multiple calls [s]: &quot; &lt;&lt; T &lt;&lt; EOM;
        }
        invalid_point_exception* e = masterGraph[v]-&gt;retrieve_invalid_point_exception();
        if (e != NULL) throw(*e);
      }
      // Reset the cout output precision, in case any backends have messed with it during the ObsLike evaluation.
      cout &lt;&lt; std::setprecision(boundCore-&gt;get_outprec());
    }

    /// Prints the results of an ObsLike vertex
    void DependencyResolver::printObsLike(VertexID vertex, const int pointID)
    {
      // pointID is supplied by the scanner, and is used to tell the printer which model
      // point the results should be associated with.

      if (SortedParentVertices.find(vertex) == SortedParentVertices.end())
        core_error().raise(LOCAL_INFO, &quot;Tried to calculate a function not in or not at top of dependency graph.&quot;);
      std::vector&lt;VertexID&gt; order = SortedParentVertices.at(vertex);

      for (const VertexID&amp; v : order)
      {
        std::ostringstream ss;
        ss &lt;&lt; &quot;Printing &quot; &lt;&lt; masterGraph[v]-&gt;name() &lt;&lt; &quot; from &quot; &lt;&lt; masterGraph[v]-&gt;origin() &lt;&lt; &quot;...&quot;;
        logger() &lt;&lt; LogTags::dependency_resolver &lt;&lt; LogTags::info &lt;&lt; LogTags::debug &lt;&lt; ss.str() &lt;&lt; EOM;

        if (not typeComp(masterGraph[v]-&gt;type(),  &quot;void&quot;, *boundTEs))
        {
          // Note that this prints from thread index 0 only, i.e. results created by
          // threads other than the main one need to be accessed with
          //   masterGraph[*it]-&gt;print(boundPrinter,pointID,index);
          // where index is some integer s.t. 0 &lt;= index &lt;= number of hardware threads.
          // At the moment GAMBIT only prints results of thread 0, under the expectation
          // that nested module functions are all designed to gather their results into
          // thread 0.
          masterGraph[v]-&gt;print(boundPrinter,pointID);
        }
      }
    }

    /// Getter for print_timing flag (used by LikelihoodContainer)
    bool DependencyResolver::printTiming() { return print_timing; }

    /// Get the functor corresponding to a single VertexID
    functor* DependencyResolver::get_functor(VertexID id)
    {
      graph_traits&lt;MasterGraphType&gt;::vertex_iterator vi, vi_end;
      for (std::tie(vi, vi_end) = vertices(masterGraph); vi != vi_end; ++vi)
      {
        if (*vi == id) return masterGraph[id];
      }
      return NULL;
    }

    /// Ensure that the type of a given vertex is equivalent to at least one of a provided list, and return the match.
    str DependencyResolver::checkTypeMatch(VertexID vertex, const str&amp; purpose, const std::vector&lt;str&gt;&amp; types)
    {
      for (const auto&amp; t : types)
      {
        if (typeComp(t, masterGraph[vertex]-&gt;type(), *boundTEs)) return t;
      }
      std::stringstream msg;
      msg &lt;&lt; &quot;All quantities with purpose \&quot;&quot; &lt;&lt; purpose &lt;&lt; &quot;\&quot; in your yaml file must have one &quot; &lt;&lt; endl
          &lt;&lt; &quot;of the following types: &quot; &lt;&lt; endl &lt;&lt; &quot;  &quot; &lt;&lt; types &lt;&lt; endl
          &lt;&lt; &quot;You have tried to assign this purpose to &quot; &lt;&lt; masterGraph[vertex]-&gt;origin() &lt;&lt; &quot;::&quot;
          &lt;&lt; masterGraph[vertex]-&gt;name() &lt;&lt; &quot;,&quot; &lt;&lt; endl &lt;&lt; &quot;which has capability: &quot; &lt;&lt; endl
          &lt;&lt; &quot;  &quot; &lt;&lt; masterGraph[vertex]-&gt;capability() &lt;&lt; endl &lt;&lt; &quot;and result type: &quot; &lt;&lt; endl
          &lt;&lt; &quot;  [&quot; &lt;&lt; masterGraph[vertex]-&gt;type() &lt;&lt; &quot;]&quot; &lt;&lt; endl &lt;&lt; &quot;Please assign a different purpose to this entry.&quot;;
      core_error().raise(LOCAL_INFO, msg.str());
      return &quot;If you make core errors non-fatal you deserve what you get.&quot;;
    }

    /// Return the purpose associated with a given functor.
    const str&amp; DependencyResolver::getPurpose(VertexID v)
    {
      for (const OutputVertex&amp; ov : outputVertices)
      {
        if (ov.vertex == v) return ov.purpose;
      }
      /// '__no_purpose' if the functor does not correspond to an ObsLike entry in the ini file.
      static const str none(&quot;__no_purpose&quot;);
      return none;
    }

    /// Tell functor that it invalidated the current point in model space (due to a large or NaN contribution to lnL)
    void DependencyResolver::invalidatePointAt(VertexID vertex, bool isnan)
    {
      if (isnan)
      {
        masterGraph[vertex]-&gt;notifyOfInvalidation(&quot;NaN returned for likelihood value.&quot;);
      }
      else
      {
        masterGraph[vertex]-&gt;notifyOfInvalidation(&quot;Cumulative log-likelihood pushed below threshold.&quot;);
      }
    }

    /// Reset all active functors and delete existing results.
    void DependencyResolver::resetAll()
    {
      graph_traits&lt;MasterGraphType&gt;::vertex_iterator vi, vi_end;
      for (std::tie(vi, vi_end) = vertices(masterGraph); vi != vi_end; ++vi)
      {
        if (masterGraph[*vi]-&gt;isActive()) masterGraph[*vi]-&gt;reset();
      }
    }


    ////////////////////////////////////////////////////
    // Private definitions of DependencyResolver class
    ////////////////////////////////////////////////////

    str DependencyResolver::printQuantityToBeResolved(const QueueEntry&amp; entry)
    {
        str s = entry.quantity.first + &quot; (&quot; + entry.quantity.second + &quot;)&quot;;
        s += &quot;, required by &quot;;
        if ( entry.obslike == NULL )
        {
            s += masterGraph[entry.toVertex]-&gt;capability() + &quot; (&quot;;
            s += masterGraph[entry.toVertex]-&gt;type() + &quot;) [&quot;;
            s += masterGraph[entry.toVertex]-&gt;name() + &quot;, &quot;;
            s += masterGraph[entry.toVertex]-&gt;origin() + &quot;]&quot;;
        }
        else
            s += &quot;ObsLike section of yaml file&quot;;
        return s;
    }

    /// Generic printer of the contents of a vector of functors as vertices
    str DependencyResolver::printGenericFunctorList(const std::vector&lt;VertexID&gt; &amp; vertexIDs, bool print_version)
    {
        std::vector&lt;functor*&gt; functorList;
        for (const auto&amp; vid : vertexIDs)
        {
          functorList.push_back(masterGraph[vid]);
        }
        return printGenericFunctorList(functorList, print_version);
    }

    /// Generic printer of the contents of a vector of functor-as-vertex, bool pairs
    str DependencyResolver::printGenericFunctorList(const std::vector&lt;std::pair&lt;VertexID, bool&gt;&gt; &amp; vertexIDs, bool print_version)
    {
        std::vector&lt;functor*&gt; functorList;
        for (const auto&amp; vid : vertexIDs)
        {
          functorList.push_back(masterGraph[vid.first]);
        }
        return printGenericFunctorList(functorList, print_version);
    }

    /// Generic printer of the contents of a vector of functors
    str DependencyResolver::printGenericFunctorList(const std::vector&lt;functor*&gt;&amp; functorList, bool print_version)
    {
      const str formatString = &quot;%-20s %-32s %-48s %-32s %-7i\n&quot;;
      str vtstring = (print_version ? &quot;ORIGIN (VERSION)&quot; : &quot;ORIGIN&quot;);
      std::ostringstream stream;
      stream &lt;&lt; boost::format(formatString)%vtstring% &quot;FUNCTION&quot;% &quot;CAPABILITY&quot;% &quot;TYPE&quot;% &quot;STATUS&quot;;
      for (const functor* f : functorList)
      {
        str vstring = (print_version ? &quot; (&quot; + f-&gt;version() + &quot;)&quot; : &quot;&quot;);
        stream &lt;&lt; boost::format(formatString)%
         (f-&gt;origin() + vstring) %
         f-&gt;name()%
         f-&gt;capability()%
         f-&gt;type()%
         f-&gt;status();
      }
      return stream.str();
    }

    /// Generic printer of the contents of a vector of functor, bool pairs
    str DependencyResolver::printGenericFunctorList(const std::vector&lt;std::pair&lt;functor*, bool&gt;&gt; &amp; vertexIDs, bool print_version)
    {
        std::vector&lt;functor*&gt; functorList;
        for (const auto&amp; vid : vertexIDs)
        {
          functorList.push_back(vid.first);
        }
        return printGenericFunctorList(functorList, print_version);
    }

    /// Add module and primary model functors in bound core to class-internal
    /// masterGraph object
    void DependencyResolver::addFunctors()
    {
      // Add primary model functors to masterGraph
      for (const auto&amp; f : boundCore-&gt;getPrimaryModelFunctors())
      {
        // Ignore functors with status set to 0 or less in order to ignore primary_model_functors
        // that are not to be used for the scan.
        if ( f-&gt;isAvailable() )
        {
          #ifdef DEPRES_DEBUG
            std::cout &lt;&lt; &quot;Adding primary model functor &quot; &lt;&lt; f-&gt;origin() &lt;&lt; &quot;::&quot; &lt;&lt; f-&gt;name() &lt;&lt; &quot; to masterGraph.&quot; &lt;&lt; std::endl;
          #endif
          boost::add_vertex(f, this-&gt;masterGraph);
        }
      }
      // Add module functors to masterGraph
      for (const auto&amp; f : boundCore-&gt;getModuleFunctors())
      {
          #ifdef DEPRES_DEBUG
            std::cout &lt;&lt; &quot;Adding module functor &quot; &lt;&lt; f-&gt;origin() &lt;&lt; &quot;::&quot; &lt;&lt; f-&gt;name() &lt;&lt; &quot; to masterGraph.&quot; &lt;&lt; std::endl;
          #endif
          boost::add_vertex(f, this-&gt;masterGraph);
      }
    }

    /// Activate functors that are allowed to be used with one or more of the models being scanned.
    /// Also activate the model-conditional dependencies and backend requirements of those functors.
    void DependencyResolver::makeFunctorsModelCompatible()
    {
      // Run just once
      static bool already_run = false;
      if (already_run) return;

      graph_traits&lt;MasterGraphType&gt;::vertex_iterator vi, vi_end;
      std::set&lt;str&gt; modelList = boundClaw-&gt;get_activemodels();

      // Activate those module functors that match the combination of models being scanned.
      for (std::tie(vi, vi_end) = vertices(masterGraph); vi != vi_end; ++vi)
      {
        if (masterGraph[*vi]-&gt;isEnabled() and masterGraph[*vi]-&gt;modelComboAllowed(modelList))
        {
          for (const str&amp; model : modelList)
          {
            masterGraph[*vi]-&gt;notifyOfModel(model);
            masterGraph[*vi]-&gt;setStatus(FunctorStatus::Available);
          }
        }
      }

      // Activate those backend functors that match one of the models being scanned.
      for (const str&amp; model : modelList)
      {
        for (functor* f : boundCore-&gt;getBackendFunctors())
        {
          // Activate if the backend vertex permits the model and has not been (severely) disabled by the backend system
          if ( f-&gt;isEnabled() and f-&gt;modelAllowed(model) )
          {
            f-&gt;setStatus(FunctorStatus::Available);
          }
        }
      }
      already_run = true;
    }

    /// Set up printer object
    /// (i.e. give it the list of functors that need printing)
    void DependencyResolver::initialisePrinter()
    {
      // Send the state of the &quot;print_unitcube&quot; flag to the printer
      boundPrinter-&gt;set_printUnitcube(print_unitcube);

      std::vector&lt;int&gt; functors_to_print;
      graph_traits&lt;MasterGraphType&gt;::vertex_iterator vi, vi_end;
      //IndexMap index = get(vertex_index, masterGraph); // Now done in the constructor
      //Err does that make sense? There is nothing in masterGraph at that point surely... maybe put this back.
      //Ok well it does seem to work in the constructor, not sure why though...

      for (std::tie(vi, vi_end) = vertices(masterGraph); vi != vi_end; ++vi)
      {
        // Inform the active functors of the vertex ID that the masterGraph has assigned to them
        // (so that later on they can pass this to the printer object to identify themselves)
        //masterGraph[*vi]-&gt;setVertexID(index[*vi]); // Ugh cannot do this, needs to be consistent with get_param_id
        std::string label = masterGraph[*vi]-&gt;label();
        masterGraph[*vi]-&gt;setVertexID(Printers::get_param_id(label));
        // Same for timing output ID, but get ID number from printer system
        std::string timing_label = masterGraph[*vi]-&gt;timingLabel();
        masterGraph[*vi]-&gt;setTimingVertexID(Printers::get_param_id(timing_label));

        // Check for non-void type and whether functor is active (after the dependency resolution) to print only active, printable functors.
        // TODO: this doesn't currently check for non-void type; that is done at the time of printing in calcObsLike.
        if( masterGraph[*vi]-&gt;requiresPrinting() and masterGraph[*vi]-&gt;isActive() )
        {
          functors_to_print.push_back(index[*vi]); // TODO: Probably obsolete
          boundPrinter-&gt;addToPrintList(label); // Needed mainly by postprocessor.
          // Trigger a dummy print call for all printable functors. This is used by some printers
          // to set up buffers for each of these output streams.
          //logger() &lt;&lt; LogTags::dependency_resolver &lt;&lt; &quot;Triggering dummy print for functor '&quot;&lt;&lt;masterGraph[*vi]-&gt;capability()&lt;&lt;&quot;' (&quot;&lt;&lt;masterGraph[*vi]-&gt;type()&lt;&lt;&quot;)...&quot; &lt;&lt; EOM;

          //masterGraph[*vi]-&gt;print(boundPrinter,-1);
        }
      }

      // Force-reset the printer to erase the dummy calls
      // (but don't do this if we are in resume mode!)
      //if(not boundCore-&gt;resume) boundPrinter-&gt;reset(true);
      //boundPrinter-&gt;reset(true); // Actually *do* do it in resume mode as well. Printers should only reset new data, not destroy old data.

      // sent vector of ID's of functors to be printed to printer.
      // (if we want to only print functor output sometimes, and dynamically
      // switch this on and off, we'll have to rethink the strategy here a
      // little... for now if the print function of a functor does not get
      // called, it is up to the printer how it deals with the missing result.
      // Similarly for extra results, i.e. from any functors not in this
      // initial list, whose &quot;requiresPrinting&quot; flag later gets set to 'true'
      // somehow.)
      boundPrinter-&gt;initialise(functors_to_print); // TODO: Probably obsolete
    }

    std::vector&lt;std::pair&lt;VertexID,bool&gt;&gt; DependencyResolver::closestCandidateForModel(std::vector&lt;std::pair&lt;VertexID,bool&gt;&gt; candidates)
    {
      // In case of doubt (and if not explicitely disabled in the ini-file), prefer functors
      // that are more specifically tailored for the model being scanned. Do not consider functors
      // that are accessible via INTERPRET_AS_X links, as these are all considered to be equally 'far'
      // from the model being scanned, with the 'distance' being one step further than the most distant
      // ancestor.

      // Work up the model ancestry one step at a time, and stop as soon as one or more valid model-specific functors is
      // found at a given level in the hierarchy.
      std::vector&lt;std::pair&lt;VertexID,bool&gt;&gt; newCandidates;
      std::set&lt;str&gt; s = boundClaw-&gt;get_activemodels();
      std::vector&lt;str&gt; parentModelList(s.begin(), s.end());
      while (newCandidates.size() == 0 and not parentModelList.empty())
      {
        for (str&amp; model : parentModelList)
        {
          // Test each vertex candidate to see if it has been explicitly set up to work with the model
          for (const auto&amp; candidate : candidates)
          {
            if (masterGraph[candidate.first]-&gt;modelExplicitlyAllowed(model)) newCandidates.push_back({candidate.first, true});
          }
          // Step up a level in the model hierarchy for this model.
          model = boundClaw-&gt;get_parent(model);
        }
        parentModelList.erase(std::remove(parentModelList.begin(), parentModelList.end(), &quot;none&quot;), parentModelList.end());
      }
      if (newCandidates.size() != 0)
        return newCandidates;
      else
        return candidates;
    }

    /// Collect ini options
    Options DependencyResolver::collectIniOptions(const VertexID &amp; vertex)
    {
      functor* f = masterGraph[vertex];
      YAML::Node nodes;

      #ifdef DEPRES_DEBUG
        cout &lt;&lt; &quot;Searching options for &quot; &lt;&lt; f-&gt;capability() &lt;&lt; endl;
      #endif

      for (const ModuleRule* rule : f-&gt;getMatchedModuleRules())
      {
        #ifdef DEPRES_DEBUG
          cout &lt;&lt; &quot;Getting option from: &quot; &lt;&lt; rule-&gt;capability &lt;&lt; &quot; &quot; &lt;&lt; rule-&gt;type &lt;&lt; endl;
        #endif
        // Option is a new addition to collector node
        for (const auto&amp; opt : rule-&gt;options)
        {
          if (not nodes[opt.first.as&lt;std::string&gt;()])
          {
            #ifdef DEPRES_DEBUG
              cout &lt;&lt; opt.first.as&lt;std::string&gt;() &lt;&lt; &quot;: &quot; &lt;&lt; opt.second &lt;&lt; endl;
            #endif
            nodes[opt.first.as&lt;std::string&gt;()] = opt.second;
          }
          else // Option already exists in collector node
          {
            // Throw an error if the existing value differs from the new value
            if (nodes[opt.first.as&lt;std::string&gt;()] != opt.second)
            {
              str errmsg = str(&quot;ERROR! Multiple option values for key: &quot;) + opt.first.as&lt;str&gt;();
              dependency_resolver_error().raise(LOCAL_INFO, errmsg);
            }
          }
        }
      }
      return Options(nodes);
    }

    /// Collect sub-capabilities
    Options DependencyResolver::collectSubCaps(const VertexID&amp; v)
    {
      functor* f = masterGraph[v];
      YAML::Node nodes;

      #ifdef DEPRES_DEBUG
        cout &lt;&lt; &quot;Searching for subcaps of &quot; &lt;&lt; f-&gt;capability() &lt;&lt; endl;
      #endif

      // Iterate over all ObsLikes entries that match this functor
      for (const Observable* obslike : f-&gt;getMatchedObservables())
      {
        // Select only those entries that actually have subcaps
        if (not obslike-&gt;subcaps.IsNull())
        {
          #ifdef DEPRES_DEBUG
            cout &lt;&lt; &quot;Found subcaps for &quot; &lt;&lt; f-&gt;capability() &lt;&lt; &quot; &quot; &lt;&lt; f-&gt;type() &lt;&lt; &quot; &quot; &lt;&lt; f-&gt;origin() &lt;&lt; &quot;:&quot; &lt;&lt; endl;
          #endif
          // The user has given just a single entry as a subcap
          if (obslike-&gt;subcaps.IsScalar())
          {
            str key = obslike-&gt;subcaps.as&lt;str&gt;();
            if (nodes[key]) dependency_resolver_error().raise(LOCAL_INFO,&quot;Duplicate sub-capability for &quot; + key + &quot;.&quot;);
            nodes[key] = YAML::Node();
          }
          // The user has passed a simple list of subcaps
          else if (obslike-&gt;subcaps.IsSequence())
          {
            for (const auto&amp; subcap : obslike-&gt;subcaps)
            {
              if (not subcap.IsScalar())
               dependency_resolver_error().raise(LOCAL_INFO,&quot;Attempt to pass map using sequence syntax for subcaps of &quot;+obslike-&gt;capability+&quot;.&quot;);
              str key = subcap.as&lt;str&gt;();
              if (nodes[key]) dependency_resolver_error().raise(LOCAL_INFO,&quot;Duplicate sub-capability for &quot; + key + &quot;.&quot;);
              nodes[key] = YAML::Node();
            }
          }
          // The user has passed some more complicated subcap structure than just a list of strings
          else if (obslike-&gt;subcaps.IsMap())
          {
            for (const auto&amp; subcap : obslike-&gt;subcaps)
            {
              str key = subcap.first.as&lt;str&gt;();
              if (nodes[key]) dependency_resolver_error().raise(LOCAL_INFO,&quot;Duplicate sub-capability for &quot; + key + &quot;.&quot;);
              nodes[key] = subcap.second.as&lt;YAML::Node&gt;();
            }
          }
          #ifdef DEPRES_DEBUG
            cout &lt;&lt; nodes &lt;&lt; endl;
          #endif
        }
      }
      return Options(nodes);
    }

    /// Helper function to update vertex candidate lists in resolveDependencyFromRules
    void DependencyResolver::updateCandidates(bool match, const VertexID&amp; v, int i,
                                              std::vector&lt;std::pair&lt;VertexID, bool&gt;&gt;&amp; allowed,
                                              std::vector&lt;std::pair&lt;VertexID, bool&gt;&gt;&amp; disabled)
    {
      if (match)
      {
        // Add the vertex to the active list of vertex candidates if
        //   a) vertex is not disabled in any way;
        //   b) we only want the list of backends, and the vertex comes from an ini function;
        //   c) we only want the list of backends, and the vertex comes from a function that relies on classes from a disabled backend.
        // Otherwise, the vertex would have been fine except that it is disabled, so save it for printing in diagnostic messages.
        bool vertex_allowed = masterGraph[v]-&gt;isAvailable();
        if (!vertex_allowed)
        {
          FunctorStatus status = masterGraph[v]-&gt;status();
          vertex_allowed = boundCore-&gt;show_backends &amp;&amp; (status == FunctorStatus::Classes_missing || status == FunctorStatus::Backend_missing);
        }
        allowed[i] = {v, vertex_allowed};
        disabled[i] = {v, not vertex_allowed};
      }
      else
      {
        allowed[i] = {v, false};
        disabled[i] = {v, false};
      }
    }


    /// Resolve dependencies by matching capability, type pair of input queue entry, ensuring consistency with all obslike entries and subjugate rules.
    /// As non-subjugate rules have global applicability, all (strong) instances are assumed to have already been applied before this function is called.
    std::vector&lt;VertexID&gt; DependencyResolver::resolveDependencyFromRules(const QueueEntry&amp; entry, const std::vector&lt;VertexID&gt;&amp; vertexCandidates)
    {
      // Candidate vertices after applying rules
      std::vector&lt;std::pair&lt;VertexID, bool&gt;&gt; allowedVertexCandidates(vertexCandidates.size());
      std::vector&lt;std::pair&lt;VertexID, bool&gt;&gt; disabledVertexCandidates(vertexCandidates.size());

      // If the dependency to be resolved comes from the ObsLike section, apply the conditions found in its ObsLike entry.
      if (entry.obslike != NULL)
      {
        // Iterate over all candidates
        #pragma omp parallel for
        for (unsigned int i = 0; i &lt; vertexCandidates.size(); ++i)
        {
          const VertexID&amp; v = vertexCandidates[i];
          // Require match to entry.quantity, and forbid self-resolution
          bool match = (v != entry.toVertex and entry.obslike-&gt;matches(masterGraph[v], *boundTEs));
          updateCandidates(match, v, i, allowedVertexCandidates, disabledVertexCandidates);
        }
      }
      else
      {
        // If this dependency does not come from an ObsLike entry, make a temporary rule to filter
        // vertexCandidates down to only those that match the passed quantity. This rule has the format
        // if:
        //   module: any
        // then:
        //   capability: quantity.first
        //   type: quantity.second
        ModuleRule dep_rule;
        dep_rule.has_if = dep_rule.if_module = dep_rule.has_then = dep_rule.then_capability = dep_rule.then_type = true;
        dep_rule.module = &quot;any&quot;;
        dep_rule.capability = entry.quantity.first;
        dep_rule.type = entry.quantity.second;
        // Don't let functors log this rule when it is matched, as it is only a temporary rule.
        dep_rule.log_matches = false;

        // Iterate over all candidates
        #pragma omp parallel for
        for (unsigned int i = 0; i &lt; vertexCandidates.size(); ++i)
        {
          const VertexID&amp; v = vertexCandidates[i];
          // Require match to quantity, and forbid self-resolution
          bool match = (v != entry.toVertex and dep_rule.allows(masterGraph[v], *boundTEs));
          updateCandidates(match, v, i, allowedVertexCandidates, disabledVertexCandidates);
        }
      }
      Utils::masked_erase(allowedVertexCandidates);
      Utils::masked_erase(disabledVertexCandidates);

      // Bail now if we are already down to zero candidates.
      if (allowedVertexCandidates.size() == 0)
      {
        std::ostringstream errmsg;
        errmsg &lt;&lt; &quot;No candidates found while trying to resolve:&quot; &lt;&lt; endl;
        errmsg &lt;&lt; printQuantityToBeResolved(entry) &lt;&lt; endl;
        if (disabledVertexCandidates.size() != 0)
        {
          errmsg &lt;&lt; &quot;\nNote that potentially viable candidates exist that have been disabled:\n&quot;
                 &lt;&lt; printGenericFunctorList(disabledVertexCandidates)
                 &lt;&lt; endl
          &lt;&lt; &quot;Status flags:&quot; &lt;&lt; endl
          &lt;&lt; &quot; 0: This function is not compatible with any model you are scanning.&quot; &lt;&lt; endl
          &lt;&lt; &quot;-3: This function requires a BOSSed class that is missing. The &quot; &lt;&lt; endl
          &lt;&lt; &quot;    backend that provides the class is missing (most likely), the &quot; &lt;&lt; endl
          &lt;&lt; &quot;    class is missing from the backend, or the factory functions&quot; &lt;&lt; endl
          &lt;&lt; &quot;    for this class have not been BOSSed and loaded correctly.&quot; &lt;&lt; endl;
        }
        errmsg &lt;&lt; &quot;Please check your yaml file for typos, and make sure that the&quot; &lt;&lt; endl
        &lt;&lt; &quot;models you are scanning are compatible with at least one function&quot; &lt;&lt; endl
        &lt;&lt; &quot;that provides this capability (they may all have been deactivated&quot; &lt;&lt; endl
        &lt;&lt; &quot;due to having ALLOW_MODELS declarations that are&quot; &lt;&lt; endl
        &lt;&lt; &quot;incompatible with the models selected for scanning).&quot; &lt;&lt; endl;
        dependency_resolver_error().raise(LOCAL_INFO,errmsg.str());
      }

      logger() &lt;&lt; LogTags::dependency_resolver;
      logger() &lt;&lt; &quot;List of candidate vertices:&quot; &lt;&lt; endl;
      logger() &lt;&lt; printGenericFunctorList(allowedVertexCandidates) &lt;&lt; EOM;

      // Apply any conditions imposed by subjugate rules and function chains.
      // Note that it is not possible to write a subjugate rule nor a functionChain
      // that constrains the identity of the functor used to resolve an ObsLike entry.
      if (entry.obslike == NULL)
      {
        #pragma omp parallel for
        for (unsigned int i = 0; i &lt; allowedVertexCandidates.size(); ++i)
        {
          const VertexID&amp; v = allowedVertexCandidates[i].first;
          bool&amp; allowed = allowedVertexCandidates[i].second;

          // Iterate over all obslikes that matched the entry.toVertex.
          for (const Observable* match : masterGraph[entry.toVertex]-&gt;getMatchedObservables())
          {
            // Allow only candidates that are allowed by all subjugate module rules of all rules that matched the entry.toVertex
            allowed = allowed and match-&gt;dependencies_allow(masterGraph[v], *boundTEs);
          }

          // Iterate over all obslikes in order to check if they have functionChain entries that are relevant.
          for (const Observable&amp; obs : obslikes)
          {
            // Check that the candidate is consistent with any functionChain included in the obslike entry.
            allowed = allowed and obs.function_chain_allows(masterGraph[v], masterGraph[entry.toVertex], *boundTEs);
          }

          // Iterate over all rules that matched the entry.toVertex.
          for (const ModuleRule* match : masterGraph[entry.toVertex]-&gt;getMatchedModuleRules())
          {
            // Allow only candidates that match all subjugate module rules of all rules that matched the entry.toVertex
            allowed = allowed and match-&gt;dependencies_allow(masterGraph[v], *boundTEs);
          }

          // Iterate over all rules in order to check if they have functionChain entries that are relevant.
          for (const ModuleRule&amp; rule : module_rules)
          {
            // Check that the candidate is consistent with any functionChain included in the obslike entry.
            allowed = allowed and rule.function_chain_allows(masterGraph[v], masterGraph[entry.toVertex], *boundTEs);
          }
        }
        Utils::masked_erase(allowedVertexCandidates);
      }

      logger() &lt;&lt; LogTags::dependency_resolver;
      logger() &lt;&lt; &quot;List of candidate vertices after applying subjugate rules and functionChain constraints:&quot; &lt;&lt; endl;
      logger() &lt;&lt; printGenericFunctorList(allowedVertexCandidates) &lt;&lt; EOM;

      // Apply model-specific filter
      unsigned int remaining = allowedVertexCandidates.size();
      if (remaining &gt; 1 and boundIniFile-&gt;getValueOrDef&lt;bool&gt;(true, &quot;dependency_resolution&quot;, &quot;prefer_model_specific_functions&quot;))
      {
        allowedVertexCandidates = closestCandidateForModel(allowedVertexCandidates);
        if (allowedVertexCandidates.size() &lt; remaining)
        {
          logger() &lt;&lt; &quot;A subset of vertex candidates is tailor-made for the scanned model.&quot; &lt;&lt; endl;
          logger() &lt;&lt; &quot;After using this as an additional constraint, the remaining vertices are:&quot; &lt;&lt; endl;
          logger() &lt;&lt; printGenericFunctorList(allowedVertexCandidates) &lt;&lt; EOM;
        }
      }

      // As a last resort, try applying weak rules (both subjugate and non-subjugate).
      if (allowedVertexCandidates.size() &gt; 1 and entry.obslike == NULL)
      {
        logger() &lt;&lt; &quot;Applying rules declared as '!weak' in final attempt to resolve dependency.&quot; &lt;&lt; endl;

        #pragma omp parallel for
        for (unsigned int i = 0; i &lt; allowedVertexCandidates.size(); ++i)
        {
          const VertexID&amp; v = allowedVertexCandidates[i].first;
          bool&amp; allowed = allowedVertexCandidates[i].second;

          // Filter out vertices that fail any non-subjugate (undirected) rules.
          for (const ModuleRule&amp; rule : module_rules)
          {
            if (rule.weakrule and allowed) allowed = rule.allows(masterGraph[v], *boundTEs, false);
          }

          // Iterate over all obslikes that matched the entry.toVertex.
          for (const Observable* match : masterGraph[entry.toVertex]-&gt;getMatchedObservables())
          {
            // Allow only candidates that are allowed by all subjugate module rules of all rules that matched the entry.toVertex
            allowed = allowed and match-&gt;dependencies_allow(masterGraph[v], *boundTEs, false);
            // Check that the candidate is consistent with any functionChain included in the obslike entry.
            allowed = allowed and match-&gt;function_chain_allows(masterGraph[v], masterGraph[entry.toVertex], *boundTEs);
          }

          // Iterate over all rules that matched the entry.toVertex.
          for (const ModuleRule* match : masterGraph[entry.toVertex]-&gt;getMatchedModuleRules())
          {
            // Allow only candidates that match all subjugate module rules of all rules that matched the entry.toVertex
            if (match-&gt;weakrule and allowed) allowed = match-&gt;dependencies_allow(masterGraph[v], *boundTEs, false);
            // Check that the candidate is consistent with any functionChain included in the rule.
            if (match-&gt;weakrule and allowed) allowed = match-&gt;function_chain_allows(masterGraph[v], masterGraph[entry.toVertex], *boundTEs, false);
          }
        }
        Utils::masked_erase(allowedVertexCandidates);

        logger() &lt;&lt; &quot;Candidate vertices after applying weak rules:&quot; &lt;&lt; endl;
        logger() &lt;&lt; printGenericFunctorList(allowedVertexCandidates) &lt;&lt; EOM;
      }

      // Nothing left?
      if (allowedVertexCandidates.size() == 0)
      {
        str errmsg = &quot;None of the vertex candidates for&quot;;
        errmsg += &quot;\n&quot; + printQuantityToBeResolved(entry);
        errmsg += &quot;\nfulfills all rules in the YAML file.&quot;;
        errmsg += &quot;\nPlease check your YAML file for contradictory rules, and&quot;;
        errmsg += &quot;\nensure that you have built GAMBIT in the first place with&quot;;
        errmsg += &quot;\nall of the components that you are trying to use.&quot;;
        dependency_resolver_error().raise(LOCAL_INFO,errmsg);
      }

      // At least one left.
      logger() &lt;&lt; &quot;Candidate vertices that fulfill all rules:&quot; &lt;&lt; endl;
      logger() &lt;&lt; printGenericFunctorList(allowedVertexCandidates) &lt;&lt; EOM;

      // Is more than one result OK?
      if (entry.obslike != NULL and entry.obslike-&gt;include_all)
      {
        std::vector&lt;VertexID&gt; retv;
        for (auto v : allowedVertexCandidates) retv.push_back(v.first);
        return retv;
      }

      // First remaining candidate.
      const VertexID v = allowedVertexCandidates[0].first;

      // Did we get down to one vertex?
      if (allowedVertexCandidates.size() == 1) return std::vector&lt;VertexID&gt;(1, v);

      // Failure - still more than one left.
      const functor* f = masterGraph[v];
      str errmsg = &quot;Unfortunately, the dependency resolution for&quot;;
      errmsg += &quot;\n&quot; + printQuantityToBeResolved(entry);
      errmsg += &quot;\nis still ambiguous.\n&quot;;
      errmsg += &quot;\nThe candidate vertices are:\n&quot;;
      errmsg += printGenericFunctorList(allowedVertexCandidates) +&quot;\n&quot;;
      if (entry.obslike != NULL) 
      {
        errmsg += &quot;\nNote that because the failed resolution is for an ObsLike entry,\n&quot;;
        errmsg += &quot;you could accept all of the above candidates by using !include_all.\n&quot;;
        
      }
      errmsg += &quot;\nSee logger output for details on the attempted (but failed) dependency resolution.\n&quot;;
      errmsg += &quot;\nAn entry in the ObsLike or Rules section of your YAML file that would&quot;;
      errmsg += &quot;\ne.g. select the first of the above candidates could read &quot;;
      if (entry.obslike == NULL)
      {
        errmsg += &quot;as a targeted rule:\n&quot;;
        errmsg += &quot;\n  - if:&quot;;
        errmsg += &quot;\n      capability: &quot;+masterGraph[entry.toVertex]-&gt;capability();
        errmsg += &quot;\n      function: &quot;+masterGraph[entry.toVertex]-&gt;name();
        errmsg += &quot;\n    then:&quot;;
        errmsg += &quot;\n      dependencies:&quot;;
        errmsg += &quot;\n        - if:&quot;;
        errmsg += &quot;\n            capability: &quot; +f-&gt;capability();
        errmsg += &quot;\n          then:&quot;;
        errmsg += &quot;\n            module: &quot; +f-&gt;origin();
        errmsg += &quot;\n            function: &quot; +f-&gt;name() +&quot;\n\nor &quot;;
        errmsg += &quot;as an untargeted rule:\n&quot;;
      }
      errmsg += &quot;\n  - if:&quot;;
      errmsg += &quot;\n      capability: &quot;+f-&gt;capability();
      errmsg += &quot;\n      type: &quot;+Utils::quote_if_contains_commas(f-&gt;type());
      errmsg += &quot;\n    then:&quot;;
      errmsg += &quot;\n      module: &quot; +f-&gt;origin();
      errmsg += &quot;\n      function: &quot;+f-&gt;name() + &quot;\n&quot;;
      dependency_resolver_error().raise(LOCAL_INFO,errmsg);

      return std::vector&lt;VertexID&gt;(1, 0);
    }


    /// Set up dependency tree
    void DependencyResolver::generateTree(std::queue&lt;QueueEntry&gt;&amp; resolutionQueue)
    {
      OutputVertex outVertex;
      std::vector&lt;VertexID&gt; fromVertices;
      EdgeID edge;
      bool ok;

      logger() &lt;&lt; LogTags::dependency_resolver &lt;&lt; endl;
      logger() &lt;&lt; &quot;################################################&quot; &lt;&lt; endl;
      logger() &lt;&lt; &quot;#         Starting dependency resolution       #&quot; &lt;&lt; endl;
      logger() &lt;&lt; &quot;#                                              #&quot; &lt;&lt; endl;
      logger() &lt;&lt; &quot;# format: Capability (Type) [Function, Module] #&quot; &lt;&lt; endl;
      logger() &lt;&lt; &quot;################################################&quot; &lt;&lt; EOM;

      // Print something to stdout as well
      #ifdef DEPRES_DEBUG
        std::cout &lt;&lt; &quot;Resolving dependency graph...&quot; &lt;&lt; std::endl;
      #endif

      // Read ini entries
      print_timing   = boundIniFile-&gt;getValueOrDef&lt;bool&gt;(false, &quot;print_timing_data&quot;);
      print_unitcube = boundIniFile-&gt;getValueOrDef&lt;bool&gt;(false, &quot;print_unitcube&quot;);

      if ( print_timing   ) logger() &lt;&lt; &quot;Will output timing information for all functors (via printer system)&quot; &lt;&lt; EOM;
      if ( print_unitcube ) logger() &lt;&lt; &quot;Printing of unitCubeParameters will be enabled.&quot; &lt;&lt; EOM;

      // Generate a list of module functors able to participate in dependency resolution.
      std::vector&lt;VertexID&gt; vertexCandidates;
      #pragma omp parallel for
      for (auto vi = vertices(masterGraph).first; vi != vertices(masterGraph).second; ++vi)
      {
        bool allowed = true;

        for (const ModuleRule&amp; rule : module_rules)
        {
          // Filter out vertices that fail any non-subjugate (undirected) rules.
          allowed = allowed and rule.allows(masterGraph[*vi], *boundTEs);
        }

        if (allowed)
        {
          #pragma omp critical (vertexCandidates)
          vertexCandidates.push_back(*vi);
        }
      }

      // Generate a list of backend functors able to participate in dependency resolution.
      std::vector&lt;functor*&gt; backendFunctorCandidates;
      #pragma omp parallel for
      for(functor* f: boundCore-&gt;getBackendFunctors())
      {
        bool allowed = true;

        for (const BackendRule&amp; rule : backend_rules)
        {
          // Filter out backend functors that fail any non-subjugate (undirected) rules.
          allowed = allowed and rule.allows(f, *boundTEs, &quot;any&quot;);
        }

        if (allowed)
        {
          #pragma omp critical (vertexCandidates)
          backendFunctorCandidates.push_back(f);
        }
      }


      //
      // Main loop: repeat until dependency queue is empty
      //

      while (not resolutionQueue.empty())
      {

        // Retrieve dependency of interest
        const QueueEntry&amp; entry = resolutionQueue.front();

        // Print information about required quantity and dependent vertex
        logger() &lt;&lt; LogTags::dependency_resolver;
        logger() &lt;&lt; &quot;Resolving &quot;;
        logger() &lt;&lt; printQuantityToBeResolved(entry) &lt;&lt; endl &lt;&lt; endl;

        // Extra verbose output to terminal
        #ifdef VERBOSE_DEP_RES
          std::cout &lt;&lt; &quot;Resolving dependency &quot;&lt;&lt;printQuantityToBeResolved(entry)&lt;&lt;&quot;...&quot; &lt;&lt;std::endl;
        #endif

        // Figure out how to resolve dependency
        fromVertices = resolveDependencyFromRules(entry, vertexCandidates);

        // If there is more than one result, log that fact.
        if (fromVertices.size() &gt; 1)
        {
          logger() &lt;&lt; LogTags::dependency_resolver;
          logger() &lt;&lt; &quot;Due to include_all tag, &quot; &lt;&lt; printQuantityToBeResolved(entry);
          logger() &lt;&lt; &quot; will be resolved by &quot; &lt;&lt; fromVertices.size() &lt;&lt; &quot; functions.&quot; &lt;&lt; endl;
        }

        // Step through all results
        for (VertexID fromVertex : fromVertices)
        {

          // Print user info.
          logger() &lt;&lt; LogTags::dependency_resolver;
          logger() &lt;&lt; printQuantityToBeResolved(entry) &lt;&lt; &quot;resolved by: [&quot;;
          logger() &lt;&lt; (*masterGraph[fromVertex]).name() &lt;&lt; &quot;, &quot;;
          logger() &lt;&lt; (*masterGraph[fromVertex]).origin() &lt;&lt; &quot;]&quot; &lt;&lt; endl;

          // Extra verbose output to terminal
          #ifdef VERBOSE_DEP_RES
            std::cout &lt;&lt; &quot;   ...resolved by [&quot;&lt;&lt;(*masterGraph[fromVertex]).name()&lt;&lt;&quot;, &quot;&lt;&lt;(*masterGraph[fromVertex]).origin()&lt;&lt;&quot;]&quot;&lt;&lt;std::endl;
          #endif

          // Check if we wanted to output this observable to the printer system.
          if (entry.obslike != NULL) masterGraph[fromVertex]-&gt;setPrintRequirement(entry.printme);
          // Check if the flag to output timing data is set
          if(print_timing) masterGraph[fromVertex]-&gt;setTimingPrintRequirement(true);

          // Apply resolved dependency to masterGraph and functors
          if (entry.obslike == NULL)
          {
            // Resolve the dependency at the functor level.
            // Default is to resolve dependency at functor level for entry.toVertex.
            if (entry.dependency_type != LOOP_MANAGER_DEPENDENCY)
            {
              (*masterGraph[entry.toVertex]).resolveDependency(masterGraph[fromVertex]);
            }
            // In case the fromVertex is a loop manager, store nested function
            // temporarily in loopManagerMap (they have to be sorted later)
            else
            {
              // Check whether fromVertex is allowed to manage loops
              if (not masterGraph[fromVertex]-&gt;canBeLoopManager())
              {
                str errmsg = &quot;Trying to resolve dependency on loop manager with\n&quot;
                 &quot;module function that is not declared as loop manager.\n&quot;
                 + printGenericFunctorList(initVector&lt;functor*&gt;(masterGraph[fromVertex]));
                dependency_resolver_error().raise(LOCAL_INFO,errmsg);
              }
              std::set&lt;VertexID&gt; v;
              if (loopManagerMap.count(fromVertex) == 1)
              {
                v = loopManagerMap[fromVertex];
              }
              v.insert(entry.toVertex);
              loopManagerMap[fromVertex] = v;
              (*masterGraph[entry.toVertex]).resolveLoopManager(masterGraph[fromVertex]);

              // Take any dependencies of loop-managed vertices that have already been resolved,
              // and add them as &quot;hidden&quot; dependencies to this loop manager.
              if (edges_to_force_on_manager.find(entry.toVertex) != edges_to_force_on_manager.end())
              {
                for (auto it = edges_to_force_on_manager.at(entry.toVertex).begin();
                     it != edges_to_force_on_manager.at(entry.toVertex).end(); ++it)
                {
                  logger() &lt;&lt; &quot;Dynamically adding dependency of &quot; &lt;&lt; masterGraph[fromVertex]-&gt;origin()
                           &lt;&lt; &quot;::&quot; &lt;&lt; masterGraph[fromVertex]-&gt;name() &lt;&lt; &quot; on &quot;
                           &lt;&lt; masterGraph[*it]-&gt;origin() &lt;&lt; &quot;::&quot; &lt;&lt; masterGraph[*it]-&gt;name() &lt;&lt; endl;
                  std::tie(edge, ok) = add_edge(*it, fromVertex, masterGraph);
                }
              }
            }
            // Now save the resolved dependency into the masterGraph.
            std::tie(edge, ok) = add_edge(fromVertex, entry.toVertex, masterGraph);

            // In the case that entry.toVertex is a nested function, add fromVertex to
            // the edges of entry.toVertex's loop manager.
            str to_lmcap = (*masterGraph[entry.toVertex]).loopManagerCapability();
            str to_lmtype = (*masterGraph[entry.toVertex]).loopManagerType();
            str from_lmcap = (*masterGraph[fromVertex]).loopManagerCapability();
            str from_lmtype = (*masterGraph[fromVertex]).loopManagerType();
            bool is_same_lmcap = to_lmcap == from_lmcap;
            bool is_same_lmtype = to_lmtype == &quot;any&quot; or from_lmtype == &quot;any&quot; or to_lmtype == from_lmtype;
            if (to_lmcap != &quot;none&quot;)
            {
              // This function runs nested.  Check if its loop manager has been resolved yet.
              if ((*masterGraph[entry.toVertex]).loopManagerName() == &quot;none&quot;)
              {
                // entry.toVertex's loop manager has not yet been determined.
                // Add the edge to the list to deal with when the loop manager dependency is resolved,
                // as long as entry.toVertex and fromVertex cannot end up inside the same loop.
                if (!is_same_lmcap or !is_same_lmtype)
                {
                  if (edges_to_force_on_manager.find(entry.toVertex) == edges_to_force_on_manager.end())
                   edges_to_force_on_manager[entry.toVertex] = std::set&lt;VertexID&gt;();
                  edges_to_force_on_manager.at(entry.toVertex).insert(fromVertex);
                }
              }
              else
              {
                // entry.toVertex's loop manager has already been resolved.
                // If fromVertex is not the manager itself, and is not
                // itself a nested function that has the possibility to
                // end up in the same loop as entry.toVertex, then add
                // fromVertex as an edge of the manager.
                str name = (*masterGraph[entry.toVertex]).loopManagerName();
                str origin = (*masterGraph[entry.toVertex]).loopManagerOrigin();
                bool is_itself = (name == (*masterGraph[fromVertex]).name() and origin == (*masterGraph[fromVertex]).origin());
                if (!is_itself and (!is_same_lmcap or !is_same_lmtype) )
                {
                  // Hunt through the edges of entry.toVertex and find the one that corresponds to its loop manager.
                  graph_traits&lt;MasterGraphType&gt;::in_edge_iterator ibegin, iend;
                  std::tie(ibegin, iend) = in_edges(entry.toVertex, masterGraph);
                  if (ibegin != iend)
                  {
                    VertexID managerVertex;
                    for (; ibegin != iend; ++ibegin)
                    {
                      managerVertex = source(*ibegin, masterGraph);
                      if ((*masterGraph[managerVertex]).name() == name and
                          (*masterGraph[managerVertex]).origin() == origin) break;
                    }
                    logger() &lt;&lt; &quot;Dynamically adding dependency of &quot; &lt;&lt; (*masterGraph[managerVertex]).origin()
                             &lt;&lt; &quot;::&quot; &lt;&lt; (*masterGraph[managerVertex]).name() &lt;&lt; &quot; on &quot;
                             &lt;&lt; (*masterGraph[fromVertex]).origin() &lt;&lt; &quot;::&quot; &lt;&lt; (*masterGraph[fromVertex]).name() &lt;&lt; endl;
                    std::tie(edge, ok) = add_edge(fromVertex, managerVertex, masterGraph);
                  }
                  else
                  {
                    dependency_resolver_error().raise(LOCAL_INFO, &quot;entry.toVertex has no edges! So its loop manager hasn't been added as a dependency?!&quot;);
                  }
                }
              }
            }
          }
          else // if output vertex
          {
            outVertex.vertex = fromVertex;
            outVertex.purpose = entry.obslike-&gt;purpose;;
            outputVertices.push_back(outVertex);
            // Don't need subcaps during dry-run
            if (not boundCore-&gt;show_runorder)
            {
              Options mySubCaps = collectSubCaps(fromVertex);
              masterGraph[fromVertex]-&gt;notifyOfSubCaps(mySubCaps);
            }
          }

          // If fromVertex is new, activate it
          if ( !masterGraph[fromVertex]-&gt;isActive() )
          {
            logger() &lt;&lt; LogTags::dependency_resolver &lt;&lt; &quot;Activate new module function&quot; &lt;&lt; endl;
            masterGraph[fromVertex]-&gt;setStatus(FunctorStatus::Active);
            resolveVertexBackend(fromVertex, backendFunctorCandidates);
            resolveVertexClassLoading(fromVertex);

            // Don't need options during dry-run, so skip this (just to simplify terminal output)
            if(not boundCore-&gt;show_runorder)
            {
              Options myOptions = collectIniOptions(fromVertex);
              masterGraph[fromVertex]-&gt;notifyOfIniOptions(myOptions);
            }
            // Fill parameter queue with dependencies of fromVertex
            fillResolutionQueue(resolutionQueue, fromVertex);
          }
        }

        // Done.
        logger() &lt;&lt; EOM;
        resolutionQueue.pop();
      }
    }

    /// Put module function dependencies into the resolution queue
    void DependencyResolver::fillResolutionQueue(std::queue&lt;QueueEntry&gt;&amp; resolutionQueue, VertexID vertex)
    {
      // Set the default printing flag for functors to pass to the resolutionQueue constructor.
      bool printme_default = false;

      // Tell the logger what the following messages are about.
      logger() &lt;&lt; LogTags::dependency_resolver;

      // Digest capability of loop manager (if defined)
      str lmcap = masterGraph[vertex]-&gt;loopManagerCapability();
      str lmtype = masterGraph[vertex]-&gt;loopManagerType();
      if (lmcap != &quot;none&quot;)
      {
        logger() &lt;&lt; &quot;Adding module function loop manager to resolution queue:&quot; &lt;&lt; endl;
        logger() &lt;&lt; lmcap &lt;&lt; &quot; ()&quot; &lt;&lt; endl;
        resolutionQueue.push(QueueEntry(sspair(lmcap, lmtype), vertex, LOOP_MANAGER_DEPENDENCY, printme_default));
      }

      // Digest regular dependencies
      std::set&lt;sspair&gt; s = masterGraph[vertex]-&gt;dependencies();
      if (s.size() &gt; 0) logger() &lt;&lt; &quot;Add dependencies of new module function to queue&quot; &lt;&lt; endl;
      for (const sspair&amp; ss : s)
      {
        // If the loop manager requirement exists and is type-specific, it is a true depencency,
        // and thus appears in the output of functor.dependencies(). So, we need to take care
        // not to double-count it for entry into the resolutionQueue.
        if (lmcap == &quot;none&quot; or lmtype == &quot;any&quot; or lmcap != ss.first or lmtype != ss.second)
        {
          logger() &lt;&lt; ss.first &lt;&lt; &quot; (&quot; &lt;&lt; ss.second &lt;&lt; &quot;)&quot; &lt;&lt; endl;
          resolutionQueue.push(QueueEntry(ss, vertex, NORMAL_DEPENDENCY, printme_default));
        }
      }

      // Tell the logger we're done here.
      logger() &lt;&lt; EOM;
    }

    /// Boost lib topological sort
    std::list&lt;VertexID&gt; DependencyResolver::run_topological_sort()
    {
      std::list&lt;VertexID&gt; topo_order;
      topological_sort(masterGraph, front_inserter(topo_order));
      return topo_order;
    }

    /// Node-by-node backend resolution
    void DependencyResolver::resolveVertexBackend(VertexID vertex, const std::vector&lt;functor*&gt;&amp; backendFunctorCandidates)
    {
      functor* solution;
      std::vector&lt;functor*&gt; previous_successes;
      std::set&lt;str&gt; remaining_groups;
      std::set&lt;sspair&gt; remaining_reqs;
      bool allow_deferral = true;

      // If there are no backend requirements, and thus nothing to do, return.
      if (masterGraph[vertex]-&gt;backendreqs().size() == 0) return;

      // Get started.
      logger() &lt;&lt; LogTags::dependency_resolver &lt;&lt; &quot;Doing backend function resolution...&quot; &lt;&lt; EOM;

      // Collect the list of groups that the backend requirements of this vertex exist in.
      std::set&lt;str&gt; groups = masterGraph[vertex]-&gt;backendgroups();

      // Collect the list of orphan (i.e. groupless) backend requirements.
      std::set&lt;sspair&gt; orphan_reqs = masterGraph[vertex]-&gt;backendreqs(&quot;none&quot;);

      // Loop until no further backend resolutions are possible, or no more are required.
      while ( not ( groups.empty() and orphan_reqs.empty() ) )
      {

        // Loop over all groups, including the null group (group=&quot;none&quot;).
        for (const str&amp; group : groups)
        {
          // Switch depending on whether this is a real group or not.
          if (group == &quot;none&quot;)
          {
            // Loop over all the orphan requirements.
            for (const sspair&amp; req : orphan_reqs)
            {
              logger() &lt;&lt; LogTags::dependency_resolver;
              logger() &lt;&lt; &quot;Resolving ungrouped requirement &quot; &lt;&lt; req.first;
              logger() &lt;&lt; &quot; (&quot; &lt;&lt; req.second &lt;&lt; &quot;)...&quot; &lt;&lt; EOM;

              // Find a backend function that fulfills the backend requirement.
              std::set&lt;sspair&gt; reqsubset;
              reqsubset.insert(req);
              solution = solveRequirement(reqsubset,vertex,backendFunctorCandidates,previous_successes,allow_deferral);

              // Check if a valid solution has been returned
              if (solution != NULL)
              {
                // It has, so resolve the backend requirement with that function and add it to the list of successful resolutions.
                resolveRequirement(solution,vertex);
                previous_successes.push_back(solution);

                // If req is in remaining_reqs, remove it
                if (remaining_reqs.find(req) != remaining_reqs.end())
                {
                  remaining_reqs.erase(req);
                }
              }
              else // No valid solution found, but deferral has been suggested - so defer resolution of this group until later.
              {
                remaining_reqs.insert(req);
                logger() &lt;&lt; LogTags::dependency_resolver;
                logger() &lt;&lt; &quot;Resolution of ungrouped requirement &quot; &lt;&lt; req.first;
                logger() &lt;&lt; &quot; (&quot; &lt;&lt; req.second &lt;&lt; &quot;) deferred until later.&quot; &lt;&lt; EOM;
              }
            }
            if (not remaining_reqs.empty()) remaining_groups.insert(group);
          }
          else
          {
            logger() &lt;&lt; LogTags::dependency_resolver;
            logger() &lt;&lt; &quot;Resolving from group &quot; &lt;&lt; group &lt;&lt; &quot;...&quot; &lt;&lt; EOM;

            // Collect the list of backend requirements in this group.
            std::set&lt;sspair&gt; reqs = masterGraph[vertex]-&gt;backendreqs(group);

            // Find a backend function that fulfills one of the backend requirements in the group.
            solution = solveRequirement(reqs,vertex,backendFunctorCandidates,previous_successes,allow_deferral,group);

            // Check if a valid solution has been returned
            if (solution != NULL)
            {
              // It has, so resolve the backend requirement with that function and add it to the list of successful resolutions.
              resolveRequirement(solution,vertex);
              previous_successes.push_back(solution);
            }
            else // No valid solution found, but deferral has been suggested - so defer resolution of this group until later.
            {
              remaining_groups.insert(group);
              logger() &lt;&lt; LogTags::dependency_resolver;
              logger() &lt;&lt; &quot;Resolution from group &quot; &lt;&lt; group;
              logger() &lt;&lt; &quot;deferred until later.&quot; &lt;&lt; EOM;
            }
          }
        }

        // If there has been no improvement this round, turn off deferral and make the next round the last attempt.
        if (orphan_reqs == remaining_reqs and groups == remaining_groups)
        {
          allow_deferral = false;
        }
        else // Otherwise try again to resolve the remaining groups and orphan requirements, now that some others are known.
        {
          orphan_reqs = remaining_reqs;
          groups = remaining_groups;
          remaining_reqs.clear();
          remaining_groups.clear();
        }
      }
    }

    /// Find a backend function that matches any one of a vector of capability-type pairs,
    /// ensuring consistency with all subjugate backend rules. As non-subjugate rules have
    /// global applicability, all instances are assumed to have already been applied before
    /// this function is called.
    functor* DependencyResolver::solveRequirement(std::set&lt;sspair&gt; reqs, VertexID toVertex,
     const std::vector&lt;functor*&gt;&amp; backendFunctorCandidates, std::vector&lt;functor*&gt; previous_successes,
     bool allow_deferral, str group_being_resolved)
    {
      // Candidate vertices after applying rules
      std::vector&lt;std::pair&lt;functor*, bool&gt;&gt; allowedBackendFunctorCandidates(backendFunctorCandidates.size());
      std::vector&lt;std::pair&lt;functor*, bool&gt;&gt; disabledBackendFunctorCandidates(backendFunctorCandidates.size());

      // Loop over all existing backend vertices, retaining only functors
      // that are available and fulfill the backend requirement.
      #pragma omp parallel for
      for (unsigned int i = 0; i &lt; backendFunctorCandidates.size(); ++i)
      {
        functor* f = backendFunctorCandidates[i];
        bool allowed = false;

        // Look for a basic match to at least one backend requirement, taking into account type equivalency classes.
        for (const sspair&amp; req : reqs)
        {
          // Make a temporary rule to filter down to only those that match the requirement. This rule has the format
          // if:
          //   group: group_being_resolved
          // then:
          //   capability: req.first
          //   type: req.second
          BackendRule req_rule;
          req_rule.has_if = req_rule.has_then = req_rule.if_group = req_rule.then_capability = req_rule.then_type = true;
          req_rule.group = group_being_resolved;
          req_rule.capability = req.first;
          req_rule.type = req.second;
          // Don't let functors log this rule when it is matched, as it is only a temporary rule.
          req_rule.log_matches = false;
          if (req_rule.allows(f, *boundTEs, group_being_resolved))
          {
            allowed = true;
            break;
          }
        }

        // Move on to the next candidate immediately if the current one doesn't even constitute a basic match to the requirement.
        if (not allowed) continue;

        // Continue to allow the backend vertex if it is available, or if we only want to show a list of backends.
        allowed = boundCore-&gt;show_backends or f-&gt;isAvailable();

        // Is the candidate permitted to fill a backend requirement of toVertex, given any specification of permitted
        // backends and permitted versions in the basic rollcall declaration of this requirement?
        if (allowed)
        {
          // First we create the backend-version pair for the backend vertex.
          sspair f_signature(f-&gt;origin(), f-&gt;version());
          // Next we create its semi-generic form, where any version is OK.
          sspair f_generic(f-&gt;origin(), &quot;any&quot;);
          // Then we find the set of backend-version pairs that are permitted.
          std::set&lt;sspair&gt; permitted_bes = masterGraph[toVertex]-&gt;backendspermitted(f-&gt;quantity());

          // Now we see if any match.  First we test for generic matches, where any version of any backend is allowed.
          allowed = ( permitted_bes.empty()
           // Next we test for semi-generic matches, where the backend matches and any version of that backend is allowed.
           or std::find(permitted_bes.begin(), permitted_bes.end(), f_generic) != permitted_bes.end()
           // Finally we test for specific matches, where both the backend and version match what is allowed.
           or std::find(permitted_bes.begin(), permitted_bes.end(), f_signature) != permitted_bes.end() );
        }

        // Now we check if the candidate is compatible with all applicable subjugate backend rules.
        // Iterate over all observables that matched toVertex.
        for (const Observable* match : masterGraph[toVertex]-&gt;getMatchedObservables())
        {
          // Allow only candidates that match all subjugate backend rules of all observables that matched the entry.toVertex
          allowed = allowed and match-&gt;backend_reqs_allow(f, *boundTEs, group_being_resolved);
        }
        // Iterate over all module rules that matched toVertex.
        for (const ModuleRule* match : masterGraph[toVertex]-&gt;getMatchedModuleRules())
        {
          // Allow only candidates that match all subjugate backend rules of all rules that matched the entry.toVertex
          allowed = allowed and match-&gt;backend_reqs_allow(f, *boundTEs, group_being_resolved);
        }

        // Next, we purge all candidates that conflict with a backend-matching rule given in the rollcall declaration.
        if (allowed)
        {
          // Retrieve the tags of the candidate.
          std::set&lt;str&gt; tags = masterGraph[toVertex]-&gt;backendreq_tags(f-&gt;quantity());
          // Loop over the tags
          for (const str&amp; tag : tags)
          {
            // Find out which other backend requirements exhibiting this tag must be filled from the same backend as the req this candidate would fill.
            std::set&lt;sspair&gt; must_match = masterGraph[toVertex]-&gt;forcematchingbackend(tag);
            // Set up a flag to keep track of whether any of the other backend reqs have already been filled.
            bool others_filled = false;
            // Set up a string to keep track of which backend the other backend reqs have been filled from (if any).
            str common_backend_and_version;
            // Loop over the other backend reqs.
            for (const sspair&amp; bereq_must_match : must_match)
            {
              // Set up a flag to indicate if the other backend req in question has been filled yet.
              bool other_filled = false;
              // Set up a string to keep track of which backend the other backend req in question has been filled from (if any).
              str filled_from;
              // Loop over the backend functors that have successfully filled backend reqs already for this funcition
              for (const functor* previous_success : previous_successes)
              {
                // Check if the current previous success was of the same backend requirement as the
                // current one of the backend requirements (bereq_must_match) that must be filled from the same backend as the current candidate (f).
                if (previous_success-&gt;quantity() == bereq_must_match)
                {
                  // Note that bereq_must_match (the current backend req that must be filled from the same backend as the current candidate) has indeed been filled, by previous_success
                  other_filled = true;
                  // Note which backend bereq_must_match has been filled from (i.e. where does previous_success come from?)
                  filled_from = previous_success-&gt;origin() + &quot; v&quot; + previous_success-&gt;version();
                  break;
                }
              }
              // If the other req has been filled, update the tracker of whether any of the reqs linked to this flag have been filled,
              // and compare the filling backend to the one used to fill any other reqs associated with this tag.
              if (other_filled)
              {
                others_filled = true;
                if (common_backend_and_version.empty()) common_backend_and_version = filled_from; // Save the filling backend
                if (filled_from != common_backend_and_version) // Something buggy has happened and the rule is already broken(!)
                {
                  str errmsg = &quot;A backend-matching rule has been violated!&quot;;
                  errmsg  += &quot;\nFound whilst checking which backends have been used&quot;
                             &quot;\nto fill requirements with tag &quot; + tag + &quot; in function &quot;
                             &quot;\n&quot; + masterGraph[toVertex]-&gt;name() + &quot; of &quot; + masterGraph[toVertex]-&gt;origin() + &quot;.&quot;
                             &quot;\nOne requirement was filled from &quot; + common_backend_and_version + &quot;, &quot;
                             &quot;\nwhereas another was filled from &quot; + filled_from + &quot;.&quot;
                             &quot;\nThis should not happen and is probably a bug in GAMBIT.&quot;;
                  dependency_resolver_error().raise(LOCAL_INFO,errmsg);
                }
              }
            }
            // Keep this candidate if it comes from the same backend as those already filled, or if none of the others are filled yet.
            allowed = (not others_filled or common_backend_and_version == f-&gt;origin() + &quot; v&quot; + f-&gt;version());
            if (not allowed) break;
          }
        }

        // Finally, save the verdict.
        allowedBackendFunctorCandidates[i] = {f, allowed};
        disabledBackendFunctorCandidates[i] = {f, not allowed};
      }
      Utils::masked_erase(allowedBackendFunctorCandidates);
      Utils::masked_erase(disabledBackendFunctorCandidates);

      // Only print the status flags -5 or -6 if any of the disabled vertices has it
      bool printMathematicaStatus = false;
      bool printPythonStatus = false;
      for (const auto&amp; c : disabledBackendFunctorCandidates)
      {
        if (c.first-&gt;status() == FunctorStatus::Mathematica_missing) printMathematicaStatus = true;
        if (c.first-&gt;status() == FunctorStatus::Pybind_missing) printPythonStatus = true;
      }

      // No candidates? Death.
      if (allowedBackendFunctorCandidates.size() == 0)
      {
        std::ostringstream errmsg;
        errmsg
          &lt;&lt; &quot;Found no candidates for backend requirements of &quot;
          &lt;&lt; masterGraph[toVertex]-&gt;origin() &lt;&lt; &quot;::&quot; &lt;&lt; masterGraph[toVertex]-&gt;name() &lt;&lt; &quot;:\n&quot;
          &lt;&lt; reqs &lt;&lt; &quot;\nfrom group: &quot; &lt;&lt; group_being_resolved;
        if (disabledBackendFunctorCandidates.size() != 0)
        {
          errmsg &lt;&lt; &quot;\nNote that viable candidates exist but have been disabled:\n&quot;
                 &lt;&lt;     printGenericFunctorList(disabledBackendFunctorCandidates, true)
                 &lt;&lt; endl
                 &lt;&lt; &quot;Status flags:&quot; &lt;&lt; endl
                 &lt;&lt; &quot; 1: This function is available, but the backend and/or its version are &quot; &lt;&lt; endl
                 &lt;&lt; &quot;    not compatible with all relevant rollcall declarations and YAML rules.&quot; &lt;&lt; endl
                 &lt;&lt; &quot; 0: This function is not compatible with any model you are scanning.&quot; &lt;&lt; endl
                 &lt;&lt; &quot;-1: The backend that provides this function is missing.&quot; &lt;&lt; endl
                 &lt;&lt; &quot;-2: The backend is present, but function is absent or broken.&quot; &lt;&lt; endl;
         if(printMathematicaStatus)
            errmsg &lt;&lt; &quot;-5: The backend requires Mathematica, but Mathematica is absent.&quot; &lt;&lt; endl;
         if(printPythonStatus)
            errmsg &lt;&lt; &quot;-6: The backend requires Python, but pybind11 is absent.&quot; &lt;&lt; endl;
          errmsg &lt;&lt; endl
                 &lt;&lt; &quot;Make sure to check your YAML file, especially the rules&quot; &lt;&lt; endl
                 &lt;&lt; &quot;pertaining to backends.&quot;  &lt;&lt; endl
                 &lt;&lt; endl
                 &lt;&lt; &quot;Please also check that all shared objects exist for the&quot;  &lt;&lt; endl
                 &lt;&lt; &quot;necessary backends, and that they contain all the&quot;  &lt;&lt; endl
                 &lt;&lt; &quot;necessary functions required for this scan.  You may&quot;  &lt;&lt; endl
                 &lt;&lt; &quot;check the status of different backends by running&quot;  &lt;&lt; endl
                 &lt;&lt; &quot;  ./gambit backends&quot;  &lt;&lt; endl
                 &lt;&lt; &quot;You may also wish to check the specified search paths for each&quot; &lt;&lt; endl
                 &lt;&lt; &quot;backend shared library in &quot;  &lt;&lt; endl;
          if (Backends::backendInfo().custom_locations_exist())
          {
            errmsg &lt;&lt; &quot;  &quot; &lt;&lt; Backends::backendInfo().backend_locations()  &lt;&lt; endl &lt;&lt; &quot;and&quot;  &lt;&lt; endl;
          }
          errmsg &lt;&lt; &quot;  &quot; &lt;&lt; Backends::backendInfo().default_backend_locations()  &lt;&lt; endl;
        }
        dependency_resolver_error().raise(LOCAL_INFO,errmsg.str());
      }

      // Still more than one candidate...
      if (allowedBackendFunctorCandidates.size() &gt; 1)
      {
        // Check whether any of the remaining candidates is subject to a backend-matching rule,
        // and might therefore be uniquely chosen over the other(s) if resolution for this req is attempted again, after
        // another of the reqs subject to the same rule is resolved.
        bool rule_exists = false;
        // Loop over the remaining candidates.
        for (const auto&amp; c : allowedBackendFunctorCandidates)
        {
          // Retrieve the tags of the candidate.
          std::set&lt;str&gt; tags = masterGraph[toVertex]-&gt;backendreq_tags(c.first-&gt;quantity());
          // Loop over the tags
          for (const str&amp; tag : tags)
          {
            // Find if there is a backend-matching rule associated with this tag.
            rule_exists = not masterGraph[toVertex]-&gt;forcematchingbackend(tag).empty();
            if (rule_exists) break;
          }
          if (rule_exists) break;
        }

        // If deferral is allowed and appears to be potentially useful, defer resolution until later.
        if (allow_deferral and rule_exists)
        {
          return NULL;
        }

        // If not, we have just one more trick up our sleeves... use the models scanned to narrow things down.
        if (boundIniFile-&gt;getValueOrDef&lt;bool&gt;(true, &quot;dependency_resolution&quot;, &quot;prefer_model_specific_functions&quot;))
        {
          // Prefer backend functors that are more specifically tailored for the model being scanned. Do not
          // consider backend functors that are accessible via INTERPRET_AS_X links, as these are all considered
          // to be equally 'far' from the model being scanned, with the 'distance' being one step further than
          // the most distant ancestor.
          std::vector&lt;std::pair&lt;functor*, bool&gt;&gt; newCandidates;
          std::set&lt;str&gt; s = boundClaw-&gt;get_activemodels();
          std::vector&lt;str&gt; parentModelList(s.begin(), s.end());
          while (newCandidates.size() == 0 and not parentModelList.empty())
          {
            for (str&amp; model : parentModelList)
            {
              // Test each vertex candidate to see if it has been explicitly set up to work with model
              for (const auto&amp; c : allowedBackendFunctorCandidates)
              {
                if (c.first-&gt;modelExplicitlyAllowed(model)) newCandidates.push_back({c.first, true});
              }
              // Step up a level in the model hierarchy for this model.
              model = boundClaw-&gt;get_parent(model);
            }
            parentModelList.erase(std::remove(parentModelList.begin(), parentModelList.end(), &quot;none&quot;), parentModelList.end());
          }
          if (newCandidates.size() != 0) allowedBackendFunctorCandidates = newCandidates;
        }

        // Still more than one candidate, so the game is up (unless we only want the list of required backends).
        if (allowedBackendFunctorCandidates.size() &gt; 1 and not boundCore-&gt;show_backends)
        {
          str errmsg = &quot;Found too many candidates for backend requirement &quot;;
          if (reqs.size() == 1) errmsg += reqs.begin()-&gt;first + &quot; (&quot; + reqs.begin()-&gt;second + &quot;)&quot;;
          else errmsg += &quot;group &quot; + group_being_resolved;
          errmsg += &quot; of module function &quot; + masterGraph[toVertex]-&gt;origin() + &quot;::&quot; + masterGraph[toVertex]-&gt;name()
           + &quot;\nViable candidates are:\n&quot; + printGenericFunctorList(allowedBackendFunctorCandidates, true);
          errmsg += &quot;\nIf you don't need all the above backends, you can resolve the ambiguity simply by&quot;;
          errmsg += &quot;\nuninstalling the backends that you don't want to use.&quot;;
          errmsg += &quot;\n\nAlternatively, you can add an entry in your YAML file that selects which backend&quot;;
          errmsg += &quot;\nthe module function &quot; + masterGraph[toVertex]-&gt;origin() + &quot;::&quot; + masterGraph[toVertex]-&gt;name() + &quot; should use. A YAML entry in the Rules section&quot;;
          errmsg += &quot;\nthat selects e.g. the first candidate above could read\n&quot;;
          errmsg += &quot;\n  - if&quot;;
          errmsg += &quot;\n      capability: &quot;+masterGraph[toVertex]-&gt;capability();
          errmsg += &quot;\n      function: &quot;+masterGraph[toVertex]-&gt;name();
          errmsg += &quot;\n    then:&quot;;
          errmsg += &quot;\n      backends:&quot;;
          errmsg += &quot;\n        - if:&quot;;
          errmsg += &quot;\n            capability: &quot;+allowedBackendFunctorCandidates.at(0).first-&gt;capability();
          errmsg += &quot;\n            type: &quot;+Utils::quote_if_contains_commas(allowedBackendFunctorCandidates.at(0).first-&gt;type());
          errmsg += &quot;\n          then:&quot;;
          errmsg += &quot;\n            backend: &quot;+allowedBackendFunctorCandidates.at(0).first-&gt;origin();
          errmsg += &quot;\n            version: &quot;+allowedBackendFunctorCandidates.at(0).first-&gt;version() + &quot;\n&quot;;
          dependency_resolver_error().raise(LOCAL_INFO,errmsg);
        }
      }

      // Store the resolved backend requirements
      std::vector&lt;sspair&gt; resolvedBackends;
      for (const auto&amp; c : allowedBackendFunctorCandidates)
      {
        sspair backend(c.first-&gt;origin(), c.first-&gt;version());
        resolvedBackends.push_back(backend);
      }

      bool found = false;
      for (const auto&amp; br : backendsRequired)
      {
        found = true;
        for (auto backend : resolvedBackends)
        {
          if (std::find(br.begin(), br.end(), backend) == br.end())
            found = false;
        }
        if (found) break;
      }
      if (not found)
      {
        backendsRequired.push_back(resolvedBackends);
      }

      // Just one candidate.  Jackpot.
      return allowedBackendFunctorCandidates[0].first;
    }

    /// Resolve a backend requirement of a specific module function using a specific backend function.
    void DependencyResolver::resolveRequirement(functor* func, VertexID vertex)
    {
      masterGraph[vertex]-&gt;resolveBackendReq(func);
      logger() &lt;&lt; LogTags::dependency_resolver;
      logger() &lt;&lt; &quot;Resolved by: [&quot; &lt;&lt; func-&gt;name() &lt;&lt; &quot;, &quot;;
      logger() &lt;&lt; func-&gt;origin() &lt;&lt; &quot; (&quot; &lt;&lt; func-&gt;version() &lt;&lt; &quot;)]&quot;;
      logger() &lt;&lt; EOM;
    }

    /// Retrieve used or unused rules
    template&lt;typename RuleT&gt;
    std::set&lt;const RuleT*&gt; getUsedOrUnusedRules(bool find_used, const std::vector&lt;RuleT&gt;&amp; rules, const MasterGraphType&amp; masterGraph)
    {
      std::set&lt;const RuleT*&gt; returnRules;
      for(const auto&amp; rule : rules)
      {
        #ifdef DEPRES_DEBUG
          std::cout &lt;&lt; &quot;Triggering for &quot; &lt;&lt; (find_used ? &quot;used&quot; : &quot;unused&quot;) &lt;&lt; &quot; rules.&quot; &lt;&lt; std::endl;
          std::cout &lt;&lt; &quot;Checking rule with capability &quot; &lt;&lt; rule.capability &lt;&lt; std::endl;
        #endif
        graph_traits&lt;MasterGraphType&gt;::vertex_iterator vi, vi_end;
        bool unused = true;
        for (std::tie(vi, vi_end) = vertices(masterGraph); vi != vi_end; ++vi)
        {
          // Check only for enabled functors
          if (masterGraph[*vi]-&gt;isActive())
          {
            const std::set&lt;const RuleT*&gt;&amp; matched = masterGraph[*vi]-&gt;getMatchedRules&lt;const RuleT&gt;();
            bool found = (std::find_if(matched.begin(), matched.end(), [&amp;](const RuleT* r){ return r==&amp;rule; } ) != matched.end());
            if (found)
            {
              unused = false;
              break;
            }
          }
        }
        if (unused xor find_used) returnRules.insert(&amp;rule);
      }
      return returnRules;
    }
    template&lt;typename RuleT&gt;
    std::set&lt;const RuleT*&gt; getUsedRules(const std::vector&lt;RuleT&gt;&amp; rules, const MasterGraphType&amp; masterGraph)
    {
      return getUsedOrUnusedRules(true, rules, masterGraph);
    }
    template&lt;typename RuleT&gt;
    std::set&lt;const RuleT*&gt; getUnusedRules(const std::vector&lt;RuleT&gt;&amp; rules, const MasterGraphType&amp; masterGraph)
    {
      return getUsedOrUnusedRules(false, rules, masterGraph);
    }



    /// Check for unused rules and options
    void DependencyResolver::checkForUnusedRules()
    {
      // Retrieve sets of used and unused module and backend rules
      std::set&lt;const ModuleRule*&gt; usedModuleRules = getUsedRules(module_rules, masterGraph);
      std::set&lt;const ModuleRule*&gt; unusedModuleRules = getUnusedRules(module_rules, masterGraph);
      std::set&lt;const BackendRule*&gt; usedBackendRules = getUsedRules(backend_rules, masterGraph);
      std::set&lt;const BackendRule*&gt; unusedBackendRules = getUnusedRules(backend_rules, masterGraph);

      // Remove any unused module rules that are also backend rules, and have been used as such.
      while(true)
      {
        auto duplicate_rule = std::find_if(unusedModuleRules.begin(),
                                           unusedModuleRules.end(),
                                           [&amp;](const ModuleRule* moduleRule)
                                           {
                                             for (const auto&amp; backendRule : usedBackendRules)
                                             {
                                               if (moduleRule-&gt;yaml == backendRule-&gt;yaml) return true;
                                             }
                                             return false;
                                           });
        if (duplicate_rule == unusedModuleRules.end()) break;
        unusedModuleRules.erase(duplicate_rule);
      }

      // Remove any unused backend rules that are also module rules, and have been used as such.
      while(true)
      {
        auto duplicate_rule = std::find_if(unusedBackendRules.begin(),
                                           unusedBackendRules.end(),
                                           [&amp;](const BackendRule* backendRule)
                                           {
                                             for (const auto&amp; moduleRule : usedModuleRules)
                                             {
                                               if (moduleRule-&gt;yaml == backendRule-&gt;yaml) return true;
                                             }
                                             return false;
                                           });
        if (duplicate_rule == unusedBackendRules.end()) break;
        unusedBackendRules.erase(duplicate_rule);
      }

      // If any unused rules remain, trigger an error/warning.
      if(unusedModuleRules.size() &gt; 0 or unusedBackendRules.size() &gt; 0)
      {
        std::ostringstream msg;
        msg &lt;&lt; &quot;The following rules and options are not used in the current scan:&quot; &lt;&lt; endl;
        if (unusedModuleRules.size() &gt; 0) msg &lt;&lt; endl &lt;&lt; &quot;Module rules:&quot; &lt;&lt; endl;
        for (const ModuleRule* rule : unusedModuleRules) msg &lt;&lt; endl &lt;&lt; rule-&gt;yaml &lt;&lt; endl;
        if (unusedBackendRules.size() &gt; 0) msg &lt;&lt; endl &lt;&lt; &quot;Backend rules:&quot; &lt;&lt; endl;
        for (const BackendRule* rule : unusedBackendRules) msg &lt;&lt; endl &lt;&lt; rule-&gt;yaml &lt;&lt; endl;
        if (boundIniFile-&gt;getValueOrDef&lt;bool&gt;(true, &quot;dependency_resolution&quot;, &quot;unused_rule_is_an_error&quot;))
          dependency_resolver_error().raise(LOCAL_INFO,msg.str());
        else dependency_resolver_warning().raise(LOCAL_INFO,msg.str());
      }
    }

    /// Construct metadata information from used observables, rules and options
    /// Note: No keys can be identical (or differing only by capitalisation)
    ///       to those printed in the main file, otherwise the sqlite printer fails
    map_str_str DependencyResolver::getMetadata()
    {
      map_str_str metadata;

      // Gambit version
      metadata[&quot;GAMBIT&quot;] = gambit_version();

      // Date
      auto now = std::chrono::system_clock::now();
      auto in_time_t = std::chrono::system_clock::to_time_t(now);

      std::stringstream ss;
      ss &lt;&lt; std::put_time(std::localtime(&amp;in_time_t), &quot;%Y-%m-%d %H:%M&quot;);
      metadata[&quot;Date&quot;] =  ss.str();

      // scanID
      if (boundIniFile-&gt;getValueOrDef&lt;bool&gt;(true, &quot;print_scanID&quot;))
      {
        ss.str(&quot;&quot;);
        ss &lt;&lt; scanID;
        metadata[&quot;Scan_ID&quot;] = ss.str();
      }

      // Parameters
      YAML::Node parametersNode = boundIniFile-&gt;getParametersNode();
      Options(parametersNode).toMap(metadata, &quot;Parameters&quot;);

      // Priors
      YAML::Node priorsNode = boundIniFile-&gt;getPriorsNode();
      Options(priorsNode).toMap(metadata, &quot;Priors&quot;);

      // Printer
      YAML::Node printerNode = boundIniFile-&gt;getPrinterNode();
      Options(printerNode).toMap(metadata, &quot;Printer&quot;);

      // Scanners
      YAML::Node scanNode = boundIniFile-&gt;getScannerNode();
      str scanner = scanNode[&quot;use_scanner&quot;].as&lt;str&gt;();
      metadata[&quot;Scanner::scanner&quot;] = scanner;
      for(const auto&amp; entry : scanNode)
      {
        const str key = entry.first.as&lt;str&gt;();
        if(key == &quot;scanners&quot;) Options(scanNode[&quot;scanners&quot;][scanner]).toMap(metadata, &quot;Scanner::options&quot;);
        else if(key != &quot;use_scanner&quot;) Options(entry).toMap(metadata, &quot;Scanner::&quot; + key);
      }

      // ObsLikes
      for (const Observable&amp; obslike : obslikes)
      {
        std::stringstream key;
        key &lt;&lt; &quot;ObsLikes::&quot; &lt;&lt; &amp;obslike;
        Options(obslike.yaml).toMap(metadata, key.str());
      }

      // Used rules and options
      for (const ModuleRule* rule : getUsedRules(module_rules, masterGraph))
      {
        std::stringstream key;
        key &lt;&lt; &quot;Rule::&quot; &lt;&lt; rule-&gt;yaml;
        Options(rule-&gt;yaml).toMap(metadata, key.str());
      }
      for (const BackendRule* rule : getUsedRules(backend_rules, masterGraph))
      {
        std::stringstream key;
        key &lt;&lt; &quot;Rule::&quot; &lt;&lt; rule-&gt;yaml;
        Options(rule-&gt;yaml).toMap(metadata, key.str());
      }

      // Logger
      YAML::Node logNode = boundIniFile-&gt;getLoggerNode();
      Options(logNode).toMap(metadata,&quot;Logger&quot;);

      // KeyValues
      YAML::Node keyvalue = boundIniFile-&gt;getKeyValuePairNode();
      Options(keyvalue).toMap(metadata,&quot;KeyValue&quot;);

      // YAML file
      ss.str(&quot;&quot;);
      ss &lt;&lt; boundIniFile-&gt;getYAMLNode();
      metadata[&quot;YAML&quot;] = ss.str();

      return metadata;

    }

    // Resolve a dependency on backend classes
    void DependencyResolver::resolveVertexClassLoading(VertexID vertex)
    {
      // If there are no backend class loading requirements, and thus nothing to do, return.
      if (masterGraph[vertex]-&gt;backendclassloading().size() == 0) return;

      // If the backend is not present, this vertex has already been disabled, so from now just assume it hasn't
      // Unless the list of required backends is requested, in which case it is enabled, but it won't run a scan, so no worries

      // Add to the logger
      logger() &lt;&lt; LogTags::dependency_resolver &lt;&lt; &quot;Doing backend class loading resolution...&quot; &lt;&lt; EOM;

      // Add the backends to list of required backends
      std::vector&lt;sspair&gt; resolvedBackends;
      for(auto backend : masterGraph[vertex]-&gt;backendclassloading())
        resolvedBackends.push_back(backend);

      bool found = false;
      for(const auto&amp; br : backendsRequired)
      {
        found = true;
        for(auto backend : resolvedBackends)
        {
          if(std::find(br.begin(), br.end(), backend) == br.end())
            found = false;
        }
        if(found) break;
      }
      if(not found)
      {
        backendsRequired.push_back(resolvedBackends);
      }

    }

    // Set the Scan ID
    void DependencyResolver::set_scanID()
    {
      // Get the scanID from the yaml node.
      scanID = boundIniFile-&gt;getValueOrDef&lt;int&gt;(-1, &quot;scanID&quot;);

      // If scanID is supplied by user, use that
      if (scanID != -1)
      {
        return;
      }
      else
      {
        const std::chrono::time_point&lt;std::chrono::system_clock&gt; now = std::chrono::system_clock::now();
        std::time_t in_time_t = std::chrono::system_clock::to_time_t(now);
        std::chrono::milliseconds ms = std::chrono::duration_cast&lt;std::chrono::milliseconds&gt; (now.time_since_epoch()) - std::chrono::duration_cast&lt;std::chrono::seconds&gt; (now.time_since_epoch());
        std::stringstream ss;
        ss &lt;&lt; std::put_time(std::localtime(&amp;in_time_t), &quot;%H%M%S&quot;);
        ss &lt;&lt; ms.count();
        ss &gt;&gt; scanID;
      }
    }

    // Get BibTeX citation keys for backends, modules, etc
    void DependencyResolver::getCitationKeys()
    {
      // First add the necessary citation keys to use GAMBIT
      citationKeys.insert(citationKeys.end(), gambit_citation_keys.begin(), gambit_citation_keys.end());

      // Get the keys for the required backends
      for(auto backend : backendsRequired)
      {
        str bibkey = &quot;&quot;;

        // Run over references of loaded backends
        for(auto beref : boundCore-&gt;getBackendCitationKeys())
        {
          str origin = beref.first.first;
          str version = beref.first.second;
          if (backend[0].first == origin and backend[0].second == version)
          {
            bibkey = beref.second;
            if (bibkey != &quot;&quot; and bibkey != &quot;REFERENCE&quot;)
            {
              logger() &lt;&lt; LogTags::dependency_resolver &lt;&lt; &quot;Found bibkey for backend &quot; &lt;&lt; origin &lt;&lt; &quot; version &quot; &lt;&lt; version &lt;&lt; &quot;: &quot; &lt;&lt; bibkey &lt;&lt; EOM;
              BibTeX::addCitationKey(citationKeys, bibkey);
            }
          }
        }
        if (bibkey == &quot;&quot; or bibkey == &quot;REFERENCE&quot;)
        {
          std::ostringstream errmsg;
          errmsg &lt;&lt; &quot;Missing reference for backend &quot; &lt;&lt; backend[0].first &lt;&lt; &quot;(&quot; &lt;&lt; backend[0].second &lt;&lt; &quot;).&quot; &lt;&lt; endl;
          errmsg &lt;&lt; &quot;Please add the bibkey to the frontend header, and full bibtex entry to &quot;;
          errmsg &lt;&lt; boundIniFile-&gt;getValueOrDef&lt;str&gt;(&quot;config/bibtex_entries.bib&quot;, &quot;dependecy_resolution&quot;, &quot;bibtex_file_location&quot;) &lt;&lt; &quot;.&quot; &lt;&lt; endl;
          dependency_resolver_error().raise(LOCAL_INFO,errmsg.str());
        }
      }

      // Now look over activated vertices in the mastergraph and add any references to module, module functions, etc
      for (const VertexID&amp; vertex : getObsLikeOrder())
      {
        std::set&lt;VertexID&gt; parents;
        getParentVertices(vertex, masterGraph, parents);
        parents.insert(vertex);
        for (const VertexID&amp; vertex2 : parents)
        {

          // Add citation key for used modules
          for(const auto&amp; key : boundCore-&gt;getModuleCitationKeys())
          {
            if(key.first == masterGraph[vertex2]-&gt;origin())
            {
              BibTeX::addCitationKey(citationKeys, key.second);
            }
          }

          // Add citation key for specific module functions
          if(masterGraph[vertex2]-&gt;citationKey() != &quot;&quot;)
          {
            BibTeX::addCitationKey(citationKeys, masterGraph[vertex2]-&gt;citationKey());
          }

        }

      }
    }

  }

}
</code></pre><hr><p>Updated on 2025-02-12 at 16:10:35 +0000</p></main></div></div></div><footer class="footer text-muted"><div class=container-xxl><div class=row><div class="col-lg-8 order-last order-lg-first"><ul class=list-inline><li class=list-inline-item>Powered by <a href=https://gohugo.io/>Hugo</a> and <a href=https://getdoks.org/>Doks</a></li></ul></div><div class="col-lg-8 order-first order-lg-last text-lg-end"><ul class=list-inline><li class=list-inline-item><a href=/license/>License</a></li></ul></div></div></div></footer><script src=/js/bootstrap.min.862c9eb8ab97f8c1c8584b21ce31113d8553917669561b040011b0061009a0b6c7a6b61fb659f56eabfa9f45259f001417dba1d65b229f685f3cdbb709482f8e.js integrity="sha512-hiyeuKuX+MHIWEshzjERPYVTkXZpVhsEABGwBhAJoLbHprYftln1bqv6n0UlnwAUF9uh1lsin2hfPNu3CUgvjg==" crossorigin=anonymous defer></script>
<script src=/js/highlight.min.3fa03d1d36ae7a66d6d5d2e19796832d40b4a5417eaaae1dfba8837d033467084e8c051f25aee596d415422573116115ccc5c2b29970d3490dafdce1a920a402.js integrity="sha512-P6A9HTauembW1dLhl5aDLUC0pUF+qq4d+6iDfQM0ZwhOjAUfJa7lltQVQiVzEWEVzMXCsplw00kNr9zhqSCkAg==" crossorigin=anonymous defer></script>
<script src=/main.min.04459eeb2d9d601a3ccc10d2699fb84f0442d5f5d3a16372b023be7564838ed2a755b908598f715d6b42c0be95895835b2e872f4fa4acd028ef3904671a92f1a.js integrity="sha512-BEWe6y2dYBo8zBDSaZ+4TwRC1fXToWNysCO+dWSDjtKnVbkIWY9xXWtCwL6ViVg1suhy9PpKzQKO85BGcakvGg==" crossorigin=anonymous defer></script>
<script src=https://gambitbsm.org/index.min.387fb62f7bf7e38a573f925984d01b0d75516351168887237dea58b44fa1eb0e0c453e28c8bf00ca014214fd962ef8544057de88bd713d8102e69f6320860b3d.js integrity="sha512-OH+2L3v344pXP5JZhNAbDXVRY1EWiIcjfepYtE+h6w4MRT4oyL8AygFCFP2WLvhUQFfeiL1xPYEC5p9jIIYLPQ==" crossorigin=anonymous defer></script></body></html>