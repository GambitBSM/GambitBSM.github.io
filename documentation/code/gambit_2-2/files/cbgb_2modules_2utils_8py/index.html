<!DOCTYPE html><html lang="en-us"><head><meta charset="utf-8"/><meta http-equiv="x-ua-compatible" content="ie=edge"/><meta name="viewport" content="width=device-width,initial-scale=1,shrink-to-fit=no"/><link rel="preload" as="font" href="https://gambitbsm.github.io/fonts/vendor/jost/jost-v4-latin-regular.woff2" type="font/woff2" crossorigin=""/><link rel="preload" as="font" href="https://gambitbsm.github.io/fonts/vendor/jost/jost-v4-latin-500.woff2" type="font/woff2" crossorigin=""/><link rel="preload" as="font" href="https://gambitbsm.github.io/fonts/vendor/jost/jost-v4-latin-700.woff2" type="font/woff2" crossorigin=""/><script>(()=>{var e=localStorage.getItem("theme");e==="dark"&&document.documentElement.setAttribute("data-dark-mode","")})()</script><link rel="stylesheet" href="https://gambitbsm.github.io/main.e60a30503f41dfe2a8e849eba3bb572667400d7915356bae7eff31d3e22e4492fc8c0b2ff150168b1139b9c0caad1a20c84c8957336bcc2bba8559379cc39f91.css" integrity="sha512-5gowUD9B3+Ko6Enro7tXJmdADXkVNWuufv8x0+IuRJL8jAsv8VAWixE5ucDKrRogyEyJVzNrzCu6hVk3nMOfkQ==" crossorigin="anonymous"/><noscript><style>img.lazyload{display:none}</style></noscript><meta name="robots" content="index, follow"/><meta name="googlebot" content="index, follow, max-snippet:-1, max-image-preview:large, max-video-preview:-1"/><meta name="bingbot" content="index, follow, max-snippet:-1, max-image-preview:large, max-video-preview:-1"/><title>file modules/CBGB/modules/utils.py - GAMBIT</title><meta name="description" content="[No description available]"/><link rel="canonical" href="https://gambitbsm.github.io/documentation/code/gambit_2-2/files/cbgb_2modules_2utils_8py/"/><meta property="og:locale" content="en_US"/><meta property="og:type" content="article"/><meta property="og:title" content="file modules/CBGB/modules/utils.py"/><meta property="og:description" content="[No description available]"/><meta property="og:url" content="https://gambitbsm.github.io/documentation/code/gambit_2-2/files/cbgb_2modules_2utils_8py/"/><meta property="og:site_name" content="GAMBIT"/><meta property="og:image" content="https://gambitbsm.github.io/gambit_logo.png"/><meta property="og:image:alt" content="GAMBIT"/><meta name="twitter:card" content="summary_large_image"/><meta name="twitter:site" content=""/><meta name="twitter:creator" content=""/><meta name="twitter:title" content="file modules/CBGB/modules/utils.py"/><meta name="twitter:description" content="[No description available]"/><meta name="twitter:image" content="https://gambitbsm.github.io/gambit_logo.png"/><meta name="twitter:image:alt" content="file modules/CBGB/modules/utils.py"/><script type="application/ld+json">{"@context":"https://schema.org","@graph":[{"@type":"Organization","@id":"https://gambitbsm.github.io/#/schema/organization/1","name":"Doks","url":"https://gambitbsm.github.io/","sameAs":["https://github.com/GambitBSM"],"logo":{"@type":"ImageObject","@id":"https://gambitbsm.github.io/#/schema/image/1","url":"https://gambitbsm.github.io/logo-doks.png","width":450,"height":416,"caption":"Doks"},"image":{"@id":"https://gambitbsm.github.io/#/schema/image/1"}},{"@type":"WebSite","@id":"https://gambitbsm.github.io/#/schema/website/1","url":"https://gambitbsm.github.io/","name":"GAMBIT","description":"Documentation for the Global And Modular BSM Inference Tool","publisher":{"@id":"https://gambitbsm.github.io/#/schema/organization/1"}},{"@type":"WebPage","@id":"https://gambitbsm.github.io/documentation/code/gambit_2-2/files/cbgb_2modules_2utils_8py/","url":"https://gambitbsm.github.io/documentation/code/gambit_2-2/files/cbgb_2modules_2utils_8py/","name":"file modules\/CBGB\/modules\/utils.py","description":"[No description available]","isPartOf":{"@id":"https://gambitbsm.github.io/#/schema/website/1"},"about":{"@id":"https://gambitbsm.github.io/#/schema/organization/1"},"datePublished":"0001-01-01T00:00:00CET","dateModified":"0001-01-01T00:00:00CET","breadcrumb":{"@id":"https://gambitbsm.github.io/documentation/code/gambit_2-2/files/cbgb_2modules_2utils_8py/#/schema/breadcrumb/1"},"primaryImageOfPage":{"@id":"https://gambitbsm.github.io/documentation/code/gambit_2-2/files/cbgb_2modules_2utils_8py/#/schema/image/2"},"inLanguage":"en-US","potentialAction":[{"@type":"ReadAction","target":["https://gambitbsm.github.io/documentation/code/gambit_2-2/files/cbgb_2modules_2utils_8py/"]}]},{"@type":"BreadcrumbList","@id":"https://gambitbsm.github.io/documentation/code/gambit_2-2/files/cbgb_2modules_2utils_8py/#/schema/breadcrumb/1","name":"Breadcrumbs","itemListElement":[{"@type":"ListItem","position":1,"item":{"@type":"WebPage","@id":"https://gambitbsm.github.io/","url":"https://gambitbsm.github.io/","name":"Home"}},{"@type":"ListItem","position":2,"item":{"@type":"WebPage","@id":"https://gambitbsm.github.io/documentation/","url":"https://gambitbsm.github.io/documentation/","name":"Documentation"}},{"@type":"ListItem","position":3,"item":{"@type":"WebPage","@id":"https://gambitbsm.github.io/documentation/code/","url":"https://gambitbsm.github.io/documentation/code/","name":"Code"}},{"@type":"ListItem","position":4,"item":{"@type":"WebPage","@id":"https://gambitbsm.github.io/documentation/code/gambit_2-2/","url":"https://gambitbsm.github.io/documentation/code/gambit_2-2/","name":"Gambit 2 2"}},{"@type":"ListItem","position":5,"item":{"@type":"WebPage","@id":"https://gambitbsm.github.io/documentation/code/gambit_2-2/files/","url":"https://gambitbsm.github.io/documentation/code/gambit_2-2/files/","name":"Files"}},{"@type":"ListItem","position":6,"item":{"@id":"https://gambitbsm.github.io/documentation/code/gambit_2-2/files/cbgb_2modules_2utils_8py/"}}]},{"@context":"https://schema.org","@graph":[{"@type":"ImageObject","@id":"https://gambitbsm.github.io/documentation/code/gambit_2-2/files/cbgb_2modules_2utils_8py/#/schema/image/2","url":"https://gambitbsm.github.io/gambit_logo.png","contentUrl":"https://gambitbsm.github.io/gambit_logo.png","caption":"file modules\/CBGB\/modules\/utils.py"}]}]}</script><meta name="theme-color" content="#fff"/><link rel="icon" href="https://gambitbsm.github.io/favicon.ico" sizes="any"/><link rel="icon" type="image/svg+xml" href="https://gambitbsm.github.io/favicon.svg"/><link rel="apple-touch-icon" sizes="180x180" href="https://gambitbsm.github.io/apple-touch-icon.png"/><link rel="icon" type="image/png" sizes="32x32" href="https://gambitbsm.github.io/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="16x16" href="https://gambitbsm.github.io/favicon-16x16.png"/><link rel="manifest" crossorigin="use-credentials" href="https://gambitbsm.github.io/site.webmanifest"/></head><body class="documentation single light"><div class="sticky-top"><div class="header-bar"></div><header class="navbar navbar-expand-md navbar-light doks-navbar"><nav class="container-xxl flex-wrap flex-md-nowrap" aria-label="Main navigation"><a class="navbar-brand p-0 me-auto" href="https://gambitbsm.github.io/" aria-label="GAMBIT"><img class="logo-light" src="https://gambitbsm.github.io//images/gambit_logo.png" width="50px"/>
<img class="logo-dark d-none" src="https://gambitbsm.github.io//images/gambit_logo.png" width="50px"/>
GAMBIT</a>
<button class="btn btn-menu order-2 d-block d-lg-none" type="button" data-bs-toggle="offcanvas" data-bs-target="#offcanvasDoks" aria-controls="offcanvasDoks" aria-label="Open main menu"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-menu"><line x1="3" y1="12" x2="21" y2="12"></line><line x1="3" y1="6" x2="21" y2="6"></line><line x1="3" y1="18" x2="21" y2="18"></line></svg></button><div class="offcanvas offcanvas-end border-0 py-lg-1" tabindex="-1" id="offcanvasDoks" data-bs-backdrop="true" aria-labelledby="offcanvasDoksLabel"><div class="header-bar d-lg-none"></div><div class="offcanvas-header d-lg-none"><h2 class="h5 offcanvas-title ps-2" id="offcanvasDoksLabel"><a class="text-dark" href="/">GAMBIT</a></h2><button type="button" class="btn-close text-reset me-2" data-bs-dismiss="offcanvas" aria-label="Close main menu"></button></div><div class="offcanvas-body p-4 p-lg-0"><ul class="nav flex-column flex-lg-row align-items-lg-center mt-2 mt-lg-0 ms-lg-2 me-lg-auto"><li class="nav-item dropdown"><a class="nav-link dropdown-toggle ps-0 py-1" href="#" id="navbarDropdownMenuLink" role="button" data-bs-toggle="dropdown" aria-expanded="false">Documentation
<span class="dropdown-caret"><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-chevron-down"><polyline points="6 9 12 15 18 9"></polyline></svg></span></a><ul class="dropdown-menu dropdown-menu-main shadow rounded border-0" aria-labelledby="navbarDropdownMenuLink"><li><a class="dropdown-item" href="/documentation/installation/introduction/">Installation</a></li><li><a class="dropdown-item" href="/documentation/examples/colliderbit_example">Examples</a></li><li><a class="dropdown-item" href="/documentation/help/faqs/">Help</a></li><li><a class="dropdown-item" href="/documentation/code/gambit_2-2/index_classes">Code Reference</a></li></ul></li><li class="nav-item dropdown"><a class="nav-link dropdown-toggle ps-0 py-1" href="#" id="navbarDropdownMenuLink" role="button" data-bs-toggle="dropdown" aria-expanded="false">Community
<span class="dropdown-caret"><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-chevron-down"><polyline points="6 9 12 15 18 9"></polyline></svg></span></a><ul class="dropdown-menu dropdown-menu-main shadow rounded border-0" aria-labelledby="navbarDropdownMenuLink"><li><a class="dropdown-item" href="/community/publications/">Publications</a></li><li><a class="dropdown-item" href="/community/talks/">Talks</a></li><li><a class="dropdown-item" href="/community/members/">Members</a></li><li><a class="dropdown-item active" href="/community/code_of_conduct/" aria-current="true">Code of Conduct</a></li><li><a class="dropdown-item" href="/community/contact/">Contact</a></li></ul></li><li class="nav-item"><a class="nav-link ps-0 py-1" href="/wiki/homepage/">Wiki</a></li></ul><hr class="text-black-50 my-4 d-lg-none"/><form class="doks-search position-relative flex-grow-1 ms-lg-auto me-lg-2"><input id="search" class="form-control is-search" type="search" placeholder="Search site..." aria-label="Search site..." autocomplete="off"/><div id="suggestions" class="shadow bg-white rounded d-none"></div></form><hr class="text-black-50 my-4 d-lg-none"/><ul class="nav flex-column flex-lg-row"><li class="nav-item"><a class="nav-link social-link" href="https://github.com/GambitBSM"><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-github"><path d="M9 19c-5 1.5-5-2.5-7-3m14 6v-3.87a3.37 3.37.0 00-.94-2.61c3.14-.35 6.44-1.54 6.44-7A5.44 5.44.0 0020 4.77 5.07 5.07.0 0019.91 1S18.73.65 16 2.48a13.38 13.38.0 00-7 0C6.27.65 5.09 1 5.09 1A5.07 5.07.0 005 4.77 5.44 5.44.0 003.5 8.55c0 5.42 3.3 6.61 6.44 7A3.37 3.37.0 009 18.13V22"></path></svg><small class="ms-2 d-lg-none">GitHub</small></a></li></ul><hr class="text-black-50 my-4 d-lg-none"/><button id="mode" class="btn btn-link" type="button" aria-label="Toggle user interface mode">
<span class="toggle-dark"><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-moon"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"></path></svg></span><span class="toggle-light"><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-sun"><circle cx="12" cy="12" r="5"></circle><line x1="12" y1="1" x2="12" y2="3"></line><line x1="12" y1="21" x2="12" y2="23"></line><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line><line x1="1" y1="12" x2="3" y2="12"></line><line x1="21" y1="12" x2="23" y2="12"></line><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line></svg></span></button></div></div></nav></header></div><div class="wrap container-xxl" role="document"><div class="content"><div class="row flex-xl-nowrap"><div class="col-lg-5 col-xl-4 docs-sidebar"><nav class="docs-links" aria-label="Main navigation"><ul class="list-unstyled collapsible-sidebar"><li class="mb-1"><button class="btn btn-toggle align-items-center rounded collapsed" data-bs-toggle="collapse" data-bs-target="#section-installation" aria-expanded="false">
Installation</button><div class="collapse" id="section-installation"><ul class="btn-toggle-nav list-unstyled fw-normal pb-1 small"><li><a class="docs-link rounded" href="/documentation/installation/introduction/">Getting Started</a></li><li><a class="docs-link rounded" href="/documentation/installation/docker_usage/">Docker Usage</a></li><li><a class="docs-link rounded" href="/documentation/installation/installation_for_linux/">Installation for Linux</a></li><li><a class="docs-link rounded" href="/documentation/installation/installation_for_windows/">Installation for Windows</a></li><li><a class="docs-link rounded" href="/documentation/installation/installation_for_macos/">Installation for macOS</a></li></ul></div></li><li class="mb-1"><button class="btn btn-toggle align-items-center rounded collapsed" data-bs-toggle="collapse" data-bs-target="#section-examples" aria-expanded="false">
Examples</button><div class="collapse" id="section-examples"><ul class="btn-toggle-nav list-unstyled fw-normal pb-1 small"><li><a class="docs-link rounded" href="/documentation/examples/colliderbit_example/">ColliderBit Example</a></li><li><a class="docs-link rounded" href="/documentation/examples/anotherbit/">AnotherBit</a></li><li><a class="docs-link rounded" href="/documentation/examples/anotherbit2/">AnotherBit2</a></li></ul></div></li><li class="mb-1"><button class="btn btn-toggle align-items-center rounded collapsed" data-bs-toggle="collapse" data-bs-target="#section-help" aria-expanded="false">
Help</button><div class="collapse" id="section-help"><ul class="btn-toggle-nav list-unstyled fw-normal pb-1 small"><li><a class="docs-link rounded" href="/documentation/help/faqs/">FAQs</a></li><li><a class="docs-link rounded" href="/documentation/help/compiler_matrix/">Compiler Matrix</a></li><li><a class="docs-link rounded" href="/documentation/help/known_issues/">Known Issues</a></li><li><a class="docs-link rounded" href="/documentation/help/configuration_examples/">Configuration Examples</a></li></ul></div></li><li class="mb-1"><button class="btn btn-toggle align-items-center rounded collapsed" data-bs-toggle="collapse" data-bs-target="#section-code" aria-expanded="true">
Code Reference</button><div class="collapse show" id="section-code"><ul class="btn-toggle-nav list-unstyled fw-normal pb-1 small"><li class="my-1 ms-3"><button class="btn btn-toggle align-items-center rounded collapsed" data-bs-toggle="collapse" data-bs-target="#section-gambit_2-2" aria-expanded="true">
<font style="color: #5d2f86;" size="-6">release</font>   gambit 2-2</button><div class="collapse show" id="section-gambit_2-2"><ul class="btn-toggle-nav list-unstyled fw-normal pb-1 small"><li><a class="docs-link rounded" href="/documentation/code/gambit_2-2/index_classes/">Classes</a></li><li><a class="docs-link rounded" href="/documentation/code/gambit_2-2/index_files/">Files</a></li><li><a class="docs-link rounded" href="/documentation/code/gambit_2-2/index_pages/">Pages</a></li><li><a class="docs-link rounded" href="/documentation/code/gambit_2-2/index_namespaces/">Namespaces</a></li></ul></div></li></ul></div></li></ul></nav></div><nav class="docs-toc d-none d-xl-block col-xl-3" aria-label="Secondary navigation"><div class="d-xl-none"><button class="btn btn-outline-primary btn-sm doks-toc-toggle collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#onThisPage" aria-controls="doks-docs-nav" aria-expanded="false" aria-label="Toggle On this page navigation">
<span>On this page</span>
<span><svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24" class="doks doks-expand" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><title>Expand</title><polyline points="7 13 12 18 17 13"></polyline><polyline points="7 6 12 11 17 6"></polyline></svg><svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24" class="doks doks-collapse" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><title>Collapse</title><polyline points="17 11 12 6 7 11"></polyline><polyline points="17 18 12 13 7 18"></polyline></svg></span></button><div class="collapse" id="onThisPage"><div class="card card-body mt-3 py-1"><div class="page-links"><nav id="TableOfContents"><ul><li><ul><li><a href="#namespaces">Namespaces</a></li><li><a href="#source-code">Source code</a></li></ul></li></ul></nav></div></div></div></div><div class="page-links d-none d-xl-block"><h3>On this page</h3><nav id="TableOfContents"><ul><li><ul><li><a href="#namespaces">Namespaces</a></li><li><a href="#source-code">Source code</a></li></ul></li></ul></nav></div></nav><main class="docs-content col-lg-11 col-xl-9 mx-xl-auto"><nav aria-label="breadcrumb"><ol class="breadcrumb"><li class="breadcrumb-item"><a href="/">Home</a></li><li class="breadcrumb-item"><a href="/documentation/">Documentation</a></li><li class="breadcrumb-item"><a href="/documentation/code/">Code Reference</a></li><li class="breadcrumb-item"><a href="/documentation/code/gambit_2-2/">gambit_2-2</a></li><li class="breadcrumb-item active" aria-current="page">file modules/CBGB/modules/utils.py</li></ol></nav><h1>file modules/CBGB/modules/utils.py</h1><p class="lead"></p><p>[No description available]</p><h2 id="namespaces">Namespaces <a href="#namespaces" class="anchor" aria-hidden="true">#</a></h2><table><thead><tr><th>Name</th></tr></thead><tbody><tr><td><strong><a href="/documentation/code/gambit_2-2/namespaces/namespacemodules/">modules</a></strong></td></tr><tr><td><strong><a href="/documentation/code/gambit_2-2/namespaces/namespacemodules_1_1utils/">modules::utils</a></strong></td></tr></tbody></table><h2 id="source-code">Source code <a href="#source-code" class="anchor" aria-hidden="true">#</a></h2><pre><code>#
#   ==================================
#   |                                |
#   |   Utility functions for CBGB   |
#   |                                |
#   ==================================
#

from collections import OrderedDict
from modules import gb
import importlib
import modules.active_cfg
cfg = importlib.import_module(&#34;configs.&#34; + modules.active_cfg.module_name)


# ====== removeComments ========

# Takes a list of code lines and removes comments.
# For fixed format files, any character at position 0 is a comment.
# For lines containing &#39;!&#39; everything after &#39;!&#39; is removed.

def removeComments(code_lines):

    code_lines_nocomment = []

    for line in code_lines:

        if len(line) == 0:
            code_lines_nocomment.append(&#39;&#39;)
            continue

        if (cfg.format == &#39;fixed&#39;) and (line[0] != &#39; &#39;):
            new_line = &#39;&#39;

        elif &#39;!&#39; in line:
            pos = line.find(&#39;!&#39;)
            new_line = line[:pos]

        else:
            new_line = line

        code_lines_nocomment.append(new_line)

    return code_lines_nocomment

# ====== END: removeComments ========



# ====== removeBlankLines ========

# Removes any empty (all whitespace) strings from a list of strings.

def removeBlankLines(code_lines):

    # Walk through the list of code lines backwards and discard 
    # any lines that contain nothing but whitespace.
    for i in range(len(code_lines))[::-1]:
        if code_lines[i].strip() == &#39;&#39;:
            code_lines.pop(i)

    return code_lines

# ====== END: removeBlankLines ========



# ====== removeLeadingTrailingBlanks ========

# Removes leading and trailing blanks from the strings
# in a list of strings.

def removeLeadingTrailingBlanks(code_lines):

    for i in range(len(code_lines)):
        code_lines[i] = code_lines[i].lstrip().rstrip()

    return code_lines

# ====== END: removeLeadingTrailingBlanks ========



# ====== removeStatementLabels ========

# Replaces statement labels with empty spaces.
# (A statement label is a number given as the first 
# non-blank part of a statement.)

def removeStatementLabels(code_lines):

    for i in range(len(code_lines)):

        line = code_lines[i]

        if cfg.format == &#39;fixed&#39;:
            label = line[0:5].strip()
            if label.isdigit():
                code_lines[i] = line.replace(label, &#39; &#39;*len(label), 1)

        elif cfg.format == &#39;free&#39;:

            line_list = line.split()
            if (len(line_list) &gt; 0):
                label = line_list[0]
                if label.isdigit():
                    code_lines[i] = line.replace(label, &#39; &#39;*len(label), 1)                    

        else:
            raise RuntimeError(&#34;cfg.format must be set to either &#39;fixed&#39; or &#39;free&#39;.&#34;)

    return code_lines

# ====== END: removeStatementLabels ========



# ====== removeKeywords ========

# Replaces Fortran keywords that CBGB doesn&#39;t 
# care about with empty spaces.

def removeKeywords(code_lines):

    for i in range(len(code_lines)):

        line = code_lines[i]

        line = line.replace(&#34;::&#34;, &#34; &#34;)

        line = line.replace(&#34;intent(in)&#34;, &#34; &#34;)
        line = line.replace(&#34;intent(out)&#34;, &#34; &#34;)
        line = line.replace(&#34;intent (in)&#34;, &#34; &#34;)
        line = line.replace(&#34;intent (out)&#34;, &#34; &#34;)

        # Add more keywords here...

        code_lines[i] = line

    return code_lines

# ====== END: removeKeywords ========



# ====== allSingleSpace ========

# Replaces multiple spaces with a single space.

def allSingleSpace(code_lines):

    for i in range(len(code_lines)):

        line = code_lines[i]

        line = &#39; &#39;.join(line.split())

        code_lines[i] = line

    return code_lines

# ====== END: allSingleSpace ========



# ====== joinContinuedLines ========

def joinContinuedLines(code_lines):

    joined_code_lines = [&#39;&#39;]

    if cfg.format == &#39;fixed&#39;:

        for line in code_lines:
            
            # Check for line continuation (any character at column 6).
            # (This assumes that len(line) &gt;= 6 for all lines in code_lines,
            # which should be OK due to prior code formatting.)

            try:
                # - If found, append to previous line.
                if line[5] not in [&#39; &#39;,&#39;\t&#39;]:
                    joined_code_lines[-1] += line[6:]

                # - If not found, store current_line and start constructing a new.
                else:
                    joined_code_lines.append(line)

            except:
                print [line]
                raise
            


    elif cfg.format == &#39;free&#39;:

        continue_line = False
        for line in code_lines:

            if continue_line:
                if line.lstrip()[0] == &#39;&amp;&#39;:
                    joined_code_lines[-1] += line.lstrip()[1:].rstrip().rstrip(&#39;&amp;&#39;)
                else:
                    joined_code_lines[-1] += line.rstrip().rstrip(&#39;&amp;&#39;)
            else:
                joined_code_lines.append(line.rstrip().rstrip(&#39;&amp;&#39;))


            # Check for line continuation. (Line ends with &#39;&amp;&#39;.)
            if line.rstrip()[-1] == &#39;&amp;&#39;:
                continue_line = True
            else:
                continue_line = False

    else:
        raise RuntimeError(&#34;cfg.format must be set to either &#39;fixed&#39; or &#39;free&#39;.&#34;)

    if joined_code_lines[0] == &#39;&#39;:
        joined_code_lines.pop(0)

    return joined_code_lines


# ====== END: joinContinuedLines ========




# ====== getCodeParts ========

def getCodeParts(code_lines, prepend_module_name=False):

    code_parts_dict = OrderedDict()

    unnamed_part_counter = 1
    start_line  = 0
    end_line    = 0

    current_part = &#39;general&#39;
    current_module = &#39;&#39;

    for i, line in enumerate(code_lines):

        #
        # Detect beginning/end of a module
        #
        if current_part == &#39;general&#39;:

            # Detect beginning of a module
            if &#39;module &#39; in line[0:7].lower():
                current_module = line.split()[1]

            # Detect end of a module
            if current_module != &#39;&#39;:
                if (line.replace(&#39; &#39;,&#39;&#39;).strip().lower() in [&#39;end&#39;,&#39;endmodule&#39;, &#39;endmodule&#39;+current_module.lower()]):
                    current_module = &#39;&#39;

        #
        # Detect start of program/function/subroutine, end current &#39;general&#39; part
        #

        if current_part == &#39;general&#39;:

            new_part = &#39;&#39;
            if &#39;subroutine &#39; in line[0:11].lower():
                new_part = &#39;subroutine&#39;
            elif (&#39;function &#39; in line[0:9].lower()) or (&#39; function &#39; in line.lower()):
                new_part = &#39;function&#39;
            elif &#39;program &#39; in line[0:8].lower():
                new_part = &#39;program&#39;

            # If the beginning of a new code part is found:
            # - store the line numbers for the current &#39;general&#39; code part
            # - set start_line for the new code part
            # - identify a name for the new code part
            if new_part in [&#39;subroutine&#39;, &#39;function&#39;, &#39;program&#39;]:
    
    
                # Store lines (if any) from current &#39;general&#39; part
                if (start_line &lt; i):

                    if current_part == &#39;general&#39;:
                        name_long = &#39;unnamed_&#39; + current_part + &#39;_&#39; + str(unnamed_part_counter)
                        unnamed_part_counter += 1

                    code_parts_dict[name_long] = { 
                                              &#39;category&#39;   : current_part,
                                              &#39;code_lines&#39; : code_lines[start_line:i],
                                              &#39;module&#39;     : current_module
                                            }


                # Restart line count for new code part
                start_line = i
    
                # Identify name for new code part
                name = getCodePartName(line, new_part)
                if (name == &#39;unnamed_&#39; + new_part):
                    name = name + &#39;_&#39; + str(unnamed_part_counter)
                    unnamed_part_counter += 1

                # line_list = line.split()
                # line_list_lowercase = line.lower().split()
                # keyword_index = line_list_lowercase.index(new_part)

                # if len(line_list) == keyword_index+1:
                #     name_long = &#39;unnamed_&#39; + new_part + &#39;_&#39; + str(unnamed_part_counter)
                #     unnamed_part_counter += 1

                # else:
                #     # name_item = line_list[line_list.index(new_part)+1]
                #     name_item = line_list[keyword_index+1]
                #     if &#39;(&#39; in name_item:
                #         name = name_item[:name_item.find(&#39;(&#39;)]
                #     else:
                #         name = name_item

                if (current_module != &#39;&#39;) and (prepend_module_name):
                    name_long = current_module + &#39;::&#39; + name
                else:
                    name_long =  name

                # Update current_part
                current_part = new_part


      
        #
        # Detect end of program/function/subroutine, start new &#39;general&#39; part
        #

        elif (current_part in [&#39;subroutine&#39;, &#39;function&#39;, &#39;program&#39;]) and (line.replace(&#39; &#39;,&#39;&#39;).strip().lower() in [&#39;end&#39;,&#39;end&#39;+current_part, &#39;end&#39;+current_part+name.lower()]):


            # Store in dict
            if (start_line &lt; i):

                if current_part == &#39;general&#39;:
                    name_long = &#39;unnamed_&#39; + current_part + &#39;_&#39; + str(unnamed_part_counter)
                    unnamed_part_counter += 1

                code_parts_dict[name_long] = { 
                                          &#39;category&#39;   : current_part,
                                          &#39;code_lines&#39; : code_lines[start_line:i+1],
                                          &#39;module&#39;     : current_module
                                        }

                # Set variables for the next code part
                start_line = i+1
                current_part = &#39;general&#39;

    #
    # end loop over code lines
    #

    # Store final bit:
    if (start_line &lt; i):

        if current_part == &#39;general&#39;:
            name_long = &#39;unnamed_&#39; + current_part + &#39;_&#39; + str(unnamed_part_counter)
            unnamed_part_counter += 1

        code_parts_dict[name_long] = { 
                                  &#39;category&#39;   : current_part,
                                  &#39;code_lines&#39; : code_lines[start_line:i+1],
                                  &#39;module&#39;     : current_module
                                }

    return code_parts_dict

# ====== END: getCodeParts ========




# ====== getCodePartName ========

def getCodePartName(code_line, keyword):

    line_list = code_line.split()
    line_list_lowercase = code_line.lower().split()
    keyword_index = line_list_lowercase.index(keyword)

    if len(line_list) == keyword_index+1:
        name = &#39;unnamed_&#39; + keyword

    else:
        name_item = line_list[keyword_index+1]
        if &#39;(&#39; in name_item:
            name = name_item[:name_item.find(&#39;(&#39;)]
        else:
            name = name_item

    return name

# ====== END: getCodePartName ========






# ====== getImplicitDefs ========

# Return a dict with the following structure: 
#   { 
#     &#39;a&#39;: (&#39;double precision&#39;,1), 
#     &#39;b&#39;: (&#39;real&#39;,8),
#     &#39;c&#39;: (None,None),
#     ...
#   }
#

def getImplicitDefs(code_lines):

    implicit_defs = gb.default_implicit_types

    for i,line in enumerate(code_lines):

        # Split line into words
        line_list = line.split()

        # Look for &#39;implicit&#39; statement
        if line_list[0].lower() == &#39;implicit&#39;:

            # If &#39;implicit none&#39;, then no other &#39;implicit&#39; statements are allowed
            if line_list[1].lower() == &#39;none&#39;:
                return dict.fromkeys(gb.alphabet,(None,None))

            # Remove the &#39;implicit&#39; keyword
            typedef_line   = &#39; &#39;.join(line_list[1:])

            # If there are multiple implicit statements on a single line,
            # split them up and treat them separately.
            for temp_line in typedef_line.split(&#39;)&#39;):

                # Do a bunch of string manipulations to identify
                # the type name (e.g. &#39;double precision&#39;) and 
                # character specifications (e.g. &#39;a-z&#39;).
                if temp_line == &#39;&#39;:
                    continue

                temp_line = temp_line.replace(&#39;(&#39;,&#39;&#39;)
                temp_line = temp_line.replace(&#39;,&#39;,&#39; &#39;)
                temp_line = temp_line.strip()
                while &#39; -&#39; in temp_line:
                    temp_line = temp_line.replace(&#39; -&#39;,&#39;-&#39;)
                while &#39;- &#39; in temp_line:
                    temp_line = temp_line.replace(&#39;- &#39;,&#39;-&#39;)
                temp_line = &#39; &#39;.join(temp_line.split())
                temp_line_list = temp_line.split()

                char_list = []
                type_name_list = []
                for entry in temp_line_list:
                    if ((len(entry)==1) and (entry in gb.alphabet)) or (len(entry)==3 and (entry[1]==&#39;-&#39;)):
                        char_list.append(entry)
                    else:
                        type_name_list.append(entry)

                full_type_name = &#39;&#39;.join(type_name_list)
                if &#39;*&#39; in full_type_name:
                    type_name, type_size_str = full_type_name.split(&#39;*&#39;)
                    type_size = int(type_size_str)
                else:
                    type_name = full_type_name
                    type_size = 1


                # Loop through the character specifiers in char_list
                # and set the correct types in the implicit_defs dict

                for char in char_list:

                    if (len(char)==1) and (char in gb.alphabet):
                        implicit_defs[char.lower()] = (type_name,type_size)

                    elif (len(char)==3 ) and (char[1]==&#39;-&#39;):
                        start_char = char[0]
                        end_char = char[2]

                        for key_char in implicit_defs.keys():
                            if (key_char &gt;= start_char) and (key_char &lt;= end_char):
                                implicit_defs[key_char.lower()] = (type_name,type_size)

    return implicit_defs

# ====== END: getImplicitDefs ========




# ====== getParameterDefs ========

# Return a dict with the following structure: 
#   { 
#     &#39;some_variable&#39;   : &#39;1234&#39; 
#     &#39;another_variable&#39;: &#39;10&#39;
#     ...
#   }
#
# Note: Currently, only integer parameters are useful (array dimensions and indices).
#

def getParameterDefs(code_lines):

    parameter_defs = {}

    for i,line in enumerate(code_lines):

        # Look for &#39;parameter&#39; statement
        if line[0:9].lower() == &#39;parameter&#39;:

            # Remove &#39;parameter&#39;
            line = line[9:]

            # Remove blanks
            line = line.replace(&#39; &#39;,&#39;&#39;)

            # Remove parenthesis
            line = line.lstrip(&#39;(&#39;).rstrip(&#39;)&#39;)

            # Split at comma
            parameter_entries = line.split(&#39;,&#39;)

            for entry in parameter_entries:

                # Split at &#39;=&#39; symbol
                var_name, value_str = entry.split(&#39;=&#39;)

                try:
                    value = eval(value_str)
                except:
                    print &#39;    WARNING: Could not interpret the parameter &#34;%s&#34; with value &#34;%s&#34;. Ignoring it.&#39; % (var_name, value_str)
                    continue


                # At the moment, CBGB can only make use of integer parameters. (Their only use is for array dimensions and indices.)
                if not isinstance( value, ( int, long ) ):
                    print &#39;    INFO: Ignoring parameter &#34;%s&#34; with value &#34;%s&#34; as it was not recognized as an integer.&#39; % (var_name, value_str)
                    continue

                value = int(value)

                # Adding variable to parameter_defs dictionary
                parameter_defs[var_name] = value

    return parameter_defs

# ====== END: getParameterDefs ========




# ====== getCommonBlockDicts ========

def getCommonBlockDicts(code_lines):

    cb_dicts = []

    for line in code_lines:

        # Remove whitespaces
        line = line.replace(&#39; &#39;,&#39;&#39;)

        # Ignore lines that don&#39;t start with &#39;common/&#39;
        if (len(line) &lt; 7) or (line[:7].lower() != &#39;common/&#39;):
            continue

        # Identify common block name and names of member variables
        line_list   = line.split(&#39;/&#39;)
        cb_name     = line_list[1]
        var_seq_str = line_list[2] 

        var_dicts = parseVariableSequence(var_seq_str)
        var_names = var_dicts.keys()

        cb_dicts.append( {&#39;name&#39;:cb_name, &#39;member_names&#39;:var_names} )

    return cb_dicts

# ====== END: getCommonBlockDicts ========




# ====== isVariableDecl ========

def isVariableDecl(line_in, return_type=False):

    is_variable_decl = False
    type_name = &#39;&#39;
    type_size = 1

    line = line_in
    line = line.replace(&#39;,&#39;,&#39; &#39;).replace(&#39;*&#39;,&#39; * &#39;).replace(&#39;::&#39;,&#39; &#39;)
    line = line.replace(&#39;(&#39;, &#39; (&#39;).replace(&#39;)&#39;,&#39;) &#39;)
    line = &#39; &#39;.join(line.split())

    line_list = line.split()
    for i in [3,2,1]:
        check_type = &#39;&#39;.join(line_list[:i]).lower()

        print &#39;DEBUG: Is this a type? : &#39;, [line_in], [check_type]

        # Check that we can deal with this Fortran type.
        if check_type in gb.type_translation_dict.keys():

            # If type is &#39;character*&#39;, identify the integer that specifies the 
            # string length.
            if check_type==&#39;character&#39;:
                if (line_list[1] == &#39;*&#39;) and (line_list[2].isdigit()):
                    check_type += &#39;*&#39; + line_list[2]

            if &#39;*&#39; in check_type:
                type_name, type_size_str = check_type.split(&#39;*&#39;)
                type_size = int(type_size_str)
            else:
                type_name = check_type

            is_variable_decl = True
            print &#39;DEBUG: --- YES!&#39;
            break

    if return_type:
        return is_variable_decl, type_name, type_size
    else:
        return is_variable_decl

# ====== END: isVariableDecl ========




# ====== isDimensionStatement ========

def isDimensionStatement(line_in):

    is_dim_stmnt = False

    line = line_in
    line_list = line.split()

    if (len(line_list) &gt; 1) and (line_list[0].lower() == &#39;dimension&#39;):
        is_dim_stmnt = True

    return is_dim_stmnt

# ====== END: isDimensionStatement ========



# ====== getArrayIndicesTuples ========

# Example:
# Input:  &#39;-2:10,7,1:2&#39;
# Output: [(-2,7), (1,7), (1,2)]

def getArrayIndicesTuples(dimensions_str, parameter_defs):

    indicies_tuples = []

    # Check for empty dimensions string
    if dimensions_str == &#39;&#39;:
        return indicies_tuples

    # Check for assumed-shape arrays. We can&#39;t deal with that yet...        
    if dimensions_str == &#39;:&#39;:
        raise RuntimeError

    # Loop over comma-separated entries in dimensions_str
    for dim_str in dimensions_str.split(&#39;,&#39;):

        if &#39;:&#39; in dim_str:
            # start_index, end_index = [int(s) for s in dim_str.split(&#39;:&#39;)]
            start_index_str, end_index_str = [s for s in dim_str.split(&#39;:&#39;)]

            if start_index_str in parameter_defs.keys():
                start_index = int( parameter_defs[start_index_str] )
            else:
                start_index = int(start_index_str)

            if end_index_str in parameter_defs.keys():
                end_index = int( parameter_defs[end_index_str] )
            else:
                end_index = int(end_index_str)

        else:
            start_index = 1
            end_index_str = dim_str
            if end_index_str in parameter_defs.keys():
                end_index = int( parameter_defs[end_index_str] )
            else:
                end_index = int(end_index_str)


        indicies_tuples.append( (start_index,end_index) )

    return indicies_tuples

# ====== END: getArrayIndicesTuples ========



# ====== getVariablesDict ========

def getVariablesDict(code_lines, get_variables):

    if len(get_variables) == 0:
        return OrderedDict()

    return_var_dicts = OrderedDict.fromkeys(get_variables, value=None)

    implicit_defs = getImplicitDefs(code_lines)

    for line in code_lines:

        #
        # First, make use of all variable type declaration lines
        #
        
        is_var_decl, type_name, type_size = isVariableDecl(line, return_type=True)

        if is_var_decl:

            # Remove type name from beginning of line so that
            # only the list of variable names remain.
            full_type_name = type_name + &#39;*&#39; + str(type_size)

            line_list = line.split()
            i = 1
            while i &lt;= len(line_list):
                if &#39;&#39;.join(line_list[:i]).lower() in full_type_name:
                    i += 1
                    continue
                else:
                    break
            var_seq = &#39;&#39;.join(line_list[i-1:])

            # Parse line to extract info on the different variables
            var_dicts = parseVariableSequence(var_seq)

            # Append type_name and type_size to var_dicts
            for var_name in var_dicts.keys():

                # - Add type name
                var_dicts[var_name][&#39;type&#39;] = type_name
                # - Use the maximum of the sizes specified in the type name and in the variable sequence
                #   (Normally one of these should be 1 by default.)
                var_dicts[var_name][&#39;size&#39;] = max(type_size,var_dicts[var_name][&#39;size&#39;])


                # Check for character array type:
                if (var_dicts[var_name][&#39;type&#39;] == &#39;character&#39;): 
                    dim_str = var_dicts[var_name][&#39;dimension&#39;]
                    size    = var_dicts[var_name][&#39;size&#39;]
                    if (dim_str == &#39;&#39;) and (size &gt; 1):
                        var_dicts[var_name][&#39;dimension&#39;] = &#39;1:%i&#39; % size

            # For requested variables, append the variable dicts to return_var_dicts
            for var_name in var_dicts.keys():
                if var_name in get_variables:
                    return_var_dicts[var_name] = var_dicts[var_name]



        #
        # Then, check all the &#39;dimension&#39; statements
        #

        is_dim_stmnt = isDimensionStatement(line)

        if is_dim_stmnt:

            # Remove whitespace and &#39;dimension&#39; keyword
            line = line.replace(&#39; &#39;,&#39;&#39;)
            line = line.replace(&#39;dimension&#39;,&#39;&#39;,1)

            # Parse line to extract info on the different variables
            dim_var_dicts = parseVariableSequence(line)

            # For variables that already exist in return_var_dicts, simply
            # update the &#39;dimension&#39;. For variables that don&#39;t exist in 
            # return_var_dicts, create a new entry based on implicit types.
            for var_name in dim_var_dicts.keys():

                if var_name in get_variables:

                    # If info on this variable has not yet been added to return_var_dicts,
                    # insert a complete dict
                    if return_var_dicts[var_name] == None:
                        # Get type from implicit types
                        first_char = var_name[0]
                        type_name, type_size = implicit_defs[first_char.lower()]

                        if type_name == None or type_size == None:
                            raise RuntimeError(&#34;No type declaration (neither explicit nor implicit) was found for variable &#39;%s&#39;.&#34; % var_name)

                        return_var_dicts[var_name] = { 
                                                       &#39;type&#39;     : type_name,
                                                       &#39;dimension&#39;: dim_var_dicts[var_name][&#39;dimension&#39;],
                                                       &#39;size&#39;     : type_size
                                                     }

                    # If info on this variable already exists, simply update the &#39;dimension&#39; entry in the
                    # correct dict
                    else:
                        return_var_dicts[var_name][&#39;dimension&#39;] = dim_var_dicts[var_name][&#39;dimension&#39;]


    #
    # END: Loop over code lines
    #

    #
    # Finally, add any missing variables that have not appeared in explicit type
    # declarations or &#39;dimension&#39; statements
    #

    for get_var_name in get_variables:

        if return_var_dicts[get_var_name] == None:

            # Get type from implicit types
            first_char = get_var_name[0]
            type_name, type_size = implicit_defs[first_char.lower()]

            if type_name == None or type_size == None:
                raise RuntimeError(&#34;No type declaration (neither explicit nor implicit) was found for variable &#39;%s&#39;.&#34; % get_var_name)

            return_var_dicts[get_var_name] = { 
                                              &#39;type&#39;     : type_name,
                                              &#39;dimension&#39;: &#39;&#39;,
                                              &#39;size&#39;     : type_size
                                             }

    return return_var_dicts

# ====== END: getVariablesDict ========




# ====== parseVariableSequence ========

# Input : &#34;var1*100, var2(1:20)*20, var3&#34;
#
# Output: { 
#           &#39;var1&#39;: { &#39;size&#39;: 100, &#39;dimension&#39;: &#39;&#39;       }, 
#           &#39;var2&#39;: { &#39;size&#39;: 20,  &#39;dimension&#39;: &#39;(1:20)&#39; },
#           &#39;var3&#39;: { &#39;size&#39;: 1,   &#39;dimension&#39;: &#39;&#39;       }
#         }

def parseVariableSequence(var_seq_str):

    result_dict = OrderedDict()

    line = var_seq_str

    # Remove all whitespace
    line = line.replace(&#39; &#39;,&#39;&#39;)

    # Split into separate variables by detecting commas 
    # (excluding commas inside brackets).
    i = 0
    bracket_balance = 0
    while i &lt; len(line):
        
        char = line[i]

        # Keep track of the brackets
        if char == &#39;(&#39;:
            bracket_balance += 1
        elif char == &#39;)&#39;:
            bracket_balance -= 1

        # If a comma is found, replace it with a whitespace
        if (char == &#39;,&#39;) and (bracket_balance == 0):
            line = line[:i] + &#39; &#39; + line[i+1:]

        # Increment index
        i += 1

    # Split line at whitespaces
    var_str_list = line.split()

    for var_str in var_str_list:

        # Check for dimension bracket and size integer
        has_dim_bracket = bool(&#39;(&#39; in var_str and &#39;)&#39; in var_str)
        has_size_int    = bool(&#39;*&#39; in var_str)

        # Insert whitespace to separate variable name, dimension bracket and size integer
        var_str = var_str.replace(&#39;(&#39;,&#39; &#39;).replace(&#39;)&#39;,&#39; &#39;).replace(&#39;*&#39;,&#39; &#39;)

        # Split at whitespace
        var_str_list = var_str.split()

        # Identify name, dimension, size
        if has_dim_bracket and has_size_int:
            var_name     = var_str_list[0]
            var_dim_str  = var_str_list[1]
            var_size     = int(var_str_list[2])
        elif has_dim_bracket and not has_size_int:
            var_name     = var_str_list[0]
            var_dim_str  = var_str_list[1]
            var_size     = 1
        elif has_size_int and not has_dim_bracket:
            var_name     = var_str_list[0]
            var_dim_str  = &#39;&#39;
            var_size     = int(var_str_list[1])
        else:
            var_name     = var_str_list[0]
            var_dim_str  = &#39;&#39; 
            var_size     = 1

        # Append to result_dict
        result_dict[var_name] = {&#39;dimension&#39;: var_dim_str, &#39;size&#39;: var_size}

    return result_dict

# ====== END: parseVariableSequence ========



# ====== getFunctionArgumentNames ========

def getFunctionArgumentNames(code_line):

# Input : &#34;subroutine some_subroutine(arg1,arg2,arg3)&#34;
#
# Output: [&#34;arg1&#34;,&#34;arg2&#34;,&#34;arg3&#34;] 

    arg_names = []
    if (&#39;(&#39; not in code_line) or (&#39;)&#39; not in code_line):
        return arg_names

    # Pick out argument sequence
    arg_seq_str = code_line.split(&#39;(&#39;)[-1].split(&#39;)&#39;)[0]

    # Strip away any whitespace
    arg_seq_str = &#39;&#39;.join(arg_seq_str.split())

    # Construct list
    if arg_seq_str != &#39;&#39;:
        arg_names = arg_seq_str.split(&#39;,&#39;)

    # Return resulting list
    return arg_names

# ====== END: getFunctionArgumentNames ========



# ====== getFunctionReturnType ========

def getFunctionReturnType(code_lines):

    f_decl_line = code_lines[0]

    f_decl_line_list = f_decl_line.split()
    f_index = f_decl_line.lower().split().index(&#39;function&#39;)
    
    # Get function name
    f_name = getCodePartName(f_decl_line, &#39;function&#39;)

    # Grab content in declaration line preceding the &#39;function&#39; keyword
    # and append the function name to form a regular variable declaration: 
    f_return_type_line = &#39; &#39;.join(f_decl_line_list[:f_index] + [f_name])

    # If f_return_type_line forms a valid type declaration, use it.
    # Otherwise, search the function body for a declaration.
    is_decl = isVariableDecl(f_return_type_line)
    if is_decl:
        result_dict = getVariablesDict([f_return_type_line], [f_name])
        return_type_dict = result_dict[f_name]
    else:
        result_dict = getVariablesDict(code_lines[1:], [f_name])
        return_type_dict = result_dict[f_name]

    return return_type_dict

# ====== END: getFunctionReturnType ========



# # ====== getFunctionDict ========

# def getFunctionDict(code_lines):

#     f_dict = OrderedDict()

#     # Get function/subroutine name
#     f_dict[&#39;name&#39;] = getF


#     return f_dict

# # ====== END: getFunctionDict ========



# ====== generateTypeDeclCommonBlock ========

def generateTypeDeclCommonBlock(cb_dict, var_info_dict, parameter_defs):

    indent = &#39; &#39;*4

    code = &#39;&#39;

    cb_name = cb_dict[&#39;name&#39;]
    cb_type_name = cb_name + &#39;_type&#39;

    code += &#39;struct %s\n&#39; % cb_type_name
    code += &#39;{\n&#39;

    for var_name, var_dict in var_info_dict.items():

        try:
            c_type_name = getCTypeName(var_dict, parameter_defs)
        except RuntimeError:
            print &#34;    ERROR: Failed to translate variable &#39;%s&#39; in common block &#39;%s&#39; to C type.&#34; % (var_name, cb_name)
            raise

        code += indent + c_type_name + &#39; &#39; + var_name + &#39;;\n&#39;

    code += &#39;};\n&#39;

    return code

# ====== END: generateTypeDeclCommonBlock ========



# ====== generateFrontendCommonBlock ========

def generateFrontendCommonBlock(cb_dict):

    code = &#39;&#39;

    cb_name            = cb_dict[&#39;name&#39;]
    cb_type_name       = cb_name + &#39;_type&#39;
    cb_capability_name = cfg.cb_capability_prefix + cb_name + cfg.cb_capability_suffix

    cb_mangled_symbol = getMangledSymbolName(cb_name)

    code += &#39;BE_VARIABLE(%s, %s, &#34;%s&#34;, &#34;%s&#34;)\n&#39; % (cb_name, cb_type_name, cb_mangled_symbol, cb_capability_name)

    return code

# ====== END: generateFrontendCommonBlock ========



# ====== generateFrontendFunction ========

def generateFrontendFunction(f_dict, parameter_defs):

    code = &#39;&#39;

    module_name  = f_dict[&#39;module&#39;]
    f_name_short = f_dict[&#39;name&#39;]
    if module_name != &#39;&#39;:
        f_name = module_name + &#39;_&#39; + f_name_short
    else:
        f_name = f_name_short

    arg_info_dict = f_dict[&#39;arg_info&#39;]

    # Get correct C type for the return type.
    # - if function:
    if &#39;return_type_info&#39; in f_dict.keys():
        ret_type_info_dict = f_dict[&#39;return_type_info&#39;]
        try:
            f_return_type_c = getCTypeName(ret_type_info_dict, parameter_defs)
        except RuntimeError:
            print &#34;    ERROR: Failed to translate the return type of function &#39;%s&#39; to C type.&#34; % (f_name)
            raise
    # - if subroutine:
    else:
        f_return_type_c = &#39;void&#39;


    # Generate mangled symbol name
    f_mangled_symbol = getMangledSymbolName(f_name_short, module=module_name)

    # Construct capability name
    if (cfg.module_name_in_capability) and (module_name != &#39;&#39;):
        f_capability_name = cfg.f_capability_prefix + f_name + cfg.f_capability_suffix
    else:
        f_capability_name = cfg.f_capability_prefix + f_name_short + cfg.f_capability_suffix


    # Construct argument list
    arg_bracket = &#39;(&#39;
    for arg_name, d in arg_info_dict.items():
        try:
            c_type_name = getCTypeName(d, parameter_defs)
        except RuntimeError:
            print &#34;    ERROR: Failed to translate the argument &#39;%s&#39; in %s &#39;%s&#39; to C type.&#34; % (arg_name, f_dict[&#39;category&#39;], f_name_short)
            raise
        arg_bracket += c_type_name + &#39;&amp;, &#39;
    arg_bracket = arg_bracket.rstrip(&#39;, &#39;)
    arg_bracket += &#39;)&#39;

    # Generate BE_FUNCTION macro call
    code += &#39;BE_FUNCTION(%s, %s, %s &#34;%s&#34;, &#34;%s&#34;)\n&#39; % (f_name, f_return_type_c, arg_bracket, f_mangled_symbol, f_capability_name)
    
    return code

# ====== END: generateFrontendFunction ========




# ====== getMangledSymbolName ========

def getMangledSymbolName(identifier, module=&#39;&#39;):

    if cfg.name_mangling == &#39;gfortran&#39;:
        if module != &#39;&#39;:
            mangled_symbol = &#39;__&#39; + module.lower() + &#39;_MOD_&#39; + identifier.lower()
        else:
            mangled_symbol = identifier.lower() + &#39;_&#39;
    elif cfg.name_mangling == &#39;ifort&#39;:
        if module != &#39;&#39;:
            mangled_symbol = module.lower() + &#39;_MP_&#39; + identifier.lower() + &#39;_&#39;
        else:
            mangled_symbol = identifier.lower() + &#39;_&#39;
    elif cfg.name_mangling == &#39;g77&#39;:
        if &#39;_&#39; in identifier:
            mangled_symbol = identifier.lower() + &#39;__&#39;
        else:
            mangled_symbol = identifier.lower() + &#39;_&#39;
    else:
        raise RuntimeError(&#34;cfg.name_mangling must be set to either &#39;gfortran&#39;, &#39;ifort&#39; or &#39;g77&#39;.&#34;)

    return mangled_symbol

# ====== END: getMangledSymbolName ========



# ====== getCTypeName ========

def getCTypeName(var_dict, parameter_defs):

    fortran_type_name = var_dict[&#39;type&#39;]
    
    if (fortran_type_name != &#39;character&#39;) and (var_dict[&#39;size&#39;] &gt; 1):
        fortran_type_name += &#39;*&#39; + str(var_dict[&#39;size&#39;])

    c_type_base_name = gb.type_translation_dict[fortran_type_name]

    try:
        array_indices_tuples = getArrayIndicesTuples(var_dict[&#39;dimension&#39;], parameter_defs)
    except RuntimeError:
        print &#39;    ERROR: Cannot determine the correct size for variable of type %s(%s).&#39; % (fortran_type_name, var_dict[&#39;dimension&#39;])
        raise

    # Is this variable an array?
    if (fortran_type_name != &#39;character&#39;) and (len(array_indices_tuples) &gt; 0):
        is_array = True
    elif (fortran_type_name == &#39;character&#39;) and (len(array_indices_tuples) &gt; 1):
        is_array = True
    else:
        is_array = False

    # For arrays, construct a string of comma-separated array indices
    if is_array:
        all_indices_list = [i for tpl in array_indices_tuples for i in tpl]
        all_indices_str = &#39;,&#39;.join( map(str,all_indices_list) )

    #
    # Determine the correct C++ type name
    #

    # Special treatment for the character type
    if (fortran_type_name == &#39;character&#39;) and (var_dict[&#39;size&#39;] &gt; 1):
        if is_array:
            template_bracket = &#39;&lt; %i,%s &gt;&#39; % (var_dict[&#39;size&#39;], all_indices_str)
            c_type_name = &#39;FstringArray&#39; + template_bracket
        else:
            c_type_name = &#39;Fstring&lt;%i&gt;&#39; % var_dict[&#39;size&#39;] 

    # All other types
    else:
        if is_array:
            template_bracket = &#39;&lt; %s,%s &gt;&#39; % (c_type_base_name, all_indices_str)
            c_type_name = &#39;Farray&#39; + template_bracket
        else:
            c_type_name = c_type_base_name


    # Return result
    return c_type_name

# ====== END: getCTypeName ========



# ====== addNamespace ========

# Encapsulate code string in a namespace

def addNamespace(code, namespace_name, indent=4):

    # Add indentation
    code_lines = [&#39; &#39;*indent + line for line in code.splitlines()]
    code = &#39;\n&#39;.join(code_lines)

    # Add namespace
    code = &#39;namespace &#39; + namespace_name + &#39;\n&#39; + &#39;{\n&#39; + code + &#39;\n}\n&#39;

    return code

# ====== END: addNamespace ========
</code></pre><hr/><p>Updated on 2022-08-10 at 17:51:38 +0000</p></main></div></div></div><footer class="footer text-muted"><div class="container-xxl"><div class="row"><div class="col-lg-8 order-last order-lg-first"><ul class="list-inline"><li class="list-inline-item">Powered by <a class="text-muted" href="https://www.netlify.com/">Netlify</a>, <a class="text-muted" href="https://gohugo.io/">Hugo</a>, and <a class="text-muted" href="https://getdoks.org/">Doks</a></li></ul></div><div class="col-lg-8 order-first order-lg-last text-lg-end"><ul class="list-inline"><li class="list-inline-item"><a href="/license/">License</a></li></ul></div></div></div></footer><script src="/js/bootstrap.min.54bf0932b8a36d0e152b1635b099a6ef1394d35327e2437550a075c9c8ed1bd8aed5847c21b36fc02ed24014c031d9ca24017b0c78b1639d7e2fa8329898b842.js" integrity="sha512-VL8JMrijbQ4VKxY1sJmm7xOU01Mn4kN1UKB1ycjtG9iu1YR8IbNvwC7SQBTAMdnKJAF7DHixY51+L6gymJi4Qg==" crossorigin="anonymous" defer=""></script>
<script src="/js/highlight.min.5b48bc253dc75aeea5fb366ecf700f4925e2b6eb1a1466f2124b722d68148d67bc0a9365d2b8ad9c585161b46372d23b08509a16f1fd518542b894756d4752d0.js" integrity="sha512-W0i8JT3HWu6l+zZuz3APSSXitusaFGbyEktyLWgUjWe8CpNl0ritnFhRYbRjctI7CFCaFvH9UYVCuJR1bUdS0A==" crossorigin="anonymous" defer=""></script>
<script src="/main.min.40265e9a032aeba5eaf67baac3cbbc22667a7533215d326eeb3e9f4d5e4be40f9ff4dcd22949db73ae527ca26a19d7998091a8973c82af760b2c0daa335190ed.js" integrity="sha512-QCZemgMq66Xq9nuqw8u8ImZ6dTMhXTJu6z6fTV5L5A+f9NzSKUnbc65SfKJqGdeZgJGolzyCr3YLLA2qM1GQ7Q==" crossorigin="anonymous" defer=""></script>
<script src="https://gambitbsm.github.io/index.min.1e0f859443ac81a8b8c357ddfae5d899d83ab224e24e44c1c9620a99f2a527d70a1676148a868f87f22fb67994386d592e508dafb575df7c2b80d97f143ad1ea.js" integrity="sha512-Hg+FlEOsgai4w1fd+uXYmdg6siTiTkTByWIKmfKlJ9cKFnYUioaPh/IvtnmUOG1ZLlCNr7V133wrgNl/FDrR6g==" crossorigin="anonymous" defer=""></script></body></html>