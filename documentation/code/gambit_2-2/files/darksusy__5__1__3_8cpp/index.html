<!DOCTYPE html><html lang="en-us"><head><meta charset="utf-8"/><meta http-equiv="x-ua-compatible" content="ie=edge"/><meta name="viewport" content="width=device-width,initial-scale=1,shrink-to-fit=no"/><link rel="preload" as="font" href="https://gambitbsm.github.io/fonts/vendor/jost/jost-v4-latin-regular.woff2" type="font/woff2" crossorigin=""/><link rel="preload" as="font" href="https://gambitbsm.github.io/fonts/vendor/jost/jost-v4-latin-500.woff2" type="font/woff2" crossorigin=""/><link rel="preload" as="font" href="https://gambitbsm.github.io/fonts/vendor/jost/jost-v4-latin-700.woff2" type="font/woff2" crossorigin=""/><script>(()=>{var e=localStorage.getItem("theme");e==="dark"&&document.documentElement.setAttribute("data-dark-mode","")})()</script><link rel="stylesheet" href="https://gambitbsm.github.io/main.e60a30503f41dfe2a8e849eba3bb572667400d7915356bae7eff31d3e22e4492fc8c0b2ff150168b1139b9c0caad1a20c84c8957336bcc2bba8559379cc39f91.css" integrity="sha512-5gowUD9B3+Ko6Enro7tXJmdADXkVNWuufv8x0+IuRJL8jAsv8VAWixE5ucDKrRogyEyJVzNrzCu6hVk3nMOfkQ==" crossorigin="anonymous"/><noscript><style>img.lazyload{display:none}</style></noscript><meta name="robots" content="index, follow"/><meta name="googlebot" content="index, follow, max-snippet:-1, max-image-preview:large, max-video-preview:-1"/><meta name="bingbot" content="index, follow, max-snippet:-1, max-image-preview:large, max-video-preview:-1"/><title>file frontends/DarkSUSY_5_1_3.cpp - GAMBIT</title><meta name="description" content="[No description available]"/><link rel="canonical" href="https://gambitbsm.github.io/documentation/code/gambit_2-2/files/darksusy__5__1__3_8cpp/"/><meta property="og:locale" content="en_US"/><meta property="og:type" content="article"/><meta property="og:title" content="file frontends/DarkSUSY_5_1_3.cpp"/><meta property="og:description" content="[No description available]"/><meta property="og:url" content="https://gambitbsm.github.io/documentation/code/gambit_2-2/files/darksusy__5__1__3_8cpp/"/><meta property="og:site_name" content="GAMBIT"/><meta property="og:image" content="https://gambitbsm.github.io/gambit_logo.png"/><meta property="og:image:alt" content="GAMBIT"/><meta name="twitter:card" content="summary_large_image"/><meta name="twitter:site" content=""/><meta name="twitter:creator" content=""/><meta name="twitter:title" content="file frontends/DarkSUSY_5_1_3.cpp"/><meta name="twitter:description" content="[No description available]"/><meta name="twitter:image" content="https://gambitbsm.github.io/gambit_logo.png"/><meta name="twitter:image:alt" content="file frontends/DarkSUSY_5_1_3.cpp"/><script type="application/ld+json">{"@context":"https://schema.org","@graph":[{"@type":"Organization","@id":"https://gambitbsm.github.io/#/schema/organization/1","name":"Doks","url":"https://gambitbsm.github.io/","sameAs":["https://github.com/GambitBSM"],"logo":{"@type":"ImageObject","@id":"https://gambitbsm.github.io/#/schema/image/1","url":"https://gambitbsm.github.io/logo-doks.png","width":450,"height":416,"caption":"Doks"},"image":{"@id":"https://gambitbsm.github.io/#/schema/image/1"}},{"@type":"WebSite","@id":"https://gambitbsm.github.io/#/schema/website/1","url":"https://gambitbsm.github.io/","name":"GAMBIT","description":"Documentation for the Global And Modular BSM Inference Tool","publisher":{"@id":"https://gambitbsm.github.io/#/schema/organization/1"}},{"@type":"WebPage","@id":"https://gambitbsm.github.io/documentation/code/gambit_2-2/files/darksusy__5__1__3_8cpp/","url":"https://gambitbsm.github.io/documentation/code/gambit_2-2/files/darksusy__5__1__3_8cpp/","name":"file frontends\/DarkSUSY_5_1_3.cpp","description":"[No description available]","isPartOf":{"@id":"https://gambitbsm.github.io/#/schema/website/1"},"about":{"@id":"https://gambitbsm.github.io/#/schema/organization/1"},"datePublished":"0001-01-01T00:00:00CET","dateModified":"0001-01-01T00:00:00CET","breadcrumb":{"@id":"https://gambitbsm.github.io/documentation/code/gambit_2-2/files/darksusy__5__1__3_8cpp/#/schema/breadcrumb/1"},"primaryImageOfPage":{"@id":"https://gambitbsm.github.io/documentation/code/gambit_2-2/files/darksusy__5__1__3_8cpp/#/schema/image/2"},"inLanguage":"en-US","potentialAction":[{"@type":"ReadAction","target":["https://gambitbsm.github.io/documentation/code/gambit_2-2/files/darksusy__5__1__3_8cpp/"]}]},{"@type":"BreadcrumbList","@id":"https://gambitbsm.github.io/documentation/code/gambit_2-2/files/darksusy__5__1__3_8cpp/#/schema/breadcrumb/1","name":"Breadcrumbs","itemListElement":[{"@type":"ListItem","position":1,"item":{"@type":"WebPage","@id":"https://gambitbsm.github.io/","url":"https://gambitbsm.github.io/","name":"Home"}},{"@type":"ListItem","position":2,"item":{"@type":"WebPage","@id":"https://gambitbsm.github.io/documentation/","url":"https://gambitbsm.github.io/documentation/","name":"Documentation"}},{"@type":"ListItem","position":3,"item":{"@type":"WebPage","@id":"https://gambitbsm.github.io/documentation/code/","url":"https://gambitbsm.github.io/documentation/code/","name":"Code"}},{"@type":"ListItem","position":4,"item":{"@type":"WebPage","@id":"https://gambitbsm.github.io/documentation/code/gambit_2-2/","url":"https://gambitbsm.github.io/documentation/code/gambit_2-2/","name":"Gambit 2 2"}},{"@type":"ListItem","position":5,"item":{"@type":"WebPage","@id":"https://gambitbsm.github.io/documentation/code/gambit_2-2/files/","url":"https://gambitbsm.github.io/documentation/code/gambit_2-2/files/","name":"Files"}},{"@type":"ListItem","position":6,"item":{"@id":"https://gambitbsm.github.io/documentation/code/gambit_2-2/files/darksusy__5__1__3_8cpp/"}}]},{"@context":"https://schema.org","@graph":[{"@type":"ImageObject","@id":"https://gambitbsm.github.io/documentation/code/gambit_2-2/files/darksusy__5__1__3_8cpp/#/schema/image/2","url":"https://gambitbsm.github.io/gambit_logo.png","contentUrl":"https://gambitbsm.github.io/gambit_logo.png","caption":"file frontends\/DarkSUSY_5_1_3.cpp"}]}]}</script><meta name="theme-color" content="#fff"/><link rel="icon" href="https://gambitbsm.github.io/favicon.ico" sizes="any"/><link rel="icon" type="image/svg+xml" href="https://gambitbsm.github.io/favicon.svg"/><link rel="apple-touch-icon" sizes="180x180" href="https://gambitbsm.github.io/apple-touch-icon.png"/><link rel="icon" type="image/png" sizes="32x32" href="https://gambitbsm.github.io/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="16x16" href="https://gambitbsm.github.io/favicon-16x16.png"/><link rel="manifest" crossorigin="use-credentials" href="https://gambitbsm.github.io/site.webmanifest"/></head><body class="documentation single light"><div class="sticky-top"><div class="header-bar"></div><header class="navbar navbar-expand-md navbar-light doks-navbar"><nav class="container-xxl flex-wrap flex-md-nowrap" aria-label="Main navigation"><a class="navbar-brand p-0 me-auto" href="https://gambitbsm.github.io/" aria-label="GAMBIT"><img class="logo-light" src="https://gambitbsm.github.io//images/gambit_logo.png" width="50px"/>
<img class="logo-dark d-none" src="https://gambitbsm.github.io//images/gambit_logo.png" width="50px"/>
GAMBIT</a>
<button class="btn btn-menu order-2 d-block d-lg-none" type="button" data-bs-toggle="offcanvas" data-bs-target="#offcanvasDoks" aria-controls="offcanvasDoks" aria-label="Open main menu"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-menu"><line x1="3" y1="12" x2="21" y2="12"></line><line x1="3" y1="6" x2="21" y2="6"></line><line x1="3" y1="18" x2="21" y2="18"></line></svg></button><div class="offcanvas offcanvas-end border-0 py-lg-1" tabindex="-1" id="offcanvasDoks" data-bs-backdrop="true" aria-labelledby="offcanvasDoksLabel"><div class="header-bar d-lg-none"></div><div class="offcanvas-header d-lg-none"><h2 class="h5 offcanvas-title ps-2" id="offcanvasDoksLabel"><a class="text-dark" href="/">GAMBIT</a></h2><button type="button" class="btn-close text-reset me-2" data-bs-dismiss="offcanvas" aria-label="Close main menu"></button></div><div class="offcanvas-body p-4 p-lg-0"><ul class="nav flex-column flex-lg-row align-items-lg-center mt-2 mt-lg-0 ms-lg-2 me-lg-auto"><li class="nav-item dropdown"><a class="nav-link dropdown-toggle ps-0 py-1" href="#" id="navbarDropdownMenuLink" role="button" data-bs-toggle="dropdown" aria-expanded="false">Documentation
<span class="dropdown-caret"><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-chevron-down"><polyline points="6 9 12 15 18 9"></polyline></svg></span></a><ul class="dropdown-menu dropdown-menu-main shadow rounded border-0" aria-labelledby="navbarDropdownMenuLink"><li><a class="dropdown-item" href="/documentation/installation/introduction/">Installation</a></li><li><a class="dropdown-item" href="/documentation/examples/colliderbit_example">Examples</a></li><li><a class="dropdown-item" href="/documentation/help/faqs/">Help</a></li><li><a class="dropdown-item" href="/documentation/code/gambit_2-2/index_classes">Code Reference</a></li></ul></li><li class="nav-item dropdown"><a class="nav-link dropdown-toggle ps-0 py-1" href="#" id="navbarDropdownMenuLink" role="button" data-bs-toggle="dropdown" aria-expanded="false">Community
<span class="dropdown-caret"><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-chevron-down"><polyline points="6 9 12 15 18 9"></polyline></svg></span></a><ul class="dropdown-menu dropdown-menu-main shadow rounded border-0" aria-labelledby="navbarDropdownMenuLink"><li><a class="dropdown-item" href="/community/publications/">Publications</a></li><li><a class="dropdown-item" href="/community/talks/">Talks</a></li><li><a class="dropdown-item" href="/community/members/">Members</a></li><li><a class="dropdown-item active" href="/community/code_of_conduct/" aria-current="true">Code of Conduct</a></li><li><a class="dropdown-item" href="/community/contact/">Contact</a></li></ul></li><li class="nav-item"><a class="nav-link ps-0 py-1" href="/wiki/general/homepage/">Wiki</a></li></ul><hr class="text-black-50 my-4 d-lg-none"/><form class="doks-search position-relative flex-grow-1 ms-lg-auto me-lg-2"><input id="search" class="form-control is-search" type="search" placeholder="Search site..." aria-label="Search site..." autocomplete="off"/><div id="suggestions" class="shadow bg-white rounded d-none"></div></form><hr class="text-black-50 my-4 d-lg-none"/><ul class="nav flex-column flex-lg-row"><li class="nav-item"><a class="nav-link social-link" href="https://github.com/GambitBSM"><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-github"><path d="M9 19c-5 1.5-5-2.5-7-3m14 6v-3.87a3.37 3.37.0 00-.94-2.61c3.14-.35 6.44-1.54 6.44-7A5.44 5.44.0 0020 4.77 5.07 5.07.0 0019.91 1S18.73.65 16 2.48a13.38 13.38.0 00-7 0C6.27.65 5.09 1 5.09 1A5.07 5.07.0 005 4.77 5.44 5.44.0 003.5 8.55c0 5.42 3.3 6.61 6.44 7A3.37 3.37.0 009 18.13V22"></path></svg><small class="ms-2 d-lg-none">GitHub</small></a></li></ul><hr class="text-black-50 my-4 d-lg-none"/><button id="mode" class="btn btn-link" type="button" aria-label="Toggle user interface mode">
<span class="toggle-dark"><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-moon"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"></path></svg></span><span class="toggle-light"><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-sun"><circle cx="12" cy="12" r="5"></circle><line x1="12" y1="1" x2="12" y2="3"></line><line x1="12" y1="21" x2="12" y2="23"></line><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line><line x1="1" y1="12" x2="3" y2="12"></line><line x1="21" y1="12" x2="23" y2="12"></line><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line></svg></span></button></div></div></nav></header></div><div class="wrap container-xxl" role="document"><div class="content"><div class="row flex-xl-nowrap"><div class="col-lg-5 col-xl-4 docs-sidebar"><nav class="docs-links" aria-label="Main navigation"><ul class="list-unstyled collapsible-sidebar"><li class="mb-1"><button class="btn btn-toggle align-items-center rounded collapsed" data-bs-toggle="collapse" data-bs-target="#section-installation" aria-expanded="false">
Installation</button><div class="collapse" id="section-installation"><ul class="btn-toggle-nav list-unstyled fw-normal pb-1 small"><li><a class="docs-link rounded" href="/documentation/installation/introduction/">Getting Started</a></li><li><a class="docs-link rounded" href="/documentation/installation/docker_usage/">Docker Usage</a></li><li><a class="docs-link rounded" href="/documentation/installation/installation_for_linux/">Installation for Linux</a></li><li><a class="docs-link rounded" href="/documentation/installation/installation_for_windows/">Installation for Windows</a></li><li><a class="docs-link rounded" href="/documentation/installation/installation_for_macos/">Installation for macOS</a></li></ul></div></li><li class="mb-1"><button class="btn btn-toggle align-items-center rounded collapsed" data-bs-toggle="collapse" data-bs-target="#section-examples" aria-expanded="false">
Examples</button><div class="collapse" id="section-examples"><ul class="btn-toggle-nav list-unstyled fw-normal pb-1 small"><li><a class="docs-link rounded" href="/documentation/examples/colliderbit_example/">ColliderBit Example</a></li><li><a class="docs-link rounded" href="/documentation/examples/anotherbit/">AnotherBit</a></li><li><a class="docs-link rounded" href="/documentation/examples/anotherbit2/">AnotherBit2</a></li></ul></div></li><li class="mb-1"><button class="btn btn-toggle align-items-center rounded collapsed" data-bs-toggle="collapse" data-bs-target="#section-help" aria-expanded="false">
Help</button><div class="collapse" id="section-help"><ul class="btn-toggle-nav list-unstyled fw-normal pb-1 small"><li><a class="docs-link rounded" href="/documentation/help/faqs/">FAQs</a></li><li><a class="docs-link rounded" href="/documentation/help/compiler_matrix/">Compiler Matrix</a></li><li><a class="docs-link rounded" href="/documentation/help/known_issues/">Known Issues</a></li><li><a class="docs-link rounded" href="/documentation/help/configuration_examples/">Configuration Examples</a></li></ul></div></li><li class="mb-1"><button class="btn btn-toggle align-items-center rounded collapsed" data-bs-toggle="collapse" data-bs-target="#section-code" aria-expanded="true">
Code Reference</button><div class="collapse show" id="section-code"><ul class="btn-toggle-nav list-unstyled fw-normal pb-1 small"><li class="my-1 ms-3"><button class="btn btn-toggle align-items-center rounded collapsed" data-bs-toggle="collapse" data-bs-target="#section-gambit_2-2" aria-expanded="true">
<font style="color: #5d2f86;" size="-6">release</font>   gambit 2-2</button><div class="collapse show" id="section-gambit_2-2"><ul class="btn-toggle-nav list-unstyled fw-normal pb-1 small"><li><a class="docs-link rounded" href="/documentation/code/gambit_2-2/index_classes/">Classes</a></li><li><a class="docs-link rounded" href="/documentation/code/gambit_2-2/index_files/">Files</a></li><li><a class="docs-link rounded" href="/documentation/code/gambit_2-2/index_pages/">Pages</a></li><li><a class="docs-link rounded" href="/documentation/code/gambit_2-2/index_namespaces/">Namespaces</a></li></ul></div></li></ul></div></li></ul></nav></div><nav class="docs-toc d-none d-xl-block col-xl-3" aria-label="Secondary navigation"><div class="d-xl-none"><button class="btn btn-outline-primary btn-sm doks-toc-toggle collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#onThisPage" aria-controls="doks-docs-nav" aria-expanded="false" aria-label="Toggle On this page navigation">
<span>On this page</span>
<span><svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24" class="doks doks-expand" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><title>Expand</title><polyline points="7 13 12 18 17 13"></polyline><polyline points="7 6 12 11 17 6"></polyline></svg><svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24" class="doks doks-collapse" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><title>Collapse</title><polyline points="17 11 12 6 7 11"></polyline><polyline points="17 18 12 13 7 18"></polyline></svg></span></button><div class="collapse" id="onThisPage"><div class="card card-body mt-3 py-1"><div class="page-links"><nav id="TableOfContents"><ul><li><ul><li><a href="#functions">Functions</a></li><li><a href="#attributes">Attributes</a></li><li><a href="#detailed-description">Detailed Description</a></li><li><a href="#functions-documentation">Functions Documentation</a><ul><li><a href="#function-if">function if</a></li><li><a href="#function-if-1">function if</a></li><li><a href="#function-if-2">function if</a></li><li><a href="#function-if-3">function if</a></li><li><a href="#function-if-4">function if</a></li></ul></li><li><a href="#attributes-documentation">Attributes Documentation</a><ul><li><a href="#variable-be_namespace">variable BE_NAMESPACE</a></li><li><a href="#variable-dsparticle_mass">variable DSparticle_mass</a></li><li><a href="#variable-gambitparticle_mass">variable GAMBITparticle_mass</a></li><li><a href="#variable-be_ini_function">variable BE_INI_FUNCTION</a></li><li><a href="#variable-mssm_result">variable mssm_result</a></li></ul></li><li><a href="#source-code">Source code</a></li></ul></li></ul></nav></div></div></div></div><div class="page-links d-none d-xl-block"><h3>On this page</h3><nav id="TableOfContents"><ul><li><ul><li><a href="#functions">Functions</a></li><li><a href="#attributes">Attributes</a></li><li><a href="#detailed-description">Detailed Description</a></li><li><a href="#functions-documentation">Functions Documentation</a><ul><li><a href="#function-if">function if</a></li><li><a href="#function-if-1">function if</a></li><li><a href="#function-if-2">function if</a></li><li><a href="#function-if-3">function if</a></li><li><a href="#function-if-4">function if</a></li></ul></li><li><a href="#attributes-documentation">Attributes Documentation</a><ul><li><a href="#variable-be_namespace">variable BE_NAMESPACE</a></li><li><a href="#variable-dsparticle_mass">variable DSparticle_mass</a></li><li><a href="#variable-gambitparticle_mass">variable GAMBITparticle_mass</a></li><li><a href="#variable-be_ini_function">variable BE_INI_FUNCTION</a></li><li><a href="#variable-mssm_result">variable mssm_result</a></li></ul></li><li><a href="#source-code">Source code</a></li></ul></li></ul></nav></div></nav><main class="docs-content col-lg-11 col-xl-9 mx-xl-auto"><nav aria-label="breadcrumb"><ol class="breadcrumb"><li class="breadcrumb-item"><a href="/">Home</a></li><li class="breadcrumb-item"><a href="/documentation/">Documentation</a></li><li class="breadcrumb-item"><a href="/documentation/code/">Code Reference</a></li><li class="breadcrumb-item"><a href="/documentation/code/gambit_2-2/">gambit_2-2</a></li><li class="breadcrumb-item active" aria-current="page">file frontends/DarkSUSY_5_1_3.cpp</li></ol></nav><h1>file frontends/DarkSUSY_5_1_3.cpp</h1><p class="lead"></p><p>[No description available] <a href="#detailed-description">More…</a></p><h2 id="functions">Functions <a href="#functions" class="anchor" aria-hidden="true">#</a></h2><table><thead><tr><th></th><th>Name</th></tr></thead><tbody><tr><td></td><td><strong><a href="/documentation/code/gambit_2-2/files/darksusy__5__1__3_8cpp/#function-if">if</a></strong>(scan_level )</td></tr><tr><td></td><td><strong><a href="/documentation/code/gambit_2-2/files/darksusy__5__1__3_8cpp/#function-if">if</a></strong>(runOptions-&gt; hasKey&#34;debug_SLHA_filenames&#34;)</td></tr><tr><td>else</td><td><strong><a href="/documentation/code/gambit_2-2/files/darksusy__5__1__3_8cpp/#function-if">if</a></strong>(ModelInUse(“CMSSM”) and runOptions-&gt;getValueOrDef&lt; bool &gt;(false, “use_DS_isasugra”) )<br/>Option use_DS_isasugra<bool>: Use DS internal isasugra for parameter running (false)</bool></td></tr><tr><td>else</td><td><strong><a href="/documentation/code/gambit_2-2/files/darksusy__5__1__3_8cpp/#function-if">if</a></strong>(ModelInUse(“MSSM63atQ”)</td></tr><tr><td></td><td><strong><a href="/documentation/code/gambit_2-2/files/darksusy__5__1__3_8cpp/#function-if">if</a></strong>((ModelInUse(“MSSM63atQ”)</td></tr></tbody></table><h2 id="attributes">Attributes <a href="#attributes" class="anchor" aria-hidden="true">#</a></h2><table><thead><tr><th></th><th>Name</th></tr></thead><tbody><tr><td></td><td><strong><a href="/documentation/code/gambit_2-2/files/darksusy__5__1__3_8cpp/#variable-be-namespace">BE_NAMESPACE</a></strong></td></tr><tr><td>std::vector&lt; double &gt;</td><td><strong><a href="/documentation/code/gambit_2-2/files/darksusy__5__1__3_8cpp/#variable-dsparticle-mass">DSparticle_mass</a></strong></td></tr><tr><td>std::vector&lt; double &gt;</td><td><strong><a href="/documentation/code/gambit_2-2/files/darksusy__5__1__3_8cpp/#variable-gambitparticle-mass">GAMBITparticle_mass</a></strong></td></tr><tr><td><a href="/documentation/code/gambit_2-2/files/common__macros_8hpp/#define-end-be-namespace">END_BE_NAMESPACE</a></td><td><strong><a href="/documentation/code/gambit_2-2/files/darksusy__5__1__3_8cpp/#variable-be-ini-function">BE_INI_FUNCTION</a></strong></td></tr><tr><td>bool</td><td><strong><a href="/documentation/code/gambit_2-2/files/darksusy__5__1__3_8cpp/#variable-mssm-result">mssm_result</a></strong></td></tr></tbody></table><h2 id="detailed-description">Detailed Description <a href="#detailed-description" class="anchor" aria-hidden="true">#</a></h2><p><strong>Author</strong>:</p><ul><li>Anders Kvellestad (<a href="mailto:anders.kvellestad@fys.uio.no">anders.kvellestad@fys.uio.no</a>)</li><li>Pat Scott (<a href="mailto:p.scott@imperial.ac.uk">p.scott@imperial.ac.uk</a>)</li><li>Christoph Weniger (<a href="mailto:c.weniger@uva.nl">c.weniger@uva.nl</a>)</li><li>Torsten Bringmann (<a href="mailto:torsten.bringmann@fys.uio.no">torsten.bringmann@fys.uio.no</a>)</li><li>Lars A. Dal (<a href="mailto:l.a.dal@fys.uio.no">l.a.dal@fys.uio.no</a>)</li><li>Joakim Edsjo (<a href="mailto:edsjo@fysik.su.se">edsjo@fysik.su.se</a>)</li></ul><p><strong>Date</strong>:</p><ul><li>2013 Mar</li><li>2013 Apr 2015 Mar, Aug 2016 Feb</li><li>2013 Jul</li><li>2013 Jul, 2014 Mar, 2015 May, 2019 May</li><li>2014 Mar</li><li>2015 Aug, 2016 Mar</li></ul><p>Frontend for DarkSUSY 5.1.3 backend</p><hr/><p>Authors (add name and date if you modify):</p><hr/><h2 id="functions-documentation">Functions Documentation <a href="#functions-documentation" class="anchor" aria-hidden="true">#</a></h2><h3 id="function-if">function if <a href="#function-if" class="anchor" aria-hidden="true">#</a></h3><pre><code>if(
    scan_level 
)
</code></pre><h3 id="function-if-1">function if <a href="#function-if-1" class="anchor" aria-hidden="true">#</a></h3><pre><code>if(
    runOptions-&gt; hasKey&#34;debug_SLHA_filenames&#34;
)
</code></pre><p>Option debug_SLHA_filenames&lt;std::vector<a href="std::string">std::string</a>&gt;: Optional override list of SLHA filenames used for backend initialization default</p><h3 id="function-if-2">function if <a href="#function-if-2" class="anchor" aria-hidden="true">#</a></h3><pre><code>else if(
    ModelInUse(&#34;CMSSM&#34;) and runOptions-&gt;getValueOrDef&lt; bool &gt;(false, &#34;use_DS_isasugra&#34;) 
)
</code></pre><p>Option use_DS_isasugra<bool>: Use DS internal isasugra for parameter running (false)</bool></p><h3 id="function-if-3">function if <a href="#function-if-3" class="anchor" aria-hidden="true">#</a></h3><pre><code>else if(
    ModelInUse(&#34;MSSM63atQ&#34;)||ModelInUse(&#34;CMSSM&#34;) 
)
</code></pre><p>Option use_dsSLHAread<bool>: Use DS internal SLHA reader to initialize backend (false)</bool></p><h3 id="function-if-4">function if <a href="#function-if-4" class="anchor" aria-hidden="true">#</a></h3><pre><code>if(
    (ModelInUse(&#34;MSSM63atQ&#34;)||ModelInUse(&#34;CMSSM&#34;)) &amp;&amp;! mssm_result
)
</code></pre><h2 id="attributes-documentation">Attributes Documentation <a href="#attributes-documentation" class="anchor" aria-hidden="true">#</a></h2><h3 id="variable-be_namespace">variable BE_NAMESPACE <a href="#variable-be_namespace" class="anchor" aria-hidden="true">#</a></h3><pre><code>BE_NAMESPACE {
  const double min_DS_rwidth = 5.e-3;
</code></pre><h3 id="variable-dsparticle_mass">variable DSparticle_mass <a href="#variable-dsparticle_mass" class="anchor" aria-hidden="true">#</a></h3><pre><code>std::vector&lt; double &gt; DSparticle_mass;
</code></pre><h3 id="variable-gambitparticle_mass">variable GAMBITparticle_mass <a href="#variable-gambitparticle_mass" class="anchor" aria-hidden="true">#</a></h3><pre><code>std::vector&lt; double &gt; GAMBITparticle_mass;
</code></pre><h3 id="variable-be_ini_function">variable BE_INI_FUNCTION <a href="#variable-be_ini_function" class="anchor" aria-hidden="true">#</a></h3><pre><code>END_BE_NAMESPACE BE_INI_FUNCTION {
  
  bool static scan_level = true;
</code></pre><h3 id="variable-mssm_result">variable mssm_result <a href="#variable-mssm_result" class="anchor" aria-hidden="true">#</a></h3><pre><code>bool mssm_result = false;
</code></pre><h2 id="source-code">Source code <a href="#source-code" class="anchor" aria-hidden="true">#</a></h2><pre><code>//   GAMBIT: Global and Modular BSM Inference Tool
//   *********************************************
///  \file
///
///  Frontend for DarkSUSY 5.1.3 backend
///
///  *********************************************
///
///  Authors (add name and date if you modify):
///
///  \author Anders Kvellestad
///          (anders.kvellestad@fys.uio.no)
///  \date 2013 Mar
///
///  \author Pat Scott
///          (p.scott@imperial.ac.uk)
///  \date 2013 Apr
///        2015 Mar, Aug
///        2016 Feb
///
///  \author Christoph Weniger
///          (c.weniger@uva.nl)
///  \date 2013 Jul
///
///  \author Torsten Bringmann
///          (torsten.bringmann@fys.uio.no)
///  \date 2013 Jul, 2014 Mar, 2015 May, 2019 May
///
///  \author Lars A. Dal
///          (l.a.dal@fys.uio.no)
///  \date 2014 Mar
///
///  \author Joakim Edsjo
///          (edsjo@fysik.su.se)
///  \date 2015 Aug, 2016 Mar
///
///  *********************************************

#include &#34;gambit/Backends/frontend_macros.hpp&#34;
#include &#34;gambit/Backends/frontends/DarkSUSY_5_1_3.hpp&#34;
#include &#34;gambit/Utils/file_lock.hpp&#34;
#include &#34;gambit/Utils/mpiwrapper.hpp&#34;

//#define DARKSUSY_DEBUG

// Some ad-hoc DarkSUSY global state.
BE_NAMESPACE
{
  const double min_DS_rwidth = 5.e-3; // 0.5%  to avoid numerical problems
  std::vector&lt;double&gt; DSparticle_mass;
  std::vector&lt;double&gt; GAMBITparticle_mass;
}
END_BE_NAMESPACE

// Initialisation function (definition)
BE_INI_FUNCTION
{
  // Initialize DarkSUSY (only) if run for the first time
  bool static scan_level = true;

  if (scan_level)
  {

    // Do the call to dsinit one-by-one for each MPI process, as DarkSUSY loads up
    // HiggsBounds, which writes files at init then reads them back in later.
    Utils::ProcessLock mylock(&#34;DarkSUSY_&#34; STRINGIFY(SAFE_VERSION) &#34;_init&#34;);
    mylock.get_lock();
    dsinit();
    mylock.release_lock();

    dsrdinit();

    // Initialize yield tables for use in cascade decays (initialize more if needed)
    dshainit(151); // Initialize positron tables
    dshainit(152); // Initialize gamma ray tables
    dshainit(154); // Initialize antiproton tables
    // Note, for DarkSUSY 5, anti-deuteron does not need special initialization
    // as they are calculated from antiproton fluxes

    // Call dshayield for first call initialization of variables
    double tmp1 = 100.0;
    double tmp2 = 10.0;
    int tmp3 = 15;
    int tmp4 = 152;
    int tmp5 = 0;
    dshayield(tmp1,tmp2,tmp3,tmp4,tmp5);

    scan_level = false;

  }

  // Initialization function for a given MSSM point
  // (previous capability DarkSUSY_PointInit)
  bool mssm_result = false;

  // If the user provides a file list, just read in SLHA files for debugging
  // and ignore the MSSM_spectrum dependency.
  if (runOptions-&gt;hasKey(&#34;debug_SLHA_filenames&#34;))
  {
    static unsigned int counter = 0;
    logger() &lt;&lt; LogTags::debug &lt;&lt;
      &#34;Initializing DarkSUSY via debug_SLHA_filenames option.&#34; &lt;&lt; EOM;

    /// Option debug_SLHA_filenames&lt;std::vector&lt;std::string&gt;&gt;: Optional override list of SLHA filenames used for backend initialization default
    std::vector&lt;str&gt; filenames = runOptions-&gt;getValue&lt;std::vector&lt;str&gt; &gt;(&#34;debug_SLHA_filenames&#34;);
    const char * filename = filenames[counter].c_str();
    int len = filenames[counter].length();
    int flag = 15;
    dsSLHAread(byVal(filename),flag,byVal(len));
    dsprep();

    counter++;
    if (counter &gt;= filenames.size()) counter = 0;
    mssm_result = true;
  }

  // CMSSM with DS-internal ISASUGRA (should be avoided, only for debugging)
  /// Option use_DS_isasugra&lt;bool&gt;: Use DS internal isasugra for parameter running (false)
  else if (ModelInUse(&#34;CMSSM&#34;) and runOptions-&gt;getValueOrDef&lt;bool&gt;(false, &#34;use_DS_isasugra&#34;))
  {
    // Setup mSUGRA model from CMSSM parameters
    double am0    = *Param[&#34;M0&#34;];     // m0
    double amhf   = *Param[&#34;M12&#34;];    // m_1/2
    double aa0    = *Param[&#34;A0&#34;];     // A0
    double asgnmu = *Param[&#34;SignMu&#34;];  // sign(mu)
    double atanbe = *Param[&#34;TanBeta&#34;];   // tan(beta)
    logger() &lt;&lt; &#34;Initializing DarkSUSY via dsgive_model_isasugra:&#34; &lt;&lt; EOM;
    logger() &lt;&lt; &#34;  m0        =&#34; &lt;&lt; am0    &lt;&lt; std::endl;
    logger() &lt;&lt; &#34;  m_1/2     =&#34; &lt;&lt; amhf   &lt;&lt; std::endl;
    logger() &lt;&lt; &#34;  A0        =&#34; &lt;&lt; aa0    &lt;&lt; std::endl;
    logger() &lt;&lt; &#34;  sign(mu)  =&#34; &lt;&lt; asgnmu &lt;&lt; std::endl;
    logger() &lt;&lt; &#34;  tan(beta) =&#34; &lt;&lt; atanbe &lt;&lt; EOM;
    dsgive_model_isasugra(am0, amhf, aa0, asgnmu, atanbe);
    int unphys, hwarning;
    dssusy_isasugra(unphys, hwarning);

    if (unphys &lt; 0)
    {
      backend_warning().raise(LOCAL_INFO, &#34;Model point is theoretically inconsistent (DarkSUSY).&#34;);
      invalid_point().raise(&#34;Model point is theoretically inconsistent (DarkSUSY).&#34;);
      mssm_result = false;
    }
    else if (unphys &gt; 0)
    {
      backend_warning().raise(LOCAL_INFO, &#34;Neutralino is not the LSP (DarkSUSY).&#34;);
      invalid_point().raise(&#34;Neutralino is not the LSP (DarkSUSY).&#34;);
      mssm_result = false;
    }
    else if (hwarning != 0)
    {
      backend_warning().raise(LOCAL_INFO,
          &#34;Radiative corrections in Higgs sector &#34;
          &#34;outside range of validity (DarkSUSY).&#34;);
      mssm_result = true;
    }
    else
    {
      mssm_result = true;
    }
  }

  else if (ModelInUse(&#34;MSSM63atQ&#34;) || ModelInUse(&#34;CMSSM&#34;))
  {
    SLHAstruct mySLHA;
    /// Option use_dsSLHAread&lt;bool&gt;: Use DS internal SLHA reader to initialize backend (false)
    bool use_dsSLHAread = runOptions-&gt;getValueOrDef&lt;bool&gt;(false, &#34;use_dsSLHAread&#34;);
    int slha_version = 2;
    const Spectrum&amp; mySpec = *Dep::MSSM_spectrum;
    try
    {
      mySLHA = mySpec.getSLHAea(2);
    }
    catch(Gambit::exception&amp; e)
    {
        slha_version = 1;
        mySLHA = mySpec.getSLHAea(1);
        use_dsSLHAread = true;
    }

    // Use an actual SLHA file.  DarkSUSY is on its own wrt (s)particle widths this way.
    if (use_dsSLHAread || slha_version == 1)
    {
      if (!use_dsSLHAread) {backend_error().raise(LOCAL_INFO,
              &#34;An SLHA1 spectrum requires use of the DarkSUSY SLHA reader rather than the diskless\n&#34;
              &#34;GAMBIT DarkSUSY initialization. To enable the DarkSUSY SLHA reader, set the option\n&#34;
              &#34;use_dsSLHAread for the function DarkSUSY_PointInit_MSSM to true.&#34;);}

      int rank = 0;
      #ifdef WITH_MPI
        if(GMPI::Is_initialized())
        {
          GMPI::Comm comm;
          rank = comm.Get_rank();
        }
      #endif

      // Add model select block to inform DS about 6x6 mixing
      if (slha_version == 2)
      {
          SLHAea::Block modsel_block(&#34;MODSEL&#34;);
          modsel_block.push_back(&#34;BLOCK MODSEL&#34;);
          modsel_block.push_back(&#34;6 3 # FV&#34;);
          mySLHA.push_back(modsel_block);
      }

      // Set filename
      std::string fstr = &#34;DarkBit_temp_&#34;;
      fstr += std::to_string(rank) + &#34;.slha&#34;;
      // Dump SLHA onto disk
      std::ofstream ofs(fstr);
      ofs &lt;&lt; mySLHA;
      ofs.close();
      // Initialize SUSY spectrum from SLHA
      int len = fstr.size();
      int flag = 15;
      const char * filename = fstr.c_str();
      logger() &lt;&lt; LogTags::debug &lt;&lt; &#34;Initializing DarkSUSY via SLHA.&#34; &lt;&lt; EOM;
      dsSLHAread(byVal(filename),flag,byVal(len));
      //The following used to be a separate capability dsprep up to DS5
      //(as also specified in the manual)
      dsprep();
      mssm_result = true;
    }

    // Do pure diskless SLHA initialisation, including (s)particle widths from GAMBIT.
    else
    {
      if (init_diskless(mySLHA, *Dep::decay_rates) == 0 )
      {
        logger() &lt;&lt; LogTags::debug &lt;&lt; &#34;Using diskless SLHA interface to DarkSUSY.&#34; &lt;&lt; EOM;
        dsprep();
        mssm_result = true;
      }
    }
  }

  if ( (ModelInUse(&#34;MSSM63atQ&#34;) || ModelInUse(&#34;CMSSM&#34;)) &amp;&amp; !mssm_result )
  {
    backend_warning().raise(LOCAL_INFO,
        &#34;DarkSUSY point initialization failed.&#34;);
    invalid_point().raise(&#34;DarkSUSY point initialization failed.&#34;);
  }

}
END_BE_INI_FUNCTION


// Convenience functions (definitions)
BE_NAMESPACE
{

  /// Shortcut for dealing with SLHA blocks
  void required_block(const std::string&amp; name, const SLHAea::Coll&amp; slha)
  {
    if (slha.find(name) != slha.end()) return;
    else backend_error().raise(LOCAL_INFO, &#34;Sorry, DarkSUSY needs SLHA block: &#34; + name + &#34;.\n&#34;
    &#34;If you tried to read in a debug SLHA file with missing entries,                       \n&#34;
    &#34;then sort out your SLHA file so that it is readable by DarkSUSY!                      &#34;);
  }

  /// Sets DarkSUSY&#39;s internal common blocks with some of the properties required to compute neutrino
  /// yields for a generic WIMP. Remaining internal variables are internal to this frontend.
  void dsgenericwimp_nusetup(const double (&amp;annihilation_bf)[29], const double (&amp;Higgs_decay_BFs_neutral)[29][3],
   const double (&amp;Higgs_decay_BFs_charged)[15], const double (&amp;Higgs_masses_neutral)[3], const double &amp;Higgs_mass_charged,
   const double &amp;mwimp)
  {
    // Transfer WIMP mass common block.
    wabranch-&gt;wamwimp = mwimp;

    // Transfer branching fractions to WIMP annihilation common blocks.
    // For channel indices, see dswayieldone.f
    for (int i=1; i&lt;=29; i++)
    {
      wabranch-&gt;wabr(i) = annihilation_bf[i-1];
    }

    // Transfer Higgs decay branching fractions (not widths) to Higgs decay common blocks.
    // The total width is not relevant, as all Higgs decay in flight eventually, so
    // only the BFs are needed to calculate the yields into neutrinos from decays in flight.
    for (int i=1; i&lt;=3; i++)    // Loop over the neutral Higgses
    {
      for (int j=1; j&lt;=29; j++) // Loop over the known decay channels
      {
        wabranch-&gt;was0br(j,i) = Higgs_decay_BFs_neutral[j-1][i-1];
      }
    }

    for (int i=1; i&lt;=15; i++)   // Loop over the known charged Higgs decay channels
    {
      wabranch-&gt;wascbr(i) = Higgs_decay_BFs_charged[i-1];
    }

    // Transfer Higgs masses to common blocks.
    for (int i=1; i&lt;=3; i++)    // Loop over the neutral Higgses
    {
      wabranch-&gt;was0m(i) = Higgs_masses_neutral[i-1];                   // Neutral Higgses
    }
    wabranch-&gt;wascm = Higgs_mass_charged;                               // Charged Higgses

    // Tell DarkSUSY we&#39;ve taken care of business.
    wabranch-&gt;dswasetupcalled = true;

  }

  /// Returns neutrino yields at the top of the atmosphere,
  /// in m^-2 GeV^-1 annihilation^-1.  Provided here for
  /// interfacing with nulike.
  ///   --&gt; log10Enu log_10(neutrino energy/GeV)
  ///   --&gt; p        p=1 for neutrino yield, p=2 for nubar yield
  ///   --&gt; context  void pointer (ignored)
  double neutrino_yield(const double&amp; log10E, const int&amp; ptype, void*&amp;)
  {
    int istat = 0;
    const char object[3] = &#34;su&#34;;
    double result = 1e-30 * dsntmuonyield(pow(10.0,log10E),10.0,object[0],3,1,ptype,istat);
    if ((istat bitand 1) == 1)
    {
      if (not piped_warnings.inquire()) // Don&#39;t bother re-raising a warning if it&#39;s already been done since the last .check().
        piped_warnings.request(LOCAL_INFO, &#34;Neutrino yield from Sun is lower bound; likelihood will be conservative.&#34;);
    }
    if ((istat bitand 4) == 4)
    {
      if (not piped_warnings.inquire()) // Don&#39;t bother re-raising a warning if it&#39;s already been done since the last .check().
        piped_warnings.request(LOCAL_INFO, &#34;DarkSUSY&#39;s dswayield_int didn&#39;t converge. This occasionally happens &#34;
                                           &#34;due to finite statistics in the nu yield tables from Pythia. &#34;
                                           &#34;This is benign (the missing integrals are always negligible).&#34;);
    }
    if (istat &gt; 4)
    {
      std::ostringstream err;
      err &lt;&lt; &#34;Error from DarkSUSY::dswayield functions in neutrino flux calculation.  istat = &#34; &lt;&lt; istat;
      piped_errors.request(LOCAL_INFO, err.str());
    }
    return result;
  }

  /// Translates GAMBIT string identifiers to the SUSY
  /// particle codes used internally in DS (as stored in common block /pacodes/)
  // FIXME: add channel codes!
  int DSparticle_code(const str&amp; particleID)
  {
    int kpart;
    if (particleID==&#34;nu_e&#34; or particleID==&#34;nubar_e&#34;){
     kpart=1;
    }else if (particleID==&#34;e-_1&#34; or particleID==&#34;e+_1&#34;){
     kpart=2;
    }else if (particleID==&#34;nu_mu&#34; or particleID==&#34;nubar_mu&#34;){
     kpart=3;
    }else if (particleID==&#34;e-_2&#34; or particleID==&#34;e+_2&#34;){
     kpart=4;
    }else if (particleID==&#34;nu_tau&#34; or particleID==&#34;nubar_tau&#34;){
     kpart=5;
    }else if (particleID==&#34;e-_3&#34; or particleID==&#34;e+_3&#34;){
     kpart=6;
    }else if (particleID==&#34;u_1&#34; or particleID==&#34;ubar_1&#34;){
     kpart=7;
    }else if (particleID==&#34;d_1&#34; or particleID==&#34;dbar_1&#34;){
     kpart=8;
    }else if (particleID==&#34;u_2&#34; or particleID==&#34;ubar_2&#34;){
     kpart=9;
    }else if (particleID==&#34;d_2&#34; or particleID==&#34;dbar_2&#34;){
     kpart=10;
    }else if (particleID==&#34;u_3&#34; or particleID==&#34;ubar_3&#34;){
     kpart=11;
    }else if (particleID==&#34;d_3&#34; or particleID==&#34;dbar_3&#34;){
     kpart=12;
    }else if (particleID==&#34;gamma&#34;){
     kpart=13;
    }else if (particleID==&#34;W+&#34; or particleID==&#34;W-&#34;){
     kpart=14;
    }else if (particleID==&#34;Z0&#34;){
     kpart=15;
    }else if (particleID==&#34;g&#34;){
     kpart=16;
    }else if (particleID==&#34;h0_1&#34;){
     kpart=18;
    }else if (particleID==&#34;h0_2&#34;){
     kpart=17;
    }else if (particleID==&#34;A0&#34;){
     kpart=19;
    }else if (particleID==&#34;H+&#34; or particleID==&#34;H-&#34;){
     kpart=20;
    }else if (particleID==&#34;~nu_1&#34; or particleID==&#34;~nubar_1&#34;){
     kpart=21;
    }else if (particleID==&#34;~e-_1&#34; or particleID==&#34;~e+_1&#34;){
     kpart=22;
    }else if (particleID==&#34;~e-_4&#34; or particleID==&#34;~e+_4&#34;){
     kpart=23;
    }else if (particleID==&#34;~nu_2&#34; or particleID==&#34;~nubar_2&#34;){
     kpart=24;
    }else if (particleID==&#34;~e-_2&#34; or particleID==&#34;~e+_2&#34;){
     kpart=25;
    }else if (particleID==&#34;~e-_5&#34; or particleID==&#34;~e+_5&#34;){
     kpart=26;
    }else if (particleID==&#34;~nu_3&#34; or particleID==&#34;~nubar_3&#34;){
     kpart=27;
    }else if (particleID==&#34;~e-_3&#34; or particleID==&#34;~e+_3&#34;){
     kpart=28;
    }else if (particleID==&#34;~e-_6&#34; or particleID==&#34;~e+_6&#34;){
     kpart=29;
    }else if (particleID==&#34;~u_1&#34; or particleID==&#34;~ubar_1&#34;){
     kpart=30;
    }else if (particleID==&#34;~u_4&#34; or particleID==&#34;~ubar_4&#34;){
     kpart=31;
    }else if (particleID==&#34;~d_1&#34; or particleID==&#34;~dbar_1&#34;){
     kpart=32;
    }else if (particleID==&#34;~d_4&#34; or particleID==&#34;~dbar_4&#34;){
     kpart=33;
    }else if (particleID==&#34;~u_2&#34; or particleID==&#34;~ubar_2&#34;){
     kpart=34;
    }else if (particleID==&#34;~u_5&#34; or particleID==&#34;~ubar_5&#34;){
     kpart=35;
    }else if (particleID==&#34;~d_2&#34; or particleID==&#34;~dbar_2&#34;){
     kpart=36;
    }else if (particleID==&#34;~d_5&#34; or particleID==&#34;~dbar_5&#34;){
     kpart=37;
    }else if (particleID==&#34;~u_3&#34; or particleID==&#34;~ubar_3&#34;){
     kpart=38;
    }else if (particleID==&#34;~u_6&#34; or particleID==&#34;~ubar_6&#34;){
     kpart=39;
    }else if (particleID==&#34;~d_3&#34; or particleID==&#34;~dbar_3&#34;){
     kpart=40;
    }else if (particleID==&#34;~d_6&#34; or particleID==&#34;~dbar_6&#34;){
     kpart=41;
    }else if (particleID==&#34;~chi0_1&#34;){
     kpart=42;
    }else if (particleID==&#34;~chi0_2&#34;){
     kpart=43;
    }else if (particleID==&#34;~chi0_3&#34;){
     kpart=44;
    }else if (particleID==&#34;~chi0_4&#34;){
     kpart=45;
    }else if (particleID==&#34;~chi+_1&#34; or particleID==&#34;~chi-_1&#34;){
     kpart=46;
    }else if (particleID==&#34;~chi+_2&#34; or particleID==&#34;~chi-_2&#34;){
     kpart=47;
    }else if (particleID==&#34;~g&#34;){
     kpart=48;
    } else{
     std::ostringstream err;
     err &lt;&lt; &#34;ERROR: translation into DS particle code not implemented &#34;
         &lt;&lt; &#34;for string identifier &#34; &lt;&lt; particleID;
     backend_error().raise(LOCAL_INFO, err.str());
     kpart=-100;
    }
    return kpart;
  }

  /// Initialise an MSSM model in DarkSUSY from an SLHAea object and a DecayTable.
  /// Closely mimics the DarkSUSY routine in dsfromslha.F, except that it
  /// hands over a better b pole mass, explicit decay info, and a better
  /// approximation of the CKM matrix from Wolfenstein parameters.  Throughout
  /// this routine, there are pieces of code commented out that would need to be
  /// re-added to emulate dsfromslha.F exactly, if and only if the decays are not
  /// set by GAMBIT.
  int init_diskless(const SLHAstruct &amp;mySLHA, const DecayTable &amp;myDecays)
  {
    using SLHAea::to;
    DS5_PACODES *DSpart = &amp;(*pacodes);

    // Define required blocks and raise an error if a block is missing
    required_block(&#34;SMINPUTS&#34;, mySLHA);
    required_block(&#34;VCKMIN&#34;,   mySLHA);
    required_block(&#34;MSOFT&#34;,    mySLHA);
    required_block(&#34;MASS&#34;,     mySLHA);
    required_block(&#34;NMIX&#34;,     mySLHA);
    required_block(&#34;VMIX&#34;,     mySLHA);
    required_block(&#34;UMIX&#34;,     mySLHA);
    required_block(&#34;ALPHA&#34;,    mySLHA);
    required_block(&#34;HMIX&#34;,     mySLHA);
    required_block(&#34;YU&#34;,       mySLHA);
    required_block(&#34;YD&#34;,       mySLHA);
    required_block(&#34;YE&#34;,       mySLHA);
    required_block(&#34;MSL2&#34;,     mySLHA);
    required_block(&#34;MSE2&#34;,     mySLHA);
    required_block(&#34;MSQ2&#34;,     mySLHA);
    required_block(&#34;MSD2&#34;,     mySLHA);
    required_block(&#34;MSU2&#34;,     mySLHA);
    required_block(&#34;TD&#34;,       mySLHA);
    required_block(&#34;TU&#34;,       mySLHA);
    required_block(&#34;TE&#34;,       mySLHA);
    required_block(&#34;USQMIX&#34;,   mySLHA);
    required_block(&#34;DSQMIX&#34;,   mySLHA);
    required_block(&#34;SELMIX&#34;,   mySLHA);
    required_block(&#34;SNUMIX&#34;,   mySLHA);

    // Make sure the b pole mass is present in the MASS block
    if (mySLHA.at(&#34;MASS&#34;).find(initVector&lt;str&gt;(&#34;5&#34;)) == mySLHA.at(&#34;MASS&#34;).end())
      backend_error().raise(LOCAL_INFO, &#34;DarkSUSY init_diskless needs b pole mass entry (5) in SLHA(ea) MASS block.&#34;);

    // Do some initial DarkSUSY housekeeping.
    dsmssmzero();            // zero all the MSSM parameters and variables
    mssmtype-&gt;modeltype = 0; // tell DarkSUSY that we are working in the general MSSM
    // To match the DarkSUSY SLHAreader, you would need to also set
    // mssmswitch-&gt;higwid = 1;  // tell DarkSUSY not to use FeynHiggs for Higgs widths.

    // Block SMINPUTS
    couplingconstants-&gt;alphem           = 1./to&lt;double&gt;(mySLHA.at(&#34;SMINPUTS&#34;).at(1).at(1)); // 1/alpha_{QED}
    smruseful-&gt;alph3mz                  = to&lt;double&gt;(mySLHA.at(&#34;SMINPUTS&#34;).at(3).at(1));    // alpha_s @ MZ
    smruseful-&gt;gfermi                   = to&lt;double&gt;(mySLHA.at(&#34;SMINPUTS&#34;).at(2).at(1));    // Fermi constant
    mspctm-&gt;mass(DSparticle_code(&#34;Z0&#34;)) = to&lt;double&gt;(mySLHA.at(&#34;SMINPUTS&#34;).at(4).at(1));    // Z boson mass

    // Here we set the masses to be used in DarkSUSY.  Note that all masses in the mspctm-&gt;mass block
    // must match those in the ProcessCatalog in DarkBit, as these are used to define the kinematic
    // edges used in relic density integrations and similar within DarkSUSY.  Mostly these should be
    // pole masses, except in cases where that is not possible (i.e. light quarks).

    // Lepton masses
    mspctm-&gt;mass(DSpart-&gt;kl(1))  = to&lt;double&gt;(mySLHA.at(&#34;SMINPUTS&#34;).at(11).at(1));  // electron pole mass
    mspctm-&gt;mass(DSpart-&gt;kl(2))  = to&lt;double&gt;(mySLHA.at(&#34;SMINPUTS&#34;).at(13).at(1));  // muon pole mass
    mspctm-&gt;mass(DSpart-&gt;kl(3))  = to&lt;double&gt;(mySLHA.at(&#34;SMINPUTS&#34;).at(7).at(1));   // tau pole mass
    mspctm-&gt;mass(DSpart-&gt;knu(1)) = to&lt;double&gt;(mySLHA.at(&#34;SMINPUTS&#34;).at(12).at(1));  // nu_1 pole mass
    mspctm-&gt;mass(DSpart-&gt;knu(2)) = to&lt;double&gt;(mySLHA.at(&#34;SMINPUTS&#34;).at(14).at(1));  // nu_2 pole mass
    mspctm-&gt;mass(DSpart-&gt;knu(3)) = to&lt;double&gt;(mySLHA.at(&#34;SMINPUTS&#34;).at(8).at(1));   // nu_3 pole mass

    // Quark masses as defined in SLHA2
    mspctm-&gt;mu2gev               = to&lt;double&gt;(mySLHA.at(&#34;SMINPUTS&#34;).at(22).at(1)); // up quark mass @ 2 GeV
    mspctm-&gt;md2gev               = to&lt;double&gt;(mySLHA.at(&#34;SMINPUTS&#34;).at(21).at(1)); // down quark mass @ 2 GeV
    mspctm-&gt;ms2gev               = to&lt;double&gt;(mySLHA.at(&#34;SMINPUTS&#34;).at(23).at(1)); // strange mass @ 2 GeV
    mspctm-&gt;mcmc                 = to&lt;double&gt;(mySLHA.at(&#34;SMINPUTS&#34;).at(24).at(1)); // charm mass at m_c
    mspctm-&gt;mbmb                 = to&lt;double&gt;(mySLHA.at(&#34;SMINPUTS&#34;).at(5).at(1));  // bottom mass at m_b
    mspctm-&gt;mass(DSpart-&gt;kqu(3)) = to&lt;double&gt;(mySLHA.at(&#34;SMINPUTS&#34;).at(6).at(1));  // top pole mass

    // Do the DarkSUSY-style sin^2 theta_W calculation (will be overwritten later).
    smruseful-&gt;s2thw=dsgf2s2thw(smruseful-&gt;gfermi, couplingconstants-&gt;alphem, mspctm-&gt;mass(DSparticle_code(&#34;Z0&#34;)), mspctm-&gt;mass(DSpart-&gt;kqu(3)),1);

    // Set other internal quark masses for DarkSUSY
    dsfindmtmt();                                                                  // top mass at mt
    mspctm-&gt;mass(DSpart-&gt;kqu(1)) = mspctm-&gt;mu2gev;                                 // use 2GeV u mass as proxy for pole
    mspctm-&gt;mass(DSpart-&gt;kqd(1)) = mspctm-&gt;md2gev;                                 // use 2GeV d mass as proxy for pole
    mspctm-&gt;mass(DSpart-&gt;kqd(2)) = mspctm-&gt;ms2gev;                                 // use 2GeV s mass as proxy for pole
    mspctm-&gt;mass(DSpart-&gt;kqu(2)) = dsmqpole4loop(DSpart-&gt;kqu(2),mspctm-&gt;mcmc);     // use DarkSUSY internal routine to get mc pole
    mspctm-&gt;mass(DSpart-&gt;kqd(3)) = to&lt;double&gt;(mySLHA.at(&#34;MASS&#34;).at(5).at(1));      // the GAMBIT way to get the bottom pole mass
    //mspctm-&gt;mass(DSpart-&gt;kqd(3)) = dsmqpole4loop(DSpart-&gt;kqd(3),mspctm-&gt;mbmb);   // the DarkSUSY SLHAreader way to get mb pole

    // Block MINPAR we skip, it is not needed

    // Block MSOFT
    mssmpar-&gt;m1 = to&lt;double&gt;(mySLHA.at(&#34;MSOFT&#34;).at(1).at(1));
    mssmpar-&gt;m2 = to&lt;double&gt;(mySLHA.at(&#34;MSOFT&#34;).at(2).at(1));
    mssmpar-&gt;m3 = to&lt;double&gt;(mySLHA.at(&#34;MSOFT&#34;).at(3).at(1));
    mssmpar-&gt;mass2l(1) = pow(to&lt;double&gt;(mySLHA.at(&#34;MSOFT&#34;).at(31).at(1)),2);
    mssmpar-&gt;mass2l(2) = pow(to&lt;double&gt;(mySLHA.at(&#34;MSOFT&#34;).at(32).at(1)),2);
    mssmpar-&gt;mass2l(3) = pow(to&lt;double&gt;(mySLHA.at(&#34;MSOFT&#34;).at(33).at(1)),2);
    mssmpar-&gt;mass2e(1) = pow(to&lt;double&gt;(mySLHA.at(&#34;MSOFT&#34;).at(34).at(1)),2);
    mssmpar-&gt;mass2e(2) = pow(to&lt;double&gt;(mySLHA.at(&#34;MSOFT&#34;).at(35).at(1)),2);
    mssmpar-&gt;mass2e(3) = pow(to&lt;double&gt;(mySLHA.at(&#34;MSOFT&#34;).at(36).at(1)),2);
    mssmpar-&gt;mass2q(1) = pow(to&lt;double&gt;(mySLHA.at(&#34;MSOFT&#34;).at(41).at(1)),2);
    mssmpar-&gt;mass2q(2) = pow(to&lt;double&gt;(mySLHA.at(&#34;MSOFT&#34;).at(42).at(1)),2);
    mssmpar-&gt;mass2q(3) = pow(to&lt;double&gt;(mySLHA.at(&#34;MSOFT&#34;).at(43).at(1)),2);
    mssmpar-&gt;mass2u(1) = pow(to&lt;double&gt;(mySLHA.at(&#34;MSOFT&#34;).at(44).at(1)),2);
    mssmpar-&gt;mass2u(2) = pow(to&lt;double&gt;(mySLHA.at(&#34;MSOFT&#34;).at(45).at(1)),2);
    mssmpar-&gt;mass2u(3) = pow(to&lt;double&gt;(mySLHA.at(&#34;MSOFT&#34;).at(46).at(1)),2);
    mssmpar-&gt;mass2d(1) = pow(to&lt;double&gt;(mySLHA.at(&#34;MSOFT&#34;).at(47).at(1)),2);
    mssmpar-&gt;mass2d(2) = pow(to&lt;double&gt;(mySLHA.at(&#34;MSOFT&#34;).at(48).at(1)),2);
    mssmpar-&gt;mass2d(3) = pow(to&lt;double&gt;(mySLHA.at(&#34;MSOFT&#34;).at(49).at(1)),2);

    // Block HMIX
    mssmpar-&gt;mu = to&lt;double&gt;(mySLHA.at(&#34;HMIX&#34;).at(1).at(1));
    mssmpar-&gt;tanbe = to&lt;double&gt;(mySLHA.at(&#34;HMIX&#34;).at(2).at(1));

    // A boson mass
    mspctm-&gt;mass(DSparticle_code(&#34;A0&#34;)) = to&lt;double&gt;(mySLHA.at(&#34;MASS&#34;).at(36).at(1));
    mssmpar-&gt;ma = mspctm-&gt;mass(DSparticle_code(&#34;A0&#34;));

    // Now set up some defaults (part of it will be overwritten later)
    dssuconst();
    mssmiuseful-&gt;lsp = DSpart-&gt;kn(1);
    mssmiuseful-&gt;kln = 1;
    // To match the DS SLHAreader, you would then need to call
    // int unphys, hwarning;
    // dsspectrum(unphys, hwarning);

    // CKM matrix read from VCKMIN - Wolfenstein parameters.
    double lambda = to&lt;double&gt;(mySLHA.at(&#34;VCKMIN&#34;).at(1).at(1));   // Wolfenstein lambda
    double A = to&lt;double&gt;(mySLHA.at(&#34;VCKMIN&#34;).at(2).at(1));        // Wolfenstein A
    double rhobar = to&lt;double&gt;(mySLHA.at(&#34;VCKMIN&#34;).at(3).at(1));   // Wolfenstein rhobar
    double etabar = to&lt;double&gt;(mySLHA.at(&#34;VCKMIN&#34;).at(4).at(1));   // Wolfenstein etabar
    // Use Wolfenstein converter to get the VCKM matrix.
    mixing-&gt;ckm(1,1) = Spectrum::Wolf2V_ud(lambda,A,rhobar,etabar);
    mixing-&gt;ckm(1,2) = Spectrum::Wolf2V_us(lambda,A,rhobar,etabar);
    mixing-&gt;ckm(1,3) = Spectrum::Wolf2V_ub(lambda,A,rhobar,etabar);
    mixing-&gt;ckm(2,1) = Spectrum::Wolf2V_cd(lambda,A,rhobar,etabar);
    mixing-&gt;ckm(2,2) = Spectrum::Wolf2V_cs(lambda,A,rhobar,etabar);
    mixing-&gt;ckm(2,3) = Spectrum::Wolf2V_cb(lambda,A,rhobar,etabar);
    mixing-&gt;ckm(3,1) = Spectrum::Wolf2V_td(lambda,A,rhobar,etabar);
    mixing-&gt;ckm(3,2) = Spectrum::Wolf2V_ts(lambda,A,rhobar,etabar);
    mixing-&gt;ckm(3,3) = Spectrum::Wolf2V_tb(lambda,A,rhobar,etabar);
    // The lower-order DarkSUSY SLHAreader way of doing it; not as good, but this is what you&#39;d need to use to match DS exactly.
    //sckm-&gt;ckms12 = lambda;
    //sckm-&gt;ckms23 = A*pow(sckm-&gt;ckms12,2);
    //std::complex&lt;double&gt; aux(rhobar, etabar);
    //aux = aux * (sckm-&gt;ckms23/pow(sckm-&gt;ckms12,2)) * pow(sckm-&gt;ckms12,3);
    //sckm-&gt;ckms13 = std::norm(aux);
    //sckm-&gt;ckmdelta = std::arg(aux);
    //dssuconst_ckm();

    // In principle, we might want to change to VCKM instead of VCKMIN, if VCKM is present. Like this:
    // sckm-&gt;ckms12 = to&lt;double&gt;(mySLHA.at(&#34;VCKM&#34;).at(1).at(1));
    // sckm-&gt;ckms23 = to&lt;double&gt;(mySLHA.at(&#34;VCKM&#34;).at(2).at(1))*sckm.ckms12**2;
    // sckm-&gt;ckmdelta = 0;
    // for (int i=1; i&lt;=3; i++) for (int j=1; j&lt;=3; j++)
    // {
    //   mixing-&gt;ckm(i,j) = to&lt;double_complex&gt;(mySLHA.at(&#34;VCKM&#34;).at(i,j).at(2));
    // }

    // OK, we now have to enforce the tree-level condition for unitarity.
    // We then have a choice of calculating both sin^2 theta_W and MW
    // from alpha, MZ and GF as we normally do in DarkSUSY. This line would
    // enforce that:
    //  mspctm-&gt;mass(DSparticle_code(&#34;W+&#34;))=mspctm-&gt;mass(DSparticle_code(&#34;Z0&#34;))*sqrt(1.0-smruseful-&gt;s2thw);
    // However, it is more prudent to take the value of MW from the SLHA file
    // as given (read in earlier), and instead enforce the tree-level condition
    // by redefining sin^2 theta_W. That we do here:
    mspctm-&gt;mass(DSparticle_code(&#34;W+&#34;))  = to&lt;double&gt;(mySLHA.at(&#34;MASS&#34;).at(24).at(1));    // W boson mass
    smruseful-&gt;s2thw=1.0-pow(mspctm-&gt;mass(DSparticle_code(&#34;W+&#34;))/mspctm-&gt;mass(DSparticle_code(&#34;Z0&#34;)),2);

    // Higgs masses. Note h0_1 is the lightest CP-even neutral higgs, and h2_0 the heavier.
    mspctm-&gt;mass(DSparticle_code(&#34;h0_1&#34;)) = to&lt;double&gt;(mySLHA.at(&#34;MASS&#34;).at(25).at(1));
    mspctm-&gt;mass(DSparticle_code(&#34;h0_2&#34;)) = to&lt;double&gt;(mySLHA.at(&#34;MASS&#34;).at(35).at(1));
    mspctm-&gt;mass(DSparticle_code(&#34;H+&#34;))   = to&lt;double&gt;(mySLHA.at(&#34;MASS&#34;).at(37).at(1));
    mspctm-&gt;mass(DSparticle_code(&#34;A0&#34;))   = to&lt;double&gt;(mySLHA.at(&#34;MASS&#34;).at(36).at(1));

    // SUSY particles
    mspctm-&gt;mass(DSpart-&gt;ksnu(1)) =  to&lt;double&gt;(mySLHA.at(&#34;MASS&#34;).at(1000012).at(1));
    mspctm-&gt;mass(DSpart-&gt;ksnu(2)) =  to&lt;double&gt;(mySLHA.at(&#34;MASS&#34;).at(1000014).at(1));
    mspctm-&gt;mass(DSpart-&gt;ksnu(3)) =  to&lt;double&gt;(mySLHA.at(&#34;MASS&#34;).at(1000016).at(1));
    mspctm-&gt;mass(DSpart-&gt;ksl(1))  =  to&lt;double&gt;(mySLHA.at(&#34;MASS&#34;).at(1000011).at(1));
    mspctm-&gt;mass(DSpart-&gt;ksl(2))  =  to&lt;double&gt;(mySLHA.at(&#34;MASS&#34;).at(1000013).at(1));
    mspctm-&gt;mass(DSpart-&gt;ksl(3))  =  to&lt;double&gt;(mySLHA.at(&#34;MASS&#34;).at(1000015).at(1));
    mspctm-&gt;mass(DSpart-&gt;ksl(4))  =  to&lt;double&gt;(mySLHA.at(&#34;MASS&#34;).at(2000011).at(1));
    mspctm-&gt;mass(DSpart-&gt;ksl(5))  =  to&lt;double&gt;(mySLHA.at(&#34;MASS&#34;).at(2000013).at(1));
    mspctm-&gt;mass(DSpart-&gt;ksl(6))  =  to&lt;double&gt;(mySLHA.at(&#34;MASS&#34;).at(2000015).at(1));
    mspctm-&gt;mass(DSpart-&gt;ksqu(1)) =  to&lt;double&gt;(mySLHA.at(&#34;MASS&#34;).at(1000002).at(1));
    mspctm-&gt;mass(DSpart-&gt;ksqu(2)) =  to&lt;double&gt;(mySLHA.at(&#34;MASS&#34;).at(1000004).at(1));
    mspctm-&gt;mass(DSpart-&gt;ksqu(3)) =  to&lt;double&gt;(mySLHA.at(&#34;MASS&#34;).at(1000006).at(1));
    mspctm-&gt;mass(DSpart-&gt;ksqu(4)) =  to&lt;double&gt;(mySLHA.at(&#34;MASS&#34;).at(2000002).at(1));
    mspctm-&gt;mass(DSpart-&gt;ksqu(5)) =  to&lt;double&gt;(mySLHA.at(&#34;MASS&#34;).at(2000004).at(1));
    mspctm-&gt;mass(DSpart-&gt;ksqu(6)) =  to&lt;double&gt;(mySLHA.at(&#34;MASS&#34;).at(2000006).at(1));
    mspctm-&gt;mass(DSpart-&gt;ksqd(1)) =  to&lt;double&gt;(mySLHA.at(&#34;MASS&#34;).at(1000001).at(1));
    mspctm-&gt;mass(DSpart-&gt;ksqd(2)) =  to&lt;double&gt;(mySLHA.at(&#34;MASS&#34;).at(1000003).at(1));
    mspctm-&gt;mass(DSpart-&gt;ksqd(3)) =  to&lt;double&gt;(mySLHA.at(&#34;MASS&#34;).at(1000005).at(1));
    mspctm-&gt;mass(DSpart-&gt;ksqd(4)) =  to&lt;double&gt;(mySLHA.at(&#34;MASS&#34;).at(2000001).at(1));
    mspctm-&gt;mass(DSpart-&gt;ksqd(5)) =  to&lt;double&gt;(mySLHA.at(&#34;MASS&#34;).at(2000003).at(1));
    mspctm-&gt;mass(DSpart-&gt;ksqd(6)) =  to&lt;double&gt;(mySLHA.at(&#34;MASS&#34;).at(2000005).at(1));

    // Neutralinos carry the sign of the eigenvalue, as we need it for NMIX later
    mspctm-&gt;mass(DSpart-&gt;kn(1)) =  to&lt;double&gt;(mySLHA.at(&#34;MASS&#34;).at(1000022).at(1));
    mspctm-&gt;mass(DSpart-&gt;kn(2)) =  to&lt;double&gt;(mySLHA.at(&#34;MASS&#34;).at(1000023).at(1));
    mspctm-&gt;mass(DSpart-&gt;kn(3)) =  to&lt;double&gt;(mySLHA.at(&#34;MASS&#34;).at(1000025).at(1));
    mspctm-&gt;mass(DSpart-&gt;kn(4)) =  to&lt;double&gt;(mySLHA.at(&#34;MASS&#34;).at(1000035).at(1));

    // Charginos
    mspctm-&gt;mass(DSpart-&gt;kcha(1)) =  to&lt;double&gt;(mySLHA.at(&#34;MASS&#34;).at(1000024).at(1));
    mspctm-&gt;mass(DSpart-&gt;kcha(2)) =  to&lt;double&gt;(mySLHA.at(&#34;MASS&#34;).at(1000037).at(1));

    // Gluino
    mspctm-&gt;mass(DSparticle_code(&#34;~g&#34;)) =  to&lt;double&gt;(mySLHA.at(&#34;MASS&#34;).at(1000021).at(1));

    // Gravitino (not implemented in DarkSUSY)
    // mspctm-&gt;mass(DSpart-&gt;k...) =  to&lt;double&gt;(mySLHA.at(&#34;MASS&#34;).at(1000039).at(1));

    // Block NMIX
    for (int i=1; i&lt;=4; i++)
    {
      for (int j=1; j&lt;=4; j++)
      {
        mssmmixing-&gt;neunmx(i,j)=to&lt;double&gt;(mySLHA.at(&#34;NMIX&#34;).at(i,j).at(2));
      }
    }
    // Make NMIX imaginary if mass eigenvalue is negative
    for (int i=1; i&lt;=4; i++)
    {
      for (int j=1; j&lt;=4; j++)
      {
        if (mspctm-&gt;mass(DSpart-&gt;kn(i)) &lt; 0)
        {
          mssmmixing-&gt;neunmx(i,j).im = mssmmixing-&gt;neunmx(i,j).re;
          mssmmixing-&gt;neunmx(i,j).re = 0.0;
        }
      }
      mspctm-&gt;mass(DSpart-&gt;kn(i)) = std::abs(mspctm-&gt;mass(DSpart-&gt;kn(i)));
    }

    // Block UMIX
    for (int i=1; i&lt;=2; i++)
    {
      for (int j=1; j&lt;=2; j++)
      {
        mssmmixing-&gt;chaumx(i,j)=to&lt;double&gt;(mySLHA.at(&#34;UMIX&#34;).at(i,j).at(2));
      }
    }

    // Block VMIX
    for (int i=1; i&lt;=2; i++)
    {
      for (int j=1; j&lt;=2; j++)
      {
        mssmmixing-&gt;chavmx(i,j)=to&lt;double&gt;(mySLHA.at(&#34;VMIX&#34;).at(i,j).at(2));
      }
    }

    // Block ALPHA
    mssmmixing-&gt;alpha = to&lt;double&gt;(mySLHA.at(&#34;ALPHA&#34;).back().at(0));  // Higgs mixing angle

    //If you want to exactly match the DarkSUSY SLHAreader, you should also now run
    //dssuconst_yukawa_running();

    // Block YE, YU, YD - Yukawas
    for (int i=1; i&lt;=3; i++)
    {
      couplingconstants-&gt;yukawa(DSpart-&gt;kl(i))=to&lt;double&gt;(mySLHA.at(&#34;YE&#34;).at(i,i).at(2));
      couplingconstants-&gt;yukawa(DSpart-&gt;kqu(i))=to&lt;double&gt;(mySLHA.at(&#34;YU&#34;).at(i,i).at(2));
      couplingconstants-&gt;yukawa(DSpart-&gt;kqd(i))=to&lt;double&gt;(mySLHA.at(&#34;YD&#34;).at(i,i).at(2));
    }

    // Block MSL2, MSE2, MSQ2, MSU2, MSD2
    for (int i=1; i&lt;=3; i++)
    {
      mssmpar-&gt;mass2l(i) = to&lt;double&gt;(mySLHA.at(&#34;MSL2&#34;).at(i,i).at(2));
      mssmpar-&gt;mass2e(i) = to&lt;double&gt;(mySLHA.at(&#34;MSE2&#34;).at(i,i).at(2));
      mssmpar-&gt;mass2q(i) = to&lt;double&gt;(mySLHA.at(&#34;MSQ2&#34;).at(i,i).at(2));
      mssmpar-&gt;mass2u(i) = to&lt;double&gt;(mySLHA.at(&#34;MSU2&#34;).at(i,i).at(2));
      mssmpar-&gt;mass2d(i) = to&lt;double&gt;(mySLHA.at(&#34;MSD2&#34;).at(i,i).at(2));
    }

    // BLOCK TE, TU and TD. I read these instead of AE, AU, AD.
    for (int i=1; i&lt;=3; i++)
    {
      mssmpar-&gt;asofte(i)=to&lt;double&gt;(mySLHA.at(&#34;TE&#34;).at(i,i).at(2))/couplingconstants-&gt;yukawa(DSpart-&gt;kl(i));
      mssmpar-&gt;asoftu(i)=to&lt;double&gt;(mySLHA.at(&#34;TU&#34;).at(i,i).at(2))/couplingconstants-&gt;yukawa(DSpart-&gt;kqu(i));
      mssmpar-&gt;asoftd(i)=to&lt;double&gt;(mySLHA.at(&#34;TD&#34;).at(i,i).at(2))/couplingconstants-&gt;yukawa(DSpart-&gt;kqd(i));
    }

    // Block SNUMIX
    for (int i=1; i&lt;=3; i++)
    {
      for (int j=1; j&lt;=3; j++)
      {
        mssmmixing-&gt;slulmx(i,j) = to&lt;double&gt;(mySLHA.at(&#34;SNUMIX&#34;).at(i,j).at(2));
      }
    }

    // Block SELMIX
    for (int i=1; i&lt;=6; i++)
    {
      for (int j=1; j&lt;=3; j++)
      {
        mssmmixing-&gt;sldlmx(i,j) = to&lt;double&gt;(mySLHA.at(&#34;SELMIX&#34;).at(i,j).at(2));
        mssmmixing-&gt;sldrmx(i,j) = to&lt;double&gt;(mySLHA.at(&#34;SELMIX&#34;).at(i,j+3).at(2));
      }
    }

    // Block USQMIX
    for (int i=1; i&lt;=6; i++)
    {
      for (int j=1; j&lt;=3; j++)
      {
        mssmmixing-&gt;squlmx(i,j) = to&lt;double&gt;(mySLHA.at(&#34;USQMIX&#34;).at(i,j).at(2));
        mssmmixing-&gt;squrmx(i,j) = to&lt;double&gt;(mySLHA.at(&#34;USQMIX&#34;).at(i,j+3).at(2));
      }
    }

    // Block DSQMIX
    for (int i=1; i&lt;=6; i++)
    {
      for (int j=1; j&lt;=3; j++)
      {
        mssmmixing-&gt;sqdlmx(i,j) = to&lt;double&gt;(mySLHA.at(&#34;DSQMIX&#34;).at(i,j).at(2));
        mssmmixing-&gt;sqdrmx(i,j) = to&lt;double&gt;(mySLHA.at(&#34;DSQMIX&#34;).at(i,j+3).at(2));
      }
    }

    // Do flavour reordering for SLHA2 compatibility
    dsorder_flavour();
    // Set up SUSY vertices
    dsvertx();

    // At this point, if you wanted to match the DarkSUSY SLHAreader, you would also call
    // dshigwid();
    // dsspwid();
    // which just fudge a few widths...but we won&#39;t do that, because we can get real decay widths from DecayBit.

    // Set up Higgs widths.  h1_0 is the lightest CP even Higgs in GAMBIT (opposite to DS).
    widths-&gt;width(DSparticle_code(&#34;h0_1&#34;)) = myDecays.at(std::pair&lt;int,int&gt;(25,0)).width_in_GeV;
    widths-&gt;width(DSparticle_code(&#34;h0_2&#34;)) = myDecays.at(std::pair&lt;int,int&gt;(35,0)).width_in_GeV;
    widths-&gt;width(DSparticle_code(&#34;A0&#34;))   = myDecays.at(std::pair&lt;int,int&gt;(36,0)).width_in_GeV;
    widths-&gt;width(DSparticle_code(&#34;H+&#34;))   = myDecays.at(std::pair&lt;int,int&gt;(37,0)).width_in_GeV;

    // Set up Higgs partial widths.
    const static std::vector&lt; std::vector&lt;str&gt; &gt; charged_channels = DS_charged_h_decay_channels();
    const static std::vector&lt; std::vector&lt;str&gt; &gt; neutral_channels = DS_neutral_h_decay_channels();
    const static std::vector&lt;str&gt; sister_chan = initVector&lt;str&gt;(&#34;W+&#34;, &#34;H-&#34;);
    const static std::vector&lt;str&gt; missing_chan = initVector&lt;str&gt;(&#34;W-&#34;, &#34;H+&#34;);
    const DecayTable::Entry&amp; h01 = myDecays.at(std::pair&lt;int,int&gt;(25,0));
    const DecayTable::Entry&amp; h02 = myDecays.at(std::pair&lt;int,int&gt;(35,0));
    const DecayTable::Entry&amp; A0  = myDecays.at(std::pair&lt;int,int&gt;(36,0));
    const DecayTable::Entry&amp; Hpm = myDecays.at(std::pair&lt;int,int&gt;(37,0));
    for (unsigned int i = 0; i &lt; neutral_channels.size(); i++)
    {
      const std::vector&lt;str&gt;&amp; chan = neutral_channels[i];
      mssmwidths-&gt;hdwidth(i+1,2) = (h01.has_channel(chan) ? widths-&gt;width(DSparticle_code(&#34;h0_1&#34;)) * h01.BF(chan) : 0.0);
      mssmwidths-&gt;hdwidth(i+1,1) = (h02.has_channel(chan) ? widths-&gt;width(DSparticle_code(&#34;h0_2&#34;)) * h02.BF(chan) : 0.0);
      mssmwidths-&gt;hdwidth(i+1,3) = (A0.has_channel(chan)  ? widths-&gt;width(DSparticle_code(&#34;A0&#34;))   * A0.BF(chan)  : 0.0);
      if (neutral_channels[i] == sister_chan)
      {
        // Add the missing W-H+ contributions.
        mssmwidths-&gt;hdwidth(i+1,2) = (h01.has_channel(missing_chan) ? widths-&gt;width(DSparticle_code(&#34;h0_1&#34;)) * h01.BF(missing_chan) : 0.0);
        mssmwidths-&gt;hdwidth(i+1,1) = (h02.has_channel(missing_chan) ? widths-&gt;width(DSparticle_code(&#34;h0_2&#34;)) * h02.BF(missing_chan) : 0.0);
        mssmwidths-&gt;hdwidth(i+1,3) = (A0.has_channel(missing_chan)  ? widths-&gt;width(DSparticle_code(&#34;A0&#34;))   * A0.BF(missing_chan)  : 0.0);
      }
    }
    for (unsigned int i = 0; i &lt; charged_channels.size(); i++)
    {
      mssmwidths-&gt;hdwidth(i+1,4) = (Hpm.has_channel(charged_channels[i]) ? widths-&gt;width(DSparticle_code(&#34;H+&#34;)) * Hpm.BF(charged_channels[i]) : 0.0);
    }

    // Set up SM fermion widths
    widths-&gt;width(DSparticle_code(&#34;u_3&#34;))    = myDecays.at(std::pair&lt;int,int&gt;(6,1)).width_in_GeV;
    widths-&gt;width(DSparticle_code(&#34;e-_2&#34;))  = myDecays.at(std::pair&lt;int,int&gt;(13,1)).width_in_GeV;
    widths-&gt;width(DSparticle_code(&#34;e-_3&#34;)) = myDecays.at(std::pair&lt;int,int&gt;(15,1)).width_in_GeV;

    // Set up SM gauge boson widths
    widths-&gt;width(DSparticle_code(&#34;W+&#34;)) = myDecays.at(std::pair&lt;int,int&gt;(24,0)).width_in_GeV;
    widths-&gt;width(DSparticle_code(&#34;Z0&#34;)) = myDecays.at(std::pair&lt;int,int&gt;(23,0)).width_in_GeV;

    // Set up sfermion widths
    widths-&gt;width(DSpart-&gt;ksnu(1)) = myDecays.at(std::pair&lt;int,int&gt;(1000012,0)).width_in_GeV;
    widths-&gt;width(DSpart-&gt;ksnu(2)) = myDecays.at(std::pair&lt;int,int&gt;(1000014,0)).width_in_GeV;
    widths-&gt;width(DSpart-&gt;ksnu(3)) = myDecays.at(std::pair&lt;int,int&gt;(1000016,0)).width_in_GeV;
    widths-&gt;width(DSpart-&gt;ksl(1))  = myDecays.at(std::pair&lt;int,int&gt;(1000011,0)).width_in_GeV;
    widths-&gt;width(DSpart-&gt;ksl(2))  = myDecays.at(std::pair&lt;int,int&gt;(1000013,0)).width_in_GeV;
    widths-&gt;width(DSpart-&gt;ksl(3))  = myDecays.at(std::pair&lt;int,int&gt;(1000015,0)).width_in_GeV;
    widths-&gt;width(DSpart-&gt;ksl(4))  = myDecays.at(std::pair&lt;int,int&gt;(2000011,0)).width_in_GeV;
    widths-&gt;width(DSpart-&gt;ksl(5))  = myDecays.at(std::pair&lt;int,int&gt;(2000013,0)).width_in_GeV;
    widths-&gt;width(DSpart-&gt;ksl(6))  = myDecays.at(std::pair&lt;int,int&gt;(2000015,0)).width_in_GeV;
    widths-&gt;width(DSpart-&gt;ksqu(1)) = myDecays.at(std::pair&lt;int,int&gt;(1000002,0)).width_in_GeV;
    widths-&gt;width(DSpart-&gt;ksqu(2)) = myDecays.at(std::pair&lt;int,int&gt;(1000004,0)).width_in_GeV;
    widths-&gt;width(DSpart-&gt;ksqu(3)) = myDecays.at(std::pair&lt;int,int&gt;(1000006,0)).width_in_GeV;
    widths-&gt;width(DSpart-&gt;ksqu(4)) = myDecays.at(std::pair&lt;int,int&gt;(2000002,0)).width_in_GeV;
    widths-&gt;width(DSpart-&gt;ksqu(5)) = myDecays.at(std::pair&lt;int,int&gt;(2000004,0)).width_in_GeV;
    widths-&gt;width(DSpart-&gt;ksqu(6)) = myDecays.at(std::pair&lt;int,int&gt;(2000006,0)).width_in_GeV;
    widths-&gt;width(DSpart-&gt;ksqd(1)) = myDecays.at(std::pair&lt;int,int&gt;(1000001,0)).width_in_GeV;
    widths-&gt;width(DSpart-&gt;ksqd(2)) = myDecays.at(std::pair&lt;int,int&gt;(1000003,0)).width_in_GeV;
    widths-&gt;width(DSpart-&gt;ksqd(3)) = myDecays.at(std::pair&lt;int,int&gt;(1000005,0)).width_in_GeV;
    widths-&gt;width(DSpart-&gt;ksqd(4)) = myDecays.at(std::pair&lt;int,int&gt;(2000001,0)).width_in_GeV;
    widths-&gt;width(DSpart-&gt;ksqd(5)) = myDecays.at(std::pair&lt;int,int&gt;(2000003,0)).width_in_GeV;
    widths-&gt;width(DSpart-&gt;ksqd(6)) = myDecays.at(std::pair&lt;int,int&gt;(2000005,0)).width_in_GeV;

    // Set up neutralino widths.  Note that the zero neutralino width is taken care of below.
    widths-&gt;width(DSpart-&gt;kn(1)) = myDecays.at(std::pair&lt;int,int&gt;(1000022,0)).width_in_GeV;
    widths-&gt;width(DSpart-&gt;kn(2)) = myDecays.at(std::pair&lt;int,int&gt;(1000023,0)).width_in_GeV;
    widths-&gt;width(DSpart-&gt;kn(3)) = myDecays.at(std::pair&lt;int,int&gt;(1000025,0)).width_in_GeV;
    widths-&gt;width(DSpart-&gt;kn(4)) = myDecays.at(std::pair&lt;int,int&gt;(1000035,0)).width_in_GeV;

    // Set up chargino widths.
    widths-&gt;width(DSpart-&gt;kcha(1)) = myDecays.at(std::pair&lt;int,int&gt;(1000024,0)).width_in_GeV;
    widths-&gt;width(DSpart-&gt;kcha(2)) = myDecays.at(std::pair&lt;int,int&gt;(1000037,0)).width_in_GeV;

    // Gluino width.
    widths-&gt;width(DSparticle_code(&#34;~g&#34;)) = myDecays.at(std::pair&lt;int,int&gt;(1000021,0)).width_in_GeV;

    // Gravitino width (not implemented in DS).
    //widths-&gt;width(DSparticle_code(&#34;~G&#34;)) = ;

    // Integration routines in DS cannot handle very small sparticle widths.
    // Make sure not to fall below minimal value in order to avoid numerical issues.
    for (std::size_t i=21; i&lt;49; i++)
    {
      if (widths-&gt;width(i)&lt;min_DS_rwidth *mspctm-&gt;mass(i))
      {
        widths-&gt;width(i)=min_DS_rwidth *mspctm-&gt;mass(i);
      }
    }

    #ifdef DARKSUSY_DEBUG
      // Spit out spectrum and width files for debug purposes.
      int u1 = 50;
      int u2 = 100050;
      #ifdef WITH_MPI
        int rank = GMPI::Comm().Get_rank();
        u1 += rank;
        u2 += rank;
      #endif
      dswspectrum(u1);
      dswwidth(u2);
    #endif

    return 0;  // everything OK (hah. maybe.)
  }

  /// Returns direct detection couplings gps,gns,gpa,gna
  /// (proton/neutron scalar/axial four-couplings)
  std::vector&lt;double&gt; DD_couplings()
  {
    double gps,gns,gpa,gna;
    dsddgpgn(gps,gns,gpa,gna);
    std::vector&lt;double&gt; couplings;
    couplings.clear();
    couplings.push_back(gps);
    couplings.push_back(gns);
    couplings.push_back(gpa);
    couplings.push_back(gna);
    return couplings;
  }

  /// Returns the vector of neutral Higgs decay channels in DarkSUSY
  std::vector&lt; std::vector&lt;str&gt; &gt; DS_neutral_h_decay_channels()
  {
    return initVector&lt; std::vector&lt;str&gt; &gt;
     (initVector&lt;str&gt;(&#34;h0_2&#34;, &#34;h0_2&#34;),
      initVector&lt;str&gt;(&#34;h0_1&#34;, &#34;h0_2&#34;),
      initVector&lt;str&gt;(&#34;h0_1&#34;, &#34;h0_1&#34;),
      initVector&lt;str&gt;(&#34;A0&#34;, &#34;A0&#34;),
      initVector&lt;str&gt;(&#34;h0_2&#34;, &#34;A0&#34;),
      initVector&lt;str&gt;(&#34;h0_1&#34;, &#34;A0&#34;),
      initVector&lt;str&gt;(&#34;H+&#34;, &#34;H-&#34;),
      initVector&lt;str&gt;(&#34;Z0&#34;, &#34;h0_2&#34;),
      initVector&lt;str&gt;(&#34;Z0&#34;, &#34;h0_1&#34;),
      initVector&lt;str&gt;(&#34;Z0&#34;, &#34;A0&#34;),
      // actually supposed to be W+H- and W-H+
      initVector&lt;str&gt;(&#34;W+&#34;, &#34;H-&#34;),
      initVector&lt;str&gt;(&#34;Z0&#34;, &#34;Z0&#34;),
      initVector&lt;str&gt;(&#34;W+&#34;, &#34;W-&#34;),
      initVector&lt;str&gt;(&#34;nu_e&#34;, &#34;nubar_e&#34;),
      initVector&lt;str&gt;(&#34;e+_1&#34;, &#34;e-_1&#34;),
      initVector&lt;str&gt;(&#34;nu_mu&#34;, &#34;nubar_mu&#34;),
      initVector&lt;str&gt;(&#34;e+_2&#34;, &#34;e-_2&#34;),
      initVector&lt;str&gt;(&#34;nu_tau&#34;, &#34;nubar_tau&#34;),
      initVector&lt;str&gt;(&#34;e+_3&#34;, &#34;e-_3&#34;),
      initVector&lt;str&gt;(&#34;u_1&#34;, &#34;ubar_1&#34;),
      initVector&lt;str&gt;(&#34;d_1&#34;, &#34;dbar_1&#34;),
      initVector&lt;str&gt;(&#34;u_2&#34;, &#34;ubar_2&#34;),
      initVector&lt;str&gt;(&#34;d_2&#34;, &#34;dbar_2&#34;),
      initVector&lt;str&gt;(&#34;u_3&#34;, &#34;ubar_3&#34;),
      initVector&lt;str&gt;(&#34;d_3&#34;, &#34;dbar_3&#34;),
      initVector&lt;str&gt;(&#34;g&#34;, &#34;g&#34;),
      // actually qqg (not implemented in DS though)
      initVector&lt;str&gt;(&#34;d_3&#34;, &#34;dbar_3&#34;, &#34;g&#34;),
      initVector&lt;str&gt;(&#34;gamma&#34;, &#34;gamma&#34;),
      initVector&lt;str&gt;(&#34;Z0&#34;, &#34;gamma&#34;)
     );
  }

  /// Returns the vector of charged Higgs decay channels in DarkSUSY
  std::vector&lt; std::vector&lt;str&gt; &gt; DS_charged_h_decay_channels()
  {
    return initVector&lt; std::vector&lt;str&gt; &gt;
     (initVector&lt;str&gt;(&#34;u_1&#34;, &#34;dbar_1&#34;),
      initVector&lt;str&gt;(&#34;u_1&#34;, &#34;dbar_2&#34;),
      initVector&lt;str&gt;(&#34;u_1&#34;, &#34;dbar_3&#34;),
      initVector&lt;str&gt;(&#34;u_2&#34;, &#34;dbar_1&#34;),
      initVector&lt;str&gt;(&#34;u_2&#34;, &#34;dbar_2&#34;),
      initVector&lt;str&gt;(&#34;u_2&#34;, &#34;dbar_3&#34;),
      initVector&lt;str&gt;(&#34;u_3&#34;, &#34;dbar_1&#34;),
      initVector&lt;str&gt;(&#34;u_3&#34;, &#34;dbar_2&#34;),
      initVector&lt;str&gt;(&#34;u_3&#34;, &#34;dbar_3&#34;),
      initVector&lt;str&gt;(&#34;e+_1&#34;, &#34;nu_e&#34;),
      initVector&lt;str&gt;(&#34;e+_2&#34;, &#34;nu_mu&#34;),
      initVector&lt;str&gt;(&#34;e+_3&#34;, &#34;nu_tau&#34;),
      initVector&lt;str&gt;(&#34;W+&#34;, &#34;h0_2&#34;),
      initVector&lt;str&gt;(&#34;W+&#34;, &#34;h0_1&#34;),
      initVector&lt;str&gt;(&#34;W+&#34;, &#34;A0&#34;)
     );
  }
}
END_BE_NAMESPACE
</code></pre><hr/><p>Updated on 2022-08-10 at 17:51:38 +0000</p></main></div></div></div><footer class="footer text-muted"><div class="container-xxl"><div class="row"><div class="col-lg-8 order-last order-lg-first"><ul class="list-inline"><li class="list-inline-item">Powered by <a class="text-muted" href="https://gohugo.io/">Hugo</a> and <a class="text-muted" href="https://getdoks.org/">Doks</a></li></ul></div><div class="col-lg-8 order-first order-lg-last text-lg-end"><ul class="list-inline"><li class="list-inline-item"><a href="/license/">License</a></li></ul></div></div></div></footer><script src="/js/bootstrap.min.54bf0932b8a36d0e152b1635b099a6ef1394d35327e2437550a075c9c8ed1bd8aed5847c21b36fc02ed24014c031d9ca24017b0c78b1639d7e2fa8329898b842.js" integrity="sha512-VL8JMrijbQ4VKxY1sJmm7xOU01Mn4kN1UKB1ycjtG9iu1YR8IbNvwC7SQBTAMdnKJAF7DHixY51+L6gymJi4Qg==" crossorigin="anonymous" defer=""></script>
<script src="/js/highlight.min.5b48bc253dc75aeea5fb366ecf700f4925e2b6eb1a1466f2124b722d68148d67bc0a9365d2b8ad9c585161b46372d23b08509a16f1fd518542b894756d4752d0.js" integrity="sha512-W0i8JT3HWu6l+zZuz3APSSXitusaFGbyEktyLWgUjWe8CpNl0ritnFhRYbRjctI7CFCaFvH9UYVCuJR1bUdS0A==" crossorigin="anonymous" defer=""></script>
<script src="/main.min.40265e9a032aeba5eaf67baac3cbbc22667a7533215d326eeb3e9f4d5e4be40f9ff4dcd22949db73ae527ca26a19d7998091a8973c82af760b2c0daa335190ed.js" integrity="sha512-QCZemgMq66Xq9nuqw8u8ImZ6dTMhXTJu6z6fTV5L5A+f9NzSKUnbc65SfKJqGdeZgJGolzyCr3YLLA2qM1GQ7Q==" crossorigin="anonymous" defer=""></script>
<script src="https://gambitbsm.github.io/index.min.1e0f859443ac81a8b8c357ddfae5d899d83ab224e24e44c1c9620a99f2a527d70a1676148a868f87f22fb67994386d592e508dafb575df7c2b80d97f143ad1ea.js" integrity="sha512-Hg+FlEOsgai4w1fd+uXYmdg6siTiTkTByWIKmfKlJ9cKFnYUioaPh/IvtnmUOG1ZLlCNr7V133wrgNl/FDrR6g==" crossorigin="anonymous" defer=""></script></body></html>