<!DOCTYPE html><html lang="en-us"><head><meta charset="utf-8"/><meta http-equiv="x-ua-compatible" content="ie=edge"/><meta name="viewport" content="width=device-width,initial-scale=1,shrink-to-fit=no"/><link rel="preload" as="font" href="https://gambitbsm.github.io/fonts/vendor/jost/jost-v4-latin-regular.woff2" type="font/woff2" crossorigin=""/><link rel="preload" as="font" href="https://gambitbsm.github.io/fonts/vendor/jost/jost-v4-latin-500.woff2" type="font/woff2" crossorigin=""/><link rel="preload" as="font" href="https://gambitbsm.github.io/fonts/vendor/jost/jost-v4-latin-700.woff2" type="font/woff2" crossorigin=""/><script>(()=>{var e=localStorage.getItem("theme");e==="dark"&&document.documentElement.setAttribute("data-dark-mode","")})()</script><link rel="stylesheet" href="https://gambitbsm.github.io/main.e60a30503f41dfe2a8e849eba3bb572667400d7915356bae7eff31d3e22e4492fc8c0b2ff150168b1139b9c0caad1a20c84c8957336bcc2bba8559379cc39f91.css" integrity="sha512-5gowUD9B3+Ko6Enro7tXJmdADXkVNWuufv8x0+IuRJL8jAsv8VAWixE5ucDKrRogyEyJVzNrzCu6hVk3nMOfkQ==" crossorigin="anonymous"/><noscript><style>img.lazyload{display:none}</style></noscript><meta name="robots" content="index, follow"/><meta name="googlebot" content="index, follow, max-snippet:-1, max-image-preview:large, max-video-preview:-1"/><meta name="bingbot" content="index, follow, max-snippet:-1, max-image-preview:large, max-video-preview:-1"/><title>file src/depresolver.cpp - GAMBIT</title><meta name="description" content="[No description available]"/><link rel="canonical" href="https://gambitbsm.github.io/documentation/code/gambit_2-2/files/depresolver_8cpp/"/><meta property="og:locale" content="en_US"/><meta property="og:type" content="article"/><meta property="og:title" content="file src/depresolver.cpp"/><meta property="og:description" content="[No description available]"/><meta property="og:url" content="https://gambitbsm.github.io/documentation/code/gambit_2-2/files/depresolver_8cpp/"/><meta property="og:site_name" content="GAMBIT"/><meta property="og:image" content="https://gambitbsm.github.io/gambit_logo.png"/><meta property="og:image:alt" content="GAMBIT"/><meta name="twitter:card" content="summary_large_image"/><meta name="twitter:site" content=""/><meta name="twitter:creator" content=""/><meta name="twitter:title" content="file src/depresolver.cpp"/><meta name="twitter:description" content="[No description available]"/><meta name="twitter:image" content="https://gambitbsm.github.io/gambit_logo.png"/><meta name="twitter:image:alt" content="file src/depresolver.cpp"/><script type="application/ld+json">{"@context":"https://schema.org","@graph":[{"@type":"Organization","@id":"https://gambitbsm.github.io/#/schema/organization/1","name":"Doks","url":"https://gambitbsm.github.io/","sameAs":["https://github.com/GambitBSM"],"logo":{"@type":"ImageObject","@id":"https://gambitbsm.github.io/#/schema/image/1","url":"https://gambitbsm.github.io/logo-doks.png","width":450,"height":416,"caption":"Doks"},"image":{"@id":"https://gambitbsm.github.io/#/schema/image/1"}},{"@type":"WebSite","@id":"https://gambitbsm.github.io/#/schema/website/1","url":"https://gambitbsm.github.io/","name":"GAMBIT","description":"Documentation for the Global And Modular BSM Inference Tool","publisher":{"@id":"https://gambitbsm.github.io/#/schema/organization/1"}},{"@type":"WebPage","@id":"https://gambitbsm.github.io/documentation/code/gambit_2-2/files/depresolver_8cpp/","url":"https://gambitbsm.github.io/documentation/code/gambit_2-2/files/depresolver_8cpp/","name":"file src\/depresolver.cpp","description":"[No description available]","isPartOf":{"@id":"https://gambitbsm.github.io/#/schema/website/1"},"about":{"@id":"https://gambitbsm.github.io/#/schema/organization/1"},"datePublished":"0001-01-01T00:00:00CET","dateModified":"0001-01-01T00:00:00CET","breadcrumb":{"@id":"https://gambitbsm.github.io/documentation/code/gambit_2-2/files/depresolver_8cpp/#/schema/breadcrumb/1"},"primaryImageOfPage":{"@id":"https://gambitbsm.github.io/documentation/code/gambit_2-2/files/depresolver_8cpp/#/schema/image/2"},"inLanguage":"en-US","potentialAction":[{"@type":"ReadAction","target":["https://gambitbsm.github.io/documentation/code/gambit_2-2/files/depresolver_8cpp/"]}]},{"@type":"BreadcrumbList","@id":"https://gambitbsm.github.io/documentation/code/gambit_2-2/files/depresolver_8cpp/#/schema/breadcrumb/1","name":"Breadcrumbs","itemListElement":[{"@type":"ListItem","position":1,"item":{"@type":"WebPage","@id":"https://gambitbsm.github.io/","url":"https://gambitbsm.github.io/","name":"Home"}},{"@type":"ListItem","position":2,"item":{"@type":"WebPage","@id":"https://gambitbsm.github.io/documentation/","url":"https://gambitbsm.github.io/documentation/","name":"Documentation"}},{"@type":"ListItem","position":3,"item":{"@type":"WebPage","@id":"https://gambitbsm.github.io/documentation/code/","url":"https://gambitbsm.github.io/documentation/code/","name":"Code"}},{"@type":"ListItem","position":4,"item":{"@type":"WebPage","@id":"https://gambitbsm.github.io/documentation/code/gambit_2-2/","url":"https://gambitbsm.github.io/documentation/code/gambit_2-2/","name":"Gambit 2 2"}},{"@type":"ListItem","position":5,"item":{"@type":"WebPage","@id":"https://gambitbsm.github.io/documentation/code/gambit_2-2/files/","url":"https://gambitbsm.github.io/documentation/code/gambit_2-2/files/","name":"Files"}},{"@type":"ListItem","position":6,"item":{"@id":"https://gambitbsm.github.io/documentation/code/gambit_2-2/files/depresolver_8cpp/"}}]},{"@context":"https://schema.org","@graph":[{"@type":"ImageObject","@id":"https://gambitbsm.github.io/documentation/code/gambit_2-2/files/depresolver_8cpp/#/schema/image/2","url":"https://gambitbsm.github.io/gambit_logo.png","contentUrl":"https://gambitbsm.github.io/gambit_logo.png","caption":"file src\/depresolver.cpp"}]}]}</script><meta name="theme-color" content="#fff"/><link rel="icon" href="https://gambitbsm.github.io/favicon.ico" sizes="any"/><link rel="icon" type="image/svg+xml" href="https://gambitbsm.github.io/favicon.svg"/><link rel="apple-touch-icon" sizes="180x180" href="https://gambitbsm.github.io/apple-touch-icon.png"/><link rel="icon" type="image/png" sizes="32x32" href="https://gambitbsm.github.io/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="16x16" href="https://gambitbsm.github.io/favicon-16x16.png"/><link rel="manifest" crossorigin="use-credentials" href="https://gambitbsm.github.io/site.webmanifest"/></head><body class="documentation single light"><div class="sticky-top"><div class="header-bar"></div><header class="navbar navbar-expand-md navbar-light doks-navbar"><nav class="container-xxl flex-wrap flex-md-nowrap" aria-label="Main navigation"><a class="navbar-brand p-0 me-auto" href="https://gambitbsm.github.io/" aria-label="GAMBIT"><img class="logo-light" src="https://gambitbsm.github.io//images/gambit_logo.png" width="50px"/>
<img class="logo-dark d-none" src="https://gambitbsm.github.io//images/gambit_logo.png" width="50px"/>
GAMBIT</a>
<button class="btn btn-menu order-2 d-block d-lg-none" type="button" data-bs-toggle="offcanvas" data-bs-target="#offcanvasDoks" aria-controls="offcanvasDoks" aria-label="Open main menu"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-menu"><line x1="3" y1="12" x2="21" y2="12"></line><line x1="3" y1="6" x2="21" y2="6"></line><line x1="3" y1="18" x2="21" y2="18"></line></svg></button><div class="offcanvas offcanvas-end border-0 py-lg-1" tabindex="-1" id="offcanvasDoks" data-bs-backdrop="true" aria-labelledby="offcanvasDoksLabel"><div class="header-bar d-lg-none"></div><div class="offcanvas-header d-lg-none"><h2 class="h5 offcanvas-title ps-2" id="offcanvasDoksLabel"><a class="text-dark" href="/">GAMBIT</a></h2><button type="button" class="btn-close text-reset me-2" data-bs-dismiss="offcanvas" aria-label="Close main menu"></button></div><div class="offcanvas-body p-4 p-lg-0"><ul class="nav flex-column flex-lg-row align-items-lg-center mt-2 mt-lg-0 ms-lg-2 me-lg-auto"><li class="nav-item dropdown"><a class="nav-link dropdown-toggle ps-0 py-1" href="#" id="navbarDropdownMenuLink" role="button" data-bs-toggle="dropdown" aria-expanded="false">Documentation
<span class="dropdown-caret"><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-chevron-down"><polyline points="6 9 12 15 18 9"></polyline></svg></span></a><ul class="dropdown-menu dropdown-menu-main shadow rounded border-0" aria-labelledby="navbarDropdownMenuLink"><li><a class="dropdown-item" href="/documentation/installation/introduction/">Installation</a></li><li><a class="dropdown-item" href="/documentation/examples/colliderbit_example">Examples</a></li><li><a class="dropdown-item" href="/documentation/help/faqs/">Help</a></li><li><a class="dropdown-item" href="/documentation/code/gambit_2-2/index_classes">Code Reference</a></li></ul></li><li class="nav-item dropdown"><a class="nav-link dropdown-toggle ps-0 py-1" href="#" id="navbarDropdownMenuLink" role="button" data-bs-toggle="dropdown" aria-expanded="false">Community
<span class="dropdown-caret"><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-chevron-down"><polyline points="6 9 12 15 18 9"></polyline></svg></span></a><ul class="dropdown-menu dropdown-menu-main shadow rounded border-0" aria-labelledby="navbarDropdownMenuLink"><li><a class="dropdown-item" href="/community/publications/">Publications</a></li><li><a class="dropdown-item" href="/community/talks/">Talks</a></li><li><a class="dropdown-item" href="/community/members/">Members</a></li><li><a class="dropdown-item active" href="/community/code_of_conduct/" aria-current="true">Code of Conduct</a></li><li><a class="dropdown-item" href="/community/contact/">Contact</a></li></ul></li><li class="nav-item"><a class="nav-link ps-0 py-1" href="/wiki/general/homepage/">Wiki</a></li></ul><hr class="text-black-50 my-4 d-lg-none"/><form class="doks-search position-relative flex-grow-1 ms-lg-auto me-lg-2"><input id="search" class="form-control is-search" type="search" placeholder="Search site..." aria-label="Search site..." autocomplete="off"/><div id="suggestions" class="shadow bg-white rounded d-none"></div></form><hr class="text-black-50 my-4 d-lg-none"/><ul class="nav flex-column flex-lg-row"><li class="nav-item"><a class="nav-link social-link" href="https://github.com/GambitBSM"><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-github"><path d="M9 19c-5 1.5-5-2.5-7-3m14 6v-3.87a3.37 3.37.0 00-.94-2.61c3.14-.35 6.44-1.54 6.44-7A5.44 5.44.0 0020 4.77 5.07 5.07.0 0019.91 1S18.73.65 16 2.48a13.38 13.38.0 00-7 0C6.27.65 5.09 1 5.09 1A5.07 5.07.0 005 4.77 5.44 5.44.0 003.5 8.55c0 5.42 3.3 6.61 6.44 7A3.37 3.37.0 009 18.13V22"></path></svg><small class="ms-2 d-lg-none">GitHub</small></a></li></ul><hr class="text-black-50 my-4 d-lg-none"/><button id="mode" class="btn btn-link" type="button" aria-label="Toggle user interface mode">
<span class="toggle-dark"><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-moon"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"></path></svg></span><span class="toggle-light"><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-sun"><circle cx="12" cy="12" r="5"></circle><line x1="12" y1="1" x2="12" y2="3"></line><line x1="12" y1="21" x2="12" y2="23"></line><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line><line x1="1" y1="12" x2="3" y2="12"></line><line x1="21" y1="12" x2="23" y2="12"></line><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line></svg></span></button></div></div></nav></header></div><div class="wrap container-xxl" role="document"><div class="content"><div class="row flex-xl-nowrap"><div class="col-lg-5 col-xl-4 docs-sidebar"><nav class="docs-links" aria-label="Main navigation"><ul class="list-unstyled collapsible-sidebar"><li class="mb-1"><button class="btn btn-toggle align-items-center rounded collapsed" data-bs-toggle="collapse" data-bs-target="#section-installation" aria-expanded="false">
Installation</button><div class="collapse" id="section-installation"><ul class="btn-toggle-nav list-unstyled fw-normal pb-1 small"><li><a class="docs-link rounded" href="/documentation/installation/introduction/">Getting Started</a></li><li><a class="docs-link rounded" href="/documentation/installation/docker_usage/">Docker Usage</a></li><li><a class="docs-link rounded" href="/documentation/installation/installation_for_linux/">Installation for Linux</a></li><li><a class="docs-link rounded" href="/documentation/installation/installation_for_windows/">Installation for Windows</a></li><li><a class="docs-link rounded" href="/documentation/installation/installation_for_macos/">Installation for macOS</a></li></ul></div></li><li class="mb-1"><button class="btn btn-toggle align-items-center rounded collapsed" data-bs-toggle="collapse" data-bs-target="#section-examples" aria-expanded="false">
Examples</button><div class="collapse" id="section-examples"><ul class="btn-toggle-nav list-unstyled fw-normal pb-1 small"><li><a class="docs-link rounded" href="/documentation/examples/colliderbit_example/">ColliderBit Example</a></li><li><a class="docs-link rounded" href="/documentation/examples/anotherbit/">AnotherBit</a></li><li><a class="docs-link rounded" href="/documentation/examples/anotherbit2/">AnotherBit2</a></li></ul></div></li><li class="mb-1"><button class="btn btn-toggle align-items-center rounded collapsed" data-bs-toggle="collapse" data-bs-target="#section-help" aria-expanded="false">
Help</button><div class="collapse" id="section-help"><ul class="btn-toggle-nav list-unstyled fw-normal pb-1 small"><li><a class="docs-link rounded" href="/documentation/help/faqs/">FAQs</a></li><li><a class="docs-link rounded" href="/documentation/help/compiler_matrix/">Compiler Matrix</a></li><li><a class="docs-link rounded" href="/documentation/help/known_issues/">Known Issues</a></li><li><a class="docs-link rounded" href="/documentation/help/configuration_examples/">Configuration Examples</a></li></ul></div></li><li class="mb-1"><button class="btn btn-toggle align-items-center rounded collapsed" data-bs-toggle="collapse" data-bs-target="#section-code" aria-expanded="true">
Code Reference</button><div class="collapse show" id="section-code"><ul class="btn-toggle-nav list-unstyled fw-normal pb-1 small"><li class="my-1 ms-3"><button class="btn btn-toggle align-items-center rounded collapsed" data-bs-toggle="collapse" data-bs-target="#section-gambit_2-2" aria-expanded="true">
<font style="color: #5d2f86;" size="-6">release</font>   gambit 2-2</button><div class="collapse show" id="section-gambit_2-2"><ul class="btn-toggle-nav list-unstyled fw-normal pb-1 small"><li><a class="docs-link rounded" href="/documentation/code/gambit_2-2/index_classes/">Classes</a></li><li><a class="docs-link rounded" href="/documentation/code/gambit_2-2/index_files/">Files</a></li><li><a class="docs-link rounded" href="/documentation/code/gambit_2-2/index_pages/">Pages</a></li><li><a class="docs-link rounded" href="/documentation/code/gambit_2-2/index_namespaces/">Namespaces</a></li></ul></div></li></ul></div></li></ul></nav></div><nav class="docs-toc d-none d-xl-block col-xl-3" aria-label="Secondary navigation"><div class="d-xl-none"><button class="btn btn-outline-primary btn-sm doks-toc-toggle collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#onThisPage" aria-controls="doks-docs-nav" aria-expanded="false" aria-label="Toggle On this page navigation">
<span>On this page</span>
<span><svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24" class="doks doks-expand" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><title>Expand</title><polyline points="7 13 12 18 17 13"></polyline><polyline points="7 6 12 11 17 6"></polyline></svg><svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24" class="doks doks-collapse" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><title>Collapse</title><polyline points="17 11 12 6 7 11"></polyline><polyline points="17 18 12 13 7 18"></polyline></svg></span></button><div class="collapse" id="onThisPage"><div class="card card-body mt-3 py-1"><div class="page-links"><nav id="TableOfContents"><ul><li><ul><li><a href="#namespaces">Namespaces</a></li><li><a href="#classes">Classes</a></li><li><a href="#defines">Defines</a></li><li><a href="#detailed-description">Detailed Description</a></li><li><a href="#macros-documentation">Macros Documentation</a><ul><li><a href="#define-obslike_vertexid">define OBSLIKE_VERTEXID</a></li><li><a href="#define-normal_dependency">define NORMAL_DEPENDENCY</a></li><li><a href="#define-loop_manager_dependency">define LOOP_MANAGER_DEPENDENCY</a></li></ul></li><li><a href="#source-code">Source code</a></li></ul></li></ul></nav></div></div></div></div><div class="page-links d-none d-xl-block"><h3>On this page</h3><nav id="TableOfContents"><ul><li><ul><li><a href="#namespaces">Namespaces</a></li><li><a href="#classes">Classes</a></li><li><a href="#defines">Defines</a></li><li><a href="#detailed-description">Detailed Description</a></li><li><a href="#macros-documentation">Macros Documentation</a><ul><li><a href="#define-obslike_vertexid">define OBSLIKE_VERTEXID</a></li><li><a href="#define-normal_dependency">define NORMAL_DEPENDENCY</a></li><li><a href="#define-loop_manager_dependency">define LOOP_MANAGER_DEPENDENCY</a></li></ul></li><li><a href="#source-code">Source code</a></li></ul></li></ul></nav></div></nav><main class="docs-content col-lg-11 col-xl-9 mx-xl-auto"><nav aria-label="breadcrumb"><ol class="breadcrumb"><li class="breadcrumb-item"><a href="/">Home</a></li><li class="breadcrumb-item"><a href="/documentation/">Documentation</a></li><li class="breadcrumb-item"><a href="/documentation/code/">Code Reference</a></li><li class="breadcrumb-item"><a href="/documentation/code/gambit_2-2/">gambit_2-2</a></li><li class="breadcrumb-item active" aria-current="page">file src/depresolver.cpp</li></ol></nav><h1>file src/depresolver.cpp</h1><p class="lead"></p><p>[No description available] <a href="#detailed-description">More…</a></p><h2 id="namespaces">Namespaces <a href="#namespaces" class="anchor" aria-hidden="true">#</a></h2><table><thead><tr><th>Name</th></tr></thead><tbody><tr><td><strong><a href="/documentation/code/gambit_2-2/namespaces/namespacegambit/">Gambit</a></strong><br/>TODO: see if we can use this one:</td></tr><tr><td><strong><a href="/documentation/code/gambit_2-2/namespaces/namespacegambit_1_1dres/">Gambit::DRes</a></strong></td></tr><tr><td><strong><a href="/documentation/code/gambit_2-2/namespaces/namespacelogtags/">LogTags</a></strong></td></tr></tbody></table><h2 id="classes">Classes <a href="#classes" class="anchor" aria-hidden="true">#</a></h2><table><thead><tr><th></th><th>Name</th></tr></thead><tbody><tr><td>class</td><td><strong><a href="/documentation/code/gambit_2-2/classes/classgambit_1_1dres_1_1edgewriter/">Gambit::DRes::edgeWriter</a></strong></td></tr><tr><td>class</td><td><strong><a href="/documentation/code/gambit_2-2/classes/classgambit_1_1dres_1_1labelwriter/">Gambit::DRes::labelWriter</a></strong></td></tr></tbody></table><h2 id="defines">Defines <a href="#defines" class="anchor" aria-hidden="true">#</a></h2><table><thead><tr><th></th><th>Name</th></tr></thead><tbody><tr><td></td><td><strong><a href="/documentation/code/gambit_2-2/files/depresolver_8cpp/#define-obslike-vertexid">OBSLIKE_VERTEXID</a></strong></td></tr><tr><td></td><td><strong><a href="/documentation/code/gambit_2-2/files/depresolver_8cpp/#define-normal-dependency">NORMAL_DEPENDENCY</a></strong></td></tr><tr><td></td><td><strong><a href="/documentation/code/gambit_2-2/files/depresolver_8cpp/#define-loop-manager-dependency">LOOP_MANAGER_DEPENDENCY</a></strong></td></tr></tbody></table><h2 id="detailed-description">Detailed Description <a href="#detailed-description" class="anchor" aria-hidden="true">#</a></h2><p><strong>Author</strong>:</p><ul><li>Christoph Weniger (<a href="mailto:c.weniger@uva.nl">c.weniger@uva.nl</a>)</li><li>Pat Scott (<a href="mailto:patscott@physics.mcgill.ca">patscott@physics.mcgill.ca</a>)</li><li>Ben Farmer (<a href="mailto:benjamin.farmer@monash.edu">benjamin.farmer@monash.edu</a>)</li><li>Tomas Gonzalo (<a href="mailto:gonzalo@physik.rwth-aachen.de">gonzalo@physik.rwth-aachen.de</a>)</li><li>Patrick Stoecker (<a href="mailto:stoecker@physik.rwth-aachen.de">stoecker@physik.rwth-aachen.de</a>)</li></ul><p><strong>Date</strong>:</p><ul><li>2013 May, Jun, Jul, Sep</li><li>2014 Feb, Mar, Apr</li><li>2013 May, Jul, Aug, Nov 2014 Jan, Mar, Apr, Dec 2018 Sep, Nov</li><li>2013 Sep</li><li>2017 June 2019 May 2021 Sep</li><li>2020 May</li></ul><p>Dependency resolution with boost graph library</p><pre><code>    unravels the un-unravelable
</code></pre><hr/><p>Authors (add name and date if you modify):</p><hr/><h2 id="macros-documentation">Macros Documentation <a href="#macros-documentation" class="anchor" aria-hidden="true">#</a></h2><h3 id="define-obslike_vertexid">define OBSLIKE_VERTEXID <a href="#define-obslike_vertexid" class="anchor" aria-hidden="true">#</a></h3><pre><code>#define OBSLIKE_VERTEXID 58915032
</code></pre><h3 id="define-normal_dependency">define NORMAL_DEPENDENCY <a href="#define-normal_dependency" class="anchor" aria-hidden="true">#</a></h3><pre><code>#define NORMAL_DEPENDENCY 1
</code></pre><h3 id="define-loop_manager_dependency">define LOOP_MANAGER_DEPENDENCY <a href="#define-loop_manager_dependency" class="anchor" aria-hidden="true">#</a></h3><pre><code>#define LOOP_MANAGER_DEPENDENCY 2
</code></pre><h2 id="source-code">Source code <a href="#source-code" class="anchor" aria-hidden="true">#</a></h2><pre><code>//   GAMBIT: Global and Modular BSM Inference Tool
//   *********************************************
///  \file
///
///  Dependency resolution with boost graph library
///
///          unravels the un-unravelable
///
///  *********************************************
///
///  Authors (add name and date if you modify):
///
///  \author Christoph Weniger
///          (c.weniger@uva.nl)
///  \date 2013 May, Jun, Jul, Sep
///  \date 2014 Feb, Mar, Apr
///
///  \author Pat Scott
///          (patscott@physics.mcgill.ca)
///  \date 2013 May, Jul, Aug, Nov
///        2014 Jan, Mar, Apr, Dec
///        2018 Sep, Nov
///
///  \author Ben Farmer
///          (benjamin.farmer@monash.edu)
///  \date 2013 Sep
///
///  \author Tomas Gonzalo
///          (gonzalo@physik.rwth-aachen.de)
///  \date 2017 June
///        2019 May
///        2021 Sep
///
///  \author Patrick Stoecker
///          (stoecker@physik.rwth-aachen.de)
///  \date 2020 May
///
///  *********************************************

#include &#34;gambit/Core/depresolver.hpp&#34;
#include &#34;gambit/Models/models.hpp&#34;
#include &#34;gambit/Utils/stream_overloads.hpp&#34;
#include &#34;gambit/Utils/util_functions.hpp&#34;
#include &#34;gambit/Utils/bibtex_functions.hpp&#34;
#include &#34;gambit/Utils/citation_keys.hpp&#34;
#include &#34;gambit/Logs/logger.hpp&#34;
#include &#34;gambit/Backends/backend_singleton.hpp&#34;
#include &#34;gambit/cmake/cmake_variables.hpp&#34;

#include &lt;sstream&gt;
#include &lt;fstream&gt;
#include &lt;iomanip&gt;
#include &lt;regex&gt;

#include &lt;boost/format.hpp&gt;
#include &lt;boost/algorithm/string/replace.hpp&gt;
#ifdef HAVE_GRAPHVIZ
  #include &lt;boost/graph/graphviz.hpp&gt;
#endif

// This vertex ID is reserved for nodes that correspond to
// likelihoods/observables/etc (observables of interest)
#define OBSLIKE_VERTEXID 58915032

// Dependency types
#define NORMAL_DEPENDENCY 1
#define LOOP_MANAGER_DEPENDENCY 2

// Debug flag
//#define DEPRES_DEBUG

// Verbose flag (not debug per se, just basic dependency resolution information)
//#define VERBOSE_DEP_RES

namespace Gambit
{

  namespace DRes
  {
    using namespace LogTags;
    ///////////////////////
    // Auxiliary functions
    ///////////////////////

    //
    // Functions that act on a resolved dependency graph
    //

    // Collect parent vertices recursively (excluding root vertex)
    void getParentVertices(const VertexID &amp; vertex, const
        DRes::MasterGraphType &amp; graph, std::set&lt;VertexID&gt; &amp; myVertexList)
    {
      graph_traits&lt;DRes::MasterGraphType&gt;::in_edge_iterator it, iend;

      for (boost::tie(it, iend) = in_edges(vertex, graph);
          it != iend; ++it)
      {
        if ( std::find(myVertexList.begin(), myVertexList.end(), source(*it, graph)) == myVertexList.end() )
        {
          myVertexList.insert(source(*it, graph));
          getParentVertices(source(*it, graph), graph, myVertexList);
        }
      }
    }

    // Sort given list of vertices (according to topological sort result)
    std::vector&lt;VertexID&gt; sortVertices(const std::set&lt;VertexID&gt; &amp; set,
        const std::list&lt;VertexID&gt; &amp; topoOrder)
    {
      std::vector&lt;VertexID&gt; result;
      for(std::list&lt;VertexID&gt;::const_iterator it = topoOrder.begin(); it != topoOrder.end(); it++)
      {
        if (set.find(*it) != set.end())
          result.push_back(*it);
      }
      return result;
    }

    // Get sorted list of parent vertices
    std::vector&lt;VertexID&gt; getSortedParentVertices(const VertexID &amp; vertex, const
        DRes::MasterGraphType &amp; graph, const std::list&lt;VertexID&gt; &amp; topoOrder)
    {
      std::set&lt;VertexID&gt; set;
      getParentVertices(vertex, graph, set);
      set.insert(vertex);
      return sortVertices(set, topoOrder);
    }


    //
    // Functions that compare ini-file entries and observables
    //

    // Check whether quantity matches observableType
    // Matches capability and type
    bool quantityMatchesIniEntry(const sspair &amp; quantity, const IniParser::ObservableType &amp; observable, const Utils::type_equivalency &amp; eq)
    {
      // Compares dependency specifications of rules entries or observable
      // entries with capability (capabilities have to be unique for these
      // lists)
      return ( stringComp( observable.capability, quantity.first ) and
               typeComp  ( observable.type,       quantity.second, eq ));
    }

    // Check whether quantity matches observableType
    // Matches capability
    bool capabilityMatchesIniEntry(const sspair &amp; quantity, const IniParser::ObservableType &amp; observable)
    {
      // Compares dependency specifications of rules entries or observable
      // entries with capability (capabilities have to be unique for these
      // lists)
      return ( stringComp( observable.capability, quantity.first ) );
    }

    // Check whether functor matches ObservableType
    // Matches capability, type, function and module name
    bool moduleFuncMatchesIniEntry(functor *f, const IniParser::ObservableType &amp;e, const Utils::type_equivalency &amp; eq)
    {
      return (e.capability != &#34;&#34; ? stringComp(e.capability, f-&gt;capability()) : true)
         and (e.type       != &#34;&#34; ? typeComp  (e.type,       f-&gt;type(), eq)   : true)
         and (e.function   != &#34;&#34; ? stringComp(e.function,   f-&gt;name())       : true)
         and (e.module     != &#34;&#34; ? stringComp(e.module,     f-&gt;origin())     : true);
    }

    // Check whether functor matches ObservableType
    // Matches capability, type, function and backend name
    bool backendFuncMatchesIniEntry(functor *f, const IniParser::ObservableType &amp;e, const Utils::type_equivalency &amp; eq)
    {
      return (e.capability != &#34;&#34; ? stringComp(e.capability, f-&gt;capability()) : true)
         and (e.type       != &#34;&#34; ? typeComp  (e.type,       f-&gt;type(), eq)   : true)
         and (e.function   != &#34;&#34; ? stringComp(e.function,   f-&gt;name())       : true)
         and (e.backend    != &#34;&#34; ? stringComp(e.backend,    f-&gt;origin())     : true)
         and (e.version    != &#34;&#34; ? stringComp(e.version,    f-&gt;version())    : true);
    }

    // Get entry level relevant for options
    int getEntryLevelForOptions(const IniParser::ObservableType &amp;e)
    {
      int z = 0;
      if ( e.module != &#34;&#34; ) z = 1;
      if ( e.capability != &#34;&#34; ) z = 2;
      if ( e.type != &#34;&#34; ) z = 3;
      if ( e.function != &#34;&#34; ) z = 4;
      return z;
    }

    // Check whether functor matches rules
    // Matches function name and type
    bool matchesRules( functor *f, const Rule &amp; rule)
    {
      #ifdef DEPRES_DEBUG
        cout &lt;&lt; (*f).name() &lt;&lt; &#34; vs &#34; &lt;&lt; rule.function &lt;&lt; endl;
        cout &lt;&lt; (*f).origin() &lt;&lt; &#34; vs &#34; &lt;&lt; rule.module &lt;&lt; endl;
      #endif
      return ( stringComp( rule.function, (*f).name()) and
               stringComp( rule.module, (*f).origin())
             );
    }


    //
    // Graphviz output
    //

    // Graphviz output for edges/dependencies
    class edgeWriter
    {
      public:
        edgeWriter(const DRes::MasterGraphType*) {};
        void operator()(std::ostream&amp;, const EdgeID&amp;) const
        {
          //out &lt;&lt; &#34;[style=\&#34;dotted\&#34;]&#34;;
        }
    };

    // Graphviz output for individual vertices/nodes/module functions
    class labelWriter
    {
      private:
        const DRes::MasterGraphType * myGraph;
      public:
        labelWriter(const DRes::MasterGraphType * masterGraph) : myGraph(masterGraph) {};
        void operator()(std::ostream&amp; out, const VertexID&amp; v) const
        {
          str type = Utils::fix_type((*myGraph)[v]-&gt;type());
          boost::replace_all(type, str(&#34;&amp;&#34;), str(&#34;&amp;amp;&#34;));
          boost::replace_all(type, str(&#34;&lt;&#34;), str(&#34;&amp;lt;&#34;));
          boost::replace_all(type, str(&#34;&gt;&#34;), str(&#34;&amp;gt;&#34;));
          out &lt;&lt; &#34;[fillcolor=\&#34;#F0F0D0\&#34;, style=\&#34;rounded,filled\&#34;, shape=box,&#34;;
          out &lt;&lt; &#34;label=&lt; &#34;;
          out &lt;&lt; &#34;&lt;font point-size=\&#34;20\&#34; color=\&#34;red\&#34;&gt;&#34; &lt;&lt; (*myGraph)[v]-&gt;capability() &lt;&lt; &#34;&lt;/font&gt;&lt;br/&gt;&#34;;
          out &lt;&lt;  &#34;Type: &#34; &lt;&lt; type &lt;&lt; &#34;&lt;br/&gt;&#34;;
          out &lt;&lt;  &#34;Function: &#34; &lt;&lt; (*myGraph)[v]-&gt;name() &lt;&lt; &#34;&lt;br/&gt;&#34;;
          out &lt;&lt;  &#34;Module: &#34; &lt;&lt; (*myGraph)[v]-&gt;origin();
          out &lt;&lt; &#34;&gt;]&#34;;
        }
    };


    //
    // Misc
    //

    /// Global flag for regex use
    bool use_regex;

    // Return runtime estimate for a set of nodes
    double getTimeEstimate(const std::set&lt;VertexID&gt; &amp; vertexList, const DRes::MasterGraphType &amp;graph)
    {
      double result = 0;
      for (std::set&lt;VertexID&gt;::iterator it = vertexList.begin(); it != vertexList.end(); ++it)
      {
        result += graph[*it]-&gt;getRuntimeAverage();
      }
      return result;
    }

    // Check whether s1 (wildcard + regex allowed) matches s2
    bool stringComp(const str &amp; s1, const str &amp; s2, bool with_regex)
    {
      if ( s1 == s2 ) return true;
      if ( s1 == &#34;&#34; ) return true;
      if ( s1 == &#34;*&#34; ) return true;
      try
      {
        if (with_regex) if (std::regex_match(s2, std::regex(s1))) return true;
      }
      catch (std::regex_error &amp; err)
      {
        std::ostringstream errmsg;
        errmsg &lt;&lt; &#34;ERROR during regex string comparison.&#34; &lt;&lt; std::endl;
        errmsg &lt;&lt; &#34;  Comparing regular expression: &#34; &lt;&lt; s1 &lt;&lt; std::endl;
        errmsg &lt;&lt; &#34;  with test string: &#34; &lt;&lt; s2 &lt;&lt; std::endl;
        dependency_resolver_error().raise(LOCAL_INFO,errmsg.str());
      }
      return false;
    }

    // Same thing for types (taking into account equivalence classes)
    bool typeComp(str s1, str s2, const Utils::type_equivalency &amp; eq, bool with_regex)
    {
      bool match1, match2;
      // Loop over all the default versions of BOSSed backends and replace any corresponding *_default leading namespace with the explicit version.
      if ((s1.find(&#34;_default&#34;) != std::string::npos) || (s2.find(&#34;_default&#34;) != std::string::npos))
      {
        for (auto it = Backends::backendInfo().default_safe_versions.begin(); it != Backends::backendInfo().default_safe_versions.end(); ++it)
        {
          s1 = Utils::replace_leading_namespace(s1, it-&gt;first+&#34;_default&#34;, it-&gt;first+&#34;_&#34;+it-&gt;second);
          s2 = Utils::replace_leading_namespace(s2, it-&gt;first+&#34;_default&#34;, it-&gt;first+&#34;_&#34;+it-&gt;second);
        }
      }
      // Does it just match?
      if (stringComp(s1, s2, with_regex)) return true;
      // Otherwise loop over equivalence classes.
      for (auto it1 = eq.equivalency_classes.begin(); it1 != eq.equivalency_classes.end(); it1++)
      {
        match1 = match2 = false;
        for (auto it2 = it1-&gt;begin(); it2 != it1-&gt;end(); it2++)
        {
          if (s2 == *it2) match1 = true;
          if (stringComp(s1, *it2, with_regex)) match2 = true;
        }
        if (match1 and match2) return true;
      }
      return false;
    }


    ///////////////////////////////////////////////////
    // Public definitions of DependencyResolver class
    ///////////////////////////////////////////////////

    // Constructor
    DependencyResolver::DependencyResolver(const gambit_core &amp;core,
                                           const Models::ModelFunctorClaw &amp;claw,
                                           const IniParser::IniFile &amp;iniFile,
                                           const Utils::type_equivalency &amp;equiv_classes,
                                                 Printers::BasePrinter &amp;printer)
     : boundCore(&amp;core),
       boundClaw(&amp;claw),
       boundIniFile(&amp;iniFile),
       boundTEs(&amp;equiv_classes),
       boundPrinter(&amp;printer),
       index(get(vertex_index,masterGraph)),
       activeFunctorGraphFile(Utils::runtime_scratch()+&#34;GAMBIT_active_functor_graph.gv&#34;)
    {
      addFunctors();
      logger() &lt;&lt; LogTags::dependency_resolver &lt;&lt; endl;
      logger() &lt;&lt; &#34;#######################################&#34;   &lt;&lt; endl;
      logger() &lt;&lt; &#34;#  List of Type Equivalency Classes   #&#34;   &lt;&lt; endl;
      logger() &lt;&lt; &#34;#######################################&#34;;
      for (std::set&lt;std::set&lt;str&gt; &gt;::const_iterator it = boundTEs-&gt;equivalency_classes.begin(); it != boundTEs-&gt;equivalency_classes.end(); ++it)
      {
        logger() &lt;&lt; endl &lt;&lt; *it;
      }
      logger() &lt;&lt; EOM;
    }


    //
    // Initialization stage
    //

    // Main dependency resolution
    void DependencyResolver::doResolution()
    {
      const IniParser::ObservablesType &amp; observables = boundIniFile-&gt;getObservables();
      // (cap., typ) --&gt; dep. vertex map
      std::queue&lt;QueueEntry&gt; parQueue;
      QueueEntry queueEntry;

      // Set up list of target ObsLikes
      logger() &lt;&lt; LogTags::dependency_resolver &lt;&lt; endl;
      logger() &lt;&lt; &#34;#######################################&#34;   &lt;&lt; endl;
      logger() &lt;&lt; &#34;#        List of Target ObsLikes      #&#34;   &lt;&lt; endl;
      logger() &lt;&lt; &#34;#                                     #&#34;   &lt;&lt; endl;
      logger() &lt;&lt; &#34;# format: Capability (Type) [Purpose] #&#34;   &lt;&lt; endl;
      logger() &lt;&lt; &#34;#######################################&#34;;
      for (auto it = observables.begin(); it != observables.end(); ++it)
      {
        // Format output
        logger() &lt;&lt; LogTags::dependency_resolver &lt;&lt; endl &lt;&lt; it-&gt;capability &lt;&lt; &#34; (&#34; &lt;&lt; it-&gt;type &lt;&lt; &#34;) [&#34; &lt;&lt; it-&gt;purpose &lt;&lt; &#34;]&#34;;
        queueEntry.first.first = it-&gt;capability;
        queueEntry.first.second = it-&gt;type;
        queueEntry.second = OBSLIKE_VERTEXID;
        queueEntry.printme = it-&gt;printme;
        parQueue.push(queueEntry);
      }
      logger() &lt;&lt; EOM;

      // Activate functors compatible with model we scan over (and deactivate the rest)
      makeFunctorsModelCompatible();

      // Generate dependency tree (the core of the dependency resolution)
      generateTree(parQueue);

      // Find one execution order for activated vertices that is compatible
      // with dependency structure
      function_order = run_topological_sort();

      // Loop manager initialization: Notify them about their nested functions
      for (std::map&lt;VertexID, std::set&lt;VertexID&gt;&gt;::iterator it =
          loopManagerMap.begin(); it != loopManagerMap.end(); ++it)
      {
        // Generate topologically sorted list of vertex IDs that are nested
        // within loop manager (*it) ...
        std::vector&lt;VertexID&gt; vertexList = sortVertices(it-&gt;second, function_order);
        // ... map this on functor pointers...
        std::vector&lt;functor*&gt; functorList;
        for (std::vector&lt;VertexID&gt;::iterator jt = vertexList.begin(); jt != vertexList.end(); ++jt)
        {
          functorList.push_back(masterGraph[*jt]);
        }
        // ...and store it into loop manager functor
        masterGraph[it-&gt;first]-&gt;setNestedList(functorList);
      }

      // Initialise the printer object with a list of functors that are set to print
      initialisePrinter();

#ifdef HAVE_GRAPHVIZ
      // Generate graphviz plot if running in dry-run mode.
      if (boundCore-&gt;show_runorder)
      {
        std::ofstream outf(activeFunctorGraphFile);
        write_graphviz(outf, masterGraph, labelWriter(&amp;masterGraph), edgeWriter(&amp;masterGraph));
      }
#endif

      // Pre-compute the individually ordered vertex lists for each of the ObsLike entries.
      std::vector&lt;VertexID&gt; order = getObsLikeOrder();
      for(auto it = order.begin(); it != order.end(); ++it)
      {
        SortedParentVertices[*it] = getSortedParentVertices(*it, masterGraph, function_order);
      }

      // Print list of backends required
      if (boundCore-&gt;show_backends)
      {
        printRequiredBackends();
      }

      // Get BibTeX key entries for backends, modules, etc
      getCitationKeys();

      // Done
    }

    /// List of masterGraph content
    void DependencyResolver::printFunctorList()
    {
      // Activate functors compatible with model we scan over (and deactivate the rest)
      makeFunctorsModelCompatible();

      graph_traits&lt;DRes::MasterGraphType&gt;::vertex_iterator vi, vi_end;
      const str formatString = &#34;%-20s %-32s %-32s %-32s %-15s %-7i %-5i %-5i\n&#34;;
      logger() &lt;&lt; LogTags::dependency_resolver &lt;&lt; endl &lt;&lt; &#34;Vertices registered in masterGraph&#34; &lt;&lt; endl;
      logger() &lt;&lt; &#34;----------------------------------&#34; &lt;&lt; endl;
      logger() &lt;&lt; boost::format(formatString)%
       &#34;MODULE (VERSION)&#34;% &#34;FUNCTION&#34;% &#34;CAPABILITY&#34;% &#34;TYPE&#34;% &#34;PURPOSE&#34;% &#34;STATUS&#34;% &#34;#DEPs&#34;% &#34;#BE_REQs&#34;;
      for (boost::tie(vi, vi_end) = vertices(masterGraph); vi != vi_end; ++vi)
      {
        logger() &lt;&lt; boost::format(formatString)%
         ((*masterGraph[*vi]).origin() + &#34; (&#34; + (*masterGraph[*vi]).version() + &#34;)&#34;) %
         (*masterGraph[*vi]).name()%
         (*masterGraph[*vi]).capability()%
         (*masterGraph[*vi]).type()%
         (*masterGraph[*vi]).purpose()%
         (*masterGraph[*vi]).status()%
         (*masterGraph[*vi]).dependencies().size()%
         (*masterGraph[*vi]).backendreqs().size();
      }
      logger() &lt;&lt;  &#34;Registered Backend vertices&#34; &lt;&lt; endl;
      logger() &lt;&lt;  &#34;---------------------------&#34; &lt;&lt; endl;
      logger() &lt;&lt; printGenericFunctorList(boundCore-&gt;getBackendFunctors());
      logger() &lt;&lt; EOM;
    }

    // Pretty print function evaluation order
    void DependencyResolver::printFunctorEvalOrder(bool toterminal)
    {
      // Running this lets us check the order of execution. Also helps
      // to verify that we actually have pointers to all the required
      // functors.

      // Get order of evaluation
      std::set&lt;VertexID&gt; parents;
      std::set&lt;VertexID&gt; done; //set of vertices already accounted for
      std::vector&lt;VertexID&gt; order = getObsLikeOrder();

      str formatString  = &#34;%-5s %-25s %-25s %-25s\n&#34;;
      // Might need to check if terminal supports unicode characters...
      str formatString0 = &#34;%-7s %-23s %-25s %-25s %-25s %-6s\n&#34;;  // header
      str formatString1a= &#34;%-9s %-21s %-25s %-25s %-25s %-6s\n&#34;;  // target functors
      str formatString1b= &#34;%-4s \u2514\u2500\u2500&gt; %-21s %-25s %-25s %-25s %-6s\n&#34;;  // target functors
      str formatString2a= &#34;     \u250C\u2500 %-23s %-25s %-25s %-25s %-6s\n&#34;;  // parents
      str formatString2b= &#34;     \u251C\u2500 %-23s %-25s %-25s %-25s %-6s\n&#34;;
      str formatString3a= &#34;     \u250CX %-23s %-25s %-25s %-25s %-6s\n&#34;; // &#34;already done&#34; parents
      str formatString3b= &#34;     \u251CX %-23s %-25s %-25s %-25s %-6s\n&#34;;

      int i = 0;

      // Show the order in which the target functors will be attacked.
      std::ostringstream ss;
      ss &lt;&lt; endl &lt;&lt; &#34;Initial target functor evaluation order&#34; &lt;&lt; endl;
      ss &lt;&lt; &#34;----------------------------------&#34; &lt;&lt; endl;
      ss &lt;&lt; boost::format(formatString)% &#34;#&#34;% &#34;FUNCTION&#34;% &#34;CAPABILITY&#34;% &#34;ORIGIN&#34;;

      for (std::vector&lt;VertexID&gt;::const_iterator
                  vi  = order.begin();
                  vi != order.end(); ++vi)
      {
        ss &lt;&lt; boost::format(formatString)%
         i%
         (*masterGraph[*vi]).name()%
         (*masterGraph[*vi]).capability()%
         (*masterGraph[*vi]).origin();
        i++;
      }

      ss &lt;&lt; endl;

      i = 0; // Reset counter
      // Do another loop to show the full initial sequence of functor evaluation
      // This doesn&#39;t figure out the sequence within each target functor group; I&#39;m not 100% sure where that is determined. This does, however, show which groups get evaluated first, and which functors are already evaluated.
      ss &lt;&lt; endl &lt;&lt; &#34;Full initial functor evaluation order&#34; &lt;&lt; endl;
      ss &lt;&lt; &#34;----------------------------------&#34; &lt;&lt; endl;
      ss &lt;&lt; boost::format(formatString0)% &#34;#&#34;% &#34;FUNCTION&#34;% &#34;CAPABILITY&#34;% &#34;TYPE&#34;% &#34;ORIGIN&#34;% &#34;PRINT?&#34;;

      for (std::vector&lt;VertexID&gt;::const_iterator
                  vi  = order.begin();
                  vi != order.end(); ++vi)
      {
        // loop through parents of each target functor
        parents.clear();
        getParentVertices(*vi, masterGraph, parents);
        parents.insert(*vi);
        bool first = true;
        for (std::set&lt;VertexID&gt;::const_iterator
                  vi2  = parents.begin();
                  vi2 != parents.end(); ++vi2)
        {
            str formatstr;
            bool dowrite = false;
            // Check if parent functor has been ticked off the list
            bool is_done = done.find(*vi2) != done.end();
            if( (not is_done) and (*vi != *vi2) )
            {
                formatstr = formatString2b;
                if (first) formatstr = formatString2a;
                dowrite = true;
            }
            else if( *vi != *vi2)
            {
                // Might be better to just do nothing here, i.e. set dowrite=false. For now just flagging functor as done with a special format string.
                formatstr = formatString3b;
                if (first) formatstr = formatString3a;
                dowrite = true;
            }

            if (dowrite)
            {
              ss &lt;&lt; boost::format(formatstr)%
                (*masterGraph[*vi2]).name()%
                (*masterGraph[*vi2]).capability()%
                (*masterGraph[*vi2]).type()%
                (*masterGraph[*vi2]).origin()%
                (*masterGraph[*vi2]).requiresPrinting();
            }
            done.insert(*vi2); // tick parent functor off the list
            first = false;
        }

        // Now show target functor info
        str formatstr;
        if(parents.size()==1) { formatstr = formatString1a; }
        else { formatstr = formatString1b; }
        ss &lt;&lt; boost::format(formatstr)%
         i%
         (*masterGraph[*vi]).name()%
         (*masterGraph[*vi]).capability()%
         (*masterGraph[*vi]).type()%
         (*masterGraph[*vi]).origin()%
         (*masterGraph[*vi]).requiresPrinting();
        i++;

        done.insert(*vi); // tick this target functor off the list

      }
      ss &lt;&lt; &#34;(\&#34;X\&#34; indicates that the functor is pre-evaluated before the marked position)&#34; &lt;&lt; endl &lt;&lt; endl;

      if (toterminal)
      {
        // There is a command line flag to get this information, since it is very
        // handy to check before launching a full job. It can always be checked via
        // the logs, but this feature is more convenient.
        cout &lt;&lt; ss.str();
        #ifdef HAVE_GRAPHVIZ
          cout &lt;&lt; &#34;To get postscript plot of active functors, please run: &#34; &lt;&lt; endl;
          cout &lt;&lt; GAMBIT_DIR &lt;&lt; &#34;/Core/scripts/./graphviz.sh &#34; &lt;&lt; activeFunctorGraphFile &lt;&lt; &#34; no-loners&#34; &lt;&lt; endl;
        #else
          cout &lt;&lt; &#34;To get postscript plot of active functors, please install graphviz, rerun cmake and remake GAMBIT.&#34; &lt;&lt; endl &lt;&lt; endl;
        #endif
      }

      logger() &lt;&lt; LogTags::dependency_resolver &lt;&lt; ss.str() &lt;&lt; EOM;
    }

    // Print the list of required backends
    void DependencyResolver::printRequiredBackends()
    {
      // Lists the required backends, indicating where several backends
      // can fulfil the same requirement
      std::stringstream ss;

      ss &lt;&lt; endl &lt;&lt; &#34;Required backends to run file &#34; &lt;&lt; boundIniFile-&gt;filename() &lt;&lt; std::endl;
      ss &lt;&lt; &#34;At least one backend candidate per row is required&#34; &lt;&lt; std::endl;
      ss &lt;&lt; &#34;--------------------------------------------------&#34; &lt;&lt; std::endl &lt;&lt; std::endl;

      for(auto reqs : backendsRequired)
      {
        for(auto backend : reqs)
        {
          ss &lt;&lt; boost::format(&#34;%-25s&#34;)%(&#34;(&#34;+backend.first+&#34;, &#34;+backend.second+&#34;)&#34;);
        }
        ss &lt;&lt; std::endl;
      }
      ss &lt;&lt; std::endl;

      // Print to terminal
      std::cout &lt;&lt; ss.str();

      // Print to logs
      logger() &lt;&lt; LogTags::dependency_resolver &lt;&lt; ss.str() &lt;&lt; EOM;
    }

    // Print the BibTeX citation keys
    void DependencyResolver::printCitationKeys()
    {

      // If the list is empty do not print anything
      if(citationKeys.empty()) return;

      std::stringstream ss;

      // Location of the bibtex file
      str bibtex_file_location = boundIniFile-&gt;getValueOrDef&lt;str&gt;(GAMBIT_DIR &#34;/config/bibtex_entries.bib&#34;, &#34;dependency_resolution&#34;, &#34;bibtex_file_location&#34;);

      ss &lt;&lt; &#34;The scan you are about to run uses backends. Please make sure to cite all of them in your work.&#34; &lt;&lt; std::endl;

      // Create a list of entries in the bibtex file
      BibTeX bibtex_file(bibtex_file_location);
      std::vector&lt;str&gt; entries = bibtex_file.getBibTeXEntries();

      // Make sure that each key has an entry on the bibtex file
      for(const auto&amp; key : citationKeys)
      {
        // Now find each key in the list of entries
        if(std::find(entries.begin(), entries.end(), key) == entries.end())
        {
          std::ostringstream errmsg;
          errmsg &lt;&lt; &#34;The reference with key &#34; &lt;&lt; key &lt;&lt; &#34; cannot be found in the bibtex file &#34; &lt;&lt; bibtex_file_location &lt;&lt; endl;
          errmsg &lt;&lt; &#34;Please make sure that the bibtex file contains the relevant bibtex entries.&#34; &lt;&lt; endl;
          dependency_resolver_error().raise(LOCAL_INFO,errmsg.str());
        }
      }

      // Drop a bibtex file with the citation entries
      str bibtex_output_file = boundIniFile-&gt;getValueOrDef&lt;str&gt;(&#34;GAMBIT.bib&#34;, &#34;dependency_resolution&#34;, &#34;bibtex_output_file&#34;);
      bibtex_file.dropBibTeXFile(citationKeys, bibtex_output_file);

      // Drop a sample TeX file citing all backens
      str tex_output_file = boundIniFile-&gt;getValueOrDef&lt;str&gt;(&#34;GAMBIT.tex&#34;, &#34;dependency_resolution&#34;, &#34;tex_output_file&#34;);
      bibtex_file.dropTeXFile(citationKeys, tex_output_file, bibtex_output_file);

      ss &lt;&lt; &#34;You can find the list of references to include in &#34; &lt;&lt; bibtex_output_file &lt;&lt; &#34;. And and example TeX file in &#34; &lt;&lt; tex_output_file &lt;&lt; std::endl &lt;&lt; std::endl;

      // Print to terminal
      std::cout &lt;&lt; ss.str();

      // Print to logs
      logger() &lt;&lt; LogTags::dependency_resolver &lt;&lt; ss.str() &lt;&lt; EOM;

    }

    //
    // Runtime
    //

    // Returns list of ObsLike vertices in order of runtime
    std::vector&lt;VertexID&gt; DependencyResolver::getObsLikeOrder()
    {
      std::vector&lt;VertexID&gt; unsorted;
      std::vector&lt;VertexID&gt; sorted;
      std::set&lt;VertexID&gt; parents, colleages, colleages_min;
      // Copy unsorted vertexIDs --&gt; unsorted
      for (std::vector&lt;OutputVertexInfo&gt;::iterator it = outputVertexInfos.begin();
          it != outputVertexInfos.end(); it++)
      {
        unsorted.push_back(it-&gt;vertex);
      }
      // Sort iteratively (unsorted --&gt; sorted)
      while (unsorted.size() &gt; 0)
      {
        double t2p_now;
        double t2p_min = -1;
        std::vector&lt;VertexID&gt;::iterator it_min;
        for (std::vector&lt;VertexID&gt;::iterator it = unsorted.begin(); it !=
            unsorted.end(); ++it)
        {
          parents.clear();
          getParentVertices(*it, masterGraph, parents);
          parents.insert(*it);
          // Remove vertices that were already calculated from the ist
          for ( auto cit = colleages.begin(); cit != colleages.end(); cit++)
          {
            parents.erase(*cit);
          }
          t2p_now = (double) getTimeEstimate(parents, masterGraph);
          t2p_now /= masterGraph[*it]-&gt;getInvalidationRate();
          if (t2p_min &lt; 0 or t2p_now &lt; t2p_min)
          {
            t2p_min = t2p_now;
            it_min = it;
            colleages_min = parents;
          }
        }
        // Extent list of calculated vertices
        colleages.insert(colleages_min.begin(), colleages_min.end());
        double prop = masterGraph[*it_min]-&gt;getInvalidationRate();
        logger() &lt;&lt; LogTags::dependency_resolver &lt;&lt; &#34;Estimated T [s]: &#34; &lt;&lt; t2p_min*prop &lt;&lt; EOM;
        logger() &lt;&lt; LogTags::dependency_resolver &lt;&lt; &#34;Estimated p: &#34; &lt;&lt; prop &lt;&lt; EOM;
        sorted.push_back(*it_min);
        unsorted.erase(it_min);
      }
      return sorted;
    }

    // Evaluates ObsLike vertex, and everything it depends on, and prints results
    void DependencyResolver::calcObsLike(VertexID vertex)
    {
      if (SortedParentVertices.find(vertex) == SortedParentVertices.end())
        core_error().raise(LOCAL_INFO, &#34;Tried to calculate a function not in or not at top of dependency graph.&#34;);
      std::vector&lt;VertexID&gt; order = SortedParentVertices.at(vertex);

      for (std::vector&lt;VertexID&gt;::iterator it = order.begin(); it != order.end(); ++it)
      {
        std::ostringstream ss;
        ss &lt;&lt; &#34;Calling &#34; &lt;&lt; masterGraph[*it]-&gt;name() &lt;&lt; &#34; from &#34; &lt;&lt; masterGraph[*it]-&gt;origin() &lt;&lt; &#34;...&#34;;
        logger() &lt;&lt; LogTags::dependency_resolver &lt;&lt; LogTags::info &lt;&lt; LogTags::debug &lt;&lt; ss.str() &lt;&lt; EOM;
        masterGraph[*it]-&gt;calculate();
        if (boundIniFile-&gt;getValueOrDef&lt;bool&gt;(
              false, &#34;dependency_resolution&#34;, &#34;log_runtime&#34;) )
        {
          double T = masterGraph[*it]-&gt;getRuntimeAverage();
          logger() &lt;&lt; LogTags::dependency_resolver &lt;&lt; LogTags::info &lt;&lt;
            &#34;Runtime, averaged over multiple calls [s]: &#34; &lt;&lt; T &lt;&lt; EOM;
        }
        invalid_point_exception* e = masterGraph[*it]-&gt;retrieve_invalid_point_exception();
        if (e != NULL) throw(*e);
      }
      // Reset the cout output precision, in case any backends have messed with it during the ObsLike evaluation.
      cout &lt;&lt; std::setprecision(boundCore-&gt;get_outprec());
    }

    // Prints the results of an ObsLike vertex
    void DependencyResolver::printObsLike(VertexID vertex, const int pointID)
    {
      // pointID is supplied by the scanner, and is used to tell the printer which model
      // point the results should be associated with.

      if (SortedParentVertices.find(vertex) == SortedParentVertices.end())
        core_error().raise(LOCAL_INFO, &#34;Tried to calculate a function not in or not at top of dependency graph.&#34;);
      std::vector&lt;VertexID&gt; order = SortedParentVertices.at(vertex);

      for (std::vector&lt;VertexID&gt;::iterator it = order.begin(); it != order.end(); ++it)
      {
        std::ostringstream ss;
        ss &lt;&lt; &#34;Printing &#34; &lt;&lt; masterGraph[*it]-&gt;name() &lt;&lt; &#34; from &#34; &lt;&lt; masterGraph[*it]-&gt;origin() &lt;&lt; &#34;...&#34;;
        logger() &lt;&lt; LogTags::dependency_resolver &lt;&lt; LogTags::info &lt;&lt; LogTags::debug &lt;&lt; ss.str() &lt;&lt; EOM;

        if (not typeComp(masterGraph[*it]-&gt;type(),  &#34;void&#34;, *boundTEs, false))
        {
          // Note that this prints from thread index 0 only, i.e. results created by
          // threads other than the main one need to be accessed with
          //   masterGraph[*it]-&gt;print(boundPrinter,pointID,index);
          // where index is some integer s.t. 0 &lt;= index &lt;= number of hardware threads.
          // At the moment GAMBIT only prints results of thread 0, under the expectation
          // that nested module functions are all designed to gather their results into
          // thread 0.
          masterGraph[*it]-&gt;print(boundPrinter,pointID);
        }
      }
    }

    /// Getter for print_timing flag (used by LikelihoodContainer)
    bool DependencyResolver::printTiming() { return print_timing; }

    // Get the functor corresponding to a single VertexID
    functor* DependencyResolver::get_functor(VertexID id)
    {
      graph_traits&lt;DRes::MasterGraphType&gt;::vertex_iterator vi, vi_end;
      for (boost::tie(vi, vi_end) = vertices(masterGraph); vi != vi_end; ++vi)
      {
        if (*vi == id) return masterGraph[id];
      }
      return NULL;
    }

    // Ensure that the type of a given vertex is equivalent to at least one of a provided list, and return the match.
    str DependencyResolver::checkTypeMatch(VertexID vertex, const str&amp; purpose, const std::vector&lt;str&gt;&amp; types)
    {
      for (auto it = types.begin(); it != types.end(); ++it)
      {
        if (typeComp(*it, masterGraph[vertex]-&gt;type(), *boundTEs, false)) return *it;
      }
      std::stringstream msg;
      msg &lt;&lt; &#34;All quantities with purpose \&#34;&#34; &lt;&lt; purpose &lt;&lt; &#34;\&#34; in your yaml file must have one &#34; &lt;&lt; endl
          &lt;&lt; &#34;of the following types: &#34; &lt;&lt; endl &lt;&lt; &#34;  &#34; &lt;&lt; types &lt;&lt; endl
          &lt;&lt; &#34;You have tried to assign this purpose to &#34; &lt;&lt; masterGraph[vertex]-&gt;origin() &lt;&lt; &#34;::&#34;
          &lt;&lt; masterGraph[vertex]-&gt;name() &lt;&lt; &#34;,&#34; &lt;&lt; endl &lt;&lt; &#34;which has capability: &#34; &lt;&lt; endl
          &lt;&lt; &#34;  &#34; &lt;&lt; masterGraph[vertex]-&gt;capability() &lt;&lt; endl &lt;&lt; &#34;and result type: &#34; &lt;&lt; endl
          &lt;&lt; &#34;  [&#34; &lt;&lt; masterGraph[vertex]-&gt;type() &lt;&lt; &#34;]&#34; &lt;&lt; endl &lt;&lt; &#34;Please assign a different purpose to this entry.&#34;;
      core_error().raise(LOCAL_INFO, msg.str());
      return &#34;If you make core errors non-fatal you deserve what you get.&#34;;
    }

    // Tell functor that it invalidated the current point in model space (due to a large or NaN contribution to lnL)
    void DependencyResolver::invalidatePointAt(VertexID vertex, bool isnan)
    {
      if (isnan)
      {
        masterGraph[vertex]-&gt;notifyOfInvalidation(&#34;NaN returned for likelihood value.&#34;);
      }
      else
      {
        masterGraph[vertex]-&gt;notifyOfInvalidation(&#34;Cumulative log-likelihood pushed below threshold.&#34;);
      }
    }

    // Returns pointer to ini-file entry associated with ObsLike
    const IniParser::ObservableType * DependencyResolver::getIniEntry(VertexID v)
    {
      for (std::vector&lt;OutputVertexInfo&gt;::iterator it = outputVertexInfos.begin();
          it != outputVertexInfos.end(); it++)
      {
        if (it-&gt;vertex == v)
          return it-&gt;iniEntry;
      }
      return NULL;
    }

    // Resets all active functors and deletes existing results
    void DependencyResolver::resetAll()
    {
      graph_traits&lt;DRes::MasterGraphType&gt;::vertex_iterator vi, vi_end;
      for (boost::tie(vi, vi_end) = vertices(masterGraph); vi != vi_end; ++vi)
      {
        if (masterGraph[*vi]-&gt;status() == 2) masterGraph[*vi]-&gt;reset();
      }
    }


    ////////////////////////////////////////////////////
    // Private definitions of DependencyResolver class
    ////////////////////////////////////////////////////

    str DependencyResolver::printQuantityToBeResolved(const sspair &amp; quantity, const DRes::VertexID &amp; vertex)
    {
        str s = quantity.first + &#34; (&#34; + quantity.second + &#34;)&#34;;
        s += &#34;, required by &#34;;
        if ( vertex != OBSLIKE_VERTEXID )
        {
            s += (*masterGraph[vertex]).capability() + &#34; (&#34;;
            s += (*masterGraph[vertex]).type() + &#34;) [&#34;;
            s += (*masterGraph[vertex]).name() + &#34;, &#34;;
            s += (*masterGraph[vertex]).origin() + &#34;]&#34;;
        }
        else
            s += &#34;Core&#34;;
        return s;
    }

    str DependencyResolver::printGenericFunctorList(const std::vector&lt;VertexID&gt; &amp; vertexIDs)
    {
        std::vector&lt;functor*&gt; functorList;
        for ( auto it = vertexIDs.begin(); it != vertexIDs.end(); ++it )
        {
            functorList.push_back(masterGraph[*it]);
        }
        return printGenericFunctorList(functorList);
    }

    // Generic printer of the contents of a functor list
    str DependencyResolver::printGenericFunctorList(const std::vector&lt;functor*&gt;&amp; functorList)
    {
      const str formatString = &#34;%-20s %-32s %-48s %-32s %-7i\n&#34;;
      std::ostringstream stream;
      stream &lt;&lt; boost::format(formatString)%&#34;ORIGIN (VERSION)&#34;% &#34;FUNCTION&#34;% &#34;CAPABILITY&#34;% &#34;TYPE&#34;% &#34;STATUS&#34;;
      for (std::vector&lt;functor *&gt;::const_iterator
          it  = functorList.begin();
          it != functorList.end();
          ++it)
      {
        stream &lt;&lt; boost::format(formatString)%
         ((*it)-&gt;origin() + &#34; (&#34; + (*it)-&gt;version() + &#34;)&#34;) %
         (*it)-&gt;name()%
         (*it)-&gt;capability()%
         (*it)-&gt;type()%
         (*it)-&gt;status();
      }
      return stream.str();
    }

    // Add module and primary model functors in bound core to class-internal
    // masterGraph object
    void DependencyResolver::addFunctors()
    {
      // Add primary model functors to masterGraph
      for (std::vector&lt;primary_model_functor *&gt;::const_iterator
          it  = boundCore-&gt;getPrimaryModelFunctors().begin();
          it != boundCore-&gt;getPrimaryModelFunctors().end();
          ++it)
      {
        // Ignore functors with status set to 0 or less in order to ignore primary_model_functors
        // that are not to be used for the scan.
        if ( (*it)-&gt;status() &gt; 0 )
        {
          boost::add_vertex(*it, this-&gt;masterGraph);
        }
      }
      // Add module functors to masterGraph
      for (std::vector&lt;functor *&gt;::const_iterator
          it  = boundCore-&gt;getModuleFunctors().begin();
          it != boundCore-&gt;getModuleFunctors().end();
          ++it)
      {
          boost::add_vertex(*it, this-&gt;masterGraph);
      }
    }

    /// Activate functors that are allowed to be used with one or more of the models being scanned.
    /// Also activate the model-conditional dependencies and backend requirements of those functors.
    void DependencyResolver::makeFunctorsModelCompatible()
    {
      // Run just once
      static bool already_run = false;
      if (already_run) return;

      graph_traits&lt;DRes::MasterGraphType&gt;::vertex_iterator vi, vi_end;
      std::vector&lt;functor *&gt;::const_iterator fi, fi_end = boundCore-&gt;getBackendFunctors().end();
      std::set&lt;str&gt; modelList = boundClaw-&gt;get_activemodels();

      // Activate those module functors that match the combination of models being scanned.
      for (boost::tie(vi, vi_end) = vertices(masterGraph); vi != vi_end; ++vi)
      {
        if (masterGraph[*vi]-&gt;status() &gt;= 0 and masterGraph[*vi]-&gt;modelComboAllowed(modelList))
        {
          for (std::set&lt;str&gt;::iterator it = modelList.begin(); it != modelList.end(); ++it)
          {
            masterGraph[*vi]-&gt;notifyOfModel(*it);
            masterGraph[*vi]-&gt;setStatus(1);
          }
        }
      }

      // Activate those backend functors that match one of the models being scanned.
      for (std::set&lt;str&gt;::iterator it = modelList.begin(); it != modelList.end(); ++it)
      {
        for (fi = boundCore-&gt;getBackendFunctors().begin(); fi != fi_end; ++fi)
        {
          // Activate if the backend vertex permits the model and has not been (severely) disabled by the backend system
          if ( (*fi)-&gt;status() &gt;= 0 and (*fi)-&gt;modelAllowed(*it) )
          {
            (*fi)-&gt;setStatus(1);
          }
        }
      }
      already_run = true;
    }

    /// Set up printer object
    // (i.e. give it the list of functors that need printing)
    void DependencyResolver::initialisePrinter()
    {
      // Send the state of the &#34;print_unitcube&#34; flag to the printer
      boundPrinter-&gt;set_printUnitcube(print_unitcube);

      std::vector&lt;int&gt; functors_to_print;
      graph_traits&lt;MasterGraphType&gt;::vertex_iterator vi, vi_end;
      //IndexMap index = get(vertex_index, masterGraph); // Now done in the constructor
      //Err does that make sense? There is nothing in masterGraph at that point surely... maybe put this back.
      //Ok well it does seem to work in the constructor, not sure why though...

      for (boost::tie(vi, vi_end) = vertices(masterGraph); vi != vi_end; ++vi)
      {
        // Inform the active functors of the vertex ID that the masterGraph has assigned to them
        // (so that later on they can pass this to the printer object to identify themselves)
        //masterGraph[*vi]-&gt;setVertexID(index[*vi]); // Ugh cannot do this, needs to be consistent with get_param_id
        std::string label = masterGraph[*vi]-&gt;label();
        masterGraph[*vi]-&gt;setVertexID(Printers::get_param_id(label));
        // Same for timing output ID, but get ID number from printer system
        std::string timing_label = masterGraph[*vi]-&gt;timingLabel();
        masterGraph[*vi]-&gt;setTimingVertexID(Printers::get_param_id(timing_label));

        // Check for non-void type and status==2 (after the dependency resolution) to print only active, printable functors.
        // TODO: this doesn&#39;t currently check for non-void type; that is done at the time of printing in calcObsLike.
        if( masterGraph[*vi]-&gt;requiresPrinting() and (masterGraph[*vi]-&gt;status()==2) )
        {
          functors_to_print.push_back(index[*vi]); // TODO: Probably obsolete
          boundPrinter-&gt;addToPrintList(label); // Needed mainly by postprocessor.
          // Trigger a dummy print call for all printable functors. This is used by some printers
          // to set up buffers for each of these output streams.
          //logger() &lt;&lt; LogTags::dependency_resolver &lt;&lt; &#34;Triggering dummy print for functor &#39;&#34;&lt;&lt;masterGraph[*vi]-&gt;capability()&lt;&lt;&#34;&#39; (&#34;&lt;&lt;masterGraph[*vi]-&gt;type()&lt;&lt;&#34;)...&#34; &lt;&lt; EOM;

          //masterGraph[*vi]-&gt;print(boundPrinter,-1);
        }
      }

      // Force-reset the printer to erase the dummy calls
      // (but don&#39;t do this if we are in resume mode!)
      //if(not boundCore-&gt;resume) boundPrinter-&gt;reset(true);
      //boundPrinter-&gt;reset(true); // Actually *do* do it in resume mode as well. Printers should only reset new data, not destroy old data.

      // sent vector of ID&#39;s of functors to be printed to printer.
      // (if we want to only print functor output sometimes, and dynamically
      // switch this on and off, we&#39;ll have to rethink the strategy here a
      // little... for now if the print function of a functor does not get
      // called, it is up to the printer how it deals with the missing result.
      // Similarly for extra results, i.e. from any functors not in this
      // initial list, whose &#34;requiresPrinting&#34; flag later gets set to &#39;true&#39;
      // somehow.)
      boundPrinter-&gt;initialise(functors_to_print); // TODO: Probably obsolete
    }

    std::vector&lt;DRes::VertexID&gt; DependencyResolver::closestCandidateForModel(std::vector&lt;DRes::VertexID&gt; candidates)
    {
      // In case of doubt (and if not explicitely disabled in the ini-file), prefer functors
      // that are more specifically tailored for the model being scanned. Do not consider functors
      // that are accessible via INTERPRET_AS_X links, as these are all considered to be equally &#39;far&#39;
      // from the model being scanned, with the &#39;distance&#39; being one step further than the most distant
      // ancestor.

      // Work up the model ancestry one step at a time, and stop as soon as one or more valid model-specific functors is
      // found at a given level in the hierarchy.
      std::vector&lt;DRes::VertexID&gt; newCandidates;
      std::set&lt;str&gt; s = boundClaw-&gt;get_activemodels();
      std::vector&lt;str&gt; parentModelList(s.begin(), s.end());
      while (newCandidates.size() == 0 and not parentModelList.empty())
      {
        for (std::vector&lt;str&gt;::iterator mit = parentModelList.begin(); mit != parentModelList.end(); ++mit)
        {
          // Test each vertex candidate to see if it has been explicitly set up to work with the model *mit
          for (std::vector&lt;DRes::VertexID&gt;::iterator it = candidates.begin(); it != candidates.end(); ++it)
          {
            if ( masterGraph[*it]-&gt;modelExplicitlyAllowed(*mit) ) newCandidates.push_back(*it);
          }
          // Step up a level in the model hierarchy for this model.
          *mit = boundClaw-&gt;get_parent(*mit);
        }
        parentModelList.erase(std::remove(parentModelList.begin(), parentModelList.end(), &#34;none&#34;), parentModelList.end());
      }
      if (newCandidates.size() != 0)
        return newCandidates;
      else
        return candidates;
    }

    /// Collect ini options
    Options DependencyResolver::collectIniOptions(const DRes::VertexID &amp; vertex)
    {
      YAML::Node nodes;
      YAML::Node zlevels;

      #ifdef DEPRES_DEBUG
        cout &lt;&lt; &#34;Searching options for &#34; &lt;&lt; masterGraph[vertex]-&gt;capability() &lt;&lt; endl;
      #endif

      const IniParser::ObservablesType &amp; entries = boundIniFile-&gt;getRules();
      for (IniParser::ObservablesType::const_iterator it =
          entries.begin(); it != entries.end(); ++it)
      {
        if (moduleFuncMatchesIniEntry(masterGraph[vertex], *it, *boundTEs))
        {
          #ifdef DEPRES_DEBUG
            cout &lt;&lt; &#34;Getting option from: &#34; &lt;&lt; it-&gt;capability &lt;&lt; &#34; &#34; &lt;&lt; it-&gt;type &lt;&lt; endl;
          #endif
          for (auto jt = it-&gt;options.begin(); jt != it-&gt;options.end(); ++jt)
          {
            if ( not nodes[jt-&gt;first.as&lt;std::string&gt;()] )
            {
              #ifdef DEPRES_DEBUG
                cout &lt;&lt; jt-&gt;first.as&lt;std::string&gt;() &lt;&lt; &#34;: &#34; &lt;&lt; jt-&gt;second &lt;&lt; endl;
              #endif
              nodes[jt-&gt;first.as&lt;std::string&gt;()] = jt-&gt;second;
              zlevels[jt-&gt;first.as&lt;std::string&gt;()] = getEntryLevelForOptions(*it);
            }
            else
            {
              if ( zlevels[jt-&gt;first.as&lt;std::string&gt;()].as&lt;int&gt;() &lt; getEntryLevelForOptions(*it) )
              {
                #ifdef DEPRES_DEBUG
                  cout &lt;&lt; &#34;Replaced : &#34; &lt;&lt; jt-&gt;first.as&lt;std::string&gt;() &lt;&lt; &#34;: &#34; &lt;&lt; jt-&gt;second &lt;&lt; endl;
                #endif
                zlevels[jt-&gt;first.as&lt;std::string&gt;()] = getEntryLevelForOptions(*it);
                nodes[jt-&gt;first.as&lt;std::string&gt;()] = jt-&gt;second;
              }
              else if ( zlevels[jt-&gt;first.as&lt;std::string&gt;()].as&lt;int&gt;() == getEntryLevelForOptions(*it) )
              {
                std::ostringstream errmsg;
                errmsg &lt;&lt; &#34;ERROR! Multiple option entries with same level for key: &#34; &lt;&lt; jt-&gt;first.as&lt;std::string&gt;();
                dependency_resolver_error().raise(LOCAL_INFO,errmsg.str());
              }
            }
          }
        }
      }
      return Options(nodes);
    }

    /// Collect sub-capabilities
    Options DependencyResolver::collectSubCaps(const DRes::VertexID &amp; vertex)
    {
      #ifdef DEPRES_DEBUG
        cout &lt;&lt; &#34;Searching for subcaps of &#34; &lt;&lt; masterGraph[vertex]-&gt;capability() &lt;&lt; endl;
      #endif

      YAML::Node nodes;
      const IniParser::ObservablesType&amp; entries = boundIniFile-&gt;getObservables();

      // Iterate over the ObsLikes entries
      for (auto it = entries.begin(); it != entries.end(); ++it)
      {
        // Select only those entries that match the current graph vertex (i.e. module function)
        if (moduleFuncMatchesIniEntry(masterGraph[vertex], *it, *boundTEs) and not it-&gt;subcaps.IsNull())
        {
          #ifdef DEPRES_DEBUG
            cout &lt;&lt; &#34;Found subcaps for &#34; &lt;&lt; it-&gt;capability &lt;&lt; &#34; &#34; &lt;&lt; it-&gt;type &lt;&lt; &#34; &#34; &lt;&lt; it-&gt;module &lt;&lt; &#34;:&#34; &lt;&lt; endl;
          #endif
          // The user has given just a single entry as a subcap
          if (it-&gt;subcaps.IsScalar())
          {
            str key = it-&gt;subcaps.as&lt;str&gt;();
            if (nodes[key]) dependency_resolver_error().raise(LOCAL_INFO,&#34;Duplicate sub-capability for &#34; + key + &#34;.&#34;);
            nodes[key] = YAML::Node();
          }
          // The user has passed a simple list of subcaps
          else if (it-&gt;subcaps.IsSequence())
          {
            for (auto jt = it-&gt;subcaps.begin(); jt != it-&gt;subcaps.end(); ++jt)
            {
              if (not jt-&gt;IsScalar())
               dependency_resolver_error().raise(LOCAL_INFO,&#34;Attempt to pass map using sequence syntax for subcaps of &#34;+it-&gt;capability+&#34;.&#34;);
              str key = jt-&gt;as&lt;str&gt;();
              if (nodes[key]) dependency_resolver_error().raise(LOCAL_INFO,&#34;Duplicate sub-capability for &#34; + key + &#34;.&#34;);
              nodes[key] = YAML::Node();
            }
          }
          // The user has passed some more complicated subcap structure than just a list of strings
          else if (it-&gt;subcaps.IsMap())
          {
            for (auto jt = it-&gt;subcaps.begin(); jt != it-&gt;subcaps.end(); ++jt)
            {
              str key = jt-&gt;first.as&lt;str&gt;();
              if (nodes[key]) dependency_resolver_error().raise(LOCAL_INFO,&#34;Duplicate sub-capability for &#34; + key + &#34;.&#34;);
              nodes[key] = jt-&gt;second.as&lt;YAML::Node&gt;();
            }
          }
          #ifdef DEPRES_DEBUG
            cout &lt;&lt; nodes &lt;&lt; endl;
          #endif
        }
      }
      return Options(nodes);
    }

    /// Resolve dependency
    // Can resolve:
    // - capability, type pair (requires toVertex)
    // Rules ordering:
    //   [Capability, Type] --&gt; [Module, Function]
    DRes::VertexID DependencyResolver::resolveDependencyFromRules(
        const DRes::VertexID &amp; toVertex, const sspair &amp; quantity)
    {
      graph_traits&lt;DRes::MasterGraphType&gt;::vertex_iterator vi, vi_end;

      // List of candidate vertices
      std::vector&lt;DRes::VertexID&gt; vertexCandidates;  // enabled
      std::vector&lt;DRes::VertexID&gt; disabledVertexCandidates;  // disabled
      // Rules
      std::vector&lt;Rule&gt; rules;
      std::vector&lt;Rule&gt; strong_rules;
      // Candidate vertices after applying rules
      std::vector&lt;DRes::VertexID&gt; filteredVertexCandidates;
      std::vector&lt;DRes::VertexID&gt; filteredVertexCandidates2;

      // Make list of candidate vertices.
      for (tie(vi, vi_end) = vertices(masterGraph); vi != vi_end; ++vi)
      {
        // Match capabilities and types (no type comparison when no types are
        // given; this can only apply to output nodes or loop managers).
        if ( stringComp(masterGraph[*vi]-&gt;capability(), quantity.first) and
             *vi != toVertex and // No self-resolution
             ( quantity.second == &#34;&#34; or quantity.second == &#34;*&#34; or quantity.second == &#34;any&#34; or
               typeComp(masterGraph[*vi]-&gt;type(), quantity.second, *boundTEs, false) ) )
        {
          // Add vertex to appropriate candidate list
          if (masterGraph[*vi]-&gt;status() &gt; 0)
            vertexCandidates.push_back(*vi);
          // If we only want the list of backends, also add vertex for ini function
          else if (masterGraph[*vi]-&gt;status() == -4 and boundCore-&gt;show_backends)
            vertexCandidates.push_back(*vi);
          // If we only want the list of backends, also add disabled backends whose classes are needed
          else if (masterGraph[*vi]-&gt;status() == -3 and boundCore-&gt;show_backends)
            vertexCandidates.push_back(*vi);
          // Otherwise
          else
            disabledVertexCandidates.push_back(*vi);
        }
      }
      if (vertexCandidates.size() == 0)
      {
        std::ostringstream errmsg;
        errmsg &lt;&lt; &#34;No candidates found while trying to resolve:&#34; &lt;&lt; endl;
        errmsg &lt;&lt; printQuantityToBeResolved(quantity, toVertex) &lt;&lt; endl;
        if (disabledVertexCandidates.size() != 0)
        {
          errmsg &lt;&lt; &#34;\nNote that viable candidates exist but have been disabled:\n&#34;
                 &lt;&lt; printGenericFunctorList(disabledVertexCandidates)
                 &lt;&lt; endl
          &lt;&lt; &#34;Status flags:&#34; &lt;&lt; endl
          &lt;&lt; &#34; 0: This function is not compatible with any model you are scanning.&#34; &lt;&lt; endl
          &lt;&lt; &#34;-3: This function requires a BOSSed class that is missing. The &#34; &lt;&lt; endl
          &lt;&lt; &#34;    backend that provides the class is missing (most likely), the &#34; &lt;&lt; endl
          &lt;&lt; &#34;    class is missing from the backend, or the factory functions&#34; &lt;&lt; endl
          &lt;&lt; &#34;    for this class have not been BOSSed and loaded correctly.&#34; &lt;&lt; endl;
        }
        errmsg &lt;&lt; &#34;Please check your yaml file for typos, and make sure that the&#34; &lt;&lt; endl
        &lt;&lt; &#34;models you are scanning are compatible with at least one function&#34; &lt;&lt; endl
        &lt;&lt; &#34;that provides this capability (they may all have been deactivated&#34; &lt;&lt; endl
        &lt;&lt; &#34;due to having ALLOW_MODELS declarations which are&#34; &lt;&lt; endl
        &lt;&lt; &#34;incompatible with the models selected for scanning).&#34; &lt;&lt; endl;
        dependency_resolver_error().raise(LOCAL_INFO,errmsg.str());
      }

      logger() &lt;&lt; LogTags::dependency_resolver;
      logger() &lt;&lt; &#34;List of candidate vertices:&#34; &lt;&lt; endl;
      logger() &lt;&lt; printGenericFunctorList(vertexCandidates) &lt;&lt; EOM;

      if (toVertex != OBSLIKE_VERTEXID)
      {
        // Make list of all relevant 1st and 2nd level dependency rules.
        const IniParser::ObservablesType &amp; entries = boundIniFile-&gt;getRules();
        for (IniParser::ObservablesType::const_iterator
            it = entries.begin(); it != entries.end(); ++it)
        {
          {
            // Evaluate &#34;dependencies&#34; section
            if (moduleFuncMatchesIniEntry(masterGraph[toVertex], *it, *boundTEs) and
                (it-&gt;capability != &#34;&#34; or it-&gt;function != &#34;&#34; or
                 it-&gt;type != &#34;&#34; or it-&gt;module != &#34;&#34;))
            {
              for (IniParser::ObservablesType::const_iterator
                  it2 = (*it).dependencies.begin();
                  it2 != (*it).dependencies.end(); ++it2)
              {
                if (quantityMatchesIniEntry(quantity, *it2, *boundTEs) and
                    (it2-&gt;capability != &#34;&#34; or it2-&gt;type != &#34;&#34;) and
                    (it2-&gt;function != &#34;&#34; or it2-&gt;module != &#34;&#34;))
                {
                  rules.push_back(Rule(*it2));
                  if (not it-&gt;weakrule and not it2-&gt;weakrule)
                    strong_rules.push_back(Rule(*it2));
                }
              }
            }
            // Evaluate &#34;functionChain:&#34; section
            if (moduleFuncMatchesIniEntry(masterGraph[toVertex], *it, *boundTEs) and
                it-&gt;capability != &#34;&#34; and
                it-&gt;function == &#34;&#34; and
                (*it).functionChain.size() &gt; 1)
            {
              for (auto it2 = (*it).functionChain.begin();
                  it2 != (*it).functionChain.end() - 1; ++it2)
              {
                if ((*it2) == masterGraph[toVertex]-&gt;name())
                {
                  Rule rule(*(it2+1), masterGraph[toVertex]-&gt;origin());
                  rules.push_back(rule);
                  if (not it-&gt;weakrule)
                    strong_rules.push_back(rule);
                }
              }
            }
            // Evaluate second order rules
            if (quantityMatchesIniEntry(quantity, *it, *boundTEs) and
                it-&gt;dependencies.size()==0 and
                (it-&gt;capability != &#34;&#34; or it-&gt;type != &#34;&#34;) and
                (it-&gt;function != &#34;&#34; or it-&gt;module != &#34;&#34;))
            {
              rules.push_back(Rule(*it));
              if (not it-&gt;weakrule)
                strong_rules.push_back(Rule(*it));
            }
          }
        }
      }
      else
      {
        // Add entries in ObsLike and Rules section as 2nd order
        const IniParser::ObservablesType &amp; entries = boundIniFile-&gt;getObservables();
        for (IniParser::ObservablesType::const_iterator it =
            entries.begin(); it != entries.end(); ++it)
        {
          if (quantityMatchesIniEntry(quantity, *it, *boundTEs) and
              (it-&gt;capability != &#34;&#34; or it-&gt;type != &#34;&#34;) and
              (it-&gt;function != &#34;&#34; or it-&gt;module != &#34;&#34;))
          {
            rules.push_back(Rule(*it));
            if (not it-&gt;weakrule)
              strong_rules.push_back(Rule(*it));
          }
          // FIXME: Throw error if dependency or options entry exists
        }
        const IniParser::ObservablesType &amp; entries2 = boundIniFile-&gt;getRules();
        for (IniParser::ObservablesType::const_iterator it =
            entries2.begin(); it != entries2.end(); ++it)
        {
          if (quantityMatchesIniEntry(quantity, *it, *boundTEs) and
              it-&gt;dependencies.size()==0 and
              (it-&gt;capability != &#34;&#34; or it-&gt;type != &#34;&#34;) and
              (it-&gt;function != &#34;&#34; or it-&gt;module != &#34;&#34;))
          {
            rules.push_back(Rule(*it));
            if (not it-&gt;weakrule)
              strong_rules.push_back(Rule(*it));
          }
        }
      }

      logger() &lt;&lt; &#34;Number of identified rules: &#34; &lt;&lt; rules.size() &lt;&lt; endl
               &lt;&lt; &#34;Number of these rules that are marked as !weak: &#34;
               &lt;&lt; rules.size()-strong_rules.size() &lt;&lt; EOM;

      // Make filtered lists
      for (std::vector&lt;DRes::VertexID&gt;::const_iterator
          it = vertexCandidates.begin();
          it != vertexCandidates.end(); it ++)
      {
        bool valid = true;
        for (std::vector&lt;Rule&gt;::const_iterator it2 = rules.begin();
            it2 != rules.end(); it2 ++)
        {
          if ( not matchesRules(masterGraph[*it], *it2) )
          {
            valid = false;
          }
        }
        if (valid)
            filteredVertexCandidates.push_back(*it);
        valid = true;
        for (std::vector&lt;Rule&gt;::const_iterator it2 = strong_rules.begin();
            it2 != strong_rules.end(); it2 ++)
        {
          if ( not matchesRules(masterGraph[*it], *it2) )
          {
            valid = false;
          }
        }
        if (valid)
            filteredVertexCandidates2.push_back(*it);
      }

      if (rules.size() &gt; 0 and filteredVertexCandidates.size() &gt; 0)
      {
        logger() &lt;&lt; &#34;Candidate vertices that fulfill all rules:&#34; &lt;&lt; endl;
        logger() &lt;&lt; printGenericFunctorList(filteredVertexCandidates) &lt;&lt; EOM;
      }

      if (filteredVertexCandidates.size() == 0)
      {
        filteredVertexCandidates = filteredVertexCandidates2;
        logger() &lt;&lt; &#34;Ignoring rules declared as &#39;!weak&#39;&#34; &lt;&lt; endl;
        logger() &lt;&lt; &#34;Candidate vertices that fulfill all non-weak rules:&#34; &lt;&lt; endl;
        logger() &lt;&lt; printGenericFunctorList(filteredVertexCandidates) &lt;&lt; EOM;
      }

      // Apply tailor-made filter
      if (boundIniFile-&gt;getValueOrDef&lt;bool&gt;(
            true, &#34;dependency_resolution&#34;, &#34;prefer_model_specific_functions&#34;)
          and filteredVertexCandidates.size() &gt; 1)
      {
        filteredVertexCandidates = closestCandidateForModel(filteredVertexCandidates);
        logger() &lt;&lt; &#34;A subset of vertex candidates is tailor-made for the scanned model.&#34; &lt;&lt; endl;
        logger() &lt;&lt; &#34;This is used as additional constraint since the YAML rules alone&#34; &lt;&lt; endl;
        logger() &lt;&lt; &#34;are not constraining enough. These vertices are:&#34; &lt;&lt; endl;
        logger() &lt;&lt; printGenericFunctorList(filteredVertexCandidates) &lt;&lt; EOM;
      }

      // Nothing left?
      if ( filteredVertexCandidates.size() == 0 )
      {
        str errmsg = &#34;None of the vertex candidates for&#34;;
        errmsg += &#34;\n&#34; + printQuantityToBeResolved(quantity, toVertex);
        errmsg += &#34;\nfulfills all rules in the YAML file.&#34;;
        errmsg += &#34;\nPlease check your YAML file for contradictory rules, and&#34;;
        errmsg += &#34;\nensure that you have built GAMBIT in the first place with&#34;;
        errmsg += &#34;\nall of the components that you are trying to use.&#34;;
        dependency_resolver_error().raise(LOCAL_INFO,errmsg);
      }

      // Did vertices survive?
      if ( filteredVertexCandidates.size() == 1 )
        return filteredVertexCandidates[0];  // And done!

      str errmsg = &#34;Unfortunately, the dependency resolution for&#34;;
      errmsg += &#34;\n&#34; + printQuantityToBeResolved(quantity, toVertex);
      errmsg += &#34;\nis still ambiguous.\n&#34;;
      errmsg += &#34;\nThe candidate vertices are:\n&#34;;
      errmsg += printGenericFunctorList(vertexCandidates) +&#34;\n&#34;;
      errmsg += &#34;See logger output for details on the attempted (but failed) dependency resolution.\n&#34;;
      errmsg += &#34;\nAn entry in your YAML file that would e.g. select&#34;;
      errmsg += &#34;\nthe first of the above candidates could read &#34;;
      if ( toVertex != OBSLIKE_VERTEXID )
      {
        errmsg += &#34;as a targeted rule (in the Rules section):\n&#34;;
        errmsg += &#34;\n  - capability: &#34;+masterGraph[toVertex]-&gt;capability();
        errmsg += &#34;\n    function: &#34;+masterGraph[toVertex]-&gt;name();
        errmsg += &#34;\n    dependencies:&#34;;
        errmsg += &#34;\n      - capability: &#34; +masterGraph[vertexCandidates[0]]-&gt;capability();
        errmsg += &#34;\n        function: &#34; +masterGraph[vertexCandidates[0]]-&gt;name();
        errmsg += &#34;\n        module: &#34; +masterGraph[vertexCandidates[0]]-&gt;origin() +&#34;\n\nor &#34;;
      }
      errmsg += &#34;as an untargeted rule (in the Rules or ObsLike section):\n&#34;;
      errmsg += &#34;\n  - capability: &#34;+masterGraph[vertexCandidates[0]]-&gt;capability();
      errmsg += &#34;\n    type: &#34;+masterGraph[vertexCandidates[0]]-&gt;type();
      errmsg += &#34;\n    function: &#34;+masterGraph[vertexCandidates[0]]-&gt;name();
      errmsg += &#34;\n    module: &#34; +masterGraph[vertexCandidates[0]]-&gt;origin() +&#34;\n&#34;;
      if ( toVertex == OBSLIKE_VERTEXID )
      {
        errmsg += &#34;\n(Note that 1st class rules are not possible for vertices on which the core depends only.)\n&#34;;
      }

      dependency_resolver_error().raise(LOCAL_INFO,errmsg);

      return 0;
    }

    /// Resolve dependency
    boost::tuple&lt;const IniParser::ObservableType *, DRes::VertexID&gt;
        DependencyResolver::resolveDependency( DRes::VertexID toVertex, sspair quantity)
    {
      graph_traits&lt;DRes::MasterGraphType&gt;::vertex_iterator vi, vi_end;
      const IniParser::ObservableType *auxEntry = NULL;  // Ptr. on ini-file entry of the dependent vertex (if existent)
      const IniParser::ObservableType *depEntry = NULL;  // Ptr. on ini-file entry that specifies how to resolve &#39;quantity&#39;
      std::vector&lt;DRes::VertexID&gt; vertexCandidates;
      bool entryExists = false;  // Ini-file entry to resolve &#39;quantity&#39; found?

      // First, we check whether the dependent vertex has a unique
      // correspondence in the inifile. Final (output) vertices have to be
      // treated different from all other vertices, since they do not appear
      // as dependencies in the rules section of the inifile. For them,
      // we just use the entry from the observable/likelihood section for the
      // resolution of ambiguities.  A pointer to the relevant inifile entry
      // is stored in depEntry.
      if ( toVertex == OBSLIKE_VERTEXID )
      {
        depEntry = findIniEntry(quantity, boundIniFile-&gt;getObservables(), &#34;ObsLike&#34;);
        entryExists = true;
      }
      // for all other vertices use the rules entries
      else
      {
        auxEntry = findIniEntry(toVertex, boundIniFile-&gt;getRules(), &#34;Rules&#34;);
        if ( auxEntry != NULL )
          depEntry = findIniEntry(quantity, (*auxEntry).dependencies, &#34;dependency&#34;);
        if ( auxEntry != NULL and depEntry != NULL )
        {
          entryExists = true;
        }
      }

      // Loop over all available vertices in masterGraph, and make a list of
      // functors that fulfill the dependency requirement.
      for (tie(vi, vi_end) = vertices(masterGraph); vi != vi_end; ++vi)
      {
        // Don&#39;t allow resolution by deactivated functors
        if (masterGraph[*vi]-&gt;status() &gt; 0)
        {
          // Without inifile entry, just match capabilities and types (no type
          // comparison when no types are given; this should only happen for
          // output nodes)
          if ( ( stringComp(masterGraph[*vi]-&gt;capability(), quantity.first) and
                 ( quantity.second == &#34;&#34; or quantity.second == &#34;*&#34; or
                   typeComp(masterGraph[*vi]-&gt;type(), quantity.second, *boundTEs, false) ) )
          // with inifile entry, we check capability, type, function name and
          // module name.
            and ( entryExists ? moduleFuncMatchesIniEntry(masterGraph[*vi], *depEntry, *boundTEs) : true ) )
          {
            // Add to vertex candidate list
            vertexCandidates.push_back(*vi);
          }
        }
      }

      // Die if there is no way to fulfill this dependency.
      if ( vertexCandidates.size() == 0 )
      {
        if ( not entryExists )
        {
            str errmsg = &#34;I could not find any module function that provides &#34;;
            errmsg += quantity.first + &#34; (&#34; + quantity.second + &#34;)&#34;
                +  &#34;\nCheck your inifile for typos, your modules for consistency, etc.&#34;;
            dependency_resolver_error().raise(LOCAL_INFO,errmsg);
        }
        else
        {
            str errmsg = &#34;I could not find any module function that provides &#34;;
            errmsg += quantity.first + &#34; (&#34; + quantity.second + &#34;) [&#34;
                + depEntry-&gt;function + &#34;, &#34; + depEntry-&gt;module + &#34;]&#34;
                +  &#34;\nCheck your inifile for typos, your modules for consistency, etc.&#34;;
            dependency_resolver_error().raise(LOCAL_INFO,errmsg);
        }
      }

      // In case of doubt (and if not explicitely disabled in the ini-file), prefer functors
      // that are more specifically tailored for the model being scanned. Do not consider functors
      // that are accessible via INTERPRET_AS_X links, as these are all considered to be equally &#39;far&#39;
      // from the model being scanned, with the &#39;distance&#39; being one step further than the most distant
      // ancestor.
      if ( vertexCandidates.size() &gt; 1 and boundIniFile-&gt;getValueOrDef&lt;bool&gt;(true, &#34;dependency_resolution&#34;, &#34;prefer_model_specific_functions&#34;) )
      {
        // Work up the model ancestry one step at a time, and stop as soon as one or more valid model-specific functors is
        // found at a given level in the hierarchy.
        std::vector&lt;DRes::VertexID&gt; newVertexCandidates;
        std::set&lt;str&gt; s = boundClaw-&gt;get_activemodels();
        std::vector&lt;str&gt; parentModelList(s.begin(), s.end());
        while (newVertexCandidates.size() == 0 and not parentModelList.empty())
        {
          for (std::vector&lt;str&gt;::iterator mit = parentModelList.begin(); mit != parentModelList.end(); ++mit)
          {
            // Test each vertex candidate to see if it has been explicitly set up to work with the model *mit
            for (std::vector&lt;DRes::VertexID&gt;::iterator it = vertexCandidates.begin(); it != vertexCandidates.end(); ++it)
            {
              if ( masterGraph[*it]-&gt;modelExplicitlyAllowed(*mit) ) newVertexCandidates.push_back(*it);
            }
            // Step up a level in the model hierarchy for this model.
            *mit = boundClaw-&gt;get_parent(*mit);
          }
          parentModelList.erase(std::remove(parentModelList.begin(), parentModelList.end(), &#34;none&#34;), parentModelList.end());
        }
        if (newVertexCandidates.size() != 0) vertexCandidates = newVertexCandidates;
      }

      if ( vertexCandidates.size() &gt; 1 )
      {
        str errmsg = &#34;&#34;;
        if ( not entryExists )
        {
            errmsg += &#34;I found too many module functions that provide &#34;;
            errmsg += quantity.first + &#34; (&#34; + quantity.second + &#34;)&#34;
                +  &#34;\nCheck your inifile for typos, your modules for consistency, etc.&#34;;
        }
        else
        {
            errmsg += &#34;I found too many module functions that provide &#34;;
            errmsg += quantity.first + &#34; (&#34; + quantity.second + &#34;) \n&#34;
                + &#34;\nneeded by &#34; + depEntry-&gt;module + &#34;::&#34; + depEntry-&gt;function
                +  &#34;\nCheck your inifile for typos, your modules for consistency, etc.&#34;;
        }
        if (not boundIniFile-&gt;getValueOrDef&lt;bool&gt;(true, &#34;dependency_resolution&#34;, &#34;prefer_model_specific_functions&#34;))
         errmsg += &#34;\nAlso consider turning on prefer_model_specific_functions in your inifile.&#34;;
        errmsg += &#34;\nCandidate module functions are:&#34;;
        for (std::vector&lt;DRes::VertexID&gt;::iterator it = vertexCandidates.begin(); it != vertexCandidates.end(); ++it)
        {
            errmsg += &#34;\n   [&#34; + masterGraph[*it]-&gt;name() + &#34;,&#34; + masterGraph[*it]-&gt;origin() + &#34;]&#34;;
        }
        dependency_resolver_error().raise(LOCAL_INFO,errmsg);
      }

      return boost::tie(depEntry, vertexCandidates[0]);
    }

    /// Set up dependency tree
    void DependencyResolver::generateTree( std::queue&lt;QueueEntry&gt; parQueue)
    {
      OutputVertexInfo outInfo;
      DRes::VertexID fromVertex, toVertex;
      DRes::EdgeID edge;
      // Inifile entry of ObsLike (if relevant)
      const IniParser::ObservableType * iniEntry;
      bool ok;
      sspair quantity;
      int dependency_type;
      bool printme;

      logger() &lt;&lt; LogTags::dependency_resolver &lt;&lt; endl;
      logger() &lt;&lt; &#34;################################################&#34; &lt;&lt; endl;
      logger() &lt;&lt; &#34;#         Starting dependency resolution       #&#34; &lt;&lt; endl;
      logger() &lt;&lt; &#34;#                                              #&#34; &lt;&lt; endl;
      logger() &lt;&lt; &#34;# format: Capability (Type) [Function, Module] #&#34; &lt;&lt; endl;
      logger() &lt;&lt; &#34;################################################&#34; &lt;&lt; EOM;

      // Print something to stdout as well
      #ifdef DEPRES_DEBUG
        std::cout &lt;&lt; &#34;Resolving dependency graph...&#34; &lt;&lt; std::endl;
      #endif

      // Read ini entries
      use_regex      = boundIniFile-&gt;getValueOrDef&lt;bool&gt;(true,  &#34;dependency_resolution&#34;, &#34;use_regex&#34;);
      print_timing   = boundIniFile-&gt;getValueOrDef&lt;bool&gt;(false, &#34;print_timing_data&#34;);
      print_unitcube = boundIniFile-&gt;getValueOrDef&lt;bool&gt;(false, &#34;print_unitcube&#34;);

      if ( use_regex      ) logger() &lt;&lt; &#34;Using regex for string comparison.&#34; &lt;&lt; endl;
      if ( print_timing   ) logger() &lt;&lt; &#34;Will output timing information for all functors (via printer system)&#34; &lt;&lt; EOM;
      if ( print_unitcube ) logger() &lt;&lt; &#34;Printing of unitCubeParameters will be enabled.&#34; &lt;&lt; EOM;

      //
      // Main loop: repeat until dependency queue is empty
      //

      while (not parQueue.empty())
      {

        // Retrieve capability, type and vertex ID of dependency of interest
        quantity = parQueue.front().first;  // (capability, type) pair
        toVertex = parQueue.front().second;  // dependent vertex
        dependency_type = parQueue.front().third;  // Normal or loop-manager
        printme = parQueue.front().printme;  // bool

        // Print information about required quantity and dependent vertex
        logger() &lt;&lt; LogTags::dependency_resolver;
        logger() &lt;&lt; &#34;Resolving &#34;;
        logger() &lt;&lt; printQuantityToBeResolved(quantity, toVertex) &lt;&lt; endl &lt;&lt; endl;

        // Extra verbose output to terminal
        #ifdef VERBOSE_DEP_RES
        std::cout &lt;&lt; &#34;Resolving dependency &#34;&lt;&lt;printQuantityToBeResolved(quantity, toVertex)&lt;&lt;&#34;...&#34; &lt;&lt;std::endl;
        #endif

        // Check that ObsLike vertices have non-empty capability
        if ( toVertex == OBSLIKE_VERTEXID and quantity.first == &#34;&#34; )
        {
          str errmsg = &#34;ObsLike entry without without capability &#34;
                       &#34;information encountered.\n&#34;;
          dependency_resolver_error().raise(LOCAL_INFO,errmsg);
        }

        // Figure out how to resolve dependency
        if ( boundIniFile-&gt;getValueOrDef&lt;bool&gt;(false, &#34;dependency_resolution&#34;, &#34;use_old_routines&#34;) )
        {
          boost::tie(iniEntry, fromVertex) = resolveDependency(toVertex, quantity);
        }
        else
        {
          fromVertex = resolveDependencyFromRules(toVertex, quantity);
        }

        // Print user info.
        logger() &lt;&lt; LogTags::dependency_resolver;
        logger() &lt;&lt; &#34;Resolved by: [&#34;;
        logger() &lt;&lt; (*masterGraph[fromVertex]).name() &lt;&lt; &#34;, &#34;;
        logger() &lt;&lt; (*masterGraph[fromVertex]).origin() &lt;&lt; &#34;]&#34; &lt;&lt; endl;

        // Extra verbose output to terminal
        #ifdef VERBOSE_DEP_RES
        std::cout &lt;&lt; &#34;   ...resolved by [&#34;&lt;&lt;(*masterGraph[fromVertex]).name()&lt;&lt;&#34;, &#34;&lt;&lt;(*masterGraph[fromVertex]).origin()&lt;&lt;&#34;]&#34;&lt;&lt;std::endl;
        #endif

        // Check if we wanted to output this observable to the printer system.
        if ( toVertex==OBSLIKE_VERTEXID ) masterGraph[fromVertex]-&gt;setPrintRequirement(printme);
        // Check if the flag to output timing data is set
        if(print_timing) masterGraph[fromVertex]-&gt;setTimingPrintRequirement(true);

        // Apply resolved dependency to masterGraph and functors
        if ( toVertex != OBSLIKE_VERTEXID )
        {
          // Resolve dependency on functor level...
          //
          // In case the fromVertex is a loop manager, store nested function
          // temporarily in loopManagerMap (they have to be sorted later)
          if (dependency_type == LOOP_MANAGER_DEPENDENCY)
          {
            // Check whether fromVertex is allowed to manage loops
            if (not masterGraph[fromVertex]-&gt;canBeLoopManager())
            {
              str errmsg = &#34;Trying to resolve dependency on loop manager with\n&#34;
               &#34;module function that is not declared as loop manager.\n&#34;
               + printGenericFunctorList(initVector&lt;functor*&gt;(masterGraph[fromVertex]));
              dependency_resolver_error().raise(LOCAL_INFO,errmsg);
            }
            std::set&lt;DRes::VertexID&gt; v;
            if (loopManagerMap.count(fromVertex) == 1)
            {
              v = loopManagerMap[fromVertex];
            }
            v.insert(toVertex);
            loopManagerMap[fromVertex] = v;
            (*masterGraph[toVertex]).resolveLoopManager(masterGraph[fromVertex]);

            // Take any dependencies of loop-managed vertices that have already been resolved,
            // and add them as &#34;hidden&#34; dependencies to this loop manager.
            if (edges_to_force_on_manager.find(toVertex) != edges_to_force_on_manager.end())
            {
              for (auto it = edges_to_force_on_manager.at(toVertex).begin();
                   it != edges_to_force_on_manager.at(toVertex).end(); ++it)
              {
                logger() &lt;&lt; &#34;Dynamically adding dependency of &#34; &lt;&lt; (*masterGraph[fromVertex]).origin()
                         &lt;&lt; &#34;::&#34; &lt;&lt; (*masterGraph[fromVertex]).name() &lt;&lt; &#34; on &#34;
                         &lt;&lt; (*masterGraph[*it]).origin() &lt;&lt; &#34;::&#34; &lt;&lt; (*masterGraph[*it]).name() &lt;&lt; endl;
                boost::tie(edge, ok) = add_edge(*it, fromVertex, masterGraph);
              }
            }
          }
          // Default is to resolve dependency on functor level of toVertex
          else
          {
            (*masterGraph[toVertex]).resolveDependency(masterGraph[fromVertex]);
          }
          // ...and on masterGraph level.
          boost::tie(edge, ok) = add_edge(fromVertex, toVertex, masterGraph);

          // In the case that toVertex is a nested function, add fromVertex to
          // the edges of toVertex&#39;s loop manager.
          str to_lmcap = (*masterGraph[toVertex]).loopManagerCapability();
          str to_lmtype = (*masterGraph[toVertex]).loopManagerType();
          str from_lmcap = (*masterGraph[fromVertex]).loopManagerCapability();
          str from_lmtype = (*masterGraph[fromVertex]).loopManagerType();
          bool is_same_lmcap = to_lmcap == from_lmcap;
          bool is_same_lmtype = to_lmtype == &#34;any&#34; or from_lmtype == &#34;any&#34; or to_lmtype == from_lmtype;
          if (to_lmcap != &#34;none&#34;)
          {
            // This function runs nested.  Check if its loop manager has been resolved yet.
            if ((*masterGraph[toVertex]).loopManagerName() == &#34;none&#34;)
            {
              // toVertex&#39;s loop manager has not yet been determined.
              // Add the edge to the list to deal with when the loop manager dependency is resolved,
              // as long as toVertex and fromVertex cannot end up inside the same loop.
              if (!is_same_lmcap or !is_same_lmtype)
              {
                if (edges_to_force_on_manager.find(toVertex) == edges_to_force_on_manager.end())
                 edges_to_force_on_manager[toVertex] = std::set&lt;DRes::VertexID&gt;();
                edges_to_force_on_manager.at(toVertex).insert(fromVertex);
              }
            }
            else
            {
              // toVertex&#39;s loop manager has already been resolved.
              // If fromVertex is not the manager itself, and is not
              // itself a nested function that has the possibility to
              // end up in the same loop as toVertex, then add
              // fromVertex as an edge of the manager.
              str name = (*masterGraph[toVertex]).loopManagerName();
              str origin = (*masterGraph[toVertex]).loopManagerOrigin();
              bool is_itself = (name == (*masterGraph[fromVertex]).name() and origin == (*masterGraph[fromVertex]).origin());
              if (!is_itself and (!is_same_lmcap or !is_same_lmtype) )
              {
                // Hunt through the edges of toVertex and find the one that corresponds to its loop manager.
                graph_traits&lt;DRes::MasterGraphType&gt;::in_edge_iterator ibegin, iend;
                boost::tie(ibegin, iend) = in_edges(toVertex, masterGraph);
                if (ibegin != iend)
                {
                  DRes::VertexID managerVertex;
                  for (; ibegin != iend; ++ibegin)
                  {
                    managerVertex = source(*ibegin, masterGraph);
                    if ((*masterGraph[managerVertex]).name() == name and
                        (*masterGraph[managerVertex]).origin() == origin) break;
                  }
                  logger() &lt;&lt; &#34;Dynamically adding dependency of &#34; &lt;&lt; (*masterGraph[managerVertex]).origin()
                           &lt;&lt; &#34;::&#34; &lt;&lt; (*masterGraph[managerVertex]).name() &lt;&lt; &#34; on &#34;
                           &lt;&lt; (*masterGraph[fromVertex]).origin() &lt;&lt; &#34;::&#34; &lt;&lt; (*masterGraph[fromVertex]).name() &lt;&lt; endl;
                  boost::tie(edge, ok) = add_edge(fromVertex, managerVertex, masterGraph);
                }
                else
                {
                  core_error().raise(LOCAL_INFO, &#34;toVertex has no edges! So its loop manager hasn&#39;t been added as a dependency?!&#34;);
                }
              }
            }
          }
        }
        else // if output vertex
        {
          iniEntry = findIniEntry(quantity, boundIniFile-&gt;getObservables(), &#34;ObsLike&#34;);
          outInfo.vertex = fromVertex;
          outInfo.iniEntry = iniEntry;
          outputVertexInfos.push_back(outInfo);
          // Don&#39;t need subcaps during dry-run
          if (not boundCore-&gt;show_runorder)
          {
            Options mySubCaps = collectSubCaps(fromVertex);
            masterGraph[fromVertex]-&gt;notifyOfSubCaps(mySubCaps);
          }
        }

        // If fromVertex is new, activate it
        if ( (*masterGraph[fromVertex]).status() != 2 )
        {
          logger() &lt;&lt; LogTags::dependency_resolver &lt;&lt; &#34;Activate new module function&#34; &lt;&lt; endl;
          masterGraph[fromVertex]-&gt;setStatus(2); // activate node
          resolveVertexBackend(fromVertex);
          resolveVertexClassLoading(fromVertex);

          // Don&#39;t need options during dry-run, so skip this (just to simplify terminal output)
          if(not boundCore-&gt;show_runorder)
          {
            if ( boundIniFile-&gt;getValueOrDef&lt;bool&gt;( false, &#34;dependency_resolution&#34;, &#34;use_old_routines&#34;) )
            {
              // Generate options object from ini-file entry that corresponds to
              // fromVertex (overwrite iniEntry) and pass it to the fromVertex for later use
              iniEntry = findIniEntry(fromVertex, boundIniFile-&gt;getRules(), &#34;Rules&#34;);
              if ( iniEntry != NULL )
              {
                Options myOptions(iniEntry-&gt;options);
                masterGraph[fromVertex]-&gt;notifyOfIniOptions(myOptions);
              }
            }
            else
            {
              Options myOptions = collectIniOptions(fromVertex);
              masterGraph[fromVertex]-&gt;notifyOfIniOptions(myOptions);
            }
          }
          // Fill parameter queue with dependencies of fromVertex
          fillParQueue(&amp;parQueue, fromVertex);
        }

        // Done.
        logger() &lt;&lt; EOM;
        parQueue.pop();
      }
    }

    /// Push module function dependencies onto the parameter queue
    void DependencyResolver::fillParQueue( std::queue&lt;QueueEntry&gt; *parQueue,
            DRes::VertexID vertex)
    {
      // Set the default printing flag for functors to pass to the parQueue constructor.
      bool printme_default = false;

      // Tell the logger what the following messages are about.
      logger() &lt;&lt; LogTags::dependency_resolver;

      // Digest capability of loop manager (if defined)
      str lmcap = (*masterGraph[vertex]).loopManagerCapability();
      str lmtype = (*masterGraph[vertex]).loopManagerType();
      if (lmcap != &#34;none&#34;)
      {
        logger() &lt;&lt; &#34;Adding module function loop manager to resolution queue:&#34; &lt;&lt; endl;
        logger() &lt;&lt; lmcap &lt;&lt; &#34; ()&#34; &lt;&lt; endl;
        parQueue-&gt;push(QueueEntry(sspair(lmcap, lmtype), vertex, LOOP_MANAGER_DEPENDENCY, printme_default));
      }

      // Digest regular dependencies
      std::set&lt;sspair&gt; s = (*masterGraph[vertex]).dependencies();
      if (s.size() &gt; 0) logger() &lt;&lt; &#34;Add dependencies of new module function to queue&#34; &lt;&lt; endl;
      for (std::set&lt;sspair&gt;::iterator it = s.begin(); it != s.end(); ++it)
      {
        // If the loop manager requirement exists and is type-specific, it is a true depencency,
        // and thus appears in the output of functor.dependencies(). So, we need to take care
        // not to double-count it for entry into the parQueue.
        if (lmcap == &#34;none&#34; or lmtype == &#34;any&#34; or lmcap != it-&gt;first or lmtype != it-&gt;second)
        {
          logger() &lt;&lt; it-&gt;first &lt;&lt; &#34; (&#34; &lt;&lt; it-&gt;second &lt;&lt; &#34;)&#34; &lt;&lt; endl;
          parQueue-&gt;push(QueueEntry(*it, vertex, NORMAL_DEPENDENCY, printme_default));
        }
      }

      // Tell the logger we&#39;re done here.
      logger() &lt;&lt; EOM;
    }

    /// Boost lib topological sort
    std::list&lt;VertexID&gt; DependencyResolver::run_topological_sort()
    {
      std::list&lt;VertexID&gt; topo_order;
      topological_sort(masterGraph, front_inserter(topo_order));
      return topo_order;
    }

    /// Find rules entry that matches vertex
    const IniParser::ObservableType * DependencyResolver::findIniEntry(DRes::VertexID toVertex,
     const IniParser::ObservablesType &amp;entries, const str &amp; errtag)
    {
      std::vector&lt;const IniParser::ObservableType*&gt; auxEntryCandidates;
      for (IniParser::ObservablesType::const_iterator it =
          entries.begin(); it != entries.end(); ++it)
      {
        if ( moduleFuncMatchesIniEntry(masterGraph[toVertex], *it, *boundTEs) and it-&gt;capability != &#34;&#34; )
        {
          auxEntryCandidates.push_back(&amp;(*it));
        }
      }
      if ( auxEntryCandidates.size() == 0 ) return NULL;
      else if ( auxEntryCandidates.size() != 1 )
      {
        str errmsg = &#34;Found multiple &#34; + errtag + &#34; entries for &#34;;
        errmsg += masterGraph[toVertex]-&gt;capability() +&#34; (&#34; +
            masterGraph[toVertex]-&gt;type() + &#34;) [&#34; +
            masterGraph[toVertex]-&gt;name() + &#34;, &#34; +
            masterGraph[toVertex]-&gt;origin() + &#34;]&#34;;
        dependency_resolver_error().raise(LOCAL_INFO, errmsg);
      }
      return auxEntryCandidates[0]; // auxEntryCandidates.size() == 1
    }

    /// Find observable entry that matches capability/type
    const IniParser::ObservableType* DependencyResolver::findIniEntry(
            sspair quantity, const IniParser::ObservablesType &amp; entries, const str &amp; errtag)
    {
      std::vector&lt;const IniParser::ObservableType*&gt; obsEntryCandidates;
      for (IniParser::ObservablesType::const_iterator it =
          entries.begin(); it != entries.end(); ++it)
      {
        if ( capabilityMatchesIniEntry(quantity, *it) ) // use same criteria than for normal dependencies
        {
          obsEntryCandidates.push_back(&amp;(*it));
        }
      }
      if ( obsEntryCandidates.size() == 0 ) return NULL;
      else if ( obsEntryCandidates.size() != 1 )
      {
        str errmsg = &#34;Found multiple &#34; + errtag + &#34; entries for &#34;;
        errmsg += quantity.first + &#34; (&#34; + quantity.second + &#34;)&#34;;
        dependency_resolver_error().raise(LOCAL_INFO,errmsg);
      }
      return obsEntryCandidates[0]; // obsEntryCandidates.size() == 1
    }

    /// Node-by-node backend resolution
    void DependencyResolver::resolveVertexBackend(VertexID vertex)
    {
      functor* solution;
      std::vector&lt;functor*&gt; previous_successes;
      std::set&lt;str&gt; remaining_groups;
      std::set&lt;sspair&gt; remaining_reqs;
      bool allow_deferral = true;

      // If there are no backend requirements, and thus nothing to do, return.
      if ((*masterGraph[vertex]).backendreqs().size() == 0) return;

      // Get started.
      logger() &lt;&lt; LogTags::dependency_resolver &lt;&lt; &#34;Doing backend function resolution...&#34; &lt;&lt; EOM;

      // Check whether this vertex is mentioned in the inifile.
      const IniParser::ObservableType * auxEntry = findIniEntry(vertex, boundIniFile-&gt;getRules(), &#34;Rules&#34;);

      // Collect the list of groups that the backend requirements of this vertex exist in.
      std::set&lt;str&gt; groups = (*masterGraph[vertex]).backendgroups();

      // Collect the list of orphan (i.e. groupless) backend requirements.
      std::set&lt;sspair&gt; orphan_reqs = (*masterGraph[vertex]).backendreqs(&#34;none&#34;);

      // Loop until no further backend resolutions are possible, or no more are required.
      while ( not ( groups.empty() and orphan_reqs.empty() ) )
      {

        // Loop over all groups, including the null group (group=&#34;none&#34;).
        for (std::set&lt;str&gt;::iterator it = groups.begin(); it != groups.end(); ++it)
        {
          // Switch depending on whether this is a real group or not.
          if (*it == &#34;none&#34;)
          {
            // Loop over all the orphan requirements.
            for (std::set&lt;sspair&gt;::iterator req = orphan_reqs.begin(); req != orphan_reqs.end(); ++req)
            {
              logger() &lt;&lt; LogTags::dependency_resolver;
              logger() &lt;&lt; &#34;Resolving ungrouped requirement &#34; &lt;&lt; req-&gt;first;
              logger() &lt;&lt; &#34; (&#34; &lt;&lt; req-&gt;second &lt;&lt; &#34;)...&#34; &lt;&lt; EOM;

              // Find a backend function that fulfills the backend requirement.
              std::set&lt;sspair&gt; reqsubset;
              reqsubset.insert(*req);
              solution = solveRequirement(reqsubset,auxEntry,vertex,previous_successes,allow_deferral);

              // Check if a valid solution has been returned
              if (solution != NULL)
              {
                // It has, so resolve the backend requirement with that function and add it to the list of successful resolutions.
                resolveRequirement(solution,vertex);
                previous_successes.push_back(solution);

                // If *req is in remaining_reqs, remove it
                if (remaining_reqs.find(*req) != remaining_reqs.end())
                {
                  remaining_reqs.erase(*req);
                }
              }
              else // No valid solution found, but deferral has been suggested - so defer resolution of this group until later.
              {
                remaining_reqs.insert(*req);
                logger() &lt;&lt; LogTags::dependency_resolver;
                logger() &lt;&lt; &#34;Resolution of ungrouped requirement &#34; &lt;&lt; req-&gt;first;
                logger() &lt;&lt; &#34; (&#34; &lt;&lt; req-&gt;second &lt;&lt; &#34;) deferred until later.&#34; &lt;&lt; EOM;
              }
            }
            if (not remaining_reqs.empty()) remaining_groups.insert(*it);
          }
          else
          {
            logger() &lt;&lt; LogTags::dependency_resolver;
            logger() &lt;&lt; &#34;Resolving from group &#34; &lt;&lt; *it &lt;&lt; &#34;...&#34; &lt;&lt; EOM;

            // Collect the list of backend requirements in this group.
            std::set&lt;sspair&gt; reqs = (*masterGraph[vertex]).backendreqs(*it);

            // Find a backend function that fulfills one of the backend requirements in the group.
            solution = solveRequirement(reqs,auxEntry,vertex,previous_successes,allow_deferral,*it);

            // Check if a valid solution has been returned
            if (solution != NULL)
            {
              // It has, so resolve the backend requirement with that function and add it to the list of successful resolutions.
              resolveRequirement(solution,vertex);
              previous_successes.push_back(solution);
            }
            else // No valid solution found, but deferral has been suggested - so defer resolution of this group until later.
            {
              remaining_groups.insert(*it);
              logger() &lt;&lt; LogTags::dependency_resolver;
              logger() &lt;&lt; &#34;Resolution from group &#34; &lt;&lt; *it;
              logger() &lt;&lt; &#34;deferred until later.&#34; &lt;&lt; EOM;
            }
          }
        }

        // If there has been no improvement this round, turn off deferral and make the next round the last attempt.
        if (orphan_reqs == remaining_reqs and groups == remaining_groups)
        {
          allow_deferral = false;
        }
        else // Otherwise try again to resolve the remaining groups and orphan requirements, now that some others are known.
        {
          orphan_reqs = remaining_reqs;
          groups = remaining_groups;
          remaining_reqs.clear();
          remaining_groups.clear();
        }

      }

    }

    /// Find a backend function that matches any one of a vector of capability-type pairs.
    functor* DependencyResolver::solveRequirement(std::set&lt;sspair&gt; reqs,
     const IniParser::ObservableType * auxEntry, VertexID vertex, std::vector&lt;functor*&gt; previous_successes,
     bool allow_deferral, str group)
    {
      std::vector&lt;functor*&gt; vertexCandidates;
      std::vector&lt;functor*&gt; vertexCandidatesWithIniEntry;
      std::vector&lt;functor*&gt; disabledVertexCandidates;

      // Loop over all existing backend vertices, and make a list of
      // functors that are available and fulfill the backend requirement
      for (std::vector&lt;functor *&gt;::const_iterator
          itf  = boundCore-&gt;getBackendFunctors().begin();
          itf != boundCore-&gt;getBackendFunctors().end();
          ++itf)
      {
        const IniParser::ObservableType * reqEntry = NULL;
        bool entryExists = false;

        // Find relevant iniFile entry from Rules section
        if ( auxEntry != NULL ) reqEntry = findIniEntry((*itf)-&gt;quantity(), (*auxEntry).backends, &#34;backend&#34;);
        if ( reqEntry != NULL) entryExists = true;

        // Look for a match to at least one backend requirement, taking into account type equivalency classes.
        bool simple_match = false;
        for (std::set&lt;sspair&gt;::const_iterator
             itr  = reqs.begin();
             itr != reqs.end();
             ++itr)
        {
          if ((*itf)-&gt;capability() == itr-&gt;first and typeComp((*itf)-&gt;type(), itr-&gt;second, *boundTEs))
          {
            simple_match = true;
            break;
          }
        }

        // If there is a relevant inifile entry, we also check for a match to the capability, type, function name and backend name in that entry.
        if ( simple_match and ( entryExists ? backendFuncMatchesIniEntry(*itf, *reqEntry, *boundTEs) : true ) )
        {

          // Has the backend vertex already been disabled by the backend system?
          bool disabled = ( (*itf)-&gt;status() &lt;= 0 );

          // Is it permitted to be used to fill this backend requirement?
          // First we create the backend-version pair for the backend vertex and its semi-generic form (where any version is OK).
          sspair itf_signature((*itf)-&gt;origin(), (*itf)-&gt;version());
          sspair itf_generic((*itf)-&gt;origin(), &#34;any&#34;);
          // Then we find the set of backend-version pairs that are permitted.
          std::set&lt;sspair&gt; permitted_bes = (*masterGraph[vertex]).backendspermitted((*itf)-&gt;quantity());
          // Then we see if any match.  First we test for generic matches, where any version of any backend is allowed.
          bool permitted = ( permitted_bes.empty()
          // Next we test for semi-generic matches, where the backend matches and any version of that backend is allowed.
          or std::find(permitted_bes.begin(), permitted_bes.end(), itf_generic) != permitted_bes.end()
          // Finally we test for specific matches, where both the backend and version match what is allowed.
          or std::find(permitted_bes.begin(), permitted_bes.end(), itf_signature) != permitted_bes.end() );

          // If the backend vertex is able and allowed,
          if (permitted and not disabled)
          {
            // add it to the overall vertex candidate list
            vertexCandidates.push_back(*itf);
            // if it has an inifile entry, add it to the candidate list with inifile entries
            if (entryExists) vertexCandidatesWithIniEntry.push_back(*itf);
          }
          else if (permitted and boundCore-&gt;show_backends) // If the backend is able and we only want to show the list of backends
          {
             // add it to the overall vertex candidate list
            vertexCandidates.push_back(*itf);
            // if it has an inifile entry, add it to the candidate list with inifile entries
            if (entryExists) vertexCandidatesWithIniEntry.push_back(*itf);
          }
          else
          {
            // otherwise, add it to disabled vertex candidate list
            if (not disabled) (*itf)-&gt;setStatus(1);
            disabledVertexCandidates.push_back(*itf);
          }
        }
      }

      // If too many candidates, prefer those with entries in the inifile.
      if (vertexCandidates.size() &gt; 1 and vertexCandidatesWithIniEntry.size() &gt;= 1)
      {
        // Loop over the remaining candidates, and disable those without entries in the inifile.
        for (std::vector&lt;functor *&gt;::iterator it = vertexCandidates.begin(); it != vertexCandidates.end(); ++it)
        {
          if (std::find(vertexCandidatesWithIniEntry.begin(), vertexCandidatesWithIniEntry.end(), *it) == vertexCandidatesWithIniEntry.end() )
            disabledVertexCandidates.push_back(*it);
        }
        // Set the new list of vertex candidates to be only those with inifile entries.
        vertexCandidates = vertexCandidatesWithIniEntry;
      }

      // Purge all candidates that conflict with a backend-matching rule.
      // Start by making a new vector to hold the candidates that survive the purge.
      std::vector&lt;functor *&gt; survivingVertexCandidates;
      // Loop over the current candidates.
      for (std::vector&lt;functor *&gt;::const_iterator it = vertexCandidates.begin(); it != vertexCandidates.end(); ++it)
      {
        // Set up a flag to keep track of whether anything has indicated that the candidate should be thrown out.
        bool keeper = true;
        // Retrieve the tags of the candidate.
        std::set&lt;str&gt; tags = (*masterGraph[vertex]).backendreq_tags((*it)-&gt;quantity());
        // Loop over the tags
        for (std::set&lt;str&gt;::iterator tagit = tags.begin(); tagit != tags.end(); ++tagit)
        {
          // Find out which other backend requirements exhibiting this tag must be filled from the same backend as the req this candidate would fill.
          std::set&lt;sspair&gt; must_match = (*masterGraph[vertex]).forcematchingbackend(*tagit);
          // Set up a flag to keep track of whether any of the other backend reqs have already been filled.
          bool others_filled = false;
          // Set up a string to keep track of which backend the other backend reqs have been filled from (if any).
          str common_backend_and_version;
          // Loop over the other backend reqs.
          for (std::set&lt;sspair&gt;::iterator mit = must_match.begin(); mit != must_match.end(); ++mit)
          {
            // Set up a flag to indicate if the other backend req in question has been filled yet.
            bool other_filled = false;
            // Set up a string to keep track of which backend the other backend req in question has been filled from (if any).
            str filled_from;
            // Loop over the backend functors that have successfully filled backend reqs already for this funcition
            for (std::vector&lt;functor*&gt;::const_iterator
                 itf  = previous_successes.begin();
                 itf != previous_successes.end();
                 ++itf)
            {
              // Check if the current previous successful resolution (itf) was of the same backend requirement as the
              // current one of the backend requirements (mit) that must be filled from the same backend as the current candidate (it).
              if ((*itf)-&gt;quantity() == *mit)
              {
                // Note that mit (the current backend req that must be filled from the same backend as the current candidate) has indeed been filled, by itf
                other_filled = true;
                // Note which backend mit has been filled from (i.e. where does itf come from?)
                filled_from = (*itf)-&gt;origin() + &#34; v&#34; + (*itf)-&gt;version();
                break;
              }
            }
            // If the other req has been filled, updated the tracker of whether any of the reqs linked to this flag have been filled,
            // and compare the filling backend to the one used to fill any other reqs associated with this tag.
            if (other_filled)
            {
              others_filled = true;
              if (common_backend_and_version.empty()) common_backend_and_version = filled_from; // Save the filling backend
              if (filled_from != common_backend_and_version) // Something buggy has happened and the rule is already broken(!)
              {
                str errmsg = &#34;A backend-matching rule has been violated!&#34;;
                errmsg  += &#34;\nFound whilst checking which backends have been used&#34;
                           &#34;\nto fill requirements with tag &#34; + *tagit + &#34; in function &#34;
                           &#34;\n&#34; + (*masterGraph[vertex]).name() + &#34; of &#34; + (*masterGraph[vertex]).origin() + &#34;.&#34;
                           &#34;\nOne requirement was filled from &#34; + common_backend_and_version + &#34;, &#34;
                           &#34;\nwhereas another was filled from &#34; + filled_from + &#34;.&#34;
                           &#34;\nThis should not happen and is probably a bug in GAMBIT.&#34;;
                dependency_resolver_error().raise(LOCAL_INFO,errmsg);
              }
            }
          }
          // Try to keep this candidate if it comes from the same backend as those already filled, or if none of the others are filled yet.
          keeper = (not others_filled or common_backend_and_version == (*it)-&gt;origin() + &#34; v&#34; + (*it)-&gt;version());
          if (not keeper) break;
        }
        if (keeper) survivingVertexCandidates.push_back(*it); else disabledVertexCandidates.push_back(*it);
      }
      // Replace the previous list of candidates with the survivors.
      vertexCandidates = survivingVertexCandidates;

      // Only print the status flags -5 or -6 if any of the disabled vertices has it
      bool printMathematicaStatus = false;
      for(unsigned int j=0; j &lt; disabledVertexCandidates.size(); j++)
        if(disabledVertexCandidates[j]-&gt;status() == -5)
          printMathematicaStatus = true;
      bool printPythonStatus = false;
      for(unsigned int j=0; j &lt; disabledVertexCandidates.size(); j++)
        if(disabledVertexCandidates[j]-&gt;status() == -6)
          printPythonStatus = true;

      // No candidates? Death.
      if (vertexCandidates.size() == 0)
      {
        std::ostringstream errmsg;
        errmsg
          &lt;&lt; &#34;Found no candidates for backend requirements of &#34;
          &lt;&lt; masterGraph[vertex]-&gt;origin() &lt;&lt; &#34;::&#34; &lt;&lt; masterGraph[vertex]-&gt;name() &lt;&lt; &#34;:\n&#34;
          &lt;&lt; reqs &lt;&lt; &#34;\nfrom group: &#34; &lt;&lt; group;
        if (disabledVertexCandidates.size() != 0)
        {
          errmsg &lt;&lt; &#34;\nNote that viable candidates exist but have been disabled:\n&#34;
                 &lt;&lt;     printGenericFunctorList(disabledVertexCandidates)
                 &lt;&lt; endl
                 &lt;&lt; &#34;Status flags:&#34; &lt;&lt; endl
                 &lt;&lt; &#34; 1: This function is available, but the backend version is not compatible with all your requests.&#34; &lt;&lt; endl
                 &lt;&lt; &#34; 0: This function is not compatible with any model you are scanning.&#34; &lt;&lt; endl
                 &lt;&lt; &#34;-1: The backend that provides this function is missing.&#34; &lt;&lt; endl
                 &lt;&lt; &#34;-2: The backend is present, but function is absent or broken.&#34; &lt;&lt; endl;
         if(printMathematicaStatus)
            errmsg &lt;&lt; &#34;-5: The backend requires Mathematica, but Mathematica is absent.&#34; &lt;&lt; endl;
         if(printPythonStatus)
            errmsg &lt;&lt; &#34;-6: The backend requires Python, but pybind11 is absent.&#34; &lt;&lt; endl;
          errmsg &lt;&lt; endl
                 &lt;&lt; &#34;Make sure to check your YAML file, especially the rules&#34; &lt;&lt; endl
                 &lt;&lt; &#34;pertaining to backends.&#34;  &lt;&lt; endl
                 &lt;&lt; endl
                 &lt;&lt; &#34;Please also check that all shared objects exist for the&#34;  &lt;&lt; endl
                 &lt;&lt; &#34;necessary backends, and that they contain all the&#34;  &lt;&lt; endl
                 &lt;&lt; &#34;necessary functions required for this scan.  You may&#34;  &lt;&lt; endl
                 &lt;&lt; &#34;check the status of different backends by running&#34;  &lt;&lt; endl
                 &lt;&lt; &#34;  ./gambit backends&#34;  &lt;&lt; endl
                 &lt;&lt; &#34;You may also wish to check the specified search paths for each&#34; &lt;&lt; endl
                 &lt;&lt; &#34;backend shared library in &#34;  &lt;&lt; endl;
          if (Backends::backendInfo().custom_locations_exist())
          {
            errmsg &lt;&lt; &#34;  &#34; &lt;&lt; Backends::backendInfo().backend_locations()  &lt;&lt; endl &lt;&lt; &#34;and&#34;  &lt;&lt; endl;
          }
          errmsg &lt;&lt; &#34;  &#34; &lt;&lt; Backends::backendInfo().default_backend_locations()  &lt;&lt; endl;
        }
        dependency_resolver_error().raise(LOCAL_INFO,errmsg.str());
      }

      // Still more than one candidate...
      if (vertexCandidates.size() &gt; 1)
      {
        // Check whether any of the remaining candidates is subject to a backend-matching rule,
        // and might therefore be uniquely chosen over the other(s) if resolution for this req is attempted again, after
        // another of the reqs subject to the same rule is resolved.
        bool rule_exists = false;
        // Loop over the remaining candidates.
        for (std::vector&lt;functor *&gt;::const_iterator it = vertexCandidates.begin(); it != vertexCandidates.end(); ++it)
        {
          // Retrieve the tags of the candidate.
          std::set&lt;str&gt; tags = (*masterGraph[vertex]).backendreq_tags((*it)-&gt;quantity());
          // Loop over the tags
          for (std::set&lt;str&gt;::iterator tagit = tags.begin(); tagit != tags.end(); ++tagit)
          {
            // Find if there is a backend-matching rule associated with this tag.
            rule_exists = not (*masterGraph[vertex]).forcematchingbackend(*tagit).empty();
            if (rule_exists) break;
          }
          if (rule_exists) break;
        }

        // If deferral is allowed and appears to be potentially useful, defer resolution until later.
        if (allow_deferral and rule_exists)
        {
          return NULL;
        }

        // If not, we have just one more trick up our sleeves... use the models scanned to narrow things down.
        if (boundIniFile-&gt;getValueOrDef&lt;bool&gt;(true, &#34;dependency_resolution&#34;, &#34;prefer_model_specific_functions&#34;))
        {
          // Prefer backend functors that are more specifically tailored for the model being scanned. Do not
          // consider backend functors that are accessible via INTERPRET_AS_X links, as these are all considered
          // to be equally &#39;far&#39; from the model being scanned, with the &#39;distance&#39; being one step further than
          // the most distant ancestor.
          std::vector&lt;functor*&gt; newCandidates;
          std::set&lt;str&gt; s = boundClaw-&gt;get_activemodels();
          std::vector&lt;str&gt; parentModelList(s.begin(), s.end());
          while (newCandidates.size() == 0 and not parentModelList.empty())
          {
            for (std::vector&lt;str&gt;::iterator mit = parentModelList.begin(); mit != parentModelList.end(); ++mit)
            {
              // Test each vertex candidate to see if it has been explicitly set up to work with the model *mit
              for (std::vector&lt;functor*&gt;::iterator it = vertexCandidates.begin(); it != vertexCandidates.end(); ++it)
              {
                if ( (*it)-&gt;modelExplicitlyAllowed(*mit) ) newCandidates.push_back(*it);
              }
              // Step up a level in the model hierarchy for this model.
              *mit = boundClaw-&gt;get_parent(*mit);
            }
            parentModelList.erase(std::remove(parentModelList.begin(), parentModelList.end(), &#34;none&#34;), parentModelList.end());
          }
          if (newCandidates.size() != 0) vertexCandidates = newCandidates;
        }

        // Still more than one candidate, so the game is up.
        // Don&#39;t worry about too many candidates if we only want the list of required backends
        if (vertexCandidates.size() &gt; 1 and not boundCore-&gt;show_backends)
        {
          str errmsg = &#34;Found too many candidates for backend requirement &#34;;
          if (reqs.size() == 1) errmsg += reqs.begin()-&gt;first + &#34; (&#34; + reqs.begin()-&gt;second + &#34;)&#34;;
          else errmsg += &#34;group &#34; + group;
          errmsg += &#34; of module function &#34; + masterGraph[vertex]-&gt;origin() + &#34;::&#34; + masterGraph[vertex]-&gt;name()
           + &#34;\nViable candidates are:\n&#34; + printGenericFunctorList(vertexCandidates);
          errmsg += &#34;\nIf you don&#39;t need all the above backends, you can resolve the ambiguity simply by&#34;;
          errmsg += &#34;\nuninstalling the backends you don&#39;t use.&#34;;
          errmsg += &#34;\n\nAlternatively, you can add an entry in your YAML file that selects which backend&#34;;
          errmsg += &#34;\nthe module function &#34; + masterGraph[vertex]-&gt;origin() + &#34;::&#34; + masterGraph[vertex]-&gt;name() + &#34; should use. A YAML file entry&#34;;
          errmsg += &#34;\nthat selects e.g. the first candidate above could read\n&#34;;
          errmsg += &#34;\n  - capability: &#34;+masterGraph[vertex]-&gt;capability();
          errmsg += &#34;\n    function: &#34;+masterGraph[vertex]-&gt;name();
          errmsg += &#34;\n    backends:&#34;;
          errmsg += &#34;\n      - {capability: &#34;+vertexCandidates.at(0)-&gt;capability()+&#34;, type: &#34;
                                             +vertexCandidates.at(0)-&gt;type()+&#34;, backend: &#34;
                                             +vertexCandidates.at(0)-&gt;origin()+&#34;, version: &#34;
                                             +vertexCandidates.at(0)-&gt;version()+&#34;}\n&#34;;
          dependency_resolver_error().raise(LOCAL_INFO,errmsg);
        }
      }

      // Store the resolved backend requirements
      std::vector&lt;sspair&gt; resolvedBackends;
      for(auto vertex : vertexCandidates)
      {
        sspair backend(vertex-&gt;origin(), vertex-&gt;version());
        resolvedBackends.push_back(backend);
      }

      bool found = false;
      for(auto br = backendsRequired.begin(); br != backendsRequired.end(); ++br)
      {
        found = true;
        for(auto backend : resolvedBackends)
        {
          if(std::find(br-&gt;begin(), br-&gt;end(), backend) == br-&gt;end())
            found = false;
        }
        if(found) break;
      }
      if(not found)
      {
        backendsRequired.push_back(resolvedBackends);
      }

      // Just one candidate.  Jackpot.
      return vertexCandidates[0];
    }

    /// Resolve a backend requirement of a specific module function using a specific backend function.
    void DependencyResolver::resolveRequirement(functor* func, VertexID vertex)
    {
      (*masterGraph[vertex]).resolveBackendReq(func);
      logger() &lt;&lt; LogTags::dependency_resolver;
      logger() &lt;&lt; &#34;Resolved by: [&#34; &lt;&lt; func-&gt;name() &lt;&lt; &#34;, &#34;;
      logger() &lt;&lt; func-&gt;origin() &lt;&lt; &#34; (&#34; &lt;&lt; func-&gt;version() &lt;&lt; &#34;)]&#34;;
      logger() &lt;&lt; EOM;
    }

    // Resolve a dependency on backend classes
    void DependencyResolver::resolveVertexClassLoading(VertexID vertex)
    {
      // If there are no backend class loading requirements, and thus nothing to do, return.
      if ((*masterGraph[vertex]).backendclassloading().size() == 0) return;

      // If the backend is not present, this vertex has already been disabled, so from now just assume it hasn&#39;t
      // Unless the list of required backends is requested, in which case it is enabled, but it won&#39;t run a scan, so no worries

      // Add to the logger
      logger() &lt;&lt; LogTags::dependency_resolver &lt;&lt; &#34;Doing backend class loading resolution...&#34; &lt;&lt; EOM;

      // Add the backends to list of required backends
      std::vector&lt;sspair&gt; resolvedBackends;
      for(auto backend : (*masterGraph[vertex]).backendclassloading())
        resolvedBackends.push_back(backend);

      bool found = false;
      for(auto br = backendsRequired.begin(); br != backendsRequired.end(); ++br)
      {
        found = true;
        for(auto backend : resolvedBackends)
        {
          if(std::find(br-&gt;begin(), br-&gt;end(), backend) == br-&gt;end())
            found = false;
        }
        if(found) break;
      }
      if(not found)
      {
        backendsRequired.push_back(resolvedBackends);
      }

    }

    // Get BibTeX citation keys for backends, modules, etc
    void DependencyResolver::getCitationKeys()
    {
      // First add the necessary citation keys to use GAMBIT
      citationKeys.insert(citationKeys.end(), gambit_citation_keys.begin(), gambit_citation_keys.end());

      // Get the keys for the required backends
      for(auto backend : backendsRequired)
      {
        str bibkey = &#34;&#34;;

        // Run over references of loaded backends
        for(auto beref : boundCore-&gt;getBackendCitationKeys())
        {
          str origin = beref.first.first;
          str version = beref.first.second;
          if (backend[0].first == origin and backend[0].second == version)
          {
            bibkey = beref.second;
            if (bibkey != &#34;&#34; and bibkey != &#34;REFERENCE&#34;)
            {
              logger() &lt;&lt; LogTags::dependency_resolver &lt;&lt; &#34;Found bibkey for backend &#34; &lt;&lt; origin &lt;&lt; &#34; version &#34; &lt;&lt; version &lt;&lt; &#34;: &#34; &lt;&lt; bibkey &lt;&lt; EOM;
              BibTeX::addCitationKey(citationKeys, bibkey);
            }
          }
        }
        if (bibkey == &#34;&#34; or bibkey == &#34;REFERENCE&#34;)
        {
          std::ostringstream errmsg;
          errmsg &lt;&lt; &#34;Missing reference for backend &#34; &lt;&lt; backend[0].first &lt;&lt; &#34;(&#34; &lt;&lt; backend[0].second &lt;&lt; &#34;).&#34; &lt;&lt; endl;
          errmsg &lt;&lt; &#34;Please add the bibkey to the frontend header, and full bibtex entry to &#34;;
          errmsg &lt;&lt; boundIniFile-&gt;getValueOrDef&lt;str&gt;(&#34;config/bibtex_entries.bib&#34;, &#34;dependecy_resolution&#34;, &#34;bibtex_file_location&#34;) &lt;&lt; &#34;.&#34; &lt;&lt; endl;
          dependency_resolver_error().raise(LOCAL_INFO,errmsg.str());
        }
      }

      // Now look over activated vertices in the mastergraph and add any references to module, module functions, etc
      std::vector&lt;VertexID&gt; order = getObsLikeOrder();
      for (std::vector&lt;VertexID&gt;::const_iterator
                  vi  = order.begin();
                  vi != order.end(); ++vi)
      {
        std::set&lt;VertexID&gt; parents;
        getParentVertices(*vi, masterGraph, parents);
        parents.insert(*vi);
        for (std::set&lt;VertexID&gt;::const_iterator
                  vi2  = parents.begin();
                  vi2 != parents.end(); ++vi2)

        {

          // Add citation key for used modules
          for(const auto &amp;key : boundCore-&gt;getModuleCitationKeys())
          {
            if(key.first == masterGraph[*vi2]-&gt;origin())
            {
              BibTeX::addCitationKey(citationKeys, key.second);
            }
          }

          // Add citation key for specific module functions
          if(masterGraph[*vi2]-&gt;citationKey() != &#34;&#34;)
          {
            BibTeX::addCitationKey(citationKeys, masterGraph[*vi2]-&gt;citationKey());
          }

        }

      }

    }

  }

}
</code></pre><hr/><p>Updated on 2022-08-10 at 17:51:36 +0000</p></main></div></div></div><footer class="footer text-muted"><div class="container-xxl"><div class="row"><div class="col-lg-8 order-last order-lg-first"><ul class="list-inline"><li class="list-inline-item">Powered by <a class="text-muted" href="https://gohugo.io/">Hugo</a> and <a class="text-muted" href="https://getdoks.org/">Doks</a></li></ul></div><div class="col-lg-8 order-first order-lg-last text-lg-end"><ul class="list-inline"><li class="list-inline-item"><a href="/license/">License</a></li></ul></div></div></div></footer><script src="/js/bootstrap.min.54bf0932b8a36d0e152b1635b099a6ef1394d35327e2437550a075c9c8ed1bd8aed5847c21b36fc02ed24014c031d9ca24017b0c78b1639d7e2fa8329898b842.js" integrity="sha512-VL8JMrijbQ4VKxY1sJmm7xOU01Mn4kN1UKB1ycjtG9iu1YR8IbNvwC7SQBTAMdnKJAF7DHixY51+L6gymJi4Qg==" crossorigin="anonymous" defer=""></script>
<script src="/js/highlight.min.5b48bc253dc75aeea5fb366ecf700f4925e2b6eb1a1466f2124b722d68148d67bc0a9365d2b8ad9c585161b46372d23b08509a16f1fd518542b894756d4752d0.js" integrity="sha512-W0i8JT3HWu6l+zZuz3APSSXitusaFGbyEktyLWgUjWe8CpNl0ritnFhRYbRjctI7CFCaFvH9UYVCuJR1bUdS0A==" crossorigin="anonymous" defer=""></script>
<script src="/main.min.40265e9a032aeba5eaf67baac3cbbc22667a7533215d326eeb3e9f4d5e4be40f9ff4dcd22949db73ae527ca26a19d7998091a8973c82af760b2c0daa335190ed.js" integrity="sha512-QCZemgMq66Xq9nuqw8u8ImZ6dTMhXTJu6z6fTV5L5A+f9NzSKUnbc65SfKJqGdeZgJGolzyCr3YLLA2qM1GQ7Q==" crossorigin="anonymous" defer=""></script>
<script src="https://gambitbsm.github.io/index.min.1e0f859443ac81a8b8c357ddfae5d899d83ab224e24e44c1c9620a99f2a527d70a1676148a868f87f22fb67994386d592e508dafb575df7c2b80d97f143ad1ea.js" integrity="sha512-Hg+FlEOsgai4w1fd+uXYmdg6siTiTkTByWIKmfKlJ9cKFnYUioaPh/IvtnmUOG1ZLlCNr7V133wrgNl/FDrR6g==" crossorigin="anonymous" defer=""></script></body></html>