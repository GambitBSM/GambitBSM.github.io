<!DOCTYPE html><html lang="en-us"><head><meta charset="utf-8"/><meta http-equiv="x-ua-compatible" content="ie=edge"/><meta name="viewport" content="width=device-width,initial-scale=1,shrink-to-fit=no"/><link rel="preload" as="font" href="https://gambitbsm.github.io/fonts/vendor/jost/jost-v4-latin-regular.woff2" type="font/woff2" crossorigin=""/><link rel="preload" as="font" href="https://gambitbsm.github.io/fonts/vendor/jost/jost-v4-latin-500.woff2" type="font/woff2" crossorigin=""/><link rel="preload" as="font" href="https://gambitbsm.github.io/fonts/vendor/jost/jost-v4-latin-700.woff2" type="font/woff2" crossorigin=""/><script>(()=>{var e=localStorage.getItem("theme");e==="dark"&&document.documentElement.setAttribute("data-dark-mode","")})()</script><link rel="stylesheet" href="https://gambitbsm.github.io/main.e60a30503f41dfe2a8e849eba3bb572667400d7915356bae7eff31d3e22e4492fc8c0b2ff150168b1139b9c0caad1a20c84c8957336bcc2bba8559379cc39f91.css" integrity="sha512-5gowUD9B3+Ko6Enro7tXJmdADXkVNWuufv8x0+IuRJL8jAsv8VAWixE5ucDKrRogyEyJVzNrzCu6hVk3nMOfkQ==" crossorigin="anonymous"/><noscript><style>img.lazyload{display:none}</style></noscript><meta name="robots" content="index, follow"/><meta name="googlebot" content="index, follow, max-snippet:-1, max-image-preview:large, max-video-preview:-1"/><meta name="bingbot" content="index, follow, max-snippet:-1, max-image-preview:large, max-video-preview:-1"/><title>file modules/classutils.py - GAMBIT</title><meta name="description" content="[No description available]"/><link rel="canonical" href="https://gambitbsm.github.io/documentation/code/gambit_2-2/files/classutils_8py/"/><meta property="og:locale" content="en_US"/><meta property="og:type" content="article"/><meta property="og:title" content="file modules/classutils.py"/><meta property="og:description" content="[No description available]"/><meta property="og:url" content="https://gambitbsm.github.io/documentation/code/gambit_2-2/files/classutils_8py/"/><meta property="og:site_name" content="GAMBIT"/><meta property="og:image" content="https://gambitbsm.github.io/gambit_logo.png"/><meta property="og:image:alt" content="GAMBIT"/><meta name="twitter:card" content="summary_large_image"/><meta name="twitter:site" content=""/><meta name="twitter:creator" content=""/><meta name="twitter:title" content="file modules/classutils.py"/><meta name="twitter:description" content="[No description available]"/><meta name="twitter:image" content="https://gambitbsm.github.io/gambit_logo.png"/><meta name="twitter:image:alt" content="file modules/classutils.py"/><script type="application/ld+json">{"@context":"https://schema.org","@graph":[{"@type":"Organization","@id":"https://gambitbsm.github.io/#/schema/organization/1","name":"Doks","url":"https://gambitbsm.github.io/","sameAs":["https://github.com/GambitBSM"],"logo":{"@type":"ImageObject","@id":"https://gambitbsm.github.io/#/schema/image/1","url":"https://gambitbsm.github.io/logo-doks.png","width":450,"height":416,"caption":"Doks"},"image":{"@id":"https://gambitbsm.github.io/#/schema/image/1"}},{"@type":"WebSite","@id":"https://gambitbsm.github.io/#/schema/website/1","url":"https://gambitbsm.github.io/","name":"GAMBIT","description":"Documentation for the Global And Modular BSM Inference Tool","publisher":{"@id":"https://gambitbsm.github.io/#/schema/organization/1"}},{"@type":"WebPage","@id":"https://gambitbsm.github.io/documentation/code/gambit_2-2/files/classutils_8py/","url":"https://gambitbsm.github.io/documentation/code/gambit_2-2/files/classutils_8py/","name":"file modules\/classutils.py","description":"[No description available]","isPartOf":{"@id":"https://gambitbsm.github.io/#/schema/website/1"},"about":{"@id":"https://gambitbsm.github.io/#/schema/organization/1"},"datePublished":"0001-01-01T00:00:00CET","dateModified":"0001-01-01T00:00:00CET","breadcrumb":{"@id":"https://gambitbsm.github.io/documentation/code/gambit_2-2/files/classutils_8py/#/schema/breadcrumb/1"},"primaryImageOfPage":{"@id":"https://gambitbsm.github.io/documentation/code/gambit_2-2/files/classutils_8py/#/schema/image/2"},"inLanguage":"en-US","potentialAction":[{"@type":"ReadAction","target":["https://gambitbsm.github.io/documentation/code/gambit_2-2/files/classutils_8py/"]}]},{"@type":"BreadcrumbList","@id":"https://gambitbsm.github.io/documentation/code/gambit_2-2/files/classutils_8py/#/schema/breadcrumb/1","name":"Breadcrumbs","itemListElement":[{"@type":"ListItem","position":1,"item":{"@type":"WebPage","@id":"https://gambitbsm.github.io/","url":"https://gambitbsm.github.io/","name":"Home"}},{"@type":"ListItem","position":2,"item":{"@type":"WebPage","@id":"https://gambitbsm.github.io/documentation/","url":"https://gambitbsm.github.io/documentation/","name":"Documentation"}},{"@type":"ListItem","position":3,"item":{"@type":"WebPage","@id":"https://gambitbsm.github.io/documentation/code/","url":"https://gambitbsm.github.io/documentation/code/","name":"Code"}},{"@type":"ListItem","position":4,"item":{"@type":"WebPage","@id":"https://gambitbsm.github.io/documentation/code/gambit_2-2/","url":"https://gambitbsm.github.io/documentation/code/gambit_2-2/","name":"Gambit 2 2"}},{"@type":"ListItem","position":5,"item":{"@type":"WebPage","@id":"https://gambitbsm.github.io/documentation/code/gambit_2-2/files/","url":"https://gambitbsm.github.io/documentation/code/gambit_2-2/files/","name":"Files"}},{"@type":"ListItem","position":6,"item":{"@id":"https://gambitbsm.github.io/documentation/code/gambit_2-2/files/classutils_8py/"}}]},{"@context":"https://schema.org","@graph":[{"@type":"ImageObject","@id":"https://gambitbsm.github.io/documentation/code/gambit_2-2/files/classutils_8py/#/schema/image/2","url":"https://gambitbsm.github.io/gambit_logo.png","contentUrl":"https://gambitbsm.github.io/gambit_logo.png","caption":"file modules\/classutils.py"}]}]}</script><meta name="theme-color" content="#fff"/><link rel="icon" href="https://gambitbsm.github.io/favicon.ico" sizes="any"/><link rel="icon" type="image/svg+xml" href="https://gambitbsm.github.io/favicon.svg"/><link rel="apple-touch-icon" sizes="180x180" href="https://gambitbsm.github.io/apple-touch-icon.png"/><link rel="icon" type="image/png" sizes="32x32" href="https://gambitbsm.github.io/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="16x16" href="https://gambitbsm.github.io/favicon-16x16.png"/><link rel="manifest" crossorigin="use-credentials" href="https://gambitbsm.github.io/site.webmanifest"/></head><body class="documentation single light"><div class="sticky-top"><div class="header-bar"></div><header class="navbar navbar-expand-md navbar-light doks-navbar"><nav class="container-xxl flex-wrap flex-md-nowrap" aria-label="Main navigation"><a class="navbar-brand p-0 me-auto" href="https://gambitbsm.github.io/" aria-label="GAMBIT"><img class="logo-light" src="https://gambitbsm.github.io//images/gambit_logo.png" width="50px"/>
<img class="logo-dark d-none" src="https://gambitbsm.github.io//images/gambit_logo.png" width="50px"/>
GAMBIT</a>
<button class="btn btn-menu order-2 d-block d-lg-none" type="button" data-bs-toggle="offcanvas" data-bs-target="#offcanvasDoks" aria-controls="offcanvasDoks" aria-label="Open main menu"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-menu"><line x1="3" y1="12" x2="21" y2="12"></line><line x1="3" y1="6" x2="21" y2="6"></line><line x1="3" y1="18" x2="21" y2="18"></line></svg></button><div class="offcanvas offcanvas-end border-0 py-lg-1" tabindex="-1" id="offcanvasDoks" data-bs-backdrop="true" aria-labelledby="offcanvasDoksLabel"><div class="header-bar d-lg-none"></div><div class="offcanvas-header d-lg-none"><h2 class="h5 offcanvas-title ps-2" id="offcanvasDoksLabel"><a class="text-dark" href="/">GAMBIT</a></h2><button type="button" class="btn-close text-reset me-2" data-bs-dismiss="offcanvas" aria-label="Close main menu"></button></div><div class="offcanvas-body p-4 p-lg-0"><ul class="nav flex-column flex-lg-row align-items-lg-center mt-2 mt-lg-0 ms-lg-2 me-lg-auto"><li class="nav-item dropdown"><a class="nav-link dropdown-toggle ps-0 py-1" href="#" id="navbarDropdownMenuLink" role="button" data-bs-toggle="dropdown" aria-expanded="false">Documentation
<span class="dropdown-caret"><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-chevron-down"><polyline points="6 9 12 15 18 9"></polyline></svg></span></a><ul class="dropdown-menu dropdown-menu-main shadow rounded border-0" aria-labelledby="navbarDropdownMenuLink"><li><a class="dropdown-item" href="/documentation/installation/introduction/">Installation</a></li><li><a class="dropdown-item" href="/documentation/examples/colliderbit_example">Examples</a></li><li><a class="dropdown-item" href="/documentation/help/faqs/">Help</a></li><li><a class="dropdown-item" href="/documentation/code/gambit_2-2/index_classes">Code Reference</a></li></ul></li><li class="nav-item dropdown"><a class="nav-link dropdown-toggle ps-0 py-1" href="#" id="navbarDropdownMenuLink" role="button" data-bs-toggle="dropdown" aria-expanded="false">Community
<span class="dropdown-caret"><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-chevron-down"><polyline points="6 9 12 15 18 9"></polyline></svg></span></a><ul class="dropdown-menu dropdown-menu-main shadow rounded border-0" aria-labelledby="navbarDropdownMenuLink"><li><a class="dropdown-item" href="/community/publications/">Publications</a></li><li><a class="dropdown-item" href="/community/talks/">Talks</a></li><li><a class="dropdown-item" href="/community/members/">Members</a></li><li><a class="dropdown-item active" href="/community/code_of_conduct/" aria-current="true">Code of Conduct</a></li><li><a class="dropdown-item" href="/community/contact/">Contact</a></li></ul></li><li class="nav-item"><a class="nav-link ps-0 py-1" href="/wiki/homepage/">Wiki</a></li></ul><hr class="text-black-50 my-4 d-lg-none"/><form class="doks-search position-relative flex-grow-1 ms-lg-auto me-lg-2"><input id="search" class="form-control is-search" type="search" placeholder="Search site..." aria-label="Search site..." autocomplete="off"/><div id="suggestions" class="shadow bg-white rounded d-none"></div></form><hr class="text-black-50 my-4 d-lg-none"/><ul class="nav flex-column flex-lg-row"><li class="nav-item"><a class="nav-link social-link" href="https://github.com/GambitBSM"><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-github"><path d="M9 19c-5 1.5-5-2.5-7-3m14 6v-3.87a3.37 3.37.0 00-.94-2.61c3.14-.35 6.44-1.54 6.44-7A5.44 5.44.0 0020 4.77 5.07 5.07.0 0019.91 1S18.73.65 16 2.48a13.38 13.38.0 00-7 0C6.27.65 5.09 1 5.09 1A5.07 5.07.0 005 4.77 5.44 5.44.0 003.5 8.55c0 5.42 3.3 6.61 6.44 7A3.37 3.37.0 009 18.13V22"></path></svg><small class="ms-2 d-lg-none">GitHub</small></a></li></ul><hr class="text-black-50 my-4 d-lg-none"/><button id="mode" class="btn btn-link" type="button" aria-label="Toggle user interface mode">
<span class="toggle-dark"><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-moon"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"></path></svg></span><span class="toggle-light"><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-sun"><circle cx="12" cy="12" r="5"></circle><line x1="12" y1="1" x2="12" y2="3"></line><line x1="12" y1="21" x2="12" y2="23"></line><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line><line x1="1" y1="12" x2="3" y2="12"></line><line x1="21" y1="12" x2="23" y2="12"></line><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line></svg></span></button></div></div></nav></header></div><div class="wrap container-xxl" role="document"><div class="content"><div class="row flex-xl-nowrap"><div class="col-lg-5 col-xl-4 docs-sidebar"><nav class="docs-links" aria-label="Main navigation"><ul class="list-unstyled collapsible-sidebar"><li class="mb-1"><button class="btn btn-toggle align-items-center rounded collapsed" data-bs-toggle="collapse" data-bs-target="#section-installation" aria-expanded="false">
Installation</button><div class="collapse" id="section-installation"><ul class="btn-toggle-nav list-unstyled fw-normal pb-1 small"><li><a class="docs-link rounded" href="/documentation/installation/introduction/">Getting Started</a></li><li><a class="docs-link rounded" href="/documentation/installation/docker_usage/">Docker Usage</a></li><li><a class="docs-link rounded" href="/documentation/installation/installation_for_linux/">Installation for Linux</a></li><li><a class="docs-link rounded" href="/documentation/installation/installation_for_windows/">Installation for Windows</a></li><li><a class="docs-link rounded" href="/documentation/installation/installation_for_macos/">Installation for macOS</a></li></ul></div></li><li class="mb-1"><button class="btn btn-toggle align-items-center rounded collapsed" data-bs-toggle="collapse" data-bs-target="#section-examples" aria-expanded="false">
Examples</button><div class="collapse" id="section-examples"><ul class="btn-toggle-nav list-unstyled fw-normal pb-1 small"><li><a class="docs-link rounded" href="/documentation/examples/colliderbit_example/">ColliderBit Example</a></li><li><a class="docs-link rounded" href="/documentation/examples/anotherbit/">AnotherBit</a></li><li><a class="docs-link rounded" href="/documentation/examples/anotherbit2/">AnotherBit2</a></li></ul></div></li><li class="mb-1"><button class="btn btn-toggle align-items-center rounded collapsed" data-bs-toggle="collapse" data-bs-target="#section-help" aria-expanded="false">
Help</button><div class="collapse" id="section-help"><ul class="btn-toggle-nav list-unstyled fw-normal pb-1 small"><li><a class="docs-link rounded" href="/documentation/help/faqs/">FAQs</a></li><li><a class="docs-link rounded" href="/documentation/help/compiler_matrix/">Compiler Matrix</a></li><li><a class="docs-link rounded" href="/documentation/help/known_issues/">Known Issues</a></li><li><a class="docs-link rounded" href="/documentation/help/configuration_examples/">Configuration Examples</a></li></ul></div></li><li class="mb-1"><button class="btn btn-toggle align-items-center rounded collapsed" data-bs-toggle="collapse" data-bs-target="#section-code" aria-expanded="true">
Code Reference</button><div class="collapse show" id="section-code"><ul class="btn-toggle-nav list-unstyled fw-normal pb-1 small"><li class="my-1 ms-3"><button class="btn btn-toggle align-items-center rounded collapsed" data-bs-toggle="collapse" data-bs-target="#section-gambit_2-2" aria-expanded="true">
<font style="color: #5d2f86;" size="-6">release</font> Â  gambit 2-2</button><div class="collapse show" id="section-gambit_2-2"><ul class="btn-toggle-nav list-unstyled fw-normal pb-1 small"><li><a class="docs-link rounded" href="/documentation/code/gambit_2-2/index_classes/">Classes</a></li><li><a class="docs-link rounded" href="/documentation/code/gambit_2-2/index_files/">Files</a></li><li><a class="docs-link rounded" href="/documentation/code/gambit_2-2/index_pages/">Pages</a></li><li><a class="docs-link rounded" href="/documentation/code/gambit_2-2/index_namespaces/">Namespaces</a></li></ul></div></li></ul></div></li></ul></nav></div><nav class="docs-toc d-none d-xl-block col-xl-3" aria-label="Secondary navigation"><div class="d-xl-none"><button class="btn btn-outline-primary btn-sm doks-toc-toggle collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#onThisPage" aria-controls="doks-docs-nav" aria-expanded="false" aria-label="Toggle On this page navigation">
<span>On this page</span>
<span><svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24" class="doks doks-expand" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><title>Expand</title><polyline points="7 13 12 18 17 13"></polyline><polyline points="7 6 12 11 17 6"></polyline></svg><svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24" class="doks doks-collapse" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><title>Collapse</title><polyline points="17 11 12 6 7 11"></polyline><polyline points="17 18 12 13 7 18"></polyline></svg></span></button><div class="collapse" id="onThisPage"><div class="card card-body mt-3 py-1"><div class="page-links"><nav id="TableOfContents"><ul><li><ul><li><a href="#namespaces">Namespaces</a></li><li><a href="#source-code">Source code</a></li></ul></li></ul></nav></div></div></div></div><div class="page-links d-none d-xl-block"><h3>On this page</h3><nav id="TableOfContents"><ul><li><ul><li><a href="#namespaces">Namespaces</a></li><li><a href="#source-code">Source code</a></li></ul></li></ul></nav></div></nav><main class="docs-content col-lg-11 col-xl-9 mx-xl-auto"><nav aria-label="breadcrumb"><ol class="breadcrumb"><li class="breadcrumb-item"><a href="/">Home</a></li><li class="breadcrumb-item"><a href="/documentation/">Documentation</a></li><li class="breadcrumb-item"><a href="/documentation/code/">Code Reference</a></li><li class="breadcrumb-item"><a href="/documentation/code/gambit_2-2/">gambit_2-2</a></li><li class="breadcrumb-item active" aria-current="page">file modules/classutils.py</li></ol></nav><h1>file modules/classutils.py</h1><p class="lead"></p><p>[No description available]</p><h2 id="namespaces">Namespaces <a href="#namespaces" class="anchor" aria-hidden="true">#</a></h2><table><thead><tr><th>Name</th></tr></thead><tbody><tr><td><strong><a href="/documentation/code/gambit_2-2/namespaces/namespacemodules/">modules</a></strong></td></tr><tr><td><strong><a href="/documentation/code/gambit_2-2/namespaces/namespacemodules_1_1classutils/">modules::classutils</a></strong></td></tr></tbody></table><h2 id="source-code">Source code <a href="#source-code" class="anchor" aria-hidden="true">#</a></h2><pre><code>####################################
#                                  #
#  Utility functions for handling  # 
#  C++ classes with BOSS           #
#                                  #
####################################

from __future__ import print_function
from collections import OrderedDict
import os

# import modules.cfg as cfg
import modules.active_cfg as active_cfg
exec(&#34;import configs.&#34; + active_cfg.module_name + &#34; as cfg&#34;)
import modules.gb as gb
import modules.funcutils as funcutils
import modules.utils as utils
import modules.exceptions as exceptions
import modules.infomsg as infomsg


# ====== getAbstractClassName ========

def getAbstractClassName(input_name, prefix=gb.abstr_class_prefix, short=False):

    if &#39;::&#39; in input_name:
        namespaces, short_class_name = input_name.rsplit(&#39;::&#39;,1)
        abstract_class_name = namespaces + &#39;::&#39; + gb.abstr_class_prefix + short_class_name
    else:
        abstract_class_name = gb.abstr_class_prefix + input_name

    if short == True:
        return abstract_class_name.rsplit(&#39;::&#39;,1)[-1]
    else:
        return abstract_class_name

# ====== END: getAbstractClassName ========


# ====== constrEmptyTemplClassDecl ========

def constrEmptyTemplClassDecl(abstr_class_name_short, namespaces, template_bracket, indent=4):

    n_indents  = len(namespaces)
    class_decl = &#39;&#39;

    class_decl += utils.constrNamespace(namespaces, &#39;open&#39;)

    class_decl += &#39; &#39;*n_indents*indent + &#39;template &#39; + template_bracket + &#39;\n&#39;
    class_decl += &#39; &#39;*n_indents*indent + &#39;class &#39; + abstr_class_name_short + &#39; {};\n&#39;

    class_decl += utils.constrNamespace(namespaces, &#39;close&#39;)
    
    class_decl += &#39;\n&#39;

    return class_decl

# ====== END: constrEmptyTemplClassDecl ========



# ====== constrTemplForwDecl ========

def constrTemplForwDecl(class_name_short, namespaces, template_bracket, indent=4):

    n_indents = len(namespaces)
    forw_decl = &#39;&#39;

    forw_decl += utils.constrNamespace(namespaces, &#39;open&#39;)

    forw_decl += &#39; &#39;*n_indents*indent + &#39;template &#39; + template_bracket + &#39;\n&#39;
    forw_decl += &#39; &#39;*n_indents*indent + &#39;class &#39; + class_name_short + &#39;;\n&#39;

    forw_decl += utils.constrNamespace(namespaces, &#39;close&#39;)
    
    forw_decl += &#39;\n&#39;

    return forw_decl

# ====== END: constrTemplForwDecl ========



# ====== constrAbstractClassDecl ========

def constrAbstractClassDecl(class_el, class_name, abstr_class_name, namespaces, indent=4, file_for_gambit=False, template_types=[], has_copy_constructor=True, construct_assignment_operator=True):

    n_indents = len(namespaces)

    # Check template_types argument:
    if len(template_types) &gt; 0:
        is_template = True

    else:
        is_template = False


    # Create list of all &#39;non-artificial&#39; members of the class
    member_elements = utils.getMemberElements(class_el, include_artificial=False)


    # Get list of dicts with info on parent classes
    parent_classes = utils.getParentClasses(class_el)


    #
    # Construct the abstract class declaration
    #
    
    class_decl = &#39;&#39;

    # - Construct the beginning of the namespaces
    class_decl += utils.constrNamespace(namespaces, &#39;open&#39;)

    # - If this class is a template specialization, add &#39;template &lt;&gt;&#39; at the top
    if is_template == True:
        class_decl += &#39; &#39;*n_indents*indent + &#39;template &lt;&gt;\n&#39;

    # - Construct the declaration line, with inheritance of abstract classes
    inheritance_line = &#39;&#39;
    for parent_dict in parent_classes:

        if parent_dict[&#39;loaded&#39;]:
            inheritance_line += &#39;virtual &#39; + parent_dict[&#39;access&#39;] + &#39; &#39; + parent_dict[&#39;abstr_class_name&#39;][&#39;long_templ&#39;] + &#39;, &#39;

        elif parent_dict[&#39;fundamental&#39;] or parent_dict[&#39;std&#39;]:
            # inheritance_line += &#39;virtual &#39; + parent_dict[&#39;access&#39;] + &#39; &#39; + parent_dict[&#39;class_name&#39;][&#39;long_templ&#39;] + &#39;, &#39;
            reason = &#39;Avoid inheritance ambiguity.&#39;
            infomsg.ParentClassIgnored(abstr_class_name[&#39;short&#39;], parent_dict[&#39;class_name&#39;][&#39;long_templ&#39;], reason).printMessage()

        else:
            reason = &#39;Not loaded or accepted type.&#39;
            infomsg.ParentClassIgnored(abstr_class_name[&#39;short&#39;], parent_dict[&#39;class_name&#39;][&#39;long_templ&#39;], reason).printMessage()
            continue
    inheritance_line = inheritance_line.rstrip(&#39;, &#39;)

    # If no other parent classes, add AbstractBase
    if inheritance_line == &#39;&#39;:
        inheritance_line = &#39; : public virtual AbstractBase&#39;
    else:
        inheritance_line = &#39; : &#39; + inheritance_line



    class_decl += &#39; &#39;*n_indents*indent
    if is_template:
        class_decl += &#39;class &#39; + abstr_class_name[&#39;short&#39;] + &#39;&lt;&#39; + &#39;,&#39;.join(template_types) + &#39;&gt;&#39; + inheritance_line + &#39;\n&#39;
    else:
        class_decl += &#39;class &#39; + abstr_class_name[&#39;short&#39;] + inheritance_line + &#39;\n&#39;

    # - Construct body of class declaration
    current_access = &#39;&#39;
    class_decl += &#39; &#39;*n_indents*indent
    class_decl += &#39;{&#39; + &#39;\n&#39;
    done_members = []
    ptr_members_for_init = []

    for el in member_elements:

        # Check access
        element_access = el.get(&#39;access&#39;)

        if element_access != &#39;public&#39;:
            continue

        if current_access != element_access:
            class_decl += &#39; &#39;*(n_indents+1)*indent
            class_decl += element_access + &#39;:&#39; +&#39;\n&#39;
            current_access = element_access

        #
        # Add code based on what element type this is
        #
        if el.tag in [&#39;Constructor&#39;, &#39;Destructor&#39;]:
            pass   # (An empty virtual destructor will be added later)

        elif el.tag in [&#39;Method&#39;, &#39;OperatorMethod&#39;]:

            # Check if this is an operator function
            is_operator = False
            if el.tag == &#39;OperatorMethod&#39;:
                is_operator = True

            # Check if this member function should be ignored.
            if funcutils.ignoreFunction(el):
                # infomsg.IgnoredMemberFunction( is_operator*&#39;operator&#39; + el.get(&#39;name&#39;) ).printMessage()
                continue

            # Check if this member function makes use of loaded types
            uses_loaded_type = funcutils.usesLoadedType(el)

            return_type_dict = utils.findType( gb.id_dict[el.get(&#39;returns&#39;)] )
            return_el     = return_type_dict[&#39;el&#39;]
            pointerness   = return_type_dict[&#39;pointerness&#39;]
            is_ref        = return_type_dict[&#39;is_reference&#39;]
            return_kw     = return_type_dict[&#39;cv_qualifiers&#39;]

            return_kw_str = &#39; &#39;.join(return_kw) + &#39; &#39;*bool(len(return_kw))
            return_type   = return_type_dict[&#39;name&#39;] + &#39;*&#39;*pointerness + &#39;&amp;&#39;*is_ref

            return_is_loaded = utils.isLoadedClass(return_el)
            args = funcutils.getArgs(el)
            w_args = funcutils.constrWrapperArgs(args, add_ref=True)

            # If return type is a known class, add &#39;::&#39; for absolute namespace.
            if (not return_is_loaded) and utils.isKnownClass(return_el):
                return_type = &#39;::&#39; + return_type 


            # Check constness
            if (&#39;const&#39; in el.keys()) and (el.get(&#39;const&#39;)==&#39;1&#39;):
                is_const = True
            else:
                is_const = False


            # If default arguments are used, we need to generate overloaded versions
            n_overloads = funcutils.numberOfDefaultArgs(el)

            # One overloaded version for each set of default arguments
            for remove_n_args in range(n_overloads+1):

                if remove_n_args == 0:
                    use_args   = args
                    use_w_args = w_args
                else:
                    use_args   = args[:-remove_n_args]
                    use_w_args = w_args[:-remove_n_args]


                w_args_bracket = funcutils.constrArgsBracket(use_w_args, include_arg_name=True, include_arg_type=True, include_namespace=True)
                w_args_bracket_notypes = funcutils.constrArgsBracket(use_w_args, include_arg_name=True, include_arg_type=False)
                w_args_bracket_nonames = funcutils.constrArgsBracket(use_w_args, include_arg_name=False, include_arg_type=True, include_namespace=True)

                if is_operator:
                    if uses_loaded_type:
                        w_func_name = &#39;operator_&#39; + gb.operator_names[el.get(&#39;name&#39;)] + gb.code_suffix
                    else:
                        w_func_name = &#39;operator&#39; + el.get(&#39;name&#39;)    
                else:
                    if uses_loaded_type or (remove_n_args&gt;0):
                        w_func_name = el.get(&#39;name&#39;) + gb.code_suffix 
                    else:
                        w_func_name = el.get(&#39;name&#39;)

                #
                # If the method makes use of a loaded class, construct a pair of wrapper methods.
                #
                if uses_loaded_type:

                    # Construct the virtual member function that is overridden, e.g.:  
                    #
                    #   virtual X* getX_GAMBIT(arguments) {}
                    #

                    if return_is_loaded:
                        if is_ref:
                            # w_return_type = toWrapperType(return_type, include_namespace=True, include_global_namespace=True)
                            w_return_type = toAbstractType(return_type, include_namespace=True)
                        elif (not is_ref) and (pointerness &gt; 0):
                            w_return_type = toAbstractType(return_type, include_namespace=True)
                        else:
                            w_return_type = toAbstractType(return_type, include_namespace=True, add_pointer=True, remove_reference=True)
                    else:
                        w_return_type = return_type

                    class_decl += &#39;\n&#39;
                    class_decl += &#39; &#39;*(n_indents+2)*indent
                    class_decl += &#39;virtual &#39; + return_kw_str + w_return_type + &#39; &#39; + w_func_name + w_args_bracket_nonames + is_const*&#39; const&#39; + &#39; =0;&#39; + &#39;\n&#39;


                #
                # If the method does not make use of any loaded class, construct a single virtual method
                #
                else:
                    class_decl += &#39;\n&#39;
                    class_decl += &#39; &#39;*(n_indents+2)*indent
                    class_decl += &#39;virtual &#39; + return_kw_str + return_type + &#39; &#39; + w_func_name + w_args_bracket_nonames + is_const*&#39; const&#39; + &#39; =0;&#39; + &#39;\n&#39;


        #
        # If element is a public member variable of accepted type, construct virtual method that returns a reference to this variable
        #
        elif (el.tag in (&#39;Field&#39;, &#39;Variable&#39;)) and (el.get(&#39;access&#39;) == &#39;public&#39;) and isAcceptedMemberVariable(el):

            class_decl += &#39;\n&#39; 
            class_decl += constrVariableRefFunction(el, virtual=True, indent=indent, n_indents=n_indents+2)

            # For member variables that are of type pointer-to-loaded-class, create a pointer-to-wrapper-class member variable
            if utils.isLoadedClass(el):
                
                el_type_dict = utils.findType(el)
                
                pointerness = el_type_dict[&#39;pointerness&#39;]
                is_ref      = el_type_dict[&#39;is_reference&#39;]
                
                if (pointerness &gt; 0) and (not is_ref):
                    el_type       = el_type_dict[&#39;name&#39;] + &#39;*&#39;*pointerness
                    variable_name = el.get(&#39;name&#39;) + gb.code_suffix
                    
                    class_decl += &#39; &#39;*(n_indents+2)*indent + el_type + &#39; &#39; + variable_name + &#39;;\n&#39;

                    # Register variable name so that it can be initialized in the constructor
                    ptr_members_for_init.append(variable_name)

        #
        # Ignore element
        #
        else:
            pass
    
    # - Member functions of the abstract class living in GAMBIT should never be called. If that happens, something is very wrong. 
    general_boss_warning = &#39;BOSS WARNING: Problem detected with the BOSSed class %s from backend %s. The function %s::%s in GAMBIT should never have been called...&#39;

    # - Construct &#39;pointer_assign&#39; and &#39;pointer_copy&#39; functions
    if class_name[&#39;long_templ&#39;] in gb.contains_pure_virtual_members:
        reason = &#34;Contains pure virtual member functions.&#34;
        infomsg.NoPointerCopyAndAssignmentFunctions(class_name[&#39;long_templ&#39;], reason).printMessage()
    else:
        class_decl += &#39;\n&#39;
        if has_copy_constructor or construct_assignment_operator:
            class_decl += &#39; &#39;*(n_indents+1)*indent + &#39;public:\n&#39;
        if construct_assignment_operator:
            for parent_dict in parent_classes:
                if (parent_dict[&#39;loaded&#39;]) and (parent_dict[&#39;class_name&#39;][&#39;long_templ&#39;] not in gb.contains_pure_virtual_members):
                    class_decl += &#39; &#39;*(n_indents+2)*indent + &#39;using &#39; + parent_dict[&#39;abstr_class_name&#39;][&#39;long_templ&#39;] + &#39;::pointer_assign&#39; + gb.code_suffix + &#39;;\n&#39;
            class_decl += constrPtrAssignFunc(class_el, abstr_class_name[&#39;short&#39;], class_name[&#39;short&#39;], virtual=True, indent=indent, n_indents=n_indents+2)
        if has_copy_constructor:
            class_decl += constrPtrCopyFunc(class_el, abstr_class_name[&#39;short&#39;], class_name[&#39;short&#39;], virtual=True, indent=indent, n_indents=n_indents+2)

    # - Construct code needed for &#39;destructor pattern&#39; (abstract class and wrapper class must can delete each other)
    class_decl += &#39;\n&#39;
    class_decl += &#39; &#39;*(n_indents+1)*indent + &#39;private:\n&#39;
    class_decl += &#39; &#39;*(n_indents+2)*indent +  class_name[&#39;short&#39;] + &#39;* wptr;\n&#39;
    class_decl += &#39; &#39;*(n_indents+2)*indent + &#39;bool delete_wrapper;\n&#39;
    class_decl += &#39; &#39;*(n_indents+1)*indent + &#39;public:\n&#39;
    class_decl += &#39; &#39;*(n_indents+2)*indent + class_name[&#39;short&#39;] + &#39;* get_wptr() { return wptr; }\n&#39;
    class_decl += &#39; &#39;*(n_indents+2)*indent + &#39;void set_wptr(&#39; + class_name[&#39;short&#39;] + &#39;* wptr_in) { wptr = wptr_in; }\n&#39;
    class_decl += &#39; &#39;*(n_indents+2)*indent + &#39;bool get_delete_wrapper() { return delete_wrapper; }\n&#39;
    class_decl += &#39; &#39;*(n_indents+2)*indent + &#39;void set_delete_wrapper(bool del_wrp_in) { delete_wrapper = del_wrp_in; }\n&#39;


    # - Constructor
    class_decl += &#39;\n&#39;
    class_decl += &#39; &#39;*(n_indents+1)*indent + &#39;public:\n&#39;
    class_decl += &#39; &#39;*(n_indents+2)*indent +  abstr_class_name[&#39;short&#39;] + &#39;()\n&#39;
    class_decl += &#39; &#39;*(n_indents+2)*indent + &#39;{\n&#39;
    if gb.debug_mode:
        class_decl += &#39; &#39;*(n_indents+3)*indent + &#39;std::cerr &lt;&lt; &#34;DEBUG: &#34; &lt;&lt; this &lt;&lt; &#34; &#39; + abstr_class_name[&#39;short&#39;] + &#39; ctor&#34; &lt;&lt; std::endl;\n&#39; 
    class_decl += &#39; &#39;*(n_indents+3)*indent + &#39;wptr = 0;\n&#39;
    class_decl += &#39; &#39;*(n_indents+3)*indent + &#39;delete_wrapper = false;\n&#39;
    class_decl += &#39; &#39;*(n_indents+2)*indent + &#39;}\n&#39;


    # - Copy constructor
    # -- Construct code for calling copy constructors of *all* parent classes.
    #    (Required because this is the copy ctor of an abstract base class.)
    all_parent_classes = utils.getAllParentClasses(class_el, only_loaded_classes=True, return_dicts=True, reverse_order=True)
    parent_cctors_line = &#39;&#39;
    for parent_dict in all_parent_classes:
        if parent_dict[&#39;loaded&#39;]:
            parent_cctors_line += parent_dict[&#39;abstr_class_name&#39;][&#39;long_templ&#39;] + &#39;(in), &#39;
        elif parent_dict[&#39;fundamental&#39;] or parent_dict[&#39;std&#39;]:
            reason = &#39;Avoid inheritance ambiguity.&#39;
            infomsg.ParentClassIgnored(abstr_class_name[&#39;short&#39;], parent_dict[&#39;class_name&#39;][&#39;long_templ&#39;], reason).printMessage()
        else:
            reason = &#39;Not loaded or accepted type.&#39;
            infomsg.ParentClassIgnored(abstr_class_name[&#39;short&#39;], parent_dict[&#39;class_name&#39;][&#39;long_templ&#39;], reason).printMessage()
            continue
    parent_cctors_line = parent_cctors_line.rstrip(&#39;, &#39;)

    class_decl += &#39;\n&#39;
    if parent_cctors_line == &#39;&#39;:
        class_decl += &#39; &#39;*(n_indents+2)*indent + abstr_class_name[&#39;short&#39;] + &#39;(const &#39; + abstr_class_name[&#39;short&#39;] + &#39;&amp;)\n&#39;
    else:
        parent_cctors_line = parent_cctors_line.rstrip(&#39;,\n&#39;) + &#39;\n&#39;
        class_decl += &#39; &#39;*(n_indents+2)*indent + abstr_class_name[&#39;short&#39;] + &#39;(const &#39; + abstr_class_name[&#39;short&#39;] + &#39;&amp; in) : \n&#39;
        class_decl += &#39; &#39;*(n_indents+3)*indent + parent_cctors_line
    class_decl += &#39; &#39;*(n_indents+2)*indent + &#39;{\n&#39;
    if gb.debug_mode:
        class_decl += &#39; &#39;*(n_indents+3)*indent + &#39;std::cerr &lt;&lt; &#34;DEBUG: &#34; &lt;&lt; this &lt;&lt; &#34; &#39; + abstr_class_name[&#39;short&#39;] + &#39; copy ctor&#34; &lt;&lt; std::endl;\n&#39; 
    class_decl += &#39; &#39;*(n_indents+3)*indent + &#39;wptr = 0;\n&#39;
    class_decl += &#39; &#39;*(n_indents+3)*indent + &#39;delete_wrapper = false;\n&#39;
    class_decl += &#39; &#39;*(n_indents+2)*indent + &#39;}\n&#39;

    
    # - Assignment operator. (Actually, no copying should be done. It only returns *this.)
    class_decl += &#39;\n&#39;
    class_decl += &#39; &#39;*(n_indents+2)*indent + abstr_class_name[&#39;short&#39;] + &#39;&amp; operator=(const &#39; + abstr_class_name[&#39;short&#39;] + &#39;&amp;) { return *this; }\n&#39;

    # - Function init_wrapper() 
    if file_for_gambit:
        class_decl += &#39;\n&#39;
        class_decl += &#39; &#39;*(n_indents+2)*indent + &#39;virtual void init_wrapper() =0;\n&#39;
    else:
        class_decl += &#39;\n&#39;
        class_decl += &#39; &#39;*(n_indents+2)*indent + &#39;virtual void init_wrapper()\n&#39;
        class_decl += &#39; &#39;*(n_indents+2)*indent + &#39;{\n&#39;
        class_decl += &#39; &#39;*(n_indents+3)*indent + &#39;if (wptr == 0)\n&#39;
        class_decl += &#39; &#39;*(n_indents+3)*indent + &#39;{\n&#39;
        class_decl += &#39; &#39;*(n_indents+4)*indent + &#39;wptr = wrapper_creator(this);\n&#39;
        # class_decl += &#39; &#39;*(n_indents+4)*indent + &#39;wrapper_creator(this);\n&#39;
        class_decl += &#39; &#39;*(n_indents+4)*indent + &#39;delete_wrapper = true;\n&#39;
        class_decl += &#39; &#39;*(n_indents+3)*indent + &#39;}\n&#39;
        class_decl += &#39; &#39;*(n_indents+2)*indent + &#39;}\n&#39;


    # - Function get_init_wptr()
    class_decl += &#39;\n&#39;
    class_decl += &#39; &#39;*(n_indents+2)*indent + class_name[&#39;short&#39;] + &#39;* get_init_wptr()\n&#39;
    class_decl += &#39; &#39;*(n_indents+2)*indent + &#39;{\n&#39;
    class_decl += &#39; &#39;*(n_indents+3)*indent + &#39;init_wrapper();\n&#39;
    class_decl += &#39; &#39;*(n_indents+3)*indent + &#39;return wptr;\n&#39;
    class_decl += &#39; &#39;*(n_indents+2)*indent + &#39;}\n&#39;

    # - Function get_init_wref()
    class_decl += &#39;\n&#39;
    class_decl += &#39; &#39;*(n_indents+2)*indent + class_name[&#39;short&#39;] + &#39;&amp; get_init_wref()\n&#39;
    class_decl += &#39; &#39;*(n_indents+2)*indent + &#39;{\n&#39;
    class_decl += &#39; &#39;*(n_indents+3)*indent + &#39;init_wrapper();\n&#39;
    class_decl += &#39; &#39;*(n_indents+3)*indent + &#39;return *wptr;\n&#39;
    class_decl += &#39; &#39;*(n_indents+2)*indent + &#39;}\n&#39;

    # - Destructor
    if file_for_gambit:
        class_decl += &#39;\n&#39;
        class_decl += &#39; &#39;*(n_indents+2)*indent + &#39;virtual ~&#39; + abstr_class_name[&#39;short&#39;] + &#39;() =0;\n&#39;
    else:
        class_decl += &#39;\n&#39;
        class_decl += &#39; &#39;*(n_indents+2)*indent + &#39;virtual ~&#39; + abstr_class_name[&#39;short&#39;] + &#39;()\n&#39;
        class_decl += &#39; &#39;*(n_indents+2)*indent + &#39;{\n&#39;
        if gb.debug_mode:
            class_decl += &#39; &#39;*(n_indents+3)*indent + &#39;std::cerr &lt;&lt; &#34;DEBUG: &#34; &lt;&lt; this &lt;&lt; &#34; &#39; + abstr_class_name[&#39;short&#39;] + &#39; dtor (BEGIN)&#34; &lt;&lt; std::endl;\n&#39; 
        class_decl += &#39; &#39;*(n_indents+3)*indent + &#39;if (wptr != 0)\n&#39;
        class_decl += &#39; &#39;*(n_indents+3)*indent + &#39;{\n&#39;
        class_decl += &#39; &#39;*(n_indents+4)*indent + &#39;set_delete_BEptr(wptr, false);\n&#39;
        class_decl += &#39; &#39;*(n_indents+4)*indent + &#39;if (delete_wrapper == true)\n&#39;
        class_decl += &#39; &#39;*(n_indents+4)*indent + &#39;{\n&#39;
        class_decl += &#39; &#39;*(n_indents+5)*indent + &#39;wrapper_deleter(wptr);\n&#39;
        class_decl += &#39; &#39;*(n_indents+5)*indent + &#39;wptr = 0;\n&#39;
        # Set wptr = 0 in all parent classes as well
        for parent_dict in all_parent_classes:
            if parent_dict[&#39;loaded&#39;]:
                class_decl += &#39; &#39;*(n_indents+5)*indent + parent_dict[&#39;abstr_class_name&#39;][&#39;long_templ&#39;] + &#39;::set_wptr(0);\n&#39;
        class_decl += &#39; &#39;*(n_indents+5)*indent + &#39;delete_wrapper = false;\n&#39;
        class_decl += &#39; &#39;*(n_indents+4)*indent + &#39;}\n&#39;
        class_decl += &#39; &#39;*(n_indents+3)*indent + &#39;}\n&#39;
        if gb.debug_mode:
            class_decl += &#39; &#39;*(n_indents+3)*indent + &#39;std::cerr &lt;&lt; &#34;DEBUG: &#34; &lt;&lt; this &lt;&lt; &#34; &#39; + abstr_class_name[&#39;short&#39;] + &#39; dtor (END)&#34; &lt;&lt; std::endl;\n&#39; 
        class_decl += &#39; &#39;*(n_indents+2)*indent + &#39;}\n&#39;


    # - Close the class body
    class_decl += &#39; &#39;*n_indents*indent + &#39;};&#39; + &#39;\n&#39;

    # - Construct the closing of the namespaces
    class_decl += utils.constrNamespace(namespaces, &#39;close&#39;)


    # Insert tags for the GAMBIT namespace
    class_decl = &#39;\n__START_GAMBIT_NAMESPACE__\n\n&#39; + class_decl + &#39;\n__END_GAMBIT_NAMESPACE__\n&#39;


    # - Add forward declaration of wrapper_creator function (needed by the &#39;destructor pattern&#39;)
    if not file_for_gambit:
        frwd_decl_creator  = &#39;\n&#39;
        frwd_decl_creator += &#39;// Forward declaration for wrapper_creator.\n&#39;
        frwd_decl_creator += gb.gambit_backend_namespace + &#39;::&#39; + class_name[&#39;long&#39;] + &#39;* wrapper_creator(&#39; + gb.gambit_backend_namespace + &#39;::&#39; + abstr_class_name[&#39;long&#39;] + &#39;*);\n&#39;
        # frwd_decl_creator += &#39;void wrapper_creator(&#39; + gb.gambit_backend_namespace + &#39;::&#39; + abstr_class_name[&#39;long&#39;] + &#39;*);\n&#39;
        frwd_decl_creator += &#39;\n&#39;

        class_decl = frwd_decl_creator + class_decl


    # - Add forward declaration of wrapper_deleter function (needed by the &#39;destructor pattern&#39;)
    if not file_for_gambit:
        frwd_decl_deleter  = &#39;\n&#39;
        frwd_decl_deleter += &#39;// Forward declaration needed by the destructor pattern.\n&#39;
        frwd_decl_deleter += &#39;void wrapper_deleter(&#39; + gb.gambit_backend_namespace + &#39;::&#39; + class_name[&#39;long&#39;] + &#39;*);\n&#39;
        frwd_decl_deleter += &#39;\n&#39;

        class_decl = frwd_decl_deleter + class_decl

    # - Add forward declaration of set_delete_BEptr function (needed by the &#39;destructor pattern&#39;)
    if not file_for_gambit:
        frwd_decl_setdel  = &#39;\n&#39;
        frwd_decl_setdel += &#39;// Forward declaration needed by the destructor pattern.\n&#39;
        frwd_decl_setdel += &#39;void set_delete_BEptr(&#39; + gb.gambit_backend_namespace + &#39;::&#39; + class_name[&#39;long&#39;] + &#39;*, bool);\n&#39;
        frwd_decl_setdel += &#39;\n&#39;

        class_decl = frwd_decl_setdel + class_decl


    # Insert include statements needed by GAMBIT
    backend_undef_incl_statement  = &#39;#include &#34;&#39; + os.path.join(gb.gambit_backend_incl_dir, &#39;backend_undefs.hpp&#39;) + &#39;&#34;\n&#39;
    identification_incl_statement = &#39;#include &#34;&#39; + &#39;identification.hpp&#39; + &#39;&#34;\n&#39;

    class_decl = identification_incl_statement + class_decl + &#39;\n&#39; + backend_undef_incl_statement


    return class_decl

# ====== END: constrAbstractClassDecl ========



# ====== getAcceptableConstructors ========

def getAcceptableConstructors(class_el, skip_copy_constructors=False):

    # Check for copy constructor?
    if skip_copy_constructors:
        has_copy_constructor, copy_constr_id = checkCopyConstructor(class_el, return_id=True)

    # Create list of all acceptable constructors of the class
    constructor_elements = []
    if &#39;members&#39; in class_el.keys():
        for mem_id in class_el.get(&#39;members&#39;).split():
            el = gb.id_dict[mem_id]
            if (el.tag == &#39;Constructor&#39;): #and (&#39;artificial&#39; not in el.keys()):  #(el.get(&#39;explicit&#39;) == &#34;1&#34;):
                if skip_copy_constructors and (el.get(&#39;id&#39;) == copy_constr_id):
                    pass
                else:
                    constructor_elements.append(el)

    return constructor_elements

# ====== END: getAcceptableConstructors ========



# ====== constrFactoryFunctionCode ========

def constrFactoryFunctionCode(class_el, class_name, indent=4, template_types=[], skip_copy_constructors=False, use_wrapper_return=False, use_wrapper_args=False, add_include_statements=True, add_signatures_comment=True):

    # Replace &#39;*&#39; and &#39;&amp;&#39; in list of template types
    template_types = [e.replace(&#39;*&#39;,&#39;P&#39;).replace(&#39;&amp;&#39;,&#39;R&#39;) for e in template_types]

    constructor_elements = getAcceptableConstructors(class_el, skip_copy_constructors=skip_copy_constructors)

    # If no public constructors are found, return nothing
    if len(constructor_elements) == 0:
        reason = &#34;No public constructors.&#34;
        infomsg.NoFactoryFunctions(class_name[&#39;long_templ&#39;], reason).printMessage()
        return &#39;&#39;

    # List to hold include statements that are generated based on the types used
    # in the constructors
    if add_include_statements:
        include_statements = []

    # Construct factory function definition(s)
    func_def = &#39;&#39;

    counter = 0
    for el in constructor_elements:
        if (el.tag == &#39;Constructor&#39;) and ((el.get(&#39;access&#39;) == &#39;protected&#39;) or (el.get(&#39;access&#39;) == &#39;private&#39;)):
            continue

        if add_include_statements:
            # - Generate include statements based on the types used in the constructor
            include_statements += utils.getIncludeStatements(el, convert_loaded_to=&#39;none&#39;, input_element=&#39;function&#39;, forward_declared=&#39;exclude&#39;)
            include_statements += utils.getIncludeStatements(el, convert_loaded_to=&#39;wrapper&#39;, input_element=&#39;function&#39;, forward_declared=&#39;exclude&#39;, use_full_path=True)

        # We need to generate as many overloaded versions as there are arguments with default values
        n_overloads = funcutils.numberOfDefaultArgs(el)

        # Identify arguments
        args = funcutils.getArgs(el)

        # Translate argument type of loaded classes
        if use_wrapper_args:
            w_args = funcutils.constrWrapperArgs(args, add_ref=True, convert_loaded_to_abstract=False)
        else:
            w_args = funcutils.constrWrapperArgs(args, add_ref=True, convert_loaded_to_abstract=True)

        # Invent argument names if missing
        argc = 1
        for i in range(len(args)):
            if args[i][&#39;name&#39;] == &#39;&#39;:
                args[i][&#39;name&#39;] = &#39;arg_&#39; + str(argc)
                argc += 1

        # Generate one factory function for each set of default arguments
        for remove_n_args in range(n_overloads+1):

            # Check that the constructor is acceptable
            if funcutils.ignoreFunction(el, limit_pointerness=True, remove_n_args=remove_n_args):
                continue

            # - Factory function name
            factory_name = &#39;Factory_&#39; + class_name[&#39;short&#39;] + &#39;_&#39; + str(counter)
            if len(template_types) &gt; 0:
                factory_name += &#39;_&#39; + &#39;_&#39;.join(template_types)
            factory_name += gb.code_suffix + &#39;_&#39; + str(gb.symbol_name_counter)
            gb.symbol_name_counter += 1

            if remove_n_args == 0:
                use_args   = args
                use_w_args = w_args
            else:
                use_args   = args[:-remove_n_args]
                use_w_args = w_args[:-remove_n_args]

            # Construct bracket with input arguments
            if use_wrapper_args:
                args_bracket         = funcutils.constrArgsBracket(use_w_args, include_namespace=True, use_wrapper_class=True)
                args_bracket_notypes = funcutils.constrArgsBracket(use_args, include_arg_type=False, cast_to_original=True, wrapper_to_pointer=True)
            else:
                args_bracket         = funcutils.constrArgsBracket(use_w_args, include_namespace=True)
                args_bracket_notypes = funcutils.constrArgsBracket(use_args, include_arg_type=False, cast_to_original=True)
            args_bracket_nonames = funcutils.constrArgsBracket(use_args, include_namespace=True, include_arg_type=True, include_arg_name=False, add_namespace_to_loaded=&#39;my_ns&#39;) 
            
            # Generate declaration line:
            if use_wrapper_return:
                return_type = toWrapperType(class_name[&#39;short&#39;], include_namespace=True)
            else:
                return_type = toAbstractType(class_name[&#39;short&#39;], add_pointer=True, include_namespace=True)
            func_def += return_type + &#39; &#39; + factory_name + args_bracket + &#39;\n&#39;

            # Generate body
            func_def += &#39;{&#39; + &#39;\n&#39;
            if use_wrapper_return:
                func_def += indent*&#39; &#39; + &#39;return &#39; + return_type + &#39;( new &#39; + class_name[&#39;long&#39;] + args_bracket_notypes + &#39; );&#39; + &#39;\n&#39;
            else:
                func_def += indent*&#39; &#39; + &#39;return new &#39; + class_name[&#39;short&#39;] + args_bracket_notypes + &#39;;&#39; + &#39;\n&#39;
            func_def += &#39;}&#39; + 2*&#39;\n&#39;

            # Add info to global dict with factory function info
            info_dict = OrderedDict()
            info_dict[&#39;name&#39;]         = factory_name
            info_dict[&#39;args_bracket&#39;] = args_bracket_nonames

            if class_name[&#39;long&#39;] not in gb.factory_info.keys():
                gb.factory_info[class_name[&#39;long&#39;]] = []
            gb.factory_info[class_name[&#39;long&#39;]].append( info_dict )

            # Increment counter
            counter += 1


    # If no functions were generated, return nothing
    if func_def == &#39;&#39;:
        reason = &#34;No accepted constructors.&#34;
        infomsg.NoFactoryFunctions(class_name[&#39;long_templ&#39;], reason).printMessage()
        return &#39;&#39;


    # Encapsulate code in the correct namespace
    namespaces = utils.getNamespaces(class_el)
    n_indents = len(namespaces)

    func_def_in_ns  = &#39;&#39;
    func_def_in_ns += utils.constrNamespace(namespaces, &#39;open&#39;)
    func_def_in_ns += utils.addIndentation(func_def, n_indents*cfg.indent)
    func_def_in_ns += utils.constrNamespace(namespaces, &#39;close&#39;)

    # Encapsulate code in &#39;extern &#34;C&#34; {...}&#39;
    func_def_in_ns = &#39;extern &#34;C&#34;\n{\n&#39; + func_def_in_ns + &#39;}\n&#39; 

    return_code = func_def_in_ns

    if add_include_statements:
        try:
            original_header_fname = utils.getOriginalHeaderPath(class_el, full_path=True)
            use_path = utils.shortenHeaderPath(original_header_fname)
            include_statements.append( &#39;#include &#34;&#39; + use_path + &#39;&#34;&#39;)

        except exceptions.ReturnError as e:
            reason =  &#34;No original header file found.&#34;
            infomsg.NoIncludeStatementGenerated(class_name[&#39;long_templ&#39;], reason).printMessage()
            pass

        include_statements.append( &#39;#include &#34;&#39; + gb.new_header_files[class_name[&#39;long&#39;]][&#39;wrapper_fullpath&#39;] + &#39;&#34;&#39; )
        include_statements.append( &#39;#include &#34;&#39; + os.path.join(gb.gambit_backend_incl_dir, gb.abstract_typedefs_fname + cfg.header_extension) + &#39;&#34;&#39; )
        include_statements.append( &#39;#include &#34;&#39; + os.path.join(gb.gambit_backend_incl_dir, gb.wrapper_typedefs_fname + cfg.header_extension) + &#39;&#34;&#39; )
        

        include_statements = list( OrderedDict.fromkeys(include_statements) )
        include_statements = utils.orderIncludeStatements(include_statements)
        include_statements_code = &#39;\n&#39;.join(include_statements) + 2*&#39;\n&#39;
        return_code = include_statements_code + return_code

    return return_code

# ====== END: constrFactoryFunctionCode ========



# ====== constrWrapperFunction ========

def constrWrapperFunction(method_el, indent=cfg.indent, n_indents=0, remove_n_args=0, only_declaration=False, include_full_namespace=False):

    # Check if this is an operator function
    is_operator = False
    if method_el.tag == &#39;OperatorMethod&#39;:
        is_operator = True

    # If operator, check that we have a name for it
    if (is_operator) and (method_el.get(&#39;name&#39;) not in gb.operator_names.keys()):
        raise Exception(&#39;No known name for the operator: %s  -- Add an entry to the following dictionary: gb.operator_names&#39; % method_el.get(&#39;name&#39;))

    # Function name
    if is_operator:
        func_name = &#39;operator&#39; + method_el.get(&#39;name&#39;)
    else:
        func_name = method_el.get(&#39;name&#39;)


    # Function return type

    return_type_dict = utils.findType( gb.id_dict[method_el.get(&#39;returns&#39;)] )
    return_el     = return_type_dict[&#39;el&#39;]
    pointerness   = return_type_dict[&#39;pointerness&#39;]
    is_ref        = return_type_dict[&#39;is_reference&#39;]
    return_kw     = return_type_dict[&#39;cv_qualifiers&#39;]
    
    return_kw_str = &#39; &#39;.join(return_kw) + &#39; &#39;*bool(len(return_kw))
    return_type   = return_type_dict[&#39;name&#39;] + &#39;*&#39;*pointerness + &#39;&amp;&#39;*is_ref


    return_is_loaded_class = utils.isLoadedClass(return_el)

    # Function arguments (get list of dicts with argument info)
    args = funcutils.getArgs(method_el)

    # Remove arguments when creating overloaded versions (for dealing with default argument values)
    if remove_n_args &gt; 0:
        args = args[:-remove_n_args]

    # Check constness (in the following sense: &#34;double someFunction() const&#34;, i.e. a function that does not modify member variables.)
    if (&#39;const&#39; in method_el.keys()) and (method_el.get(&#39;const&#39;)==&#39;1&#39;):
        is_const = True
    else:
        is_const = False

    # Construct wrapper function name
    w_func_name = funcutils.constrWrapperName(method_el, include_full_namespace=include_full_namespace)
    # if remove_n_args &gt; 0:
    #     w_func_name += &#39;_overload_&#39; + str(remove_n_args)


    # Choose wrapper return type
    if return_is_loaded_class:
        if (pointerness == 0) and (is_ref):
            w_return_type = toAbstractType(return_type, include_namespace=True)
        elif (pointerness == 0) and (not is_ref):
            w_return_type = toAbstractType(return_type, include_namespace=True, add_pointer=True, remove_reference=True)
        else:
            w_return_type = toAbstractType(return_type, include_namespace=True)

    else:
        w_return_type = return_type


    # Construct list of arguments for wrapper function
    w_args = funcutils.constrWrapperArgs(args, add_ref=True)

    # Construct bracket with input arguments for wrapper function
    if only_declaration:
        w_args_bracket = funcutils.constrArgsBracket(w_args, include_arg_name=False, include_namespace=True)
    else:
        w_args_bracket = funcutils.constrArgsBracket(w_args, include_namespace=True)

    # Construct declaration line for wrapper function
    w_func_line = funcutils.constrDeclLine(w_return_type, w_func_name, w_args_bracket, keywords=return_kw, is_const=is_const)

    # Construct function body for wrapper function
    if only_declaration:
        pass
    else:
        w_func_body = funcutils.constrWrapperBody(return_type, func_name, args, return_is_loaded_class, keywords=return_kw)

    # Combine code and add indentation
    wrapper_code  = &#39;&#39;
    if only_declaration:
        wrapper_code += utils.addIndentation(w_func_line, n_indents*indent) + &#39;;\n&#39;
    else:
        wrapper_code += utils.addIndentation(w_func_line, n_indents*indent) + &#39;\n&#39;
        wrapper_code += utils.addIndentation(w_func_body, n_indents*indent) + &#39;\n&#39;

    # Return result
    return wrapper_code

# ====== END: constrWrapperFunction ========



# ====== constrVariableRefFunction ========

def constrVariableRefFunction(var_el, virtual=False, indent=cfg.indent, n_indents=0, only_declaration=False,
                              include_full_namespace=False, add_return_type_suffix=False):

    func_code = &#39;&#39;

    var_name = var_el.get(&#39;name&#39;)

    var_type_dict    = utils.findType( var_el )
    var_type_name    = var_type_dict[&#39;name&#39;]
    pointerness      = var_type_dict[&#39;pointerness&#39;]
    is_ref           = var_type_dict[&#39;is_reference&#39;]
    var_kw           = var_type_dict[&#39;cv_qualifiers&#39;]
    var_array_limits = var_type_dict[&#39;array_limits&#39;]
    is_array         = var_type_dict[&#39;is_array&#39;]
    
    var_array_limits_str = &#39;&#39;.join([ &#39;[%i]&#39; % i for i in var_array_limits ])

    var_kw_str = &#39; &#39;.join(var_kw) + &#39; &#39;*bool(len(var_kw))
    var_type   = var_type_dict[&#39;name&#39;] + &#39;*&#39;*pointerness + &#39;&amp;&#39;*is_ref

    # pointerness, is_ref = utils.pointerAndRefCheck(var_el)

    ref_method_name = var_name + &#39;_ref&#39; + gb.code_suffix

    if include_full_namespace:
        namespaces = utils.getNamespaces(var_el)
        if len(namespaces) &gt; 0:
            ref_method_name = &#39;::&#39;.join(namespaces) + &#39;::&#39; + ref_method_name


    var_is_loaded_class = utils.isLoadedClass(var_el)
    
    if (var_is_loaded_class) and (pointerness == 0):
        return_type = toAbstractType(var_type)
    elif (var_is_loaded_class) and (pointerness == 1) and (add_return_type_suffix):
        return_type   = toWrapperType(var_type, include_namespace=include_full_namespace)
        var_type_name = toWrapperType(var_type_name, include_namespace=include_full_namespace)
    else:
        return_type = var_type


    # If variable type is a known class, add &#39;::&#39; for absolute namespace.
    if (not var_is_loaded_class) and utils.isKnownClass(var_el):
        return_type = &#39;::&#39; + return_type 


    if (not is_ref) and (not is_array):
        return_type = return_type + &#39;&amp;&#39;
    else:
        pass


    func_code += &#39; &#39;*n_indents*indent
    
    if virtual:
        if is_array:
            func_code += &#39;virtual &#39; + var_kw_str + return_type + &#39; (&amp;&#39; + ref_method_name + &#39;())&#39; + var_array_limits_str + &#39; =0;\n&#39;        
        else:
            func_code += &#39;virtual &#39; + var_kw_str + return_type + &#39; &#39; + ref_method_name + &#39;() =0;\n&#39;
    
    else:
        if is_array:
            func_code += var_kw_str + return_type + &#39; (&amp;&#39; + ref_method_name + &#39;())&#39; + var_array_limits_str
        else:
            func_code += var_kw_str + return_type + &#39; &#39; + ref_method_name + &#39;()&#39; 

        if only_declaration:
            func_code += &#39;;\n&#39;
        else:
            if (var_is_loaded_class) and (pointerness &gt; 0):

                wrapper_var_name = var_name + gb.code_suffix

                func_code += &#39;\n&#39;
                func_code += &#39; &#39;*n_indents*indent + &#39;{\n&#39;
                func_code += &#39; &#39;*(n_indents+1)*indent + &#39;if (not &#39; + wrapper_var_name + &#39;) { &#39; + wrapper_var_name + &#39; = new &#39; + var_type_name + &#39;(&#39; + var_name + &#39;, true); }\n&#39;
                func_code += &#39; &#39;*(n_indents+1)*indent + &#39;return &#39; + wrapper_var_name + &#39;;\n&#39;
                func_code += &#39; &#39;*n_indents*indent + &#39;}\n&#39;

            else:
                func_code += &#39; { return &#39; + var_name  +&#39;; }\n&#39;

    return func_code

# ====== END: constrVariableRefFunction ========



# ====== constrPtrCopyFunc ========

def constrPtrCopyFunc(class_el, abstr_class_name_short, class_name_short, virtual=False, indent=cfg.indent, n_indents=0, only_declaration=False, include_full_namespace=False):

    func_name = &#39;pointer_copy&#39; + gb.code_suffix
    class_name = class_name_short
    abstr_class_name = abstr_class_name_short

    if include_full_namespace:
        namespaces_with_self = utils.getNamespaces(class_el, include_self=True)
        namespaces           = utils.getNamespaces(class_el)
        if len(namespaces_with_self) &gt; 0:
            func_name = &#39;::&#39;.join(namespaces_with_self) + &#39;::&#39; + func_name
        if len(namespaces) &gt; 0:
            abstr_class_name = &#39;::&#39;.join(namespaces) + &#39;::&#39; + abstr_class_name
            class_name = &#39;::&#39;.join(namespaces) + &#39;::&#39; + class_name

    ptr_code = &#39;&#39;
    if virtual:
        ptr_code += &#39; &#39;*cfg.indent*n_indents + &#39;virtual &#39;+ abstr_class_name + &#39;*&#39; + &#39; &#39; + func_name + &#39;() =0;\n&#39;   
    else:
        ptr_code += &#39; &#39;*cfg.indent*n_indents + abstr_class_name + &#39;*&#39; + &#39; &#39; + func_name + &#39;()&#39;
        if only_declaration:
            ptr_code += &#39;;\n&#39;
        else:
            ptr_code += &#39;\n&#39;
            ptr_code += &#39; &#39;*cfg.indent*n_indents + &#39;{\n&#39;
            ptr_code += &#39; &#39;*cfg.indent*(n_indents+1) + abstr_class_name + &#39;* new_ptr = new &#39; + class_name_short + &#39;(*this);\n&#39;
            ptr_code += &#39; &#39;*cfg.indent*(n_indents+1) + &#39;return new_ptr;\n&#39;
            ptr_code += &#39; &#39;*cfg.indent*n_indents + &#39;}\n&#39;

    return ptr_code

# ====== END: constrPtrCopyFunc ========



# ====== constrPtrAssignFunc ========

def constrPtrAssignFunc(class_el, abstr_class_name_short, class_name_short, virtual=False, indent=cfg.indent, n_indents=0, only_declaration=False, include_full_namespace=False):

    func_name  = &#39;pointer_assign&#39; + gb.code_suffix
    class_name = class_name_short
    abstr_class_name = abstr_class_name_short

    if include_full_namespace:
        namespaces_with_self = utils.getNamespaces(class_el, include_self=True)
        namespaces           = utils.getNamespaces(class_el)
        if len(namespaces_with_self) &gt; 0:
            func_name = &#39;::&#39;.join(namespaces_with_self) + &#39;::&#39; + func_name
        if len(namespaces) &gt; 0:
            abstr_class_name = &#39;::&#39;.join(namespaces) + &#39;::&#39; + abstr_class_name
            class_name = &#39;::&#39;.join(namespaces) + &#39;::&#39; + class_name

    ptr_code = &#39;&#39;
    
    if virtual:
        ptr_code += &#39; &#39;*cfg.indent*n_indents + &#39;virtual void &#39; + func_name + &#39;(&#39; + abstr_class_name + &#39;*) =0;\n&#39;
    else:
        ptr_code += &#39; &#39;*cfg.indent*n_indents + &#39;void &#39; + func_name + &#39;(&#39; + abstr_class_name + &#39;* in)&#39;
        if only_declaration:
            ptr_code += &#39;;\n&#39;
        else:
            ptr_code += &#39;\n&#39;
            ptr_code += &#39; &#39;*cfg.indent*n_indents + &#39;{\n&#39;
            ptr_code += &#39; &#39;*cfg.indent*(n_indents+1) + gb.gambit_backend_namespace + &#39;::&#39; + class_name + &#39;* wptr_temp = &#39; + abstr_class_name + &#39;::get_wptr();\n&#39;
            ptr_code += &#39; &#39;*cfg.indent*(n_indents+1) + &#39;*this = *dynamic_cast&lt;&#39; + class_name_short + &#39;*&gt;(in);\n&#39;
            ptr_code += &#39; &#39;*cfg.indent*(n_indents+1) + abstr_class_name_short + &#39;::set_wptr(wptr_temp);\n&#39;
            ptr_code += &#39; &#39;*cfg.indent*n_indents + &#39;}\n&#39;

    return ptr_code

# ====== END: constrPtrAssignFunc ========



# ====== checkAssignmentOperator ========

def checkAssignmentOperator(class_el):

    found_assignment_operator = False
    is_artificial = False

    # Get list of all class members
    class_members = utils.getMemberElements(class_el, include_artificial=True)

    # Look for assignment operator
    for mem_el in class_members:
        if (mem_el.tag == &#39;OperatorMethod&#39;) and (mem_el.get(&#39;name&#39;) == &#39;=&#39;):

            # Check that return type is either void or the class type itself (possibly as a reference)
            return_type_dict = utils.findType(mem_el)
            return_type    = return_type_dict[&#39;name&#39;] + &#39;*&#39;*return_type_dict[&#39;pointerness&#39;] + &#39;&amp;&#39;*return_type_dict[&#39;is_reference&#39;]
            return_type_id = return_type_dict[&#39;id&#39;]

            if (return_type == &#39;void&#39;) or (return_type_id == class_el.get(&#39;id&#39;)):

                # Check that the only argument is another class instance
                args = funcutils.getArgs(mem_el)
                if (len(args) == 1) and (args[0][&#39;id&#39;] == class_el.get(&#39;id&#39;)):

                    found_assignment_operator = True
    
                    if (&#39;artificial&#39; in mem_el.keys()) and (mem_el.get(&#39;artificial&#39;)==&#39;1&#39;):
                        is_artificial = True

    return found_assignment_operator, is_artificial

# ====== END: checkAssignmentOperator ========



# ====== checkCopyConstructor ========

def checkCopyConstructor(class_el, return_id=False):

    found_copy_constructor = False
    copy_constr_id = &#39;&#39;

    # Get list of all class members
    class_members = utils.getMemberElements(class_el, include_artificial=True)

    # Look for copy constructor
    for mem_el in class_members:
        if (mem_el.tag == &#39;Constructor&#39;):

            if (mem_el.get(&#39;access&#39;) == &#39;protected&#39;) or (mem_el.get(&#39;access&#39;) == &#39;private&#39;):
                return found_copy_constructor, copy_constr_id

            # Check that the only argument is another class instance
            args = funcutils.getArgs(mem_el)
            if (len(args) == 1) and (args[0][&#39;id&#39;] == class_el.get(&#39;id&#39;)):

                found_copy_constructor = True
                copy_constr_id = mem_el.get(&#39;id&#39;)

    if return_id:
        return found_copy_constructor, copy_constr_id
    else:
        return found_copy_constructor

# ====== END: checkCopyConstructor ========



# ====== toWrapperType ========

def toWrapperType(input_type_name, remove_reference=False, remove_pointers=False, include_namespace=False, include_global_namespace=False ):

    type_name = input_type_name

    # Search for &#39;*&#39; and &#39;&amp;&#39;
    n_pointers = type_name.count(&#39;*&#39;)
    is_ref     = bool(&#39;&amp;&#39; in type_name)

    # Remove &#39;*&#39; and &#39;&amp;&#39;
    type_name = type_name.replace(&#39;*&#39;,&#39;&#39;).replace(&#39;&amp;&#39;,&#39;&#39;)

    # Split into namespace, short_type_name 
    namespace, short_type_name = utils.removeNamespace(type_name, return_namespace=True)

    if include_global_namespace:
        namespace = &#39;::&#39; + namespace

    # Insert wrapper class prefix
    short_type_name = gb.wrapper_class_prefix + short_type_name

    # Add &#39;*&#39; and &#39;&amp;&#39;
    if remove_pointers:
        pass
    else:
        short_type_name = short_type_name + &#39;*&#39;*n_pointers

    if remove_reference:
        pass
    else:
        short_type_name = short_type_name + &#39;&amp;&#39;*is_ref

    # Return result
    if (include_namespace) and (namespace != &#39;&#39;):
        return namespace + &#39;::&#39; + short_type_name
    else:
        return short_type_name

# ====== END: toWrapperType ========



# ====== toAbstractType ========

def toAbstractType(input_type_name, include_namespace=True, add_pointer=False, remove_reference=False, remove_pointers=False):

    # FIXME:
    # Should this function also translate template argument types?
    # Example: TypeA&lt;TypeB&gt;  --&gt;  Abstract__TypeA&lt;Abstract__TypeB&gt;

    type_name = input_type_name

    # Remove template bracket
    type_name_notempl = utils.removeTemplateBracket(type_name)

    # Search for &#39;*&#39; and &#39;&amp;&#39;
    n_pointers = type_name_notempl.count(&#39;*&#39;)
    is_ref     = bool(&#39;&amp;&#39; in type_name_notempl)

    # Get namespace
    namespace, type_name_short = utils.removeNamespace(type_name, return_namespace=True)

    if is_ref and remove_reference:
        type_name_short = type_name_short.replace(&#39;&amp;&#39;,&#39;&#39;)

    if (n_pointers &gt; 0) and remove_pointers:
        type_name_short = type_name_short.replace(&#39;*&#39;,&#39;&#39;)

    if namespace == &#39;&#39;:
        type_name = gb.abstr_class_prefix + type_name_short
    else:
        type_name = (namespace+&#39;::&#39;)*include_namespace  + gb.abstr_class_prefix + type_name_short


    if add_pointer:
        if is_ref and not remove_reference:
            type_name = type_name.rstrip(&#39;&amp;&#39;) + &#39;*&amp;&#39;
        else:
            type_name = type_name + &#39;*&#39;

    # Return result
    return type_name

# ====== END: toAbstractType ========



# ====== getClassNameDict ========

def getClassNameDict(class_el, abstract=False):

    class_name = {}

    xml_id = class_el.get(&#39;id&#39;)
    if &#39;name&#39; not in class_el.keys():
        raise KeyError(&#39;XML element %s does not contain the key &#34;name&#34;.&#39; % (xml_id))

    namespaces_list = utils.getNamespaces(class_el, include_self=True)
    class_name[&#39;long_templ&#39;] = &#39;::&#39;.join(namespaces_list)

    class_name[&#39;long&#39;]        = class_name[&#39;long_templ&#39;].split(&#39;&lt;&#39;,1)[0]
    class_name[&#39;short_templ&#39;] = class_el.get(&#39;name&#39;)
    class_name[&#39;short&#39;]       = class_name[&#39;short_templ&#39;].split(&#39;&lt;&#39;,1)[0]

    if abstract:
        abstr_class_name = {}
        abstr_class_name[&#39;long_templ&#39;]  = getAbstractClassName(class_name[&#39;long_templ&#39;], prefix=gb.abstr_class_prefix)
        abstr_class_name[&#39;long&#39;]        = abstr_class_name[&#39;long_templ&#39;].split(&#39;&lt;&#39;,1)[0]
        abstr_class_name[&#39;short_templ&#39;] = getAbstractClassName(class_name[&#39;long_templ&#39;], prefix=gb.abstr_class_prefix, short=True)
        abstr_class_name[&#39;short&#39;]       = abstr_class_name[&#39;short_templ&#39;].split(&#39;&lt;&#39;,1)[0]

        return abstr_class_name

    else:
        return class_name

# ====== END: getClassNameDict ========



# ====== constrWrapperDecl ========

def constrWrapperDecl(class_name, abstr_class_name, loaded_parent_classes, class_variables, class_functions, class_constructors, construct_assignment_operator, has_copy_constructor, indent=&#39; &#39;*cfg.indent):

    decl_code = &#39;&#39;

    short_wrapper_class_name = toWrapperType(class_name[&#39;short&#39;])
    wrapper_class_name = toWrapperType(class_name[&#39;long&#39;], include_namespace=True)

    # Construct inheritance line 
    inheritance_line = &#39;&#39;
    for parent_dict in loaded_parent_classes:
        inheritance_line += &#39;virtual &#39;*parent_dict[&#39;virtual&#39;] + parent_dict[&#39;access&#39;] + &#39; &#39; + parent_dict[&#39;class_name&#39;][&#39;short&#39;] + &#39;, &#39;
    inheritance_line = inheritance_line.rstrip(&#39;, &#39;)

    # If no other parent classes, add WrapperBase
    if inheritance_line == &#39;&#39;:
        # inheritance_line = &#39; : public virtual WrapperBase&#39;
        inheritance_line = &#39; : public WrapperBase&#39;
    else:
        inheritance_line = &#39; : &#39; + inheritance_line

    # Class declaration line
    decl_code += &#39;\n&#39;
    decl_code += &#39;class &#39; + class_name[&#39;short&#39;] + inheritance_line + &#39;\n&#39;

    # Class body
    decl_code += &#39;{\n&#39;

    #
    # Variables:
    #
    decl_code += 2*indent + &#39;// Member variables: \n&#39;

    # Add a static function pointer for each factory function
    decl_code += indent + &#39;public:\n&#39;
    decl_code += 2*indent + &#39;// -- Static factory pointers: \n&#39;
    factory_counter = 0
    for i, constr_el in enumerate(class_constructors):

       
        # We need pointers for all the overloaded factory functions (generated due to default value arguments)
        n_overloads = funcutils.numberOfDefaultArgs(constr_el)

        # Identify arguments, translate argument type of loaded classes
        # and construct the argument bracket
        args = funcutils.getArgs(constr_el)

        # One factory function pointer for each set of default arguments
        for remove_n_args in range(n_overloads+1):

            # Check that the constructor is acceptable
            if funcutils.ignoreFunction(constr_el, limit_pointerness=True, remove_n_args=remove_n_args):
                continue

            if remove_n_args == 0:
                use_args = args
            else:
                use_args = args[:-remove_n_args]

            args_bracket = funcutils.constrArgsBracket(use_args, include_arg_name=False, include_arg_type=True, include_namespace=True)

            # Factory pointer name
            factory_ptr_name = &#39;__factory&#39; + str(factory_counter)

            # Construct factory pointer code
            decl_code += 2*indent + &#39;static &#39; + abstr_class_name[&#39;short&#39;] + &#39;* (*&#39; + factory_ptr_name + &#39;)&#39; + args_bracket + &#39;;\n&#39;

            # Increment factory counter
            factory_counter += 1

    # Add references to all public variables
    decl_code += &#39;\n&#39;
    decl_code += 2*indent + &#39;// -- Other member variables: \n&#39;
    current_access = &#39;&#39;
    for var_el in class_variables:

        # Accessor
        accessor = var_el.get(&#39;access&#39;)
        if accessor != current_access:
            decl_code += indent + accessor + &#39;:\n&#39;
            current_access = accessor

        # Variable name
        var_name = var_el.get(&#39;name&#39;)

        # Determine variable type
        var_type_dict = utils.findType(var_el)
        pointerness      = var_type_dict[&#39;pointerness&#39;]
        is_ref           = var_type_dict[&#39;is_reference&#39;]
        var_kw           = var_type_dict[&#39;cv_qualifiers&#39;]
        var_array_limits = var_type_dict[&#39;array_limits&#39;]
        is_array         = var_type_dict[&#39;is_array&#39;]

        var_array_limits_str = &#39;&#39;.join([&#39;[%i]&#39; % i for i in var_array_limits])
       

        var_kw_str = &#39; &#39;.join(var_kw) + &#39; &#39;*bool(len(var_kw))
        
        var_type      = var_type_dict[&#39;name&#39;] + &#39;*&#39;*pointerness + &#39;&amp;&#39;*is_ref

        var_is_loaded_class = utils.isLoadedClass(var_el)
        var_is_known_class  = utils.isKnownClass(var_el)

        # # FIXME: At the moment there are problems with member variables that are pointer-to-loaded-class. For now, skip them:
        # if var_is_loaded_class and pointerness &gt; 0:
        #     print(&#39;WARNING: The member variable %s is of a loaded type and has pointerness &gt; 0. This BOSS cannot yet handle. Ignored for now...&#39; % var_name)
        #     continue


        if var_is_loaded_class:
            
            use_var_type = var_type
            
            if not is_ref:
                use_var_type = var_type + &#39;&amp;&#39;

            decl_code += 2*indent + var_kw_str + use_var_type + &#39; &#39; + var_name + var_array_limits_str  + &#39;;\n&#39;
    
        else:
            if var_is_known_class:
                var_type = &#39;::&#39; + var_type

            if is_ref:
                use_var_type = var_type
            else:
                if not is_array:
                    use_var_type = var_type + &#39;&amp;&#39;
                else:
                    use_var_type = var_type

            if is_array:
                decl_code += 2*indent + var_kw_str + use_var_type + &#39; (&amp;&#39; + var_name +&#39;)&#39; + var_array_limits_str  + &#39;;\n&#39;
            else:
                decl_code += 2*indent + var_kw_str + use_var_type + &#39; &#39; + var_name + &#39;;\n&#39;


    #
    # Functions:
    #
    decl_code += &#39;\n&#39;
    decl_code += 2*indent + &#39;// Member functions: \n&#39;

    # Add wrappers for all member functions, including operator functions
    # and overloaded versions of functions with default value arguments

    current_access = &#39;&#39;
    for func_el in class_functions:

        # Accessor
        accessor = func_el.get(&#39;access&#39;)
        if accessor != current_access:
            decl_code += indent + accessor + &#39;:\n&#39;
            current_access = accessor

        # Check if this is an operator function
        is_operator = False
        if func_el.tag == &#39;OperatorMethod&#39;:
            is_operator = True

        # Check if this function makes use of any loaded types
        uses_loaded_type = funcutils.usesLoadedType(func_el)

        # Function name
        if is_operator:
            func_name = &#39;operator&#39; + func_el.get(&#39;name&#39;)
        else:
            func_name = func_el.get(&#39;name&#39;)

        # Skip the assignment operator (we implement out own later on)
        if func_name == &#39;operator=&#39;:
            continue

        # Check for const function
        is_const = utils.isConstFunction(func_el)

        # Determine return type
        return_type_dict = utils.findType(func_el)
        return_type_el = return_type_dict[&#39;el&#39;]
        pointerness    = return_type_dict[&#39;pointerness&#39;]
        is_ref         = return_type_dict[&#39;is_reference&#39;]
        return_type_kw = return_type_dict[&#39;cv_qualifiers&#39;]
        
        return_kw_str  = &#39; &#39;.join(return_type_kw) + &#39; &#39;*bool(len(return_type_kw))
        
        return_is_loaded    = utils.isLoadedClass(return_type_el)

        return_type   = return_type_dict[&#39;name&#39;] + &#39;*&#39;*pointerness + &#39;&amp;&#39;*is_ref


        # If return type is a known class, add &#39;::&#39; for absolute namespace.
        if (not return_is_loaded) and utils.isKnownClass(return_type_el):
            return_type = &#39;::&#39; + return_type 

        # If return-by-value, then a const qualifier on the return value is meaningless
        # (will result in a compiler warning)
        if (pointerness == 0) and (is_ref == False) and (&#39;const&#39; in return_type_kw):
            return_kw_str = return_kw_str.replace(&#39;const&#39;, &#39;&#39;)

        # Arguments
        args = funcutils.getArgs(func_el)

        # One function for each set of default arguments
        n_overloads = funcutils.numberOfDefaultArgs(func_el)
        for remove_n_args in range(n_overloads+1):

            # Check that the function is acceptable
            if funcutils.ignoreFunction(func_el, remove_n_args=remove_n_args):
                continue

            if remove_n_args == 0:
                use_args = args
            else:
                use_args = args[:-remove_n_args]

            # Argument bracket
            args_bracket = funcutils.constrArgsBracket(use_args, include_arg_name=True, include_arg_type=True, include_namespace=True)

            # Name of function to call (in abstract class)
            if is_operator:
                if uses_loaded_type:
                    call_func_name = &#39;operator_&#39; + gb.operator_names[func_el.get(&#39;name&#39;)] + gb.code_suffix
                else:
                    call_func_name = &#39;operator&#39; + func_el.get(&#39;name&#39;)    
            else:
                # call_func_name = func_name + gb.code_suffix
                if uses_loaded_type or (remove_n_args&gt;0):
                    call_func_name = func_name + gb.code_suffix 
                else:
                    call_func_name = func_name


            # Write declaration line
            decl_code += 2*indent + return_kw_str + return_type + &#39; &#39; + func_name + args_bracket + is_const*&#39; const&#39; + &#39;;\n&#39;
            decl_code += &#39;\n&#39;


    #
    # Add all constructors here...
    #


    # Add wrappers for all original constructors except the copy constructor
    temp_code = &#39;&#39;
    current_access = &#39;&#39;
    for i, constr_el in enumerate(class_constructors):

        # Accessor
        accessor = constr_el.get(&#39;access&#39;)
        if accessor != current_access:
            temp_code += indent + accessor + &#39;:\n&#39;
            current_access = accessor

        # Identify arguments
        args = funcutils.getArgs(constr_el)
        factory_args = funcutils.constrWrapperArgs(args, add_ref=True)

        # If default arguments are use, we need overloaded constructors to connect to the overloaded
        # factory function pointers
        n_overloads = funcutils.numberOfDefaultArgs(constr_el)

        # One constructor for each set of default arguments
        for remove_n_args in range(n_overloads+1):

            # Check that the constructor is acceptable
            if funcutils.ignoreFunction(constr_el, limit_pointerness=True, remove_n_args=remove_n_args):
                continue

            if remove_n_args == 0:
                use_args         = args
                factory_use_args = factory_args
            else:
                use_args         = args[:-remove_n_args]
                factory_use_args = factory_args[:-remove_n_args]

            args_bracket = funcutils.constrArgsBracket(use_args, include_arg_name=True, include_arg_type=True, include_namespace=True, use_wrapper_class=False)

            temp_code += 2*indent + class_name[&#39;short&#39;] + args_bracket + &#39;;\n&#39;

    if temp_code != &#39;&#39;:
        decl_code += &#39;\n&#39;
        decl_code += 2*indent + &#39;// Wrappers for original constructors: \n&#39;    
        decl_code += temp_code + &#39;\n&#39;

    if current_access != &#39;public&#39;:
        decl_code += indent + &#39;public:\n&#39;


    # Add special constructor based on abstract pointer
    decl_code += 2*indent + &#39;// Special pointer-based constructor: \n&#39;
    decl_code += 2*indent + class_name[&#39;short&#39;] + &#39;(&#39; + abstr_class_name[&#39;short&#39;] +&#39;* in);\n&#39;
    # decl_code += 2*indent + class_name[&#39;short&#39;] + &#39;(const &#39; + abstr_class_name[&#39;long&#39;] +&#39;* in);\n&#39;


    # Add copy constructor
    if has_copy_constructor:
        decl_code += &#39;\n&#39;
        decl_code += 2*indent + &#39;// Copy constructor: \n&#39;
        decl_code += 2*indent + class_name[&#39;short&#39;] + &#39;(const &#39; + class_name[&#39;short&#39;] +&#39;&amp; in);\n&#39;

    # 
    # Add assignment operator
    #
    if construct_assignment_operator:
        decl_code += &#39;\n&#39;
        decl_code += 2*indent + &#39;// Assignment operator: \n&#39;
        decl_code += 2*indent + class_name[&#39;short&#39;] + &#39;&amp; &#39; + &#39;operator=(const &#39; + class_name[&#39;short&#39;] +&#39;&amp; in);\n&#39;


    #
    # Add destructor
    #
    decl_code += &#39;\n&#39;
    decl_code += 2*indent + &#39;// Destructor: \n&#39;
    # decl_code += 2*indent + &#39;virtual ~&#39; + class_name[&#39;short&#39;] + &#39;();\n&#39;
    decl_code += 2*indent + &#39;~&#39; + class_name[&#39;short&#39;] + &#39;();\n&#39;


    #
    # Add get_BEptr function
    #
    decl_code += &#39;\n&#39;
    # decl_code += indent + &#39;private:\n&#39;
    decl_code += 2*indent + &#39;// Returns correctly casted pointer to Abstract class: \n&#39;
    decl_code += 2*indent + abstr_class_name[&#39;short&#39;] +&#39;* get_BEptr() const;\n&#39;


    # Close class body
    decl_code += &#39;\n&#39;
    decl_code += &#39;};\n&#39;    


    # Add namespace
    namespace, class_name_short = utils.removeNamespace(class_name[&#39;long&#39;], return_namespace=True)

    if namespace == &#39;&#39;:
        namespace_list = []
    else:
        namespace_list = namespace.split(&#39;::&#39;)

    n_indents = len(namespace_list)

    decl_code_with_ns  = &#39;&#39;
    decl_code_with_ns += utils.constrNamespace(namespace_list,&#39;open&#39;)
    decl_code_with_ns += utils.addIndentation(decl_code, cfg.indent*n_indents)
    decl_code_with_ns += utils.constrNamespace(namespace_list,&#39;close&#39;)

    # Return result
    return decl_code_with_ns

# ====== END: constrWrapperDecl ========




# ====== constrWrapperDef ========

def constrWrapperDef(class_name, abstr_class_name, loaded_parent_classes, class_variables, class_functions, class_constructors, construct_assignment_operator, has_copy_constructor, indent=&#39; &#39;*cfg.indent, do_inline=False):

    def_code = &#39;&#39;

    short_wrapper_class_name = toWrapperType(class_name[&#39;short&#39;])
    wrapper_class_name = toWrapperType(class_name[&#39;long&#39;], include_namespace=True)

    # Functions:
    def_code += &#39;\n&#39;
    def_code += &#39;// Member functions: \n&#39;

    # Add wrappers for all member functions, including operator functions
    # and overloaded versions of functions with default value arguments

    for func_el in class_functions:

        # Check if this is an operator function
        is_operator = False
        if func_el.tag == &#39;OperatorMethod&#39;:
            is_operator = True

        # Check if this function makes use of any loaded types
        uses_loaded_type = funcutils.usesLoadedType(func_el)

        # Function name
        if is_operator:
            func_name = &#39;operator&#39; + func_el.get(&#39;name&#39;)
        else:
            func_name = func_el.get(&#39;name&#39;)

        # Skip the assignment operator (we implement out own later on)
        if func_name == &#39;operator=&#39;:
            continue

        # Check for const function
        is_const = utils.isConstFunction(func_el)


        # Determine return type
        return_type_dict = utils.findType(func_el)
        return_type_el = return_type_dict[&#39;el&#39;]
        pointerness    = return_type_dict[&#39;pointerness&#39;]
        is_ref         = return_type_dict[&#39;is_reference&#39;]
        return_type_kw = return_type_dict[&#39;cv_qualifiers&#39;]
        
        return_kw_str  = &#39; &#39;.join(return_type_kw) + &#39; &#39;*bool(len(return_type_kw))
        
        return_is_loaded    = utils.isLoadedClass(return_type_el)

        return_type   = return_type_dict[&#39;name&#39;] + &#39;*&#39;*pointerness + &#39;&amp;&#39;*is_ref


        # If return type is a known class, add &#39;::&#39; for absolute namespace.
        if (not return_is_loaded) and utils.isKnownClass(return_type_el):
            return_type = &#39;::&#39; + return_type 


        # If return-by-value, then a const qualifier on the return value is meaningless
        # (will result in a compiler warning)
        if (pointerness == 0) and (is_ref == False) and (&#39;const&#39; in return_type_kw):
            return_kw_str = return_kw_str.replace(&#39;const&#39;, &#39;&#39;)

        # Arguments
        args = funcutils.getArgs(func_el)


        # One function for each set of default arguments
        n_overloads = funcutils.numberOfDefaultArgs(func_el)
        for remove_n_args in range(n_overloads+1):

            # Check that the function is acceptable
            if funcutils.ignoreFunction(func_el, limit_pointerness=True, remove_n_args=remove_n_args):
                continue

            if remove_n_args == 0:
                use_args = args
            else:
                use_args = args[:-remove_n_args]

            # Arguments bracket
            args_bracket = funcutils.constrArgsBracket(use_args, include_arg_name=True, include_arg_type=True, include_namespace=True)

            # Name of function to call (in abstract class)
            if is_operator:
                if uses_loaded_type:
                    call_func_name = &#39;operator_&#39; + gb.operator_names[func_el.get(&#39;name&#39;)] + gb.code_suffix
                else:
                    call_func_name = &#39;operator&#39; + func_el.get(&#39;name&#39;)    
            else:
                if uses_loaded_type or (remove_n_args&gt;0):
                    call_func_name = func_name + gb.code_suffix 
                else:
                    call_func_name = func_name


            # Write declaration line
            def_code += do_inline*&#39;inline &#39; + return_kw_str + return_type + &#39; &#39; + class_name[&#39;short&#39;] + &#39;::&#39; + func_name + args_bracket + is_const*&#39; const&#39; + &#39;\n&#39;

            # Write function body
            def_code += &#39;{\n&#39;

            if return_type == &#39;void&#39;:
                def_code += indent
            else:
                def_code += indent + &#39;return &#39;

            args_bracket_notypes = funcutils.constrArgsBracket(use_args, include_arg_name=True, include_arg_type=False, wrapper_to_pointer=True)

            if return_is_loaded: 

                abs_return_type_simple = toAbstractType(return_type, include_namespace=True, remove_reference=True, remove_pointers=True)
                return_type_simple     = return_type.replace(&#39;*&#39;,&#39;&#39;).replace(&#39;&amp;&#39;,&#39;&#39;)

                if is_const:
                    get_BEptr_call = &#39;const_cast&lt;const &#39; + abstr_class_name[&#39;short&#39;] +&#39;*&gt;(get_BEptr())&#39;
                else:
                    get_BEptr_call = &#39;get_BEptr()&#39;

                # Return-by-reference
                if is_ref:
                    if &#39;const&#39; in return_type_kw:
                        def_code += &#39;const_cast&lt;&#39; + abs_return_type_simple + &#39;&amp;&gt;(&#39; + get_BEptr_call + &#39;-&gt;&#39; + call_func_name + args_bracket_notypes + &#39;).get_init_wref();\n&#39;
                    else:
                        def_code += get_BEptr_call + &#39;-&gt;&#39; + call_func_name + args_bracket_notypes + &#39;.get_init_wref();\n&#39;
                
                # Return-by-pointer
                elif (not is_ref) and (pointerness &gt; 0):  
                    if &#39;const&#39; in return_type_kw:
                        def_code += &#39;const_cast&lt;&#39; + abs_return_type_simple + &#39;*&gt;(&#39; + get_BEptr_call + &#39;-&gt;&#39; + call_func_name + args_bracket_notypes + &#39;)-&gt;get_init_wptr();\n&#39;
                    else:
                        def_code += get_BEptr_call + &#39;-&gt;&#39; + call_func_name + args_bracket_notypes + &#39;-&gt;get_init_wptr();\n&#39;
                
                # Return-by-value
                else:
                    if &#39;const&#39; in return_type_kw:
                        # def_code += return_type + &#39;( const_cast&lt;&#39; + abs_return_type_simple + &#39;*&gt;(&#39; + get_BEptr_call + &#39;-&gt;&#39; + call_func_name + args_bracket_notypes + &#39;)-&gt;get_init_wref() );\n&#39;
                        def_code += return_type + &#39;( const_cast&lt;&#39; + abs_return_type_simple + &#39;*&gt;(&#39; + get_BEptr_call + &#39;-&gt;&#39; + call_func_name + args_bracket_notypes + &#39;) );\n&#39;
                    else:
                        # def_code += return_type + &#39;( &#39; + get_BEptr_call + &#39;-&gt;&#39; + call_func_name + args_bracket_notypes + &#39;-&gt;get_init_wref() );\n&#39;
                        def_code += return_type + &#39;( &#39; + get_BEptr_call + &#39;-&gt;&#39; + call_func_name + args_bracket_notypes + &#39; );\n&#39;
           
            else:                
                def_code += &#39;get_BEptr()-&gt;&#39; + call_func_name + args_bracket_notypes + &#39;;\n&#39;

            def_code += &#39;}\n&#39;
            def_code += &#39;\n&#39;


    #
    # Add all constructors here...
    #

    # First generate some code common to all constructors

    common_init_list_code   = &#39;&#39;

    common_constructor_body = &#39;&#39;
    if gb.debug_mode:
        common_constructor_body += indent + &#39;std::cerr &lt;&lt; &#34;DEBUG: &#34; &lt;&lt; this &lt;&lt; &#34; &#39; + short_wrapper_class_name + &#39; ctor&#34; &lt;&lt; std::endl;\n&#39;
    common_constructor_body += indent + &#39;get_BEptr()-&gt;set_wptr(this);\n&#39;
    common_constructor_body += indent + &#39;get_BEptr()-&gt;set_delete_wrapper(false);\n&#39;

    # mem_var_init_body = &#39;&#39;
    has_loaded_class_mem_var = False
    
    for var_el in class_variables:

        # Get info
        var_name = var_el.get(&#39;name&#39;)

        var_type_dict = utils.findType(var_el)
        var_type_name = var_type_dict[&#39;name&#39;]
        var_type_el   = var_type_dict[&#39;el&#39;]
        pointerness   = var_type_dict[&#39;pointerness&#39;]
        is_ref        = var_type_dict[&#39;is_reference&#39;]

        var_type = var_type_dict[&#39;name&#39;] + &#39;*&#39;*pointerness + &#39;&amp;&#39;*is_ref
        
        var_is_loaded_class = utils.isLoadedClass(var_type_el)

        # wrapper_type_name = toWrapperType(var_type, remove_reference=True, remove_pointers=True, include_namespace=True)
        var_abstr_class_name = getClassNameDict(var_type_el, abstract=True)
        # var_wrapper_base_class_name = &#39;WrapperBase&lt;&#39; + var_abstr_class_name[&#39;long&#39;] + &#39;&gt;&#39;

        # # FIXME: At the moment there are problems with member variables that are pointer-to-loaded-class. For now, skip them:
        # if var_is_loaded_class and pointerness &gt; 0:
        #     print(&#39;WARNING: The member variable %s is of a loaded type and has pointerness &gt; 0. This BOSS cannot yet handle. Ignored for now...&#39; % var_name)
        #     continue

        # Construct common initialization list
        if var_is_loaded_class:
            if pointerness == 0:
                common_init_list_code += indent + var_name + &#39;( get_BEptr()-&gt;&#39; + var_name + &#39;_ref&#39; + gb.code_suffix + &#39;().get_init_wref()),\n&#39;
            elif pointerness == 1:
                common_init_list_code += indent + var_name + &#39;( get_BEptr()-&gt;&#39; + var_name + &#39;_ref&#39; + gb.code_suffix + &#39;()-&gt;get_init_wptr()),\n&#39;
                # common_init_list_code += indent + var_name + &#39;(wrapperbase::BEptr-&gt;&#39; + var_name + &#39;_ref&#39; + gb.code_suffix + &#39;()),\n&#39;
            else:
                raise Exception(&#39;The BOSS wrapper class system cannot presently handle member variables that have a pointerness &gt; 1&#39;)
        else:
            common_init_list_code += indent + var_name + &#39;( get_BEptr()-&gt;&#39; + var_name + &#39;_ref&#39; + gb.code_suffix + &#39;()),\n&#39;


    # Clean up initialization list
    if common_init_list_code != &#39;&#39;:
        common_init_list_code = common_init_list_code.rstrip(&#39;,\n&#39;) + &#39;\n&#39;


    # Add wrappers for all original constructors except the copy constructor
    temp_code = &#39;&#39;
    factory_counter = 0
    for i, constr_el in enumerate(class_constructors):

        # Identify arguments
        args = funcutils.getArgs(constr_el)
        factory_args = funcutils.constrWrapperArgs(args, add_ref=True)

        # If default arguments are used, we need overloaded constructors to connect to the overloaded
        # factory function pointers
        n_overloads = funcutils.numberOfDefaultArgs(constr_el)

        # One constructor for each set of default arguments
        for remove_n_args in range(n_overloads+1):

            # Check that the constructor is acceptable
            if funcutils.ignoreFunction(constr_el, limit_pointerness=True, remove_n_args=remove_n_args):
                continue

            if remove_n_args == 0:
                use_args         = args
                factory_use_args = factory_args
            else:
                use_args         = args[:-remove_n_args]
                factory_use_args = factory_args[:-remove_n_args]

            args_bracket = funcutils.constrArgsBracket(use_args, include_arg_name=True, include_arg_type=True, include_namespace=True, use_wrapper_class=False)
            args_bracket_notypes = funcutils.constrArgsBracket(use_args, include_arg_name=True, include_arg_type=False, wrapper_to_pointer=False)
            factory_args_bracket = funcutils.constrArgsBracket(factory_use_args, include_arg_name=False, include_arg_type=True, include_namespace=True)

            # Factory pointer name
            factory_ptr_name = &#39;__factory&#39; + str(factory_counter)

            temp_code += &#39;inline &#39; + class_name[&#39;short&#39;] + &#39;::&#39; + class_name[&#39;short&#39;] + args_bracket + &#39; :\n&#39;

            parent_class_init_list = &#39;&#39;
            # parent_class_init_list += indent + &#39;WrapperBase(&#39; + factory_ptr_name + args_bracket_notypes + &#39;),\n&#39;
            for parent_dict in loaded_parent_classes:
                parent_class_init_list += indent + parent_dict[&#39;class_name&#39;][&#39;short&#39;] + &#39;(&#39; + factory_ptr_name + args_bracket_notypes + &#39;),\n&#39;
            if parent_class_init_list == &#39;&#39;:
                parent_class_init_list += indent + &#39;WrapperBase(&#39; + factory_ptr_name + args_bracket_notypes + &#39;),\n&#39;

            if common_init_list_code != &#39;&#39;:
                temp_code += parent_class_init_list + common_init_list_code
            else:
                temp_code += parent_class_init_list.rstrip(&#39;,\n&#39;) + &#39;\n&#39;
            temp_code += &#39;{\n&#39;
            temp_code += common_constructor_body
            temp_code += &#39;}\n&#39;

            temp_code += &#39;\n&#39;

            # Increment factory counter
            factory_counter += 1

    if temp_code != &#39;&#39;:
        def_code += &#39;\n&#39;
        def_code += &#39;// Wrappers for original constructors: \n&#39;    
        def_code += temp_code


    # Add special constructor based on abstract class pointer.
    def_code += &#39;// Special pointer-based constructor: \n&#39;
    def_code += do_inline*&#39;inline &#39; + class_name[&#39;short&#39;] + &#39;::&#39; + class_name[&#39;short&#39;] + &#39;(&#39; + abstr_class_name[&#39;short&#39;] +&#39;* in) :\n&#39;

    parent_class_init_list = &#39;&#39;
    # parent_class_init_list += indent + &#39;WrapperBase(in),\n&#39;
    for parent_dict in loaded_parent_classes:
        parent_class_init_list += indent + parent_dict[&#39;class_name&#39;][&#39;short&#39;] + &#39;(in),\n&#39;
    if parent_class_init_list == &#39;&#39;:
        parent_class_init_list += indent + &#39;WrapperBase(in),\n&#39;

    if common_init_list_code != &#39;&#39;:
        def_code += parent_class_init_list + common_init_list_code
    else:
        def_code += parent_class_init_list.rstrip(&#39;,\n&#39;) + &#39;\n&#39;
    def_code += &#39;{\n&#39;
    def_code += common_constructor_body
    def_code += &#39;}\n&#39;

    # # Const version of constructor from abstract class pointer
    # def_code += do_inline*&#39;inline &#39; + class_name[&#39;long&#39;] + &#39;::&#39; + class_name[&#39;short&#39;] + &#39;(const &#39; + abstr_class_name[&#39;long&#39;] +&#39;* in) :\n&#39;

    # parent_class_init_list = &#39;&#39;
    # for parent_dict in loaded_parent_classes:
    #     parent_class_init_list += indent + parent_dict[&#39;class_name&#39;][&#39;short&#39;] + &#39;(in),\n&#39;
    # if parent_class_init_list == &#39;&#39;:
    #     parent_class_init_list += indent + &#39;WrapperBase(in),\n&#39;

    # if common_init_list_code != &#39;&#39;:
    #     def_code += parent_class_init_list + common_init_list_code
    # else:
    #     def_code += parent_class_init_list.rstrip(&#39;,\n&#39;) + &#39;\n&#39;
    # def_code += &#39;{\n&#39;
    # def_code += common_constructor_body
    # def_code += &#39;}\n&#39;



    # Add copy constructor
    if has_copy_constructor:
        def_code += &#39;\n&#39;
        def_code += &#39;// Copy constructor: \n&#39;
        def_code += do_inline*&#39;inline &#39; + class_name[&#39;short&#39;] + &#39;::&#39; + class_name[&#39;short&#39;] + &#39;(const &#39; + class_name[&#39;short&#39;] +&#39;&amp; in) :\n&#39;

        parent_class_init_list = &#39;&#39;
        # parent_class_init_list += indent + &#39;WrapperBase(in.get_BEptr()-&gt;pointer_copy&#39; + gb.code_suffix + &#39;()),\n&#39;
        for parent_dict in loaded_parent_classes:
            parent_class_init_list += indent + parent_dict[&#39;class_name&#39;][&#39;short&#39;] + &#39;(in.get_BEptr()-&gt;pointer_copy&#39; + gb.code_suffix + &#39;()),\n&#39;
        if parent_class_init_list == &#39;&#39;:
            parent_class_init_list += indent + &#39;WrapperBase(in.get_BEptr()-&gt;pointer_copy&#39; + gb.code_suffix + &#39;()),\n&#39;

        if common_init_list_code != &#39;&#39;:
            def_code += parent_class_init_list + common_init_list_code
        else:
            def_code += parent_class_init_list.rstrip(&#39;,\n&#39;) + &#39;\n&#39;
        def_code += &#39;{\n&#39;
        def_code += common_constructor_body
        def_code += &#39;}\n&#39;


    # 
    # Add assignment operator
    #
    if construct_assignment_operator:
        def_code += &#39;\n&#39;
        def_code += &#39;// Assignment operator: \n&#39;
        def_code += do_inline*&#39;inline &#39; + class_name[&#39;short&#39;] + &#39;&amp; &#39; + class_name[&#39;short&#39;] + &#39;::operator=(const &#39; + class_name[&#39;short&#39;] +&#39;&amp; in)\n&#39;
        def_code += &#39;{\n&#39;
        def_code +=   indent + &#39;if (this != &amp;in)\n&#39;
        def_code +=   indent + &#39;{\n&#39;
        def_code += 2*indent + &#39;get_BEptr()-&gt;pointer_assign&#39; + gb.code_suffix + &#39;(in.get_BEptr());\n&#39;
        def_code +=   indent + &#39;}\n&#39;
        def_code +=   indent + &#39;return *this;\n&#39;
        def_code += &#39;}\n\n&#39;
    

    # 
    # Add destructor
    #
    def_code += &#39;\n&#39;
    def_code += &#39;// Destructor: \n&#39;
    def_code += do_inline*&#39;inline &#39; + class_name[&#39;short&#39;] + &#39;::~&#39; + class_name[&#39;short&#39;] + &#39;()\n&#39;
    def_code += &#39;{\n&#39;
    if gb.debug_mode:
        def_code += indent + &#39;std::cerr &lt;&lt; &#34;DEBUG: &#34; &lt;&lt; this &lt;&lt; &#34; &#39; + short_wrapper_class_name + &#39; dtor (BEGIN)&#34; &lt;&lt; std::endl;\n&#39;
    def_code +=   indent + &#39;if (get_BEptr() != 0)\n&#39;
    def_code +=   indent + &#39;{\n&#39;
    def_code += 2*indent + &#39;get_BEptr()-&gt;set_delete_wrapper(false);\n&#39;
    def_code += 2*indent + &#39;if (can_delete_BEptr())\n&#39;
    def_code += 2*indent + &#39;{\n&#39;
    def_code += 3*indent + &#39;delete BEptr;\n&#39;
    def_code += 3*indent + &#39;BEptr = 0;\n&#39;
    def_code += 2*indent + &#39;}\n&#39;
    def_code +=   indent + &#39;}\n&#39;
    def_code +=   indent + &#39;set_delete_BEptr(false);\n&#39;
    if gb.debug_mode:
        def_code += indent + &#39;std::cerr &lt;&lt; &#34;DEBUG: &#34; &lt;&lt; this &lt;&lt; &#34; &#39; + short_wrapper_class_name + &#39; dtor (END)&#34; &lt;&lt; std::endl;\n&#39;
    def_code += &#39;}\n&#39;


    #
    # Add get_BEptr function
    #
    def_code += &#39;\n&#39;
    def_code += &#39;// Returns correctly casted pointer to Abstract class: \n&#39;
    def_code += do_inline*&#39;inline &#39; + abstr_class_name[&#39;short&#39;] +&#39;* &#39; + class_name[&#39;long&#39;] + &#39;::get_BEptr() const\n&#39;
    def_code += &#39;{\n&#39;
    def_code += indent + &#39;return dynamic_cast&lt;&#39; + abstr_class_name[&#39;short&#39;] + &#39;*&gt;(BEptr);\n&#39;
    def_code += &#39;}\n&#39;

    
    # Add namespace
    namespace, class_name_short = utils.removeNamespace(class_name[&#39;long&#39;], return_namespace=True)

    if namespace == &#39;&#39;:
        namespace_list = []
    else:
        namespace_list = namespace.split(&#39;::&#39;)

    n_indents = len(namespace_list)

    def_code_with_ns  = &#39;&#39;
    def_code_with_ns += utils.constrNamespace(namespace_list,&#39;open&#39;)
    def_code_with_ns += utils.addIndentation(def_code, cfg.indent*n_indents)
    def_code_with_ns += utils.constrNamespace(namespace_list,&#39;close&#39;)


    # Return 
    return def_code_with_ns

# ====== END: constrWrapperDef ========



# ====== pureVirtualMembers ========

def pureVirtualMembers(class_el):

    # Return a list with the names of all pure virtual member functions of a class.

    check_member_elements = utils.getMemberElements(class_el)
    pure_virtual_members = []

    for mem_el in check_member_elements:
        if mem_el.tag in [&#39;Constructor&#39;, &#39;Destructor&#39;, &#39;Method&#39;, &#39;OperatorMethod&#39;]:
            if (&#39;pure_virtual&#39; in mem_el.keys()) and (mem_el.get(&#39;pure_virtual&#39;)==&#39;1&#39;):
                pure_virtual_members.append(mem_el.get(&#39;name&#39;))

    return pure_virtual_members

# ====== END: pureVirtualMembers ========



# ====== generateWrapperHeaderCode ========

# Generate a header file with a GAMBIT wrapper class.

def generateWrapperHeaderCode(class_el, class_name, abstr_class_name, namespaces, 
                          short_abstr_class_fname,
                          construct_assignment_operator, has_copy_constructor,
                          copy_constructor_id=&#39;&#39;):

    # Useful variables
    indent = &#39; &#39;*cfg.indent

    # Useful lists
    class_variables    = []
    class_functions    = utils.getMemberFunctions(class_el, include_artificial=False, include_inherited=cfg.wrap_inherited_members, 
                                                            only_accepted=True, limit_pointerness=True, include_operators=True)
    class_constructors = []
    class_members      = utils.getMemberElements(class_el, include_artificial=False)
    class_members_full = utils.getMemberElements(class_el, include_artificial=True)
    for mem_el in class_members:

        if (mem_el.tag in (&#39;Field&#39;, &#39;Variable&#39;)) and (mem_el.get(&#39;access&#39;) == &#39;public&#39;):
            if isAcceptedMemberVariable(mem_el):
                class_variables.append(mem_el)
        else:
            pass

    for mem_el in class_members_full:

        # Skip the copy constructor
        if has_copy_constructor and (mem_el.get(&#39;id&#39;) == copy_constructor_id):
            continue

        # Store constructor if acceptable
        if (mem_el.tag == &#39;Constructor&#39;) and (mem_el.get(&#39;access&#39;) == &#39;public&#39;):
            class_constructors.append(mem_el)

    # Create a list of dicts with info on the (loaded) parent classes
    loaded_parent_classes = utils.getParentClasses(class_el, only_loaded_classes=True)


    #
    # Start code generation
    #

    decl_code = constrWrapperDecl(class_name, abstr_class_name, loaded_parent_classes, class_variables, class_functions, class_constructors, construct_assignment_operator, has_copy_constructor, indent=indent)
    def_code  = constrWrapperDef(class_name, abstr_class_name, loaded_parent_classes, class_variables, class_functions, class_constructors, construct_assignment_operator, has_copy_constructor, indent=indent, do_inline=True)

    # Insert tags for the GAMBIT namespace
    decl_code = &#39;\n__START_GAMBIT_NAMESPACE__\n&#39; + decl_code + &#39;\n__END_GAMBIT_NAMESPACE__\n&#39;
    def_code  = &#39;\n__START_GAMBIT_NAMESPACE__\n&#39; + def_code  + &#39;\n__END_GAMBIT_NAMESPACE__\n&#39;

    # Insert include statements needed by GAMBIT 
    backend_undef_incl_statement  = &#39;#include &#34;&#39; + os.path.join(gb.gambit_backend_incl_dir, &#39;backend_undefs.hpp&#39;) + &#39;&#34;\n&#39;
    identification_incl_statement = &#39;#include &#34;&#39; + &#39;identification.hpp&#39; + &#39;&#34;\n&#39;

    decl_code = identification_incl_statement + decl_code + &#39;\n&#39; + backend_undef_incl_statement
    def_code  = identification_incl_statement + def_code + &#39;\n&#39; + backend_undef_incl_statement


    
    #
    # Add #include statements for the declaration code
    #

    decl_code_include_statements = []

    # - Header where NULL is defined
    decl_code_include_statements.append( &#39;#include &lt;cstddef&gt;&#39; )

    # - If debug_mode, include &lt;iostream&gt; for some output
    if gb.debug_mode:
        decl_code_include_statements.append( &#39;#include &lt;iostream&gt;&#39; )        

    # - Header with forward declarations to all wrapper classes
    decl_code_include_statements.append( &#39;#include &#34;&#39; + gb.frwd_decls_wrp_fname + cfg.header_extension + &#39;&#34;&#39;)

    # - Base class for all wrapper classes
    decl_code_include_statements.append( &#39;#include &#34;&#39; + os.path.join(gb.gambit_backend_incl_dir, &#39;wrapperbase.hpp&#39;) + &#39;&#34;&#39;)

    # - Abstract class for the original class
    decl_code_include_statements.append( &#39;#include &#34;&#39; + gb.new_header_files[class_name[&#39;long&#39;]][&#39;abstract&#39;] + &#39;&#34;&#39; )

    # - Wrapper parent classes
    for parent_dict in loaded_parent_classes:
        decl_code_include_statements.append(&#39;#include &#34;&#39; + gb.new_header_files[ parent_dict[&#39;class_name&#39;][&#39;long&#39;] ][&#39;wrapper_decl&#39;] + &#39;&#34;&#39;)

    # - Any other types (excluding the current wrapper class)
    decl_code_include_statements += utils.getIncludeStatements(class_el, convert_loaded_to=&#39;wrapper_decl&#39;, exclude_types=[class_name], use_full_path=False, forward_declared=&#39;exclude&#39;)

    # Remove duplicates and construct code
    decl_code_include_statements = list( OrderedDict.fromkeys(decl_code_include_statements) )
    decl_code_include_statements = utils.orderIncludeStatements(decl_code_include_statements)
    decl_include_statements_code = &#39;\n&#39;.join(decl_code_include_statements) + 2*&#39;\n&#39;
    decl_code = decl_include_statements_code + decl_code


    #
    # Add #include statements for the definition code
    #

    def_code_include_statements = []

    # - Any other types (excluding the current wrapper class)
    def_code_include_statements += utils.getIncludeStatements(class_el, convert_loaded_to=&#39;wrapper_decl&#39;, exclude_types=[class_name], use_full_path=False, forward_declared=&#39;include&#39;)

    # Remove duplicates and construct code
    def_code_include_statements = list( OrderedDict.fromkeys(def_code_include_statements) )
    def_code_include_statements = utils.orderIncludeStatements(def_code_include_statements)
    def_include_statements_code = &#39;\n&#39;.join(def_code_include_statements) + 2*&#39;\n&#39;
    def_code = def_include_statements_code + def_code


    # Return code
    return decl_code, def_code

# ====== END: generateWrapperHeaderCode ========



# ====== findClassNamePosition ========

# Find the position of a class name  

def findClassNamePosition(class_el, file_content_nocomments):

    class_name = getClassNameDict(class_el)

    # Find the index of the \n after the first line of the class declaration
    line_number = int(class_el.get(&#39;line&#39;))
    newline_pos = utils.findNewLinePos(file_content_nocomments, line_number)

    # Find position of class name
    search_limit = newline_pos
    while search_limit &gt; -1:
        class_name_pos = file_content_nocomments[:search_limit].rfind(class_name[&#39;short&#39;])
        pre_char  = file_content_nocomments[class_name_pos-1]
        post_char = file_content_nocomments[class_name_pos+len(class_name[&#39;short&#39;])]
        if (pre_char in [&#39; &#39;,&#39;\n&#39;,&#39;\t&#39;]) and (post_char in [&#39; &#39;, &#39;:&#39;, &#39;\n&#39;, &#39;&lt;&#39;, &#39;{&#39;]):
            break
        else:
            search_limit = class_name_pos

    return class_name_pos

# ====== END: findClassNamePosition ========



# ====== isAcceptedMemberVariable ========

def isAcceptedMemberVariable(mem_el):

    is_accepted = True

    if not utils.isAcceptedType(mem_el):
        reason = &#34;Non-accepted type.&#34;
        infomsg.IgnoredMemberVariable(mem_el.get(&#39;name&#39;), reason).printMessage()
        is_accepted = False
        return is_accepted

    # Should this member be ditched?
    if &#39;name&#39; in mem_el.keys():
        namespaces_list = utils.getNamespaces(mem_el, include_self=True)
        full_name = &#39;::&#39;.join(namespaces_list)
        if full_name in cfg.ditch:
            is_accepted = False
            return is_accepted

    # BOSS cannot yet handle member variables that are pointer-to-loaded-class.
    type_dict = utils.findType(mem_el)
    type_name = type_dict[&#39;name&#39;]
    pointerness = type_dict[&#39;pointerness&#39;]

    if utils.isLoadedClass(mem_el) and pointerness &gt; 0:
        reason = &#34;BOSS cannot yet handle member variables of type pointer-to-loaded-class.&#34;
        infomsg.IgnoredMemberVariable(mem_el.get(&#39;name&#39;), reason).printMessage()
        is_accepted = False
        return is_accepted

    return is_accepted

# ====== END: isAcceptedMemberVariable ========
</code></pre><hr/><p>Updated on 2022-08-10 at 17:51:38 +0000</p></main></div></div></div><footer class="footer text-muted"><div class="container-xxl"><div class="row"><div class="col-lg-8 order-last order-lg-first"><ul class="list-inline"><li class="list-inline-item">Powered by <a class="text-muted" href="https://www.netlify.com/">Netlify</a>, <a class="text-muted" href="https://gohugo.io/">Hugo</a>, and <a class="text-muted" href="https://getdoks.org/">Doks</a></li></ul></div><div class="col-lg-8 order-first order-lg-last text-lg-end"><ul class="list-inline"><li class="list-inline-item"><a href="/license/">License</a></li></ul></div></div></div></footer><script src="/js/bootstrap.min.54bf0932b8a36d0e152b1635b099a6ef1394d35327e2437550a075c9c8ed1bd8aed5847c21b36fc02ed24014c031d9ca24017b0c78b1639d7e2fa8329898b842.js" integrity="sha512-VL8JMrijbQ4VKxY1sJmm7xOU01Mn4kN1UKB1ycjtG9iu1YR8IbNvwC7SQBTAMdnKJAF7DHixY51+L6gymJi4Qg==" crossorigin="anonymous" defer=""></script>
<script src="/js/highlight.min.5b48bc253dc75aeea5fb366ecf700f4925e2b6eb1a1466f2124b722d68148d67bc0a9365d2b8ad9c585161b46372d23b08509a16f1fd518542b894756d4752d0.js" integrity="sha512-W0i8JT3HWu6l+zZuz3APSSXitusaFGbyEktyLWgUjWe8CpNl0ritnFhRYbRjctI7CFCaFvH9UYVCuJR1bUdS0A==" crossorigin="anonymous" defer=""></script>
<script src="/main.min.40265e9a032aeba5eaf67baac3cbbc22667a7533215d326eeb3e9f4d5e4be40f9ff4dcd22949db73ae527ca26a19d7998091a8973c82af760b2c0daa335190ed.js" integrity="sha512-QCZemgMq66Xq9nuqw8u8ImZ6dTMhXTJu6z6fTV5L5A+f9NzSKUnbc65SfKJqGdeZgJGolzyCr3YLLA2qM1GQ7Q==" crossorigin="anonymous" defer=""></script>
<script src="https://gambitbsm.github.io/index.min.1e0f859443ac81a8b8c357ddfae5d899d83ab224e24e44c1c9620a99f2a527d70a1676148a868f87f22fb67994386d592e508dafb575df7c2b80d97f143ad1ea.js" integrity="sha512-Hg+FlEOsgai4w1fd+uXYmdg6siTiTkTByWIKmfKlJ9cKFnYUioaPh/IvtnmUOG1ZLlCNr7V133wrgNl/FDrR6g==" crossorigin="anonymous" defer=""></script></body></html>