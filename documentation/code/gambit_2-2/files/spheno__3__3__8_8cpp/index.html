<!DOCTYPE html><html lang="en-us"><head><meta charset="utf-8"/><meta http-equiv="x-ua-compatible" content="ie=edge"/><meta name="viewport" content="width=device-width,initial-scale=1,shrink-to-fit=no"/><link rel="preload" as="font" href="https://gambitbsm.github.io/fonts/vendor/jost/jost-v4-latin-regular.woff2" type="font/woff2" crossorigin=""/><link rel="preload" as="font" href="https://gambitbsm.github.io/fonts/vendor/jost/jost-v4-latin-500.woff2" type="font/woff2" crossorigin=""/><link rel="preload" as="font" href="https://gambitbsm.github.io/fonts/vendor/jost/jost-v4-latin-700.woff2" type="font/woff2" crossorigin=""/><script>(()=>{var e=localStorage.getItem("theme");e==="dark"&&document.documentElement.setAttribute("data-dark-mode","")})()</script><link rel="stylesheet" href="https://gambitbsm.github.io/main.e60a30503f41dfe2a8e849eba3bb572667400d7915356bae7eff31d3e22e4492fc8c0b2ff150168b1139b9c0caad1a20c84c8957336bcc2bba8559379cc39f91.css" integrity="sha512-5gowUD9B3+Ko6Enro7tXJmdADXkVNWuufv8x0+IuRJL8jAsv8VAWixE5ucDKrRogyEyJVzNrzCu6hVk3nMOfkQ==" crossorigin="anonymous"/><noscript><style>img.lazyload{display:none}</style></noscript><meta name="robots" content="index, follow"/><meta name="googlebot" content="index, follow, max-snippet:-1, max-image-preview:large, max-video-preview:-1"/><meta name="bingbot" content="index, follow, max-snippet:-1, max-image-preview:large, max-video-preview:-1"/><title>file frontends/SPheno_3_3_8.cpp - GAMBIT</title><meta name="description" content="[No description available]"/><link rel="canonical" href="https://gambitbsm.github.io/documentation/code/gambit_2-2/files/spheno__3__3__8_8cpp/"/><meta property="og:locale" content="en_US"/><meta property="og:type" content="article"/><meta property="og:title" content="file frontends/SPheno_3_3_8.cpp"/><meta property="og:description" content="[No description available]"/><meta property="og:url" content="https://gambitbsm.github.io/documentation/code/gambit_2-2/files/spheno__3__3__8_8cpp/"/><meta property="og:site_name" content="GAMBIT"/><meta property="og:image" content="https://gambitbsm.github.io/gambit_logo.png"/><meta property="og:image:alt" content="GAMBIT"/><meta name="twitter:card" content="summary_large_image"/><meta name="twitter:site" content=""/><meta name="twitter:creator" content=""/><meta name="twitter:title" content="file frontends/SPheno_3_3_8.cpp"/><meta name="twitter:description" content="[No description available]"/><meta name="twitter:image" content="https://gambitbsm.github.io/gambit_logo.png"/><meta name="twitter:image:alt" content="file frontends/SPheno_3_3_8.cpp"/><script type="application/ld+json">{"@context":"https://schema.org","@graph":[{"@type":"Organization","@id":"https://gambitbsm.github.io/#/schema/organization/1","name":"Doks","url":"https://gambitbsm.github.io/","sameAs":["https://github.com/GambitBSM"],"logo":{"@type":"ImageObject","@id":"https://gambitbsm.github.io/#/schema/image/1","url":"https://gambitbsm.github.io/logo-doks.png","width":450,"height":416,"caption":"Doks"},"image":{"@id":"https://gambitbsm.github.io/#/schema/image/1"}},{"@type":"WebSite","@id":"https://gambitbsm.github.io/#/schema/website/1","url":"https://gambitbsm.github.io/","name":"GAMBIT","description":"Documentation for the Global And Modular BSM Inference Tool","publisher":{"@id":"https://gambitbsm.github.io/#/schema/organization/1"}},{"@type":"WebPage","@id":"https://gambitbsm.github.io/documentation/code/gambit_2-2/files/spheno__3__3__8_8cpp/","url":"https://gambitbsm.github.io/documentation/code/gambit_2-2/files/spheno__3__3__8_8cpp/","name":"file frontends\/SPheno_3_3_8.cpp","description":"[No description available]","isPartOf":{"@id":"https://gambitbsm.github.io/#/schema/website/1"},"about":{"@id":"https://gambitbsm.github.io/#/schema/organization/1"},"datePublished":"0001-01-01T00:00:00CET","dateModified":"0001-01-01T00:00:00CET","breadcrumb":{"@id":"https://gambitbsm.github.io/documentation/code/gambit_2-2/files/spheno__3__3__8_8cpp/#/schema/breadcrumb/1"},"primaryImageOfPage":{"@id":"https://gambitbsm.github.io/documentation/code/gambit_2-2/files/spheno__3__3__8_8cpp/#/schema/image/2"},"inLanguage":"en-US","potentialAction":[{"@type":"ReadAction","target":["https://gambitbsm.github.io/documentation/code/gambit_2-2/files/spheno__3__3__8_8cpp/"]}]},{"@type":"BreadcrumbList","@id":"https://gambitbsm.github.io/documentation/code/gambit_2-2/files/spheno__3__3__8_8cpp/#/schema/breadcrumb/1","name":"Breadcrumbs","itemListElement":[{"@type":"ListItem","position":1,"item":{"@type":"WebPage","@id":"https://gambitbsm.github.io/","url":"https://gambitbsm.github.io/","name":"Home"}},{"@type":"ListItem","position":2,"item":{"@type":"WebPage","@id":"https://gambitbsm.github.io/documentation/","url":"https://gambitbsm.github.io/documentation/","name":"Documentation"}},{"@type":"ListItem","position":3,"item":{"@type":"WebPage","@id":"https://gambitbsm.github.io/documentation/code/","url":"https://gambitbsm.github.io/documentation/code/","name":"Code"}},{"@type":"ListItem","position":4,"item":{"@type":"WebPage","@id":"https://gambitbsm.github.io/documentation/code/gambit_2-2/","url":"https://gambitbsm.github.io/documentation/code/gambit_2-2/","name":"Gambit 2 2"}},{"@type":"ListItem","position":5,"item":{"@type":"WebPage","@id":"https://gambitbsm.github.io/documentation/code/gambit_2-2/files/","url":"https://gambitbsm.github.io/documentation/code/gambit_2-2/files/","name":"Files"}},{"@type":"ListItem","position":6,"item":{"@id":"https://gambitbsm.github.io/documentation/code/gambit_2-2/files/spheno__3__3__8_8cpp/"}}]},{"@context":"https://schema.org","@graph":[{"@type":"ImageObject","@id":"https://gambitbsm.github.io/documentation/code/gambit_2-2/files/spheno__3__3__8_8cpp/#/schema/image/2","url":"https://gambitbsm.github.io/gambit_logo.png","contentUrl":"https://gambitbsm.github.io/gambit_logo.png","caption":"file frontends\/SPheno_3_3_8.cpp"}]}]}</script><meta name="theme-color" content="#fff"/><link rel="icon" href="https://gambitbsm.github.io/favicon.ico" sizes="any"/><link rel="icon" type="image/svg+xml" href="https://gambitbsm.github.io/favicon.svg"/><link rel="apple-touch-icon" sizes="180x180" href="https://gambitbsm.github.io/apple-touch-icon.png"/><link rel="icon" type="image/png" sizes="32x32" href="https://gambitbsm.github.io/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="16x16" href="https://gambitbsm.github.io/favicon-16x16.png"/><link rel="manifest" crossorigin="use-credentials" href="https://gambitbsm.github.io/site.webmanifest"/></head><body class="documentation single light"><div class="sticky-top"><div class="header-bar"></div><header class="navbar navbar-expand-md navbar-light doks-navbar"><nav class="container-xxl flex-wrap flex-md-nowrap" aria-label="Main navigation"><a class="navbar-brand p-0 me-auto" href="https://gambitbsm.github.io/" aria-label="GAMBIT"><img class="logo-light" src="https://gambitbsm.github.io//images/gambit_logo.png" width="50px"/>
<img class="logo-dark d-none" src="https://gambitbsm.github.io//images/gambit_logo.png" width="50px"/>
GAMBIT</a>
<button class="btn btn-menu order-2 d-block d-lg-none" type="button" data-bs-toggle="offcanvas" data-bs-target="#offcanvasDoks" aria-controls="offcanvasDoks" aria-label="Open main menu"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-menu"><line x1="3" y1="12" x2="21" y2="12"></line><line x1="3" y1="6" x2="21" y2="6"></line><line x1="3" y1="18" x2="21" y2="18"></line></svg></button><div class="offcanvas offcanvas-end border-0 py-lg-1" tabindex="-1" id="offcanvasDoks" data-bs-backdrop="true" aria-labelledby="offcanvasDoksLabel"><div class="header-bar d-lg-none"></div><div class="offcanvas-header d-lg-none"><h2 class="h5 offcanvas-title ps-2" id="offcanvasDoksLabel"><a class="text-dark" href="/">GAMBIT</a></h2><button type="button" class="btn-close text-reset me-2" data-bs-dismiss="offcanvas" aria-label="Close main menu"></button></div><div class="offcanvas-body p-4 p-lg-0"><ul class="nav flex-column flex-lg-row align-items-lg-center mt-2 mt-lg-0 ms-lg-2 me-lg-auto"><li class="nav-item dropdown"><a class="nav-link dropdown-toggle ps-0 py-1" href="#" id="navbarDropdownMenuLink" role="button" data-bs-toggle="dropdown" aria-expanded="false">Documentation
<span class="dropdown-caret"><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-chevron-down"><polyline points="6 9 12 15 18 9"></polyline></svg></span></a><ul class="dropdown-menu dropdown-menu-main shadow rounded border-0" aria-labelledby="navbarDropdownMenuLink"><li><a class="dropdown-item" href="/documentation/installation/introduction/">Installation</a></li><li><a class="dropdown-item" href="/documentation/examples/colliderbit_example">Examples</a></li><li><a class="dropdown-item" href="/documentation/help/faqs/">Help</a></li><li><a class="dropdown-item" href="/documentation/code/gambit_2-2/index_classes">Code Reference</a></li></ul></li><li class="nav-item dropdown"><a class="nav-link dropdown-toggle ps-0 py-1" href="#" id="navbarDropdownMenuLink" role="button" data-bs-toggle="dropdown" aria-expanded="false">Community
<span class="dropdown-caret"><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-chevron-down"><polyline points="6 9 12 15 18 9"></polyline></svg></span></a><ul class="dropdown-menu dropdown-menu-main shadow rounded border-0" aria-labelledby="navbarDropdownMenuLink"><li><a class="dropdown-item" href="/community/publications/">Publications</a></li><li><a class="dropdown-item" href="/community/talks/">Talks</a></li><li><a class="dropdown-item" href="/community/members/">Members</a></li><li><a class="dropdown-item active" href="/community/code_of_conduct/" aria-current="true">Code of Conduct</a></li><li><a class="dropdown-item" href="/community/contact/">Contact</a></li></ul></li><li class="nav-item"><a class="nav-link ps-0 py-1" href="/wiki/general/homepage/">Wiki</a></li></ul><hr class="text-black-50 my-4 d-lg-none"/><form class="doks-search position-relative flex-grow-1 ms-lg-auto me-lg-2"><input id="search" class="form-control is-search" type="search" placeholder="Search site..." aria-label="Search site..." autocomplete="off"/><div id="suggestions" class="shadow bg-white rounded d-none"></div></form><hr class="text-black-50 my-4 d-lg-none"/><ul class="nav flex-column flex-lg-row"><li class="nav-item"><a class="nav-link social-link" href="https://github.com/GambitBSM"><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-github"><path d="M9 19c-5 1.5-5-2.5-7-3m14 6v-3.87a3.37 3.37.0 00-.94-2.61c3.14-.35 6.44-1.54 6.44-7A5.44 5.44.0 0020 4.77 5.07 5.07.0 0019.91 1S18.73.65 16 2.48a13.38 13.38.0 00-7 0C6.27.65 5.09 1 5.09 1A5.07 5.07.0 005 4.77 5.44 5.44.0 003.5 8.55c0 5.42 3.3 6.61 6.44 7A3.37 3.37.0 009 18.13V22"></path></svg><small class="ms-2 d-lg-none">GitHub</small></a></li></ul><hr class="text-black-50 my-4 d-lg-none"/><button id="mode" class="btn btn-link" type="button" aria-label="Toggle user interface mode">
<span class="toggle-dark"><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-moon"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"></path></svg></span><span class="toggle-light"><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-sun"><circle cx="12" cy="12" r="5"></circle><line x1="12" y1="1" x2="12" y2="3"></line><line x1="12" y1="21" x2="12" y2="23"></line><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line><line x1="1" y1="12" x2="3" y2="12"></line><line x1="21" y1="12" x2="23" y2="12"></line><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line></svg></span></button></div></div></nav></header></div><div class="wrap container-xxl" role="document"><div class="content"><div class="row flex-xl-nowrap"><div class="col-lg-5 col-xl-4 docs-sidebar"><nav class="docs-links" aria-label="Main navigation"><ul class="list-unstyled collapsible-sidebar"><li class="mb-1"><button class="btn btn-toggle align-items-center rounded collapsed" data-bs-toggle="collapse" data-bs-target="#section-installation" aria-expanded="false">
Installation</button><div class="collapse" id="section-installation"><ul class="btn-toggle-nav list-unstyled fw-normal pb-1 small"><li><a class="docs-link rounded" href="/documentation/installation/introduction/">Getting Started</a></li><li><a class="docs-link rounded" href="/documentation/installation/docker_usage/">Docker Usage</a></li><li><a class="docs-link rounded" href="/documentation/installation/installation_for_linux/">Installation for Linux</a></li><li><a class="docs-link rounded" href="/documentation/installation/installation_for_windows/">Installation for Windows</a></li><li><a class="docs-link rounded" href="/documentation/installation/installation_for_macos/">Installation for macOS</a></li></ul></div></li><li class="mb-1"><button class="btn btn-toggle align-items-center rounded collapsed" data-bs-toggle="collapse" data-bs-target="#section-examples" aria-expanded="false">
Examples</button><div class="collapse" id="section-examples"><ul class="btn-toggle-nav list-unstyled fw-normal pb-1 small"><li><a class="docs-link rounded" href="/documentation/examples/colliderbit_example/">ColliderBit Example</a></li><li><a class="docs-link rounded" href="/documentation/examples/anotherbit/">AnotherBit</a></li><li><a class="docs-link rounded" href="/documentation/examples/anotherbit2/">AnotherBit2</a></li></ul></div></li><li class="mb-1"><button class="btn btn-toggle align-items-center rounded collapsed" data-bs-toggle="collapse" data-bs-target="#section-help" aria-expanded="false">
Help</button><div class="collapse" id="section-help"><ul class="btn-toggle-nav list-unstyled fw-normal pb-1 small"><li><a class="docs-link rounded" href="/documentation/help/faqs/">FAQs</a></li><li><a class="docs-link rounded" href="/documentation/help/compiler_matrix/">Compiler Matrix</a></li><li><a class="docs-link rounded" href="/documentation/help/known_issues/">Known Issues</a></li><li><a class="docs-link rounded" href="/documentation/help/configuration_examples/">Configuration Examples</a></li></ul></div></li><li class="mb-1"><button class="btn btn-toggle align-items-center rounded collapsed" data-bs-toggle="collapse" data-bs-target="#section-code" aria-expanded="true">
Code Reference</button><div class="collapse show" id="section-code"><ul class="btn-toggle-nav list-unstyled fw-normal pb-1 small"><li class="my-1 ms-3"><button class="btn btn-toggle align-items-center rounded collapsed" data-bs-toggle="collapse" data-bs-target="#section-gambit_2-2" aria-expanded="true">
<font style="color: #5d2f86;" size="-6">release</font>   gambit 2-2</button><div class="collapse show" id="section-gambit_2-2"><ul class="btn-toggle-nav list-unstyled fw-normal pb-1 small"><li><a class="docs-link rounded" href="/documentation/code/gambit_2-2/index_classes/">Classes</a></li><li><a class="docs-link rounded" href="/documentation/code/gambit_2-2/index_files/">Files</a></li><li><a class="docs-link rounded" href="/documentation/code/gambit_2-2/index_pages/">Pages</a></li><li><a class="docs-link rounded" href="/documentation/code/gambit_2-2/index_namespaces/">Namespaces</a></li></ul></div></li></ul></div></li></ul></nav></div><nav class="docs-toc d-none d-xl-block col-xl-3" aria-label="Secondary navigation"><div class="d-xl-none"><button class="btn btn-outline-primary btn-sm doks-toc-toggle collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#onThisPage" aria-controls="doks-docs-nav" aria-expanded="false" aria-label="Toggle On this page navigation">
<span>On this page</span>
<span><svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24" class="doks doks-expand" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><title>Expand</title><polyline points="7 13 12 18 17 13"></polyline><polyline points="7 6 12 11 17 6"></polyline></svg><svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24" class="doks doks-collapse" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><title>Collapse</title><polyline points="17 11 12 6 7 11"></polyline><polyline points="17 18 12 13 7 18"></polyline></svg></span></button><div class="collapse" id="onThisPage"><div class="card card-body mt-3 py-1"><div class="page-links"><nav id="TableOfContents"><ul><li><ul><li><a href="#detailed-description">Detailed Description</a></li><li><a href="#source-code">Source code</a></li></ul></li></ul></nav></div></div></div></div><div class="page-links d-none d-xl-block"><h3>On this page</h3><nav id="TableOfContents"><ul><li><ul><li><a href="#detailed-description">Detailed Description</a></li><li><a href="#source-code">Source code</a></li></ul></li></ul></nav></div></nav><main class="docs-content col-lg-11 col-xl-9 mx-xl-auto"><nav aria-label="breadcrumb"><ol class="breadcrumb"><li class="breadcrumb-item"><a href="/">Home</a></li><li class="breadcrumb-item"><a href="/documentation/">Documentation</a></li><li class="breadcrumb-item"><a href="/documentation/code/">Code Reference</a></li><li class="breadcrumb-item"><a href="/documentation/code/gambit_2-2/">gambit_2-2</a></li><li class="breadcrumb-item active" aria-current="page">file frontends/SPheno_3_3_8.cpp</li></ol></nav><h1>file frontends/SPheno_3_3_8.cpp</h1><p class="lead"></p><p>[No description available] <a href="#detailed-description">More…</a></p><h2 id="detailed-description">Detailed Description <a href="#detailed-description" class="anchor" aria-hidden="true">#</a></h2><p><strong>Author</strong>: Tomas Gonzalo (<a href="mailto:tomas.gonzalo@monash.edu">tomas.gonzalo@monash.edu</a>)</p><p><strong>Date</strong>:</p><ul><li>2016 Apr, May, June</li><li>2020 Apr</li></ul><p>Frontend for SPheno 3.3.8 backend (out of the box version)</p><hr/><p>Authors (add name and date if you modify):</p><hr/><h2 id="source-code">Source code <a href="#source-code" class="anchor" aria-hidden="true">#</a></h2><pre><code>//   GAMBIT: Global and Modular BSM Inference Tool
//   *********************************************
///  \file
///
///  Frontend for SPheno 3.3.8 backend
///  (out of the box version)
///
///  *********************************************
///
///  Authors (add name and date if you modify):
///
///  \author Tomas Gonzalo
///          (tomas.gonzalo@monash.edu)
///  \date 2016 Apr, May, June
///  \date 2020 Apr
///
///  *********************************************

#include &#34;gambit/Backends/frontend_macros.hpp&#34;
#include &#34;gambit/Backends/frontends/SPheno_3_3_8.hpp&#34;
#include &#34;gambit/Elements/spectrum_factories.hpp&#34;
#include &#34;gambit/Models/SimpleSpectra/MSSMSimpleSpec.hpp&#34;
#include &#34;gambit/Utils/slhaea_helpers.hpp&#34;
#include &#34;gambit/Utils/version.hpp&#34;
#include &#34;gambit/Utils/util_functions.hpp&#34;

// Callback function for error handling
BE_NAMESPACE
{
  // This function will be called from SPheno. Needs C linkage, and thus also
  // a backend-specific name to guard against name clashes.
  extern &#34;C&#34;
  void CAT_4(BACKENDNAME,_,SAFE_VERSION,_ErrorHandler)()
  {
    throw std::runtime_error(&#34;SPheno backend called TerminateProgram.&#34;);
  }
}
END_BE_NAMESPACE

// Convenience functions (definition)
BE_NAMESPACE
{

  // Run SPheno
  int run_SPheno(Spectrum &amp;spectrum, const Finputs &amp;inputs)
  {
    Set_All_Parameters_0();

    ReadingData(inputs);

    *epsI = 1.0E-5;
    *deltaM = 1.0E-3;
    *CalcTBD = false;
    *ratioWoM = 0.0;

    try{ SPheno_Main(); }
    catch(std::runtime_error&amp; e) { invalid_point().raise(e.what()); }

    if(*kont != 0)
      ErrorHandling(*kont);

    spectrum = Spectrum_Out(inputs);

    return *kont;

  }

  Spectrum Spectrum_Out(const Finputs &amp;inputs)
  {

    SLHAstruct slha;

    Freal8 Q;
    try{ Q = sqrt(GetRenormalizationScale()); }
    catch(std::runtime_error&amp; e) { invalid_point().raise(e.what()); }

    // Spectrum generator information
    SLHAea_add_block(slha, &#34;SPINFO&#34;);
    SLHAea_add(slha, &#34;SPINFO&#34;, 1, &#34;GAMBIT, using &#34;+str(STRINGIFY(BACKENDNAME)));
    SLHAea_add(slha, &#34;SPINFO&#34;, 2, gambit_version()+&#34; (GAMBIT); &#34;+str(STRINGIFY(VERSION))+&#34; (&#34;+str(STRINGIFY(BACKENDNAME))+&#34;)&#34;);

    // General information
    SLHAea_add_block(slha, &#34;SPhenoINFO&#34;);
    if(*TwoLoopRGE)
      SLHAea_add(slha, &#34;SPhenoINFO&#34;, 1, 2, &#34;# using 2-loop RGES&#34;);
    else
      SLHAea_add(slha, &#34;SPhenoINFO&#34;, 1, 1, &#34;# using 1-loop RGES&#34;);
    if(*YukScen)
      SLHAea_add(slha, &#34;SPhenoINFO&#34;, 2, 1, &#34;# using running masses for boundary conditions at mZ&#34;);
    else
      SLHAea_add(slha, &#34;SPhenoINFO&#34;, 2, 2, &#34;# using pole masses for boundary conditions at mZ&#34;);

    // model information
    if(*HighScaleModel == &#34;mSUGRA&#34;)
    {
      SLHAea_add_block(slha, &#34;MODSEL&#34;);
      slha[&#34;MODSEL&#34;][&#34;&#34;] &lt;&lt; 1 &lt;&lt; 1 &lt;&lt; &#34;# mSUGRA model&#34;;
      if(*GenerationMixing)
        slha[&#34;MODSEL&#34;][&#34;&#34;] &lt;&lt; 6 &lt;&lt; 3 &lt;&lt; &#34;# switching on flavour violation&#34;;

      SLHAea_add_block(slha, &#34;MINPAR&#34;);
      if(inputs.param.find(&#34;M0&#34;) != inputs.param.end())
        slha[&#34;MINPAR&#34;][&#34;&#34;] &lt;&lt; 1 &lt;&lt; *inputs.param.at(&#34;M0&#34;) &lt;&lt; &#34;# m0&#34;;
      if(inputs.param.find(&#34;M12&#34;) != inputs.param.end())
        slha[&#34;MINPAR&#34;][&#34;&#34;] &lt;&lt; 2 &lt;&lt; *inputs.param.at(&#34;M12&#34;) &lt;&lt; &#34;# m12&#34;;
      slha[&#34;MINPAR&#34;][&#34;&#34;] &lt;&lt; 3 &lt;&lt; *inputs.param.at(&#34;TanBeta&#34;) &lt;&lt; &#34;# tanb at m_Z&#34;;
      slha[&#34;MINPAR&#34;][&#34;&#34;] &lt;&lt; 4 &lt;&lt; *inputs.param.at(&#34;SignMu&#34;) &lt;&lt; &#34;# cos(phase_mu)&#34;;
      if(inputs.param.find(&#34;A0&#34;) != inputs.param.end())
        slha[&#34;MINPAR&#34;][&#34;&#34;] &lt;&lt; 5 &lt;&lt; *inputs.param.at(&#34;A0&#34;) &lt;&lt; &#34;# A0&#34;;

    }

    if(*HighScaleModel == &#34;SUGRA&#34;) // SUGRA
    {
      SLHAea_add_block(slha, &#34;EXTPAR&#34;);
      if(inputs.param.find(&#34;Qin&#34;) != inputs.param.end())
        slha[&#34;EXTPAR&#34;][&#34;&#34;] &lt;&lt; 0 &lt;&lt; *inputs.param.at(&#34;Qin&#34;) &lt;&lt; &#34;# scale Q where the parameters below are defined&#34;;
      if(inputs.param.find(&#34;M1&#34;) != inputs.param.end())
        slha[&#34;EXTPAR&#34;][&#34;&#34;] &lt;&lt; 1 &lt;&lt; *inputs.param.at(&#34;M1&#34;) &lt;&lt; &#34;# M_1&#34;;
      if(inputs.param.find(&#34;M2&#34;) != inputs.param.end())
        slha[&#34;EXTPAR&#34;][&#34;&#34;] &lt;&lt; 2 &lt;&lt; *inputs.param.at(&#34;M2&#34;) &lt;&lt; &#34;# M_2&#34;;
      if(inputs.param.find(&#34;M3&#34;) != inputs.param.end())
        slha[&#34;EXTPAR&#34;][&#34;&#34;] &lt;&lt; 3 &lt;&lt; *inputs.param.at(&#34;M3&#34;) &lt;&lt; &#34;# M_3&#34;;
      if(inputs.param.find(&#34;Au_33&#34;) != inputs.param.end())
        slha[&#34;EXTPAR&#34;][&#34;&#34;] &lt;&lt; 11 &lt;&lt; *inputs.param.at(&#34;Au_33&#34;) &lt;&lt; &#34;# A_t&#34;;
      if(inputs.param.find(&#34;Ad_33&#34;) != inputs.param.end())
        slha[&#34;EXTPAR&#34;][&#34;&#34;] &lt;&lt; 12 &lt;&lt; *inputs.param.at(&#34;Ad_33&#34;) &lt;&lt; &#34;# A_b&#34;;
      if(inputs.param.find(&#34;Ae_33&#34;) != inputs.param.end())
        slha[&#34;EXTPAR&#34;][&#34;&#34;] &lt;&lt; 13 &lt;&lt; *inputs.param.at(&#34;Ae_33&#34;) &lt;&lt; &#34;# A_l&#34;;
      if(inputs.param.find(&#34;mHd2&#34;) != inputs.param.end())
        slha[&#34;EXTPAR&#34;][&#34;&#34;] &lt;&lt; 21 &lt;&lt; *inputs.param.at(&#34;mHd2&#34;) &lt;&lt; &#34;# m_Hd^2&#34;;
      if(inputs.param.find(&#34;mHu2&#34;) != inputs.param.end())
        slha[&#34;EXTPAR&#34;][&#34;&#34;] &lt;&lt; 22 &lt;&lt; *inputs.param.at(&#34;mHd2&#34;) &lt;&lt; &#34;# m_Hu^2&#34;;
      if(inputs.param.find(&#34;ml2_11&#34;) != inputs.param.end())
        slha[&#34;EXTPAR&#34;][&#34;&#34;] &lt;&lt; 31 &lt;&lt; sqrt(*inputs.param.at(&#34;ml2_11&#34;)) &lt;&lt; &#34;# M_(L,11)&#34;;
      if(inputs.param.find(&#34;ml2_22&#34;) != inputs.param.end())
        slha[&#34;EXTPAR&#34;][&#34;&#34;] &lt;&lt; 32 &lt;&lt; sqrt(*inputs.param.at(&#34;ml2_22&#34;)) &lt;&lt; &#34;# M_(L,22)&#34;;
      if(inputs.param.find(&#34;ml2_33&#34;) != inputs.param.end())
        slha[&#34;EXTPAR&#34;][&#34;&#34;] &lt;&lt; 33 &lt;&lt; sqrt(*inputs.param.at(&#34;ml2_33&#34;)) &lt;&lt; &#34;# M_(L,33)&#34;;
      if(inputs.param.find(&#34;me2_11&#34;) != inputs.param.end())
        slha[&#34;EXTPAR&#34;][&#34;&#34;] &lt;&lt; 34 &lt;&lt; sqrt(*inputs.param.at(&#34;me2_11&#34;)) &lt;&lt; &#34;# M_(E,11)&#34;;
      if(inputs.param.find(&#34;me2_22&#34;) != inputs.param.end())
        slha[&#34;EXTPAR&#34;][&#34;&#34;] &lt;&lt; 35 &lt;&lt; sqrt(*inputs.param.at(&#34;me2_22&#34;)) &lt;&lt; &#34;# M_(E,22)&#34;;
      if(inputs.param.find(&#34;me2_33&#34;) != inputs.param.end())
        slha[&#34;EXTPAR&#34;][&#34;&#34;] &lt;&lt; 36 &lt;&lt; sqrt(*inputs.param.at(&#34;me2_33&#34;)) &lt;&lt; &#34;# M_(E,33)&#34;;
      if(inputs.param.find(&#34;mq2_11&#34;) != inputs.param.end())
        slha[&#34;EXTPAR&#34;][&#34;&#34;] &lt;&lt; 41 &lt;&lt; sqrt(*inputs.param.at(&#34;mq2_11&#34;)) &lt;&lt; &#34;# M_(Q,11)&#34;;
      if(inputs.param.find(&#34;mq2_22&#34;) != inputs.param.end())
        slha[&#34;EXTPAR&#34;][&#34;&#34;] &lt;&lt; 42 &lt;&lt; sqrt(*inputs.param.at(&#34;mq2_22&#34;)) &lt;&lt; &#34;# M_(Q,22)&#34;;
      if(inputs.param.find(&#34;mq2_33&#34;) != inputs.param.end())
        slha[&#34;EXTPAR&#34;][&#34;&#34;] &lt;&lt; 43 &lt;&lt; sqrt(*inputs.param.at(&#34;mq2_33&#34;)) &lt;&lt; &#34;# M_(Q,33)&#34;;
      if(inputs.param.find(&#34;mu2_11&#34;) != inputs.param.end())
        slha[&#34;EXTPAR&#34;][&#34;&#34;] &lt;&lt; 44 &lt;&lt; sqrt(*inputs.param.at(&#34;mu2_11&#34;)) &lt;&lt; &#34;# M_(U,11)&#34;;
      if(inputs.param.find(&#34;mu2_22&#34;) != inputs.param.end())
        slha[&#34;EXTPAR&#34;][&#34;&#34;] &lt;&lt; 45 &lt;&lt; sqrt(*inputs.param.at(&#34;mu2_22&#34;)) &lt;&lt; &#34;# M_(U,22)&#34;;
      if(inputs.param.find(&#34;mu2_33&#34;) != inputs.param.end())
        slha[&#34;EXTPAR&#34;][&#34;&#34;] &lt;&lt; 46 &lt;&lt; sqrt(*inputs.param.at(&#34;mu2_33&#34;)) &lt;&lt; &#34;# M_(U,33)&#34;;
      if(inputs.param.find(&#34;md2_11&#34;) != inputs.param.end())
        slha[&#34;EXTPAR&#34;][&#34;&#34;] &lt;&lt; 47 &lt;&lt; sqrt(*inputs.param.at(&#34;md2_11&#34;)) &lt;&lt; &#34;# M_(D,11)&#34;;
      if(inputs.param.find(&#34;md2_22&#34;) != inputs.param.end())
        slha[&#34;EXTPAR&#34;][&#34;&#34;] &lt;&lt; 48 &lt;&lt; sqrt(*inputs.param.at(&#34;md2_22&#34;)) &lt;&lt; &#34;# M_(D,22)&#34;;
      if(inputs.param.find(&#34;md2_33&#34;) != inputs.param.end())
        slha[&#34;EXTPAR&#34;][&#34;&#34;] &lt;&lt; 49 &lt;&lt; sqrt(*inputs.param.at(&#34;md2_33&#34;)) &lt;&lt; &#34;# M_(D,33)&#34;;

    }

    SLHAea_add_block(slha, &#34;GAUGE&#34;, *m_GUT);
    slha[&#34;GAUGE&#34;][&#34;&#34;] &lt;&lt; 1 &lt;&lt; (*gauge_0)(1) &lt;&lt; &#34;# g&#39;(M_GUT)^DRbar&#34;;
    slha[&#34;GAUGE&#34;][&#34;&#34;] &lt;&lt; 2 &lt;&lt; (*gauge_0)(2) &lt;&lt; &#34;# g(M_GUT)^DRbar&#34;;
    slha[&#34;GAUGE&#34;][&#34;&#34;] &lt;&lt; 3 &lt;&lt; (*gauge_0)(3) &lt;&lt; &#34;# g3(M_GUT)^DRbar&#34;;

    Farray&lt;Fcomplex16,1,6,1,6&gt; RDsq_ckm, RUsq_ckm;
    Farray&lt;Fcomplex16,1,3,1,3&gt; CKM_Q;
    Farray&lt;Freal8,1,3&gt; Yu, Yd, Yl;
    if(*GenerationMixing)
    {
      Flogical True = true;
      try{ Switch_to_superCKM(*Y_d_0,*Y_u_0,*A_d_0,*A_u_0,*M2_D_0,*M2_Q_0,*M2_U_0,*Ad_sckm,*Au_sckm,*M2D_sckm,*M2Q_sckm,*M2U_sckm,True,*RSdown,*RSup,RDsq_ckm,RUsq_ckm,CKM_Q,Yd,Yu); }
      catch(std::runtime_error&amp; e) { invalid_point().raise(e.what()); }
      for(int i=1; i&lt;=3; i++)
      {
        Yl(i) = (*Y_l_0)(i,i).re;
      }

    }
    else
    {
      for(int i=1; i&lt;=3; i++)
      {
        Yu(i) = (*Y_u_0)(i,i).re;
        Yd(i) = (*Y_d_0)(i,i).re;
        Yl(i) = (*Y_l_0)(i,i).re;
      }
    }

    SLHAea_add_block(slha, &#34;Yu&#34;, *m_GUT);
    SLHAea_add_block(slha, &#34;Yd&#34;, *m_GUT);
    SLHAea_add_block(slha, &#34;Ye&#34;, *m_GUT);

    for(int i=1; i&lt;=3; i++)
    {
      slha[&#34;Yu&#34;][&#34;&#34;] &lt;&lt; i &lt;&lt; i &lt;&lt; Yu(i) &lt;&lt; &#34;# Y_u(&#34; &lt;&lt; i &lt;&lt; &#34;,&#34; &lt;&lt; i &lt;&lt; &#34;)(M_GUT)^DRbar&#34;;
      slha[&#34;Yd&#34;][&#34;&#34;] &lt;&lt; i &lt;&lt; i &lt;&lt; Yd(i) &lt;&lt; &#34;# Y_d(&#34; &lt;&lt; i &lt;&lt; &#34;,&#34; &lt;&lt; i &lt;&lt; &#34;(M_GUT)^DRbar&#34;;
      slha[&#34;Ye&#34;][&#34;&#34;] &lt;&lt; i &lt;&lt; i &lt;&lt; Yl(i) &lt;&lt; &#34;# Y_e(&#34; &lt;&lt; i &lt;&lt; &#34;,&#34; &lt;&lt; i &lt;&lt; &#34;(M_GUT)^DRbar&#34;;
    }

    if(*GenerationMixing)
    {
      // Block VKCM
      SLHAea_add_block(slha, &#34;VCKM&#34;, *m_GUT);
      for(int i=1; i&lt;=3; i++)
        for(int j=1; j&lt;=3; j++)
          slha[&#34;VCKM&#34;][&#34;&#34;] &lt;&lt; i &lt;&lt; j &lt;&lt; CKM_Q(i,j).re &lt;&lt; &#34;# V_&#34; &lt;&lt; i &lt;&lt; j;
    }

    // parameters + masses for SPheno.spc
    SLHAea_add_block(slha, &#34;SMINPUTS&#34;);
    slha[&#34;SMINPUTS&#34;][&#34;&#34;] &lt;&lt; 1 &lt;&lt; 1.0 / Alpha_MSbar(*mZ, *mW) &lt;&lt; &#34;# alpha_em^-1(MZ)^MSbar&#34;;
    slha[&#34;SMINPUTS&#34;][&#34;&#34;] &lt;&lt; 2 &lt;&lt; *G_F &lt;&lt; &#34;# G_mu [GeV^-2]&#34;;
    slha[&#34;SMINPUTS&#34;][&#34;&#34;] &lt;&lt; 3 &lt;&lt; *AlphaS_mZ &lt;&lt; &#34;# alpha_s(MZ)^MSbar&#34;;
    slha[&#34;SMINPUTS&#34;][&#34;&#34;] &lt;&lt; 4 &lt;&lt; *mZ &lt;&lt; &#34;# m_Z(pole)&#34;;
    slha[&#34;SMINPUTS&#34;][&#34;&#34;] &lt;&lt; 5 &lt;&lt; (*mf_d)(3) &lt;&lt; &#34;# m_b(m_b), MSbar&#34;;
    slha[&#34;SMINPUTS&#34;][&#34;&#34;] &lt;&lt; 6 &lt;&lt; (*mf_u)(3) &lt;&lt; &#34;# m_t(pole)&#34;;
    slha[&#34;SMINPUTS&#34;][&#34;&#34;] &lt;&lt; 7 &lt;&lt; (*mf_l)(3) &lt;&lt; &#34;# m_tau(pole)&#34;;
    slha[&#34;SMINPUTS&#34;][&#34;&#34;] &lt;&lt; 8 &lt;&lt; (*mf_nu)(3) &lt;&lt; &#34;# m_nu_3&#34;;
    slha[&#34;SMINPUTS&#34;][&#34;&#34;] &lt;&lt; 11 &lt;&lt; (*mf_l)(1) &lt;&lt; &#34;# m_e(pole)&#34;;
    slha[&#34;SMINPUTS&#34;][&#34;&#34;] &lt;&lt; 12 &lt;&lt; (*mf_nu)(1) &lt;&lt; &#34;# m_nu_1&#34;;
    slha[&#34;SMINPUTS&#34;][&#34;&#34;] &lt;&lt; 13 &lt;&lt; (*mf_l)(2) &lt;&lt; &#34;# m_muon(pole)&#34;;
    slha[&#34;SMINPUTS&#34;][&#34;&#34;] &lt;&lt; 14 &lt;&lt; (*mf_nu)(2) &lt;&lt; &#34;# m_nu_2&#34;;
    slha[&#34;SMINPUTS&#34;][&#34;&#34;] &lt;&lt; 21 &lt;&lt; (*mf_d)(1) &lt;&lt; &#34;# m_d(2 GeV), MSbar&#34;;
    slha[&#34;SMINPUTS&#34;][&#34;&#34;] &lt;&lt; 22 &lt;&lt; (*mf_u)(1) &lt;&lt; &#34;# m_u(2 GeV), MSbar&#34;;
    slha[&#34;SMINPUTS&#34;][&#34;&#34;] &lt;&lt; 23 &lt;&lt; (*mf_d)(2) &lt;&lt; &#34;# m_s(2 GeV), MSbar&#34;;
    slha[&#34;SMINPUTS&#34;][&#34;&#34;] &lt;&lt; 24 &lt;&lt; (*mf_u)(2) &lt;&lt; &#34;# m_c(m_c), MSbar&#34;;

    // SUSY-HIT requires these blocks to be present, so add them
    SLHAea_add_block(slha, &#34;VCKMIN&#34;);
    slha[&#34;VCKMIN&#34;][&#34;&#34;] &lt;&lt; 1 &lt;&lt; *lam_wolf &lt;&lt; &#34;# lambda&#34;;
    slha[&#34;VCKMIN&#34;][&#34;&#34;] &lt;&lt; 2 &lt;&lt; *A_wolf &lt;&lt; &#34;# A&#34;;
    slha[&#34;VCKMIN&#34;][&#34;&#34;] &lt;&lt; 3 &lt;&lt; *rho_wolf &lt;&lt; &#34;# rho bar&#34;;
    slha[&#34;VCKMIN&#34;][&#34;&#34;] &lt;&lt; 4 &lt;&lt; *eta_wolf &lt;&lt; &#34;# eta bar&#34;;

    SLHAea_add_block(slha, &#34;UPMNSIN&#34;);
    slha[&#34;UPMNSIN&#34;][&#34;&#34;] &lt;&lt; 1 &lt;&lt; *theta_12 &lt;&lt; &#34;# theta_12, solar&#34;;
    slha[&#34;UPMNSIN&#34;][&#34;&#34;] &lt;&lt; 2 &lt;&lt; *theta_23&lt;&lt; &#34;# theta_23, atmospheric&#34;;
    slha[&#34;UPMNSIN&#34;][&#34;&#34;] &lt;&lt; 3 &lt;&lt; *theta_13 &lt;&lt; &#34;# theta_13&#34;;
    slha[&#34;UPMNSIN&#34;][&#34;&#34;] &lt;&lt; 4 &lt;&lt; *delta_nu &lt;&lt; &#34;# delta_nu&#34;;
    slha[&#34;UPMNSIN&#34;][&#34;&#34;] &lt;&lt; 5 &lt;&lt; *alpha_nu1 &lt;&lt; &#34;# alpha_1&#34;;
    slha[&#34;UPMNSIN&#34;][&#34;&#34;] &lt;&lt; 6 &lt;&lt; *alpha_nu2 &lt;&lt; &#34;# alpha_2&#34;;

    Farray&lt;Fcomplex16,1,6,1,6&gt; RSl_pmns;
    Farray&lt;Fcomplex16,1,3,1,3&gt; RSn_pmns, id3C;
    Farray&lt;Fcomplex16,1,3,1,3&gt; PMNS_Q;
    if(*GenerationMixing)
    {
      Flogical False = false;
      try{ Switch_to_superCKM(*Y_d,*Y_u,*A_d,*A_u,*M2_D,*M2_Q,*M2_U,*Ad_sckm,*Au_sckm,*M2D_sckm,*M2Q_sckm,*M2U_sckm,False,*RSdown,*RSup,RDsq_ckm,RUsq_ckm,CKM_Q,Yd,Yu); }
      catch(std::runtime_error&amp; e) { invalid_point().raise(e.what()); }

      try{ Switch_to_superPMNS(*Y_l,id3C,*A_l,*M2_E,*M2_L,*Al_pmns,*M2E_pmns,*M2L_pmns,False,*RSlepton,*RSneut,RSl_pmns,RSn_pmns,PMNS_Q,Yl); }
      catch(std::runtime_error&amp; e) { invalid_point().raise(e.what()); }

    }
    else
    {
      for(int i=1; i&lt;=3; i++)
      {
        Yu(i) = (*Y_u)(i,i).re;
        Yd(i) = (*Y_d)(i,i).re;
        Yl(i) = (*Y_l)(i,i).re;
      }
      *Al_pmns = *A_l;
      *Ad_sckm = *A_d;
      *Au_sckm = *A_u;

      RUsq_ckm = *RSup;
      RDsq_ckm = *RSdown;

      RSn_pmns = *RSneut;
      RSl_pmns = *RSlepton;

    }

    SLHAea_add_block(slha, &#34;GAUGE&#34;, Q);
    slha[&#34;GAUGE&#34;][&#34;&#34;] &lt;&lt; 1 &lt;&lt; (*gauge)(1) &lt;&lt; &#34;# g&#39;(Q)^DRbar&#34;;
    slha[&#34;GAUGE&#34;][&#34;&#34;] &lt;&lt; 2 &lt;&lt; (*gauge)(2) &lt;&lt; &#34;# g(Q)^DRbar&#34;;
    slha[&#34;GAUGE&#34;][&#34;&#34;] &lt;&lt; 3 &lt;&lt; (*gauge)(3) &lt;&lt; &#34;# g3(Q)^DRbar&#34;;

    SLHAea_add_block(slha, &#34;Yu&#34;, Q);
    SLHAea_add_block(slha, &#34;Yd&#34;, Q);
    SLHAea_add_block(slha, &#34;Ye&#34;, Q);

    for(int i=1; i&lt;=3; i++)
    {
      slha[&#34;Yu&#34;][&#34;&#34;] &lt;&lt; i &lt;&lt; i &lt;&lt; Yu(i) &lt;&lt; &#34;# Y_u(&#34; &lt;&lt; i &lt;&lt; &#34;,&#34; &lt;&lt; i &lt;&lt; &#34;)(Q)^DRbar&#34;;
      slha[&#34;Yd&#34;][&#34;&#34;] &lt;&lt; i &lt;&lt; i &lt;&lt; Yd(i) &lt;&lt; &#34;# Y_d(&#34; &lt;&lt; i &lt;&lt; &#34;,&#34; &lt;&lt; i &lt;&lt; &#34;)(Q)^DRbar&#34;;
      slha[&#34;Ye&#34;][&#34;&#34;] &lt;&lt; i &lt;&lt; i &lt;&lt; Yl(i) &lt;&lt; &#34;# Y_e(&#34; &lt;&lt; i &lt;&lt; &#34;,&#34; &lt;&lt; i &lt;&lt; &#34;)(Q)^DRbar&#34;;
    }

    if(*GenerationMixing)
    {
      // Blocks VKCM and UPMNS
      SLHAea_add_block(slha, &#34;VCKM&#34;, Q);
      SLHAea_add_block(slha, &#34;IMVCKM&#34;, Q);
      SLHAea_add_block(slha, &#34;UPMNS&#34;, Q);
      SLHAea_add_block(slha, &#34;IMUPMNS&#34;, Q);
      for(int i=1; i&lt;=3; i++)
        for(int j=1; j&lt;=3; j++)
        {
          slha[&#34;VCKM&#34;][&#34;&#34;] &lt;&lt; i &lt;&lt; j &lt;&lt; CKM_Q(i,j).re &lt;&lt; &#34;# V_&#34; &lt;&lt; i &lt;&lt; j;
          slha[&#34;IMVCKM&#34;][&#34;&#34;] &lt;&lt; i &lt;&lt; j &lt;&lt; CKM_Q(i,j).im &lt;&lt; &#34;# Im(V_&#34; &lt;&lt; i &lt;&lt; j &lt;&lt; &#34;)&#34;;
          slha[&#34;UPMNS&#34;][&#34;&#34;] &lt;&lt; i &lt;&lt; j &lt;&lt; PMNS_Q(i,j).re &lt;&lt; &#34;# UPMNS_&#34; &lt;&lt; i &lt;&lt; j;
          slha[&#34;IMUPMNS&#34;][&#34;&#34;] &lt;&lt; i &lt;&lt; j &lt;&lt; PMNS_Q(i,j).im &lt;&lt; &#34;# Im(UPMNS_&#34; &lt;&lt; i &lt;&lt; j &lt;&lt; &#34;)&#34;;
        }

      SLHAea_add_block(slha, &#34;TE&#34;, Q);
      SLHAea_add_block(slha, &#34;TU&#34;, Q);
      SLHAea_add_block(slha, &#34;TD&#34;, Q);

      for(int i=1; i&lt;=3; i++)
        for(int j=1; j&lt;=3; j++)
        {
          slha[&#34;TE&#34;][&#34;&#34;] &lt;&lt; i &lt;&lt; j &lt;&lt; (*Al_pmns)(i,j).re &lt;&lt; &#34;# A_(E,&#34; &lt;&lt; i &lt;&lt; j &lt;&lt; &#34;)&#34;;
          slha[&#34;TU&#34;][&#34;&#34;] &lt;&lt; i &lt;&lt; j &lt;&lt; (*Au_sckm)(i,j).re &lt;&lt; &#34;# A_(U,&#34; &lt;&lt; i &lt;&lt; j &lt;&lt; &#34;)&#34;;
          slha[&#34;TD&#34;][&#34;&#34;] &lt;&lt; i &lt;&lt; j &lt;&lt; (*Ad_sckm)(i,j).re &lt;&lt; &#34;# A_(D,&#34; &lt;&lt; i &lt;&lt; j &lt;&lt; &#34;)&#34;;
        }
    }
    else
    {
      SLHAea_add_block(slha, &#34;Au&#34;, Q);
      SLHAea_add_block(slha, &#34;IMAu&#34;, Q);
      SLHAea_add_block(slha, &#34;Ad&#34;, Q);
      SLHAea_add_block(slha, &#34;IMAd&#34;, Q);
      SLHAea_add_block(slha, &#34;Ae&#34;, Q);
      SLHAea_add_block(slha, &#34;IMAe&#34;, Q);

      for(int i=1; i&lt;=3; i++)
      {
        if((*Y_u)(i,i).abs() &gt; 0)
        {
          slha[&#34;Au&#34;][&#34;&#34;] &lt;&lt; i &lt;&lt; i &lt;&lt; ((*Au_sckm)(i,i)/(*Y_u)(i,i)).re &lt;&lt; &#34;# A_u&#34; &lt;&lt; i &lt;&lt; &#34;,&#34; &lt;&lt; i &lt;&lt; &#34;)(Q)^DRbar&#34;;
          slha[&#34;IMAu&#34;][&#34;&#34;] &lt;&lt; i &lt;&lt; i &lt;&lt; ((*Au_sckm)(i,i)/(*Y_u)(i,i)).im &lt;&lt; &#34;# Im(A_u)(&#34; &lt;&lt; i &lt;&lt; &#34;,&#34; &lt;&lt; i &lt;&lt; &#34;)(Q)^DRbar&#34;;
        }
        if((*Y_d)(i,i).abs() &gt; 0)
        {
          slha[&#34;Ad&#34;][&#34;&#34;] &lt;&lt; i &lt;&lt; i &lt;&lt; ((*Ad_sckm)(i,i)/(*Y_d)(i,i)).re &lt;&lt; &#34;# A_d(&#34; &lt;&lt; i &lt;&lt; &#34;,&#34; &lt;&lt; i &lt;&lt; &#34;)(Q)^DRbar&#34;;
          slha[&#34;IMAd&#34;][&#34;&#34;] &lt;&lt; i &lt;&lt; i &lt;&lt; ((*Ad_sckm)(i,i)/(*Y_d)(i,i)).im &lt;&lt; &#34;# Im(A_d)(&#34; &lt;&lt; i &lt;&lt; &#34;,&#34; &lt;&lt; i &lt;&lt; &#34;)(Q)^DRbar&#34;;
        }
        if((*Y_l)(i,i).abs() &gt; 0)
        {
          slha[&#34;Ae&#34;][&#34;&#34;] &lt;&lt; i &lt;&lt; i &lt;&lt; ((*Al_pmns)(i,i)/(*Y_l)(i,i)).re &lt;&lt; &#34;# A_e(&#34; &lt;&lt; i &lt;&lt; &#34;,&#34; &lt;&lt; i &lt;&lt; &#34;)(Q)^DRbar&#34;;
          slha[&#34;IMAe&#34;][&#34;&#34;] &lt;&lt; i &lt;&lt; i &lt;&lt; ((*Al_pmns)(i,i)/(*Y_l)(i,i)).im &lt;&lt; &#34;# Im(A_e)(&#34; &lt;&lt; i &lt;&lt; &#34;,&#34; &lt;&lt; i &lt;&lt; &#34;)(Q)^DRbar&#34;;
        }
      }
    }

    SLHAea_add_block(slha, &#34;MSOFT&#34;, Q);
    slha[&#34;MSOFT&#34;][&#34;&#34;] &lt;&lt; 1 &lt;&lt; (*Mi)(1).re &lt;&lt; &#34;# M_1&#34;;
    slha[&#34;MSOFT&#34;][&#34;&#34;] &lt;&lt; 2 &lt;&lt; (*Mi)(2).re &lt;&lt; &#34;# M_2&#34;;
    slha[&#34;MSOFT&#34;][&#34;&#34;] &lt;&lt; 3 &lt;&lt; (*Mi)(3).re &lt;&lt; &#34;# M_3&#34;;
    slha[&#34;MSOFT&#34;][&#34;&#34;] &lt;&lt; 21 &lt;&lt; (*M2_H)(1) &lt;&lt; &#34;# M^2_(H,d)&#34;;
    slha[&#34;MSOFT&#34;][&#34;&#34;] &lt;&lt; 22 &lt;&lt; (*M2_H)(2) &lt;&lt; &#34;# M^2_(H,u)&#34;;

    slha[&#34;MSOFT&#34;][&#34;&#34;] &lt;&lt; 31 &lt;&lt; Utils::sgn((*M2L_pmns)(1,1).re) * sqrt(abs((*M2L_pmns)(1,1).re)) &lt;&lt; &#34;# M_(L,11)&#34;;
    slha[&#34;MSOFT&#34;][&#34;&#34;] &lt;&lt; 32 &lt;&lt; Utils::sgn((*M2L_pmns)(2,2).re) * sqrt(abs((*M2L_pmns)(2,2).re)) &lt;&lt; &#34;# M_(L,22)&#34;;
    slha[&#34;MSOFT&#34;][&#34;&#34;] &lt;&lt; 33 &lt;&lt; Utils::sgn((*M2L_pmns)(3,3).re) * sqrt(abs((*M2L_pmns)(3,3).re)) &lt;&lt; &#34;# M_(L,33)&#34;;
    slha[&#34;MSOFT&#34;][&#34;&#34;] &lt;&lt; 34 &lt;&lt; Utils::sgn((*M2E_pmns)(1,1).re) * sqrt(abs((*M2E_pmns)(1,1).re)) &lt;&lt; &#34;# M_(E,11)&#34;;
    slha[&#34;MSOFT&#34;][&#34;&#34;] &lt;&lt; 35 &lt;&lt; Utils::sgn((*M2E_pmns)(2,2).re) * sqrt(abs((*M2E_pmns)(2,2).re)) &lt;&lt; &#34;# M_(E,22)&#34;;
    slha[&#34;MSOFT&#34;][&#34;&#34;] &lt;&lt; 36 &lt;&lt; Utils::sgn((*M2E_pmns)(3,3).re) * sqrt(abs((*M2E_pmns)(3,3).re)) &lt;&lt; &#34;# M_(E,33)&#34;;
    slha[&#34;MSOFT&#34;][&#34;&#34;] &lt;&lt; 41 &lt;&lt; Utils::sgn((*M2Q_sckm)(1,1).re) * sqrt(abs((*M2Q_sckm)(1,1).re)) &lt;&lt; &#34;# M_(Q,11)&#34;;
    slha[&#34;MSOFT&#34;][&#34;&#34;] &lt;&lt; 42 &lt;&lt; Utils::sgn((*M2Q_sckm)(2,2).re) * sqrt(abs((*M2Q_sckm)(2,2).re)) &lt;&lt; &#34;# M_(Q,22)&#34;;
    slha[&#34;MSOFT&#34;][&#34;&#34;] &lt;&lt; 43 &lt;&lt; Utils::sgn((*M2Q_sckm)(3,3).re) * sqrt(abs((*M2Q_sckm)(3,3).re)) &lt;&lt; &#34;# M_(Q,33)&#34;;
    slha[&#34;MSOFT&#34;][&#34;&#34;] &lt;&lt; 44 &lt;&lt; Utils::sgn((*M2U_sckm)(1,1).re) * sqrt(abs((*M2U_sckm)(1,1).re)) &lt;&lt; &#34;# M_(U,11)&#34;;
    slha[&#34;MSOFT&#34;][&#34;&#34;] &lt;&lt; 45 &lt;&lt; Utils::sgn((*M2U_sckm)(2,2).re) * sqrt(abs((*M2U_sckm)(2,2).re)) &lt;&lt; &#34;# M_(U,22)&#34;;
    slha[&#34;MSOFT&#34;][&#34;&#34;] &lt;&lt; 46 &lt;&lt; Utils::sgn((*M2U_sckm)(3,3).re) * sqrt(abs((*M2U_sckm)(3,3).re)) &lt;&lt; &#34;# M_(U,33)&#34;;
    slha[&#34;MSOFT&#34;][&#34;&#34;] &lt;&lt; 47 &lt;&lt; Utils::sgn((*M2D_sckm)(1,1).re) * sqrt(abs((*M2D_sckm)(1,1).re)) &lt;&lt; &#34;# M_(D,11)&#34;;
    slha[&#34;MSOFT&#34;][&#34;&#34;] &lt;&lt; 48 &lt;&lt; Utils::sgn((*M2D_sckm)(2,2).re) * sqrt(abs((*M2D_sckm)(2,2).re)) &lt;&lt; &#34;# M_(D,22)&#34;;
    slha[&#34;MSOFT&#34;][&#34;&#34;] &lt;&lt; 49 &lt;&lt; Utils::sgn((*M2D_sckm)(3,3).re) * sqrt(abs((*M2D_sckm)(3,3).re)) &lt;&lt; &#34;# M_(D,33)&#34;;

    if((*Mi)(1).im != 0 or (*Mi)(2).im != 0 or (*Mi)(3).im != 0)
    {
      SLHAea_add_block(slha, &#34;IMMSOFT&#34;, Q);
      slha[&#34;IMMSOFT&#34;][&#34;&#34;] &lt;&lt; 1 &lt;&lt; (*Mi)(1).im &lt;&lt; &#34;# M_1&#34;;
      slha[&#34;IMMSOFT&#34;][&#34;&#34;] &lt;&lt; 2 &lt;&lt; (*Mi)(2).im &lt;&lt; &#34;# M_2&#34;;
      slha[&#34;IMMSOFT&#34;][&#34;&#34;] &lt;&lt; 3 &lt;&lt; (*Mi)(3).im &lt;&lt; &#34;# M_3&#34;;
    }

    if(*GenerationMixing)
    {
      SLHAea_add_block(slha, &#34;MSL2&#34;, Q);
      SLHAea_add_block(slha, &#34;MSE2&#34;, Q);
      SLHAea_add_block(slha, &#34;MSQ2&#34;, Q);
      SLHAea_add_block(slha, &#34;MSU2&#34;, Q);
      SLHAea_add_block(slha, &#34;MSD2&#34;, Q);

      for(int i=1; i&lt;=3; i++)
        for(int j=1; j&lt;=3; j++)
        {
          slha[&#34;MSL2&#34;][&#34;&#34;] &lt;&lt; i &lt;&lt; j &lt;&lt; (*M2L_pmns)(i,j).re &lt;&lt; &#34;# M_(L,&#34; &lt;&lt; i &lt;&lt; j &lt;&lt; &#34;)&#34;;
          slha[&#34;MSE2&#34;][&#34;&#34;] &lt;&lt; i &lt;&lt; j &lt;&lt; (*M2E_pmns)(i,j).re &lt;&lt; &#34;# M_(E,&#34; &lt;&lt; i &lt;&lt; j &lt;&lt; &#34;)&#34;;
          slha[&#34;MSQ2&#34;][&#34;&#34;] &lt;&lt; i &lt;&lt; j &lt;&lt; (*M2Q_sckm)(i,j).re &lt;&lt; &#34;# M_(Q,&#34; &lt;&lt; i &lt;&lt; j &lt;&lt; &#34;)&#34;;
          slha[&#34;MSU2&#34;][&#34;&#34;] &lt;&lt; i &lt;&lt; j &lt;&lt; (*M2U_sckm)(i,j).re &lt;&lt; &#34;# M_(U,&#34; &lt;&lt; i &lt;&lt; j &lt;&lt; &#34;)&#34;;
          slha[&#34;MSD2&#34;][&#34;&#34;] &lt;&lt; i &lt;&lt; j &lt;&lt; (*M2D_sckm)(i,j).re &lt;&lt; &#34;# M_(D,&#34; &lt;&lt; i &lt;&lt; j &lt;&lt; &#34;)&#34;;
       }
    }

    SLHAea_add_block(slha, &#34;MASS&#34;);
    slha[&#34;MASS&#34;][&#34;&#34;] &lt;&lt; 5 &lt;&lt; (*mf_d)(3) &lt;&lt; &#34;# m_b(pole)&#34;;
    slha[&#34;MASS&#34;][&#34;&#34;] &lt;&lt; 6 &lt;&lt; (*mf_u)(3) &lt;&lt; &#34;# m_t(pole)&#34;;
    slha[&#34;MASS&#34;][&#34;&#34;] &lt;&lt; 23 &lt;&lt; *mZ &lt;&lt; &#34;# m_Z(pole)&#34;;
    slha[&#34;MASS&#34;][&#34;&#34;] &lt;&lt; 24 &lt;&lt; *mW &lt;&lt; &#34;# m_W(pole)&#34;;
    slha[&#34;MASS&#34;][&#34;&#34;] &lt;&lt; 15 &lt;&lt; (*mf_l)(3) &lt;&lt; &#34;# m_tau(pole)&#34;;

    slha[&#34;MASS&#34;][&#34;&#34;] &lt;&lt; 25 &lt;&lt; (*S0)(1).m &lt;&lt; &#34;# h0&#34;;
    slha[&#34;MASS&#34;][&#34;&#34;] &lt;&lt; 35 &lt;&lt; (*S0)(2).m &lt;&lt; &#34;# H0&#34;;
    slha[&#34;MASS&#34;][&#34;&#34;] &lt;&lt; 36 &lt;&lt; (*P0)(2).m &lt;&lt; &#34;# A0&#34;;
    slha[&#34;MASS&#34;][&#34;&#34;] &lt;&lt; 37 &lt;&lt; (*Spm)(2).m &lt;&lt; &#34;# H+&#34;;

    // squarks
    if(*GenerationMixing)
    {
      std::vector&lt;int&gt; id_sd = {1000001, 1000003, 1000005,
                                2000001, 2000003, 2000005};
      for(int i=1; i&lt;=6; i++)
        slha[&#34;MASS&#34;][&#34;&#34;] &lt;&lt; id_sd[i] &lt;&lt; (*Sdown)(i).m &lt;&lt; &#34;# ~d_&#34; &lt;&lt; i;

      std::vector&lt;int&gt; id_su = {1000002, 1000004, 1000006,
                                2000002, 2000004, 2000006};
      for(int i=1; i&lt;=6; i++)
        slha[&#34;MASS&#34;][&#34;&#34;] &lt;&lt; id_su[i] &lt;&lt; (*Sup)(i).m &lt;&lt; &#34;# ~u_&#34; &lt;&lt; i;

      std::vector&lt;int&gt; id_snu = {1000012, 1000014, 1000016};
      for(int i=1; i&lt;=3; i++)
        slha[&#34;MASS&#34;][&#34;&#34;] &lt;&lt; id_snu[i] &lt;&lt; (*Sneut)(i).m &lt;&lt; &#34;# ~nu_&#34; &lt;&lt; i;

      std::vector&lt;int&gt; id_sle = {1000011, 1000013, 1000015,
                                 2000011, 2000013, 2000015};
      for(int i=1; i&lt;=6; i++)
        slha[&#34;MASS&#34;][&#34;&#34;] &lt;&lt; id_sle[i] &lt;&lt; (*Slepton)(i).m &lt;&lt; &#34;# ~l_&#34; &lt;&lt; i;

    }
    else
    {
      if((*RSdown)(1,1).abs() &gt; 0.5)
      {
        slha[&#34;MASS&#34;][&#34;&#34;] &lt;&lt; 1000001 &lt;&lt; (*Sdown)(1).m &lt;&lt; &#34;# ~d_L&#34;;
        slha[&#34;MASS&#34;][&#34;&#34;] &lt;&lt; 2000001 &lt;&lt; (*Sdown)(2).m &lt;&lt; &#34;# ~d_R&#34;;
      }
      else
      {
        slha[&#34;MASS&#34;][&#34;&#34;] &lt;&lt; 1000001 &lt;&lt; (*Sdown)(2).m &lt;&lt; &#34;# ~d_L&#34;;
        slha[&#34;MASS&#34;][&#34;&#34;] &lt;&lt; 2000001 &lt;&lt; (*Sdown)(1).m &lt;&lt; &#34;# ~d_R&#34;;
      }
      if((*RSup)(1,1).abs() &gt; 0.5)
      {
        slha[&#34;MASS&#34;][&#34;&#34;] &lt;&lt; 1000002 &lt;&lt; (*Sup)(1).m &lt;&lt; &#34;# ~u_L&#34;;
        slha[&#34;MASS&#34;][&#34;&#34;] &lt;&lt; 2000002 &lt;&lt; (*Sup)(2).m &lt;&lt; &#34;# ~u_R&#34;;
      }
      else
      {
        slha[&#34;MASS&#34;][&#34;&#34;] &lt;&lt; 1000002 &lt;&lt; (*Sup)(2).m &lt;&lt; &#34;# ~u_L&#34;;
        slha[&#34;MASS&#34;][&#34;&#34;] &lt;&lt; 2000002 &lt;&lt; (*Sup)(1).m &lt;&lt; &#34;# ~u_R&#34;;
      }
      if((*RSdown)(3,3).abs() &gt; 0.5)
      {
        slha[&#34;MASS&#34;][&#34;&#34;] &lt;&lt; 1000003 &lt;&lt; (*Sdown)(3).m &lt;&lt; &#34;# ~s_L&#34;;
        slha[&#34;MASS&#34;][&#34;&#34;] &lt;&lt; 2000003 &lt;&lt; (*Sdown)(4).m &lt;&lt; &#34;# ~s_R&#34;;
      }
      else
      {
        slha[&#34;MASS&#34;][&#34;&#34;] &lt;&lt; 1000003 &lt;&lt; (*Sdown)(4).m &lt;&lt; &#34;# ~s_L&#34;;
        slha[&#34;MASS&#34;][&#34;&#34;] &lt;&lt; 2000003 &lt;&lt; (*Sdown)(3).m &lt;&lt; &#34;# ~s_R&#34;;
      }
      if((*RSup)(3,3).abs() &gt; 0.5)
      {
        slha[&#34;MASS&#34;][&#34;&#34;] &lt;&lt; 1000004 &lt;&lt; (*Sup)(3).m &lt;&lt; &#34;# ~c_L&#34;;
        slha[&#34;MASS&#34;][&#34;&#34;] &lt;&lt; 2000004 &lt;&lt; (*Sup)(4).m &lt;&lt; &#34;# ~c_R&#34;;
      }
      else
      {
        slha[&#34;MASS&#34;][&#34;&#34;] &lt;&lt; 1000004 &lt;&lt; (*Sup)(4).m &lt;&lt; &#34;# ~c_L&#34;;
        slha[&#34;MASS&#34;][&#34;&#34;] &lt;&lt; 2000004 &lt;&lt; (*Sup)(3).m &lt;&lt; &#34;# ~c_R&#34;;
      }
      slha[&#34;MASS&#34;][&#34;&#34;] &lt;&lt; 1000005 &lt;&lt; (*Sdown)(5).m &lt;&lt; &#34;# ~b_1&#34;;
      slha[&#34;MASS&#34;][&#34;&#34;] &lt;&lt; 2000005 &lt;&lt; (*Sdown)(6).m &lt;&lt; &#34;# ~b_2&#34;;
      slha[&#34;MASS&#34;][&#34;&#34;] &lt;&lt; 1000006 &lt;&lt; (*Sup)(5).m &lt;&lt; &#34;# ~t_1&#34;;
      slha[&#34;MASS&#34;][&#34;&#34;] &lt;&lt; 2000006 &lt;&lt; (*Sup)(6).m &lt;&lt; &#34;# ~t_2&#34;;

      if((*RSlepton)(1,1).abs() &gt; 0.5)
      {
        slha[&#34;MASS&#34;][&#34;&#34;] &lt;&lt; 1000011 &lt;&lt; (*Slepton)(1).m &lt;&lt; &#34;# ~e_L-&#34;;
        slha[&#34;MASS&#34;][&#34;&#34;] &lt;&lt; 2000011 &lt;&lt; (*Slepton)(2).m &lt;&lt; &#34;# ~e_R-&#34;;
      }
      else
      {
        slha[&#34;MASS&#34;][&#34;&#34;] &lt;&lt; 1000011 &lt;&lt; (*Slepton)(2).m &lt;&lt; &#34;# ~e_L-&#34;;
        slha[&#34;MASS&#34;][&#34;&#34;] &lt;&lt; 2000011 &lt;&lt; (*Slepton)(1).m &lt;&lt; &#34;# ~e_R-&#34;;
      }
      slha[&#34;MASS&#34;][&#34;&#34;] &lt;&lt; 1000012 &lt;&lt; (*Sneut)(1).m &lt;&lt; &#34;# ~nu_eL&#34;;
      if((*RSlepton)(3,3).abs() &gt; 0.5)
      {
        slha[&#34;MASS&#34;][&#34;&#34;] &lt;&lt; 1000013 &lt;&lt; (*Slepton)(3).m &lt;&lt; &#34;# ~mu_L-&#34;;
        slha[&#34;MASS&#34;][&#34;&#34;] &lt;&lt; 2000013 &lt;&lt; (*Slepton)(4).m &lt;&lt; &#34;# ~mu_R-&#34;;
      }
      else
      {
        slha[&#34;MASS&#34;][&#34;&#34;] &lt;&lt; 1000013 &lt;&lt; (*Slepton)(4).m &lt;&lt; &#34;# ~mu_L-&#34;;
        slha[&#34;MASS&#34;][&#34;&#34;] &lt;&lt; 2000013 &lt;&lt; (*Slepton)(3).m &lt;&lt; &#34;# ~mu_R-&#34;;
      }
      slha[&#34;MASS&#34;][&#34;&#34;] &lt;&lt; 1000014 &lt;&lt; (*Sneut)(2).m &lt;&lt; &#34;# ~nu_muL&#34;;
      slha[&#34;MASS&#34;][&#34;&#34;] &lt;&lt; 1000015 &lt;&lt; (*Slepton)(5).m &lt;&lt; &#34;# ~tau_1-&#34;;
      slha[&#34;MASS&#34;][&#34;&#34;] &lt;&lt; 2000015 &lt;&lt; (*Slepton)(6).m &lt;&lt; &#34;# ~tau_2-&#34;;
      slha[&#34;MASS&#34;][&#34;&#34;] &lt;&lt; 1000016 &lt;&lt; (*Sneut)(3).m &lt;&lt; &#34;# ~nu_tauL&#34;;
    }

    // gauginos/higssinos
    slha[&#34;MASS&#34;][&#34;&#34;] &lt;&lt; 1000021 &lt;&lt; Glu-&gt;m &lt;&lt; &#34;# ~g&#34;;

    Farray_Freal8_1_4 mNr;
    Farray_Fcomplex16_1_4_1_4 Nr;

    for(int i=1; i&lt;=4; i++)
    {
      Freal8 sum = 0;
      for(int j=1; j&lt;=4; j++)
        sum += (*N)(i,j).re;
      if(sum == 0)
      {
        mNr(i) = -(*Chi0)(i).m;
        for(int j=1; j&lt;=4; j++)
          Nr(i,j).re = (*N)(i,j).im;
      }
      else
      {
        mNr(i) = (*Chi0)(i).m;
        for(int j=1; j&lt;=4; j++)
          Nr(i,j) = (*N)(i,j);
      }
    }
    slha[&#34;MASS&#34;][&#34;&#34;] &lt;&lt; 1000022 &lt;&lt; mNr(1) &lt;&lt; &#34;# ~chi_10&#34;;
    slha[&#34;MASS&#34;][&#34;&#34;] &lt;&lt; 1000023 &lt;&lt; mNr(2) &lt;&lt; &#34;# ~chi_20&#34;;
    slha[&#34;MASS&#34;][&#34;&#34;] &lt;&lt; 1000025 &lt;&lt; mNr(3) &lt;&lt; &#34;# ~chi_30&#34;;
    slha[&#34;MASS&#34;][&#34;&#34;] &lt;&lt; 1000035 &lt;&lt; mNr(4) &lt;&lt; &#34;# ~chi_40&#34;;
    slha[&#34;MASS&#34;][&#34;&#34;] &lt;&lt; 1000024 &lt;&lt; (*ChiPm)(1).m &lt;&lt; &#34;# ~chi_1+&#34;;
    slha[&#34;MASS&#34;][&#34;&#34;] &lt;&lt; 1000037 &lt;&lt; (*ChiPm)(2).m &lt;&lt; &#34;# ~chi_2+&#34;;

    // Mixing matrices
    SLHAea_add_block(slha, &#34;ALPHA&#34;);
    slha[&#34;ALPHA&#34;][&#34;&#34;] &lt;&lt; -asin((*RS0)(1,1)) &lt;&lt; &#34;# alpha&#34;;

    SLHAea_add_block(slha, &#34;HMIX&#34;, Q);
    slha[&#34;HMIX&#34;][&#34;&#34;] &lt;&lt; 1 &lt;&lt; mu-&gt;re &lt;&lt; &#34;# mu&#34;;
    slha[&#34;HMIX&#34;][&#34;&#34;] &lt;&lt; 2 &lt;&lt; *tanb_Q &lt;&lt; &#34;# tan[beta](Q)&#34;;
    slha[&#34;HMIX&#34;][&#34;&#34;] &lt;&lt; 3 &lt;&lt; *vev_Q &lt;&lt; &#34;# v(Q)&#34;;
    slha[&#34;HMIX&#34;][&#34;&#34;] &lt;&lt; 4 &lt;&lt; *mA2_Q &lt;&lt; &#34;# m^2_A(Q)&#34;;
    slha[&#34;HMIX&#34;][&#34;&#34;] &lt;&lt; 101 &lt;&lt; B-&gt;re &lt;&lt; &#34;# Bmu DRBar&#34;;
    slha[&#34;HMIX&#34;][&#34;&#34;] &lt;&lt; 102 &lt;&lt; (*vevSM)(1) &lt;&lt; &#34;# vd DRBar&#34;;
    slha[&#34;HMIX&#34;][&#34;&#34;] &lt;&lt; 103 &lt;&lt; (*vevSM)(2) &lt;&lt; &#34;# vu DRBar&#34;;

    if(mu-&gt;im != 0)
    {
      SLHAea_add_block(slha, &#34;IMHMIX&#34;, Q);
      slha[&#34;IMHMIX&#34;][&#34;&#34;] &lt;&lt; 1 &lt;&lt; mu-&gt;im &lt;&lt; &#34;# Im(mu)&#34;;
    }

    SLHAea_add_block(slha, &#34;SCALARMIX&#34;);
    SLHAea_add_block(slha, &#34;PSEUDOSCALARMIX&#34;);
    SLHAea_add_block(slha, &#34;CHARGEMIX&#34;);
    for(int i=1; i&lt;=2; i++)
      for(int j=1; j&lt;=2; j++)
      {
        slha[&#34;SCALARMIX&#34;][&#34;&#34;] &lt;&lt; i &lt;&lt; j &lt;&lt; (*RS0)(i,j) &lt;&lt; &#34;# ZH(&#34; &lt;&lt; i &lt;&lt; &#34;,&#34; &lt;&lt; j &lt;&lt; &#34;)&#34;;
        slha[&#34;PSEUDOSCALARMIX&#34;][&#34;&#34;] &lt;&lt; i &lt;&lt; j &lt;&lt; (*RP0)(i,j) &lt;&lt; &#34;# ZA(&#34; &lt;&lt; i &lt;&lt; &#34;,&#34; &lt;&lt; j &lt;&lt; &#34;)&#34;;
        slha[&#34;CHARGEMIX&#34;][&#34;&#34;] &lt;&lt; i &lt;&lt; j &lt;&lt; (*RSpm)(i,j).re &lt;&lt; &#34;# ZP(&#34; &lt;&lt; i &lt;&lt; &#34;,&#34; &lt;&lt; j &lt;&lt; &#34;)&#34;;
      }

    if(*GenerationMixing)
    {
      SLHAea_add_block(slha, &#34;USQMIX&#34;);
      for(int i=1; i&lt;=6; i++)
        for(int j=1; j&lt;=6; j++)
        {
          slha[&#34;USQMIX&#34;][&#34;&#34;] &lt;&lt; i &lt;&lt; j &lt;&lt; RUsq_ckm(i,j).re &lt;&lt; &#34;# R_Su(&#34; &lt;&lt; i &lt;&lt; &#34;,&#34; &lt;&lt; j &lt;&lt; &#34;)&#34;;
          if(RUsq_ckm(i,j).im != 0)
          {
            SLHAea_check_block(slha, &#34;IMUSQMIX&#34;, i, true);
            slha[&#34;IMUSQMIX&#34;][&#34;&#34;] &lt;&lt; i &lt;&lt; j &lt;&lt; RUsq_ckm(i,j).im &lt;&lt; &#34;# Im(R_Su)(&#34; &lt;&lt; i &lt;&lt; &#34;,&#34; &lt;&lt; j &lt;&lt; &#34;)&#34;;
          }
        }

      SLHAea_add_block(slha, &#34;DSQMIX&#34;);
      for(int i=1; i&lt;=6; i++)
        for(int j=1; j&lt;=6; j++)
        {
          slha[&#34;DSQMIX&#34;][&#34;&#34;] &lt;&lt; i &lt;&lt; j &lt;&lt; RDsq_ckm(i,j).re &lt;&lt; &#34;# R_Sd(&#34; &lt;&lt; i &lt;&lt; &#34;,&#34; &lt;&lt; j &lt;&lt; &#34;)&#34;;
          if(RDsq_ckm(i,j).im != 0)
          {
            SLHAea_check_block(slha, &#34;IMDSQMIX&#34;, i, true);
            slha[&#34;IMDSQMIX&#34;][&#34;&#34;] &lt;&lt; i &lt;&lt; j &lt;&lt; RDsq_ckm(i,j).im &lt;&lt; &#34;# Im(R_Sd)(&#34; &lt;&lt; i &lt;&lt; &#34;,&#34; &lt;&lt; j &lt;&lt; &#34;)&#34;;
          }
        }

      SLHAea_add_block(slha, &#34;SELMIX&#34;);
      for(int i=1; i&lt;=6; i++)
        for(int j=1; j&lt;=6; j++)
        {
          slha[&#34;SELMIX&#34;][&#34;&#34;] &lt;&lt; i &lt;&lt; j &lt;&lt; RSl_pmns(i,j).re &lt;&lt; &#34;# R_Sl(&#34; &lt;&lt; i &lt;&lt; &#34;,&#34; &lt;&lt; j &lt;&lt; &#34;)&#34;;
          if(RSl_pmns(i,j).im != 0)
          {
            SLHAea_check_block(slha, &#34;IMSELMIX&#34;, i, true);
            slha[&#34;IMSELMIX&#34;][&#34;&#34;] &lt;&lt; i &lt;&lt; j &lt;&lt; RSl_pmns(i,j).im &lt;&lt; &#34;# Im(R_Sl)(&#34; &lt;&lt; i &lt;&lt; &#34;,&#34; &lt;&lt; j &lt;&lt; &#34;)&#34;;
          }
        }

      SLHAea_add_block(slha, &#34;SNUMIX&#34;);
      for(int i=1; i&lt;=3; i++)
        for(int j=1; j&lt;=3; j++)
        {
          slha[&#34;SNUMIX&#34;][&#34;&#34;] &lt;&lt; i &lt;&lt; j &lt;&lt; RSn_pmns(i,j).re &lt;&lt; &#34;# R_Sn(&#34; &lt;&lt; i &lt;&lt; &#34;,&#34; &lt;&lt; j &lt;&lt; &#34;)&#34;;
          if(RSn_pmns(i,j).im != 0)
          {
            SLHAea_check_block(slha, &#34;IMSNUMIX&#34;, i, true);
            slha[&#34;IMSNUMIX&#34;][&#34;&#34;] &lt;&lt; i &lt;&lt; j &lt;&lt; RSn_pmns(i,j).im &lt;&lt; &#34;# Im(R_Sn)(&#34; &lt;&lt; i &lt;&lt; &#34;,&#34; &lt;&lt; j &lt;&lt; &#34;)&#34;;
          }
        }

    }
    else
    {
      SLHAea_add_block(slha, &#34;STOPMIX&#34;);
      for(int i=1; i&lt;=2; i++)
        for(int j=1; j&lt;=2; j++)
        {
          slha[&#34;STOPMIX&#34;][&#34;&#34;] &lt;&lt; i &lt;&lt; j &lt;&lt; RUsq_ckm(i+4,j+4).re &lt;&lt; &#34;# R_st(&#34; &lt;&lt; i &lt;&lt; &#34;,&#34; &lt;&lt; j &lt;&lt; &#34;)&#34;;
          if((*RSup)(i+4,j+4).im != 0)
          {
            SLHAea_check_block(slha, &#34;IMSTOPMIX&#34;, i, true);
            slha[&#34;IMSTOPMIX&#34;][&#34;&#34;] &lt;&lt; i &lt;&lt; j &lt;&lt; RUsq_ckm(i+4,j+4).im &lt;&lt; &#34;# Im(R_st)(&#34; &lt;&lt; i &lt;&lt; &#34;,&#34; &lt;&lt; j &lt;&lt; &#34;)&#34;;
          }
        }

      SLHAea_add_block(slha, &#34;SBOTMIX&#34;);
      for(int i=1; i&lt;=2; i++)
        for(int j=1; j&lt;=2; j++)
        {
          slha[&#34;SBOTMIX&#34;][&#34;&#34;] &lt;&lt; i &lt;&lt; j &lt;&lt; RDsq_ckm(i+4,j+4).re &lt;&lt; &#34;# R_sb(&#34; &lt;&lt; i &lt;&lt; &#34;,&#34; &lt;&lt; j &lt;&lt; &#34;)&#34;;
          if((*RSdown)(i+4,j+4).im != 0)
          {
            SLHAea_check_block(slha, &#34;IMSBOTMIX&#34;, i, true);
            slha[&#34;IMSBOTMIX&#34;][&#34;&#34;] &lt;&lt; i &lt;&lt; j &lt;&lt; RDsq_ckm(i+4,j+4).im &lt;&lt; &#34;# Im(R_sb)(&#34; &lt;&lt; i &lt;&lt; &#34;,&#34; &lt;&lt; j &lt;&lt; &#34;)&#34;;
          }
        }

      SLHAea_add_block(slha, &#34;STAUMIX&#34;);
      for(int i=1; i&lt;=2; i++)
        for(int j=1; j&lt;=2; j++)
        {
          slha[&#34;STAUMIX&#34;][&#34;&#34;] &lt;&lt; i &lt;&lt; j &lt;&lt; RSl_pmns(i+4,j+4).re &lt;&lt; &#34;# R_sta(&#34; &lt;&lt; i &lt;&lt; &#34;,&#34; &lt;&lt; j &lt;&lt; &#34;)&#34;;
          if((*RSlepton)(i+4,j+4).im != 0)
          {
            SLHAea_check_block(slha, &#34;IMSTAUMIX&#34;, i, true);
            slha[&#34;IMSTAUMIX&#34;][&#34;&#34;] &lt;&lt; i &lt;&lt; j &lt;&lt; RSl_pmns(i+4,j+4).im &lt;&lt; &#34;# Im(R_sta)(&#34; &lt;&lt; i &lt;&lt; &#34;,&#34; &lt;&lt; j &lt;&lt; &#34;)&#34;;
          }
        }
    }

    SLHAea_add_block(slha, &#34;NMIX&#34;);
    for(int i=1; i&lt;=4; i++)
      for(int j=1; j&lt;=4; j++)
      {
        slha[&#34;NMIX&#34;][&#34;&#34;] &lt;&lt; i &lt;&lt; j &lt;&lt; Nr(i,j).re &lt;&lt; &#34;# N(&#34; &lt;&lt; i &lt;&lt; j &lt;&lt; &#34;)&#34;;
        if(Nr(i,j).im != 0)
        {
          SLHAea_check_block(slha, &#34;IMNMIX&#34;, i, true);
          slha[&#34;IMNMIX&#34;][&#34;&#34;] &lt;&lt; i &lt;&lt; j &lt;&lt; Nr(i,j).im &lt;&lt; &#34;# Im(N)(&#34; &lt;&lt; i &lt;&lt; j &lt;&lt; &#34;)&#34;;
        }
      }

    SLHAea_add_block(slha, &#34;UMIX&#34;);
    for(int i=1; i&lt;=2; i++)
      for(int j=1; j&lt;=2; j++)
      {
        slha[&#34;UMIX&#34;][&#34;&#34;] &lt;&lt; i &lt;&lt; j &lt;&lt; (*U)(i,j).re &lt;&lt; &#34;# U(&#34; &lt;&lt; i &lt;&lt; j &lt;&lt; &#34;)&#34;;
        if((*U)(i,j).im != 0)
        {
          SLHAea_check_block(slha, &#34;IMUMIX&#34;, i, true);
          slha[&#34;IMUMIX&#34;][&#34;&#34;] &lt;&lt; i &lt;&lt; j &lt;&lt; (*U)(i,j).im &lt;&lt; &#34;# Im(U)(&#34; &lt;&lt; i &lt;&lt; j &lt;&lt; &#34;)&#34;;
        }
      }


    SLHAea_add_block(slha, &#34;VMIX&#34;);
    for(int i=1; i&lt;=2; i++)
      for(int j=1; j&lt;=2; j++)
      {
        slha[&#34;VMIX&#34;][&#34;&#34;] &lt;&lt; i &lt;&lt; j &lt;&lt; (*V)(i,j).re &lt;&lt; &#34;# V(&#34; &lt;&lt; i &lt;&lt; j &lt;&lt; &#34;)&#34;;
        if((*V)(i,j).im != 0)
        {
          SLHAea_check_block(slha, &#34;IMVMIX&#34;, i, true);
          slha[&#34;IMVMIX&#34;][&#34;&#34;] &lt;&lt; i &lt;&lt; j &lt;&lt; (*V)(i,j).im &lt;&lt; &#34;# Im(V)(&#34; &lt;&lt; i &lt;&lt; j &lt;&lt; &#34;)&#34;;
        }
      }

    //Create Spectrum object
    static const Spectrum::mc_info mass_cut;
    static const Spectrum::mr_info mass_ratio_cut;
    Spectrum spectrum = spectrum_from_SLHAea&lt;MSSMSimpleSpec, SLHAstruct&gt;(slha,slha,mass_cut,mass_ratio_cut);

    // Add the high scale and susy scale variables by hand
    double high_scale;
    if(inputs.param.find(&#34;Qin&#34;) != inputs.param.end())
      high_scale = *inputs.param.at(&#34;Qin&#34;);
    else
      high_scale = *m_GUT;
    double susy_scale = Q;
    spectrum.get_HE().set_override(Par::mass1, high_scale, &#34;high_scale&#34;, true);
    spectrum.get_HE().set_override(Par::mass1, susy_scale, &#34;susy_scale&#34;, true);

    return spectrum;

  }

  // Function to read data from the Gambit inputs and fill SPheno internal variables
  void ReadingData(const Finputs &amp;inputs)
  {

    InitializeStandardModel(inputs.sminputs);
    try{ InitializeLoopFunctions(); }
    catch(std::runtime_error&amp; e) { invalid_point().raise(e.what()); }

    *ErrorLevel = -1;
    *GenerationMixing = false;
    *L_BR = false;
    *L_CS = false;

    try{ Set_All_Parameters_0(); }
    catch(std::runtime_error&amp; e) { invalid_point().raise(e.what()); }

    // necessary to exclude right handed neutrinos from RGEs
    // is set to positive in the corresponding model
    *MNuR = -1E-9;

    // take highest precision, will be change at a later stage (already taken from SPHENOINPUT
    *TwoLoopRGE = true;

    *kont = 0;


    // Set up options, same as BLOCK SPHENOINPUT

    // 1, Error_Level
    *ErrorLevel = inputs.options-&gt;getValueOrDef&lt;Finteger&gt;(-1, &#34;ErrorLevel&#34;);
    // GAMBIT: keep error level always 0 (print every warning), let GAMBIT handle errors
    *ErrorLevel = 0;

    // 2, SPA_convention
    *SPA_convention = inputs.options-&gt;getValueOrDef&lt;bool&gt;(false, &#34;SPA_convention&#34;);
    if(*SPA_convention)
    {
      Freal8 scale = 1E6;
      SetRGEScale(scale);
    }

    // 3, External_Spectrum
    // GAMBIT: no need for external spectrum options
    *External_Spectrum = false;
    *External_Higgs = false;

    // 4, Use_Flavour_States
    // GAMBIT: private variable, cannot import

    // 5, FermionMassResummation
    *FermionMassResummation = inputs.options-&gt;getValueOrDef&lt;bool&gt;(true, &#34;FermionMassResummation&#34;);

    // 6, Ynu_at_MR3, Fixed_Nu_Yukawas
    // GAMBIT: not covered
    *Ynu_at_MR3 = false;
    *Fixed_Nu_Yukawas = false;

    // 7, Only_1loop_Higgsmass
    *Only_1loop_Higgsmass = inputs.options-&gt;getValueOrDef&lt;bool&gt;(false, &#34;Only_1loop_Higgsmass&#34;);

    // 8, Calculates Masses for extra scales if required, Calc_Mass
    *Calc_Mass = inputs.options-&gt;getValueOrDef&lt;bool&gt;(false, &#34;Calc_Mass&#34;);

    // 9, Use old version of BoundaryEW, UseNewBoundaryEW
    *UseNewBoundaryEW = inputs.options-&gt;getValueOrDef&lt;bool&gt;(true, &#34;UseNewBoundaryEW&#34;);

    // 10, use old version to calculate scale, UseNewScale
    *UseNewScale = inputs.options-&gt;getValueOrDef&lt;bool&gt;(true, &#34;UseNewScale&#34;);

    // 11-13, whether to calculate branching ratios or not, L_BR
    *L_BR = false;

    // 21-26, whether to calculate cross sections or not, L_CS
    *L_CS = false;

    // 31, setting a fixed GUT scale, GUTScale
    Freal8 GUTScale = inputs.options-&gt;getValueOrDef&lt;Freal8&gt;(0.0, &#34;GUTScale&#34;);
    if(GUTScale &gt; 0.0)
       SetGUTScale(GUTScale);

    // 32, requires strict unification, StrictUnification
    Flogical StrictUnification = inputs.options-&gt;getValueOrDef&lt;Flogical&gt;(false, &#34;StrictUnification&#34;);
    if(StrictUnification)
      SetStrictUnification(StrictUnification);

    // 34, precision of mass calculation, delta_mass
    *delta_mass = inputs.options-&gt;getValueOrDef&lt;Freal8&gt;(0.00001, &#34;delta_mass&#34;);

    // 35, maximal number of iterations, n_run
    *n_run = inputs.options-&gt;getValueOrDef&lt;Finteger&gt;(40, &#34;n_run&#34;);

    // 36, write out debug information, WriteOut
    // GAMBIT: no write out, all debug info is handled by GAMBIT
    *WriteOut = false;

    // 37, if = 1 -&gt; CKM through V_u, if = 2 CKM through V_d, YukawaScheme
    Finteger YukawaScheme = inputs.options-&gt;getValueOrDef&lt;Finteger&gt;(1, &#34;YukawaScheme&#34;);
    if(YukawaScheme == 1 or YukawaScheme == 2)
    {
      try{ SetYukawaScheme(YukawaScheme); }
      catch(std::runtime_error&amp; e) { invalid_point().raise(e.what()); }
    }

    // 38, set looplevel of RGEs, TwoLoopRGE
    *TwoLoopRGE = inputs.options-&gt;getValueOrDef&lt;Flogical&gt;(true, &#34;TwoLoopRGE&#34;);

    // 39, write additional SLHA1 file, Write_SLHA1
    // GABMIT: Always false, no file output
    *Write_SLHA1 = false;

    // 40, alpha(0), Alpha
    Freal8 alpha = 1.0/137.035999074;
    *Alpha = inputs.options-&gt;getValueOrDef&lt;Freal8&gt;(alpha,&#34;Alpha&#34;);

    // 41, Z-boson width, gamZ
    *gamZ = inputs.options-&gt;getValueOrDef&lt;Freal8&gt;(2.49,&#34;gamZ&#34;);

    // 42, W-boson width, gamW
    *gamW = inputs.options-&gt;getValueOrDef&lt;Freal8&gt;(2.06,&#34;gamW&#34;);

    // 80, exit for sure with non-zero value if problem occurs, Non_Zero_Exit
    // GAMBIT: never brute exit, let GAMBIT do a controlled exit
    *Non_Zero_Exit = false;

    // 81, quick and dirty way to implement model by Suchita Kulkarni, Model_Suchita
    // GAMBIT: not covered
    *Model_Suchita = false;

    // 90, add R-parity at low energies, Add_RParity
    // RParity, not covered yet
    *Add_RParity = false;

    // 91, fit RP parameters such that neutrino data are ok, L_Fit_RP_Parameters
    *L_Fit_RP_Parameters = false;

    // 92, for Pythia input, L_RP_Pythia
    // GAMBIT: private variable, cannot import

    // 93, calculates cross section in case of RP, only partially implemented, L_CSrp
    *L_CSrp = false;

    // 94, io_RP
    // GAMBIT: private variable, cannot import

    // 99, MADGraph output style, some additional information
    // GAMBIT: private variable, cannot import

    // 100, use bsstep instead of rkqs, Use_bsstep_instead_of_rkqs
    Flogical bsstep = inputs.options-&gt;getValueOrDef&lt;Flogical&gt;(false, &#34;Use_bsstep_instead_of_rkqs&#34;);
    if(bsstep)
      Set_Use_bsstep_instead_of_rkqs(bsstep);

    // 101, use rzextr instead of pzextr, Use_rzextr_instead_of_pzextr
    Flogical rzextr = inputs.options-&gt;getValueOrDef&lt;Flogical&gt;(false, &#34;Use_rzextr_instead_of_pzextr&#34;);
    if(rzextr)
      Set_Use_rzextr_instead_of_pzextr(rzextr);

    // 110, write ouput for LHC observables, LWrite_LHC_Observables
    // GAMBIT: private variable, cannot import

    // Silence screen output, added by GAMBIT to SPheno
    *SilenceOutput = inputs.options-&gt;getValueOrDef&lt;bool&gt;(false, &#34;SilenceOutput&#34;);

    // Block SMINPUTS
    // Already in InitializeStandardModel

    // Block MINPAR
    if(*HighScaleModel == &#34;mSUGRA&#34;)
    {
      // M0
      if(inputs.param.find(&#34;M0&#34;) != inputs.param.end())
      {
        for(int i=1; i&lt;=3; i++)
          (*M2D_0_sckm)(i,i) = pow(*inputs.param.at(&#34;M0&#34;),2);
        *M2E_0_pmns = *M2D_0_sckm;
        *M2L_0_pmns = *M2D_0_sckm;
        *M2_R_0 = *M2D_0_sckm;
        *M2Q_0_sckm = *M2D_0_sckm;
        *M2U_0_sckm = *M2D_0_sckm;
        for(int i=1; i&lt;=2; i++)
          (*M2_H_0)(i) = pow(*inputs.param.at(&#34;M0&#34;),2);
        *M2_T_0 = *M2_H_0;
      }
      // M12
      if(inputs.param.find(&#34;M12&#34;) != inputs.param.end())
      {
        for(int i=1; i&lt;=3; i++)
          (*Mi_0)(i) = *inputs.param.at(&#34;M12&#34;);
      }
      // TanBeta
      *tanb = *inputs.param.at(&#34;TanBeta&#34;);
      // SignMu
      *phase_mu = *inputs.param.at(&#34;SignMu&#34;);
      // A0
      if(inputs.param.find(&#34;A0&#34;) != inputs.param.end())
      {
        for(int i=1; i&lt;=3; i++)
          (*AoY_d_0)(i,i) = *inputs.param.at(&#34;A0&#34;);
        *AoY_l_0 = *AoY_d_0;
        *AoY_u_0 = *AoY_d_0;
        *AoY_nu_0 = *AoY_d_0;
        *AoT_0 = *AoY_d_0;
        for(int i=1; i&lt;=2; i++)
          (*Aolam12_0)(i) = (*AoY_d_0)(1,1);
      }
    }
    else if(*HighScaleModel == &#34;SUGRA&#34;)
    {
      // SignMu
      *phase_mu = *inputs.param.at(&#34;SignMu&#34;);
      // TanBeta
      *tanb = *inputs.param.at(&#34;TanBeta&#34;);
    }
    // Missing pars 7 - 10

    // Block EXTPAR
    if(*HighScaleModel == &#34;SUGRA&#34;) // SUGRA
    {
      // Scale of input parameters
      if(inputs.param.find(&#34;Qin&#34;) != inputs.param.end())
      {
        Freal8 Qin = *inputs.param.at(&#34;Qin&#34;);
  SetGUTScale(Qin);
      }
      // M_1
      if(inputs.param.find(&#34;M1&#34;) != inputs.param.end())
      {
        (*Mi)(1).re = *inputs.param.at(&#34;M1&#34;);
        (*Mi_0)(1).re = *inputs.param.at(&#34;M1&#34;);
      }
      // M_2
      if(inputs.param.find(&#34;M2&#34;) != inputs.param.end())
      {
        (*Mi)(2).re = *inputs.param.at(&#34;M2&#34;);
        (*Mi_0)(2).re = *inputs.param.at(&#34;M2&#34;);
      }
      // M_3
      if(inputs.param.find(&#34;M3&#34;) != inputs.param.end())
      {
        (*Mi)(3).re = *inputs.param.at(&#34;M3&#34;);
        (*Mi_0)(3).re = *inputs.param.at(&#34;M3&#34;);
      }
      // tanb
      // in GAMBIT tanb is always at mZ
      *tanb_in_at_Q = false;

      for(int i=1; i&lt;=3; i++)
        for(int j=1; j&lt;=3; j++)
        {
          // A_u, Block TUIN
          std::stringstream parname;
          parname &lt;&lt; &#34;Au_&#34; &lt;&lt; i &lt;&lt; j;
          if(inputs.param.find(parname.str()) != inputs.param.end())
          {
            (*Au_0_sckm)(i,j).re = *inputs.param.at(parname.str());
            (*Au_sckm)(j,i).re = *inputs.param.at(parname.str());
          }
          // A_d, Block TDIN
          parname.str(std::string());
          parname &lt;&lt; &#34;Ad_&#34; &lt;&lt; i &lt;&lt; j;
          if(inputs.param.find(parname.str()) != inputs.param.end())
          {
            (*Ad_0_sckm)(i,j).re = *inputs.param.at(parname.str());
            (*Ad_sckm)(j,i).re = *inputs.param.at(parname.str());
          }
          // A_l, Block TEIN
          parname.str(std::string());
          parname &lt;&lt; &#34;Ae_&#34; &lt;&lt; i &lt;&lt; j;
          if(inputs.param.find(parname.str()) != inputs.param.end())
          {
            (*Al_0_pmns)(i,j).re = *inputs.param.at(parname.str());
            (*Al_pmns)(j,i).re = *inputs.param.at(parname.str());
          }
        }

      // A_t
      if(inputs.param.find(&#34;Au_33&#34;) != inputs.param.end())
      {
        (*AoY_u)(3,3).re = *inputs.param.at(&#34;Au_33&#34;);
        *At_save = (*AoY_u)(3,3);
        *AoY_u_0 = *AoY_u;
      }
      // A_b
      if(inputs.param.find(&#34;Ad_33&#34;) != inputs.param.end())
      {
        (*AoY_d)(3,3).re = *inputs.param.at(&#34;Ad_33&#34;);
        *Ab_save = (*AoY_d)(3,3);
        *AoY_d_0 = *AoY_d;
      }
      // A_tau
      if(inputs.param.find(&#34;Ae_33&#34;) != inputs.param.end())
      {
        (*AoY_l)(3,3).re = *inputs.param.at(&#34;Ae_33&#34;);
        *Atau_save = (*AoY_l)(3,3);
        *AoY_l_0 = *AoY_l;
      }

      // M^2_Hd
      if(inputs.param.find(&#34;mHd2&#34;) != inputs.param.end())
      {
        (*M2_H)(1) = *inputs.param.at(&#34;mHd2&#34;);
        (*M2_H_0)(1) = *inputs.param.at(&#34;mHd2&#34;);
      }
      // M^2_Hu
      if(inputs.param.find(&#34;mHu2&#34;) != inputs.param.end())
      {
        (*M2_H)(2) = *inputs.param.at(&#34;mHu2&#34;);
        (*M2_H_0)(2) = *inputs.param.at(&#34;mHu2&#34;);
      }
      // mu, not in GAMBIT input
      // M^2_A(Q), not in GAMBIT input
      // m_A, pole mass, not in GAMBIT input
      for(int i=1; i&lt;=3; i++)
        for(int j=i; j&lt;=3; j++)
        {
          // M^2_L, Block MSL2
          std::stringstream parname;
          parname &lt;&lt; &#34;ml2_&#34; &lt;&lt; i &lt;&lt; j;
          if(inputs.param.find(parname.str()) != inputs.param.end())
          {
           (*M2L_pmns)(i,j) = *inputs.param.at(parname.str());
            (*M2L_pmns)(j,i) = *inputs.param.at(parname.str());
          }
          // M^2_E, Block MSE2
          parname.str(std::string());
          parname &lt;&lt; &#34;me2_&#34; &lt;&lt; i &lt;&lt; j;
          if(inputs.param.find(parname.str()) != inputs.param.end())
          {
            (*M2E_pmns)(i,j) = *inputs.param.at(parname.str());
            (*M2E_pmns)(j,i) = *inputs.param.at(parname.str());
          }
          // M^2_Q, Block MSQ2
          parname.str(std::string());
          parname &lt;&lt; &#34;mq2_&#34; &lt;&lt; i &lt;&lt; j;
          if(inputs.param.find(parname.str()) != inputs.param.end())
          {
            (*M2Q_sckm)(i,j) = *inputs.param.at(parname.str());
            (*M2Q_sckm)(j,i) = *inputs.param.at(parname.str());
          }
          // M^2_U, Block MSU2
          parname.str(std::string());
          parname &lt;&lt; &#34;mu2_&#34; &lt;&lt; i &lt;&lt; j;
          if(inputs.param.find(parname.str()) != inputs.param.end())
          {
            (*M2U_sckm)(i,j) = *inputs.param.at(parname.str());
            (*M2U_sckm)(j,i) = *inputs.param.at(parname.str());
          }
          // M^2_D, Block MSD2
          parname.str(std::string());
          parname &lt;&lt; &#34;md2_&#34; &lt;&lt; i &lt;&lt; j;
          if(inputs.param.find(parname.str()) != inputs.param.end())
          {
            (*M2D_sckm)(i,j) = *inputs.param.at(parname.str());
            (*M2D_sckm)(j,i) = *inputs.param.at(parname.str());
          }
        }
      *M2L_0_pmns = *M2L_pmns;
      *M2E_0_pmns = *M2E_pmns;
      *M2Q_0_sckm = *M2Q_sckm;
      *M2U_0_sckm = *M2U_sckm;
      *M2D_0_sckm = *M2D_sckm;
    }

    // Block SPHENOINPUT
    // Already in run_SPheno

    // Block SPINFO, nothing to do here

    // No other blocks are relevant at this stage

    // now some checks and additional settings
    if(phase_mu-&gt;re == 0 and (mu-&gt;abs() &gt; 0))
    {
      *phase_mu = *mu;
      phase_mu-&gt;re /= mu-&gt;abs();
      phase_mu-&gt;im /= mu-&gt;abs();
    }

    if(*SPA_convention)
    {
      backend_warning().raise(LOCAL_INFO,&#34;SPheno Warning: in case of SPA conventions, tan(beta) should be given at 1 TeV.&#34;);
    }

    // recalculate quantities to be sure
    *gmZ = *gamZ * *mZ;
    *gmZ2 = pow(*gmZ, 2);

    // W-boson, first rough estimate
    *mW2 = *mZ2 * (0.5 + sqrt(0.25 - *Alpha_mZ*M_PI / (sqrt(2) * *G_F * *mZ2))) / 0.985;
    *mW = sqrt(*mW2);   // mass
    *gamW = 2.06; // width
    *gamW2 = pow(*gamW, 2);
    *gmW = *gamW * *mW;
    *gmW2 = pow(*gmW, 2);

    // the running fermion masses at m_Z need to be recalculated
    *Alpha_mZ = Alpha_MSbar(*mZ, *mW);
    CalculateRunningMasses(*mf_l, *mf_d, *mf_u, *Q_light_quarks, *Alpha_mZ, *AlphaS_mZ, *mZ, *mf_l_mZ, *mf_d_mZ, *mf_u_mZ, *kont);

    // check if T_f and A_f given, if yes, then A_f gets overwritten
    if((*Au_sckm)(3,3).abs() != 0)
    {
      At_save-&gt;re = 0;
      At_save-&gt;im = 0;
    }
    if((*Ad_sckm)(3,3).abs() != 0)
    {
      Ab_save-&gt;re = 0;
      Ab_save-&gt;im = 0;
    }
    if((*Al_pmns)(3,3).abs() != 0)
    {
      Atau_save-&gt;re = 0;
      Atau_save-&gt;im = 0;
    }

  }

  void InitializeStandardModel(const SMInputs &amp;sminputs)
  {

    *kont = 0;

    // Contributions to alpha(m_Z), based on F. Jegerlehner, hep-ph/0310234 and Fanchiotti, Kniehl, Sirlin PRD 48 (1993) 307
    *Delta_Alpha_Lepton = 0.04020;
    *Delta_Alpha_Hadron = 0.027651;

    // Z-boson
    *mZ = sminputs.mZ;      // mass
    *gamZ = 2.4952;   // width, values henceforth from StandardModel.f90
    (*BrZqq)(1) = 0.156;  // branching ratio in d \bar{d}
    (*BrZqq)(2) = 0.156;  // branching ratio in s \bar{s}
    (*BrZqq)(3) = 0.151;  // branching ratio in b \bar{b}
    (*BrZqq)(4) = 0.116;  // branching ratio in u \bar{u}
    (*BrZqq)(5) = 0.12;   // branching ratio in c \bar{c}
    (*BrZll)(1) = 0.0336; // branching ratio in e+ e-
    (*BrZll)(2) = 0.0336; // branching ratio in mu+ mu-
    (*BrZll)(3) = 0.0338; // branching ratio in tau+ tau-
    *BrZinv = 0.2;    // invisible branching ratio

    *mZ2 = *mZ * *mZ;
    *gamZ2 = *gamZ * *gamZ;
    *gmZ = *gamZ * *mZ;
    *gmZ2 = *gmZ * *gmZ;

    // W-boson
    *mW = 80.385;
    *gamW = 2.085;
    (*BrWqq)(1) = 0.35;
    (*BrWqq)(2) = 0.35;
    for(int i=1; i&lt;=3; i++)
      (*BrWln)(i) = 0.1;

    *mW2 = pow(*mW, 2);
    *gamW2 = pow(*gamW, 2);
    *gmW = *gamW * *mW;
    *gmW2 = pow(*gmW, 2);

    // lepton masses: e, muon, tau
    (*mf_l)(1) = sminputs.mE;
    (*mf_l)(2) = sminputs.mMu;
    (*mf_l)(3) = sminputs.mTau;

    // neutrino masses
    (*mf_nu)(1) = sminputs.mNu1;
    (*mf_nu)(2) = sminputs.mNu2;
    (*mf_nu)(3) = sminputs.mNu3;

    // scale where masses of light quarks are defined [in GeV]
    (*Q_light_quarks) = 2;

    // up-quark masses: u, c, t
    (*mf_u)(1) = sminputs.mU;
    (*mf_u)(2) = sminputs.mCmC;
    (*mf_u)(3) = sminputs.mT;

    // down-quark masses: d, s, b
    (*mf_d)(1) = sminputs.mD;
    (*mf_d)(2) = sminputs.mS;
    (*mf_d)(3) = sminputs.mBmB;

    for(int i=1; i&lt;=3; i++)
    {
       (*mf_l2)(i) = pow((*mf_l)(i),2);
       (*mf_u2)(i) = pow((*mf_u)(i),2);
       (*mf_d2)(i) = pow((*mf_d)(i),2);
    }

    // couplings: Alpha(Q=0), Alpha(mZ), Alpha_S(mZ), Fermi constant G_F
    *Alpha_mZ = 1.0/sminputs.alphainv;
    *Alpha_mZ_MS = *Alpha_mZ; // from SMINPUTS
    *MZ_input = true;
    *AlphaS_mZ = sminputs.alphaS;
    *G_F = sminputs.GF;

    // for ISR correction in e+e- annihilation
    *KFactorLee = 1.0 + (M_PI/3.0 - 1.0/(2*M_PI))*(*Alpha);

    // CKM matrix
    *lam_wolf = sminputs.CKM.lambda;
    *A_wolf = sminputs.CKM.A;
    *rho_wolf = sminputs.CKM.rhobar;
    *eta_wolf = sminputs.CKM.etabar;

    double s12 = sminputs.CKM.lambda;
    double s23 = pow(s12,2) * sminputs.CKM.A;
    double s13 = s23 * sminputs.CKM.lambda * sqrt(pow(sminputs.CKM.etabar,2) + pow(sminputs.CKM.rhobar,2));
    double phase = atan(sminputs.CKM.etabar/sminputs.CKM.rhobar);

    double c12 = sqrt(1.0 - pow(s12,2));
    double c23 = sqrt(1.0 - pow(s23,2));
    double c13 = sqrt(1.0 - pow(s13,2));

    std::complex&lt;double&gt; i = -1;
    i = sqrt(i);

    (*CKM)(1,1) = c12 * c13;
    (*CKM)(1,2) = s12 * c13;
    (*CKM)(1,3) = s13 * exp(-i * phase);
    (*CKM)(2,1) = -s12*c23 -c12*s23*s13 * exp(i * phase);
    (*CKM)(2,2) = c12*c23 -s12*s23*s13 * exp(i * phase );
    (*CKM)(2,3) = s23 * c13;
    (*CKM)(3,1) = s12*s23 -c12*c23*s13 * exp(i * phase );
    (*CKM)(3,2) = -c12*s23 - s12*c23*s13 * exp( i * phase );
    (*CKM)(3,3) = c23 * c13;

    try{ CalculateRunningMasses(*mf_l, *mf_d, *mf_u, *Q_light_quarks, *Alpha_mZ, *AlphaS_mZ, *mZ, *mf_l_mZ, *mf_d_mZ, *mf_u_mZ, *kont); }
    catch(std::runtime_error&amp; e) { invalid_point().raise(e.what()); }

    // PMNS matrix
    *theta_12 = sminputs.PMNS.theta12;
    *theta_23 = sminputs.PMNS.theta23;
    *theta_13 = sminputs.PMNS.theta13;
    *delta_nu = sminputs.PMNS.delta13;
    *alpha_nu1 = sminputs.PMNS.alpha1;
    *alpha_nu2 = sminputs.PMNS.alpha2;

    s12 = sin(*theta_12);
    s23 = sin(*theta_23);
    s13 = sin(*theta_13);

    c12 = sqrt(1.0 - pow(s12,2));
    c23 = sqrt(1.0 - pow(s23,2));
    c13 = sqrt(1.0 - pow(s13,2));

    (*Unu)(1,1) = c12 * c13 * exp(-0.5*i * *alpha_nu1);
    (*Unu)(1,2) = s12 * c13 * exp(-0.5*i * *alpha_nu1);
    (*Unu)(1,3) = s13 * exp(-i * *delta_nu) * exp(-0.5*i * *alpha_nu1);
    (*Unu)(2,1) = -s12*c23 - c12*s23*s13 * exp(i * *delta_nu) * exp(-0.5*i * *alpha_nu2);
    (*Unu)(2,2) = c12*c23 - s12*s23*s13 * exp(i * *delta_nu) * exp(-0.5*i * *alpha_nu2);
    (*Unu)(2,3) = s23 * c13 * exp(-0.5*i * *alpha_nu2);
    (*Unu)(3,1) = s12*s23 - c12*c23*s13 * exp(i * *delta_nu);
    (*Unu)(3,2) = -c12*s23 - s12*c23*s13 * exp(i * *delta_nu);
    (*Unu)(3,3) = c23 * c13;

    if(*kont != 0)
      ErrorHandling(*kont);
  }

  // Function that handles errors
  void ErrorHandling(const int &amp;kont)
  {

    str message;

    if (kont &gt; 0 and kont &lt;= 31)
      message = (*Math_Error)(kont).str();
    else if (kont &gt; 100 and kont &lt;= 102)
      message = (*SM_Error)(kont-100).str();
    else if (kont &gt; 200 and kont &lt;= 233)
      message = (*SusyM_Error)(kont-200).str();
    else if (kont &gt; 300 and kont &lt;= 315)
      message = (*InOut_Error)(kont-300).str();
    else if (kont &gt; 400 and kont &lt;= 422)
      message = (*Sugra_Error)(kont-400).str();
    else if (kont &gt; 500 and kont &lt;= 525)
      message = (*LoopMass_Error)(kont-500).str();
    else if (kont &gt; 600 and kont &lt;= 609)
      message = (*TwoLoopHiggs_Error)(kont-600).str();
    else if (kont &gt; 1000 and kont &lt;= 1010)
      message = (*MathQP_Error)(kont-1000).str();
    else
      message = &#34;GAMBIT caught an error in SPheno. Check the SPheno output for more info.&#34;;

    logger() &lt;&lt; message &lt;&lt; EOM;
    invalid_point().raise(message);

    return ;

  }

}
END_BE_NAMESPACE

// Initialisation function (definition)
BE_INI_FUNCTION
{

    // Dump all internal output
    *ErrCan = 0;

    try{ Set_All_Parameters_0(); }
    catch(std::runtime_error&amp; e) { invalid_point().raise(e.what()); }

    // Set up model, same as Block MODSEL
    if((*ModelInUse)(&#34;CMSSM&#34;))
    {
      *HighScaleModel = &#34;mSUGRA&#34;;
      try {SetHighScaleModel(&#34;SUGRA&#34;); }
      catch(std::runtime_error&amp; e) { invalid_point().raise(e.what()); }

    }
    else
    {
      *HighScaleModel = &#34;SUGRA&#34;; // SUGRA
      try {SetHighScaleModel(&#34;SUGRA&#34;); }
      catch(std::runtime_error&amp; e) { invalid_point().raise(e.what()); }

    }

}
END_BE_INI_FUNCTION
</code></pre><hr/><p>Updated on 2022-08-10 at 17:51:38 +0000</p></main></div></div></div><footer class="footer text-muted"><div class="container-xxl"><div class="row"><div class="col-lg-8 order-last order-lg-first"><ul class="list-inline"><li class="list-inline-item">Powered by <a class="text-muted" href="https://gohugo.io/">Hugo</a> and <a class="text-muted" href="https://getdoks.org/">Doks</a></li></ul></div><div class="col-lg-8 order-first order-lg-last text-lg-end"><ul class="list-inline"><li class="list-inline-item"><a href="/license/">License</a></li></ul></div></div></div></footer><script src="/js/bootstrap.min.54bf0932b8a36d0e152b1635b099a6ef1394d35327e2437550a075c9c8ed1bd8aed5847c21b36fc02ed24014c031d9ca24017b0c78b1639d7e2fa8329898b842.js" integrity="sha512-VL8JMrijbQ4VKxY1sJmm7xOU01Mn4kN1UKB1ycjtG9iu1YR8IbNvwC7SQBTAMdnKJAF7DHixY51+L6gymJi4Qg==" crossorigin="anonymous" defer=""></script>
<script src="/js/highlight.min.5b48bc253dc75aeea5fb366ecf700f4925e2b6eb1a1466f2124b722d68148d67bc0a9365d2b8ad9c585161b46372d23b08509a16f1fd518542b894756d4752d0.js" integrity="sha512-W0i8JT3HWu6l+zZuz3APSSXitusaFGbyEktyLWgUjWe8CpNl0ritnFhRYbRjctI7CFCaFvH9UYVCuJR1bUdS0A==" crossorigin="anonymous" defer=""></script>
<script src="/main.min.40265e9a032aeba5eaf67baac3cbbc22667a7533215d326eeb3e9f4d5e4be40f9ff4dcd22949db73ae527ca26a19d7998091a8973c82af760b2c0daa335190ed.js" integrity="sha512-QCZemgMq66Xq9nuqw8u8ImZ6dTMhXTJu6z6fTV5L5A+f9NzSKUnbc65SfKJqGdeZgJGolzyCr3YLLA2qM1GQ7Q==" crossorigin="anonymous" defer=""></script>
<script src="https://gambitbsm.github.io/index.min.1e0f859443ac81a8b8c357ddfae5d899d83ab224e24e44c1c9620a99f2a527d70a1676148a868f87f22fb67994386d592e508dafb575df7c2b80d97f143ad1ea.js" integrity="sha512-Hg+FlEOsgai4w1fd+uXYmdg6siTiTkTByWIKmfKlJ9cKFnYUioaPh/IvtnmUOG1ZLlCNr7V133wrgNl/FDrR6g==" crossorigin="anonymous" defer=""></script></body></html>