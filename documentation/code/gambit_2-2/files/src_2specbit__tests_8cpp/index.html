<!DOCTYPE html><html lang="en-us"><head><meta charset="utf-8"/><meta http-equiv="x-ua-compatible" content="ie=edge"/><meta name="viewport" content="width=device-width,initial-scale=1,shrink-to-fit=no"/><link rel="preload" as="font" href="https://gambitbsm.github.io/fonts/vendor/jost/jost-v4-latin-regular.woff2" type="font/woff2" crossorigin=""/><link rel="preload" as="font" href="https://gambitbsm.github.io/fonts/vendor/jost/jost-v4-latin-500.woff2" type="font/woff2" crossorigin=""/><link rel="preload" as="font" href="https://gambitbsm.github.io/fonts/vendor/jost/jost-v4-latin-700.woff2" type="font/woff2" crossorigin=""/><script>(()=>{var e=localStorage.getItem("theme");e==="dark"&&document.documentElement.setAttribute("data-dark-mode","")})()</script><link rel="stylesheet" href="https://gambitbsm.github.io/main.e60a30503f41dfe2a8e849eba3bb572667400d7915356bae7eff31d3e22e4492fc8c0b2ff150168b1139b9c0caad1a20c84c8957336bcc2bba8559379cc39f91.css" integrity="sha512-5gowUD9B3+Ko6Enro7tXJmdADXkVNWuufv8x0+IuRJL8jAsv8VAWixE5ucDKrRogyEyJVzNrzCu6hVk3nMOfkQ==" crossorigin="anonymous"/><noscript><style>img.lazyload{display:none}</style></noscript><meta name="robots" content="index, follow"/><meta name="googlebot" content="index, follow, max-snippet:-1, max-image-preview:large, max-video-preview:-1"/><meta name="bingbot" content="index, follow, max-snippet:-1, max-image-preview:large, max-video-preview:-1"/><title>file src/src/SpecBit_tests.cpp - GAMBIT</title><meta name="description" content="[No description available]"/><link rel="canonical" href="https://gambitbsm.github.io/documentation/code/gambit_2-2/files/src_2specbit__tests_8cpp/"/><meta property="og:locale" content="en_US"/><meta property="og:type" content="article"/><meta property="og:title" content="file src/src/SpecBit_tests.cpp"/><meta property="og:description" content="[No description available]"/><meta property="og:url" content="https://gambitbsm.github.io/documentation/code/gambit_2-2/files/src_2specbit__tests_8cpp/"/><meta property="og:site_name" content="GAMBIT"/><meta property="og:image" content="https://gambitbsm.github.io/gambit_logo.png"/><meta property="og:image:alt" content="GAMBIT"/><meta name="twitter:card" content="summary_large_image"/><meta name="twitter:site" content=""/><meta name="twitter:creator" content=""/><meta name="twitter:title" content="file src/src/SpecBit_tests.cpp"/><meta name="twitter:description" content="[No description available]"/><meta name="twitter:image" content="https://gambitbsm.github.io/gambit_logo.png"/><meta name="twitter:image:alt" content="file src/src/SpecBit_tests.cpp"/><script type="application/ld+json">{"@context":"https://schema.org","@graph":[{"@type":"Organization","@id":"https://gambitbsm.github.io/#/schema/organization/1","name":"Doks","url":"https://gambitbsm.github.io/","sameAs":["https://github.com/GambitBSM"],"logo":{"@type":"ImageObject","@id":"https://gambitbsm.github.io/#/schema/image/1","url":"https://gambitbsm.github.io/logo-doks.png","width":450,"height":416,"caption":"Doks"},"image":{"@id":"https://gambitbsm.github.io/#/schema/image/1"}},{"@type":"WebSite","@id":"https://gambitbsm.github.io/#/schema/website/1","url":"https://gambitbsm.github.io/","name":"GAMBIT","description":"Documentation for the Global And Modular BSM Inference Tool","publisher":{"@id":"https://gambitbsm.github.io/#/schema/organization/1"}},{"@type":"WebPage","@id":"https://gambitbsm.github.io/documentation/code/gambit_2-2/files/src_2specbit__tests_8cpp/","url":"https://gambitbsm.github.io/documentation/code/gambit_2-2/files/src_2specbit__tests_8cpp/","name":"file src\/src\/SpecBit_tests.cpp","description":"[No description available]","isPartOf":{"@id":"https://gambitbsm.github.io/#/schema/website/1"},"about":{"@id":"https://gambitbsm.github.io/#/schema/organization/1"},"datePublished":"0001-01-01T00:00:00CET","dateModified":"0001-01-01T00:00:00CET","breadcrumb":{"@id":"https://gambitbsm.github.io/documentation/code/gambit_2-2/files/src_2specbit__tests_8cpp/#/schema/breadcrumb/1"},"primaryImageOfPage":{"@id":"https://gambitbsm.github.io/documentation/code/gambit_2-2/files/src_2specbit__tests_8cpp/#/schema/image/2"},"inLanguage":"en-US","potentialAction":[{"@type":"ReadAction","target":["https://gambitbsm.github.io/documentation/code/gambit_2-2/files/src_2specbit__tests_8cpp/"]}]},{"@type":"BreadcrumbList","@id":"https://gambitbsm.github.io/documentation/code/gambit_2-2/files/src_2specbit__tests_8cpp/#/schema/breadcrumb/1","name":"Breadcrumbs","itemListElement":[{"@type":"ListItem","position":1,"item":{"@type":"WebPage","@id":"https://gambitbsm.github.io/","url":"https://gambitbsm.github.io/","name":"Home"}},{"@type":"ListItem","position":2,"item":{"@type":"WebPage","@id":"https://gambitbsm.github.io/documentation/","url":"https://gambitbsm.github.io/documentation/","name":"Documentation"}},{"@type":"ListItem","position":3,"item":{"@type":"WebPage","@id":"https://gambitbsm.github.io/documentation/code/","url":"https://gambitbsm.github.io/documentation/code/","name":"Code"}},{"@type":"ListItem","position":4,"item":{"@type":"WebPage","@id":"https://gambitbsm.github.io/documentation/code/gambit_2-2/","url":"https://gambitbsm.github.io/documentation/code/gambit_2-2/","name":"Gambit 2 2"}},{"@type":"ListItem","position":5,"item":{"@type":"WebPage","@id":"https://gambitbsm.github.io/documentation/code/gambit_2-2/files/","url":"https://gambitbsm.github.io/documentation/code/gambit_2-2/files/","name":"Files"}},{"@type":"ListItem","position":6,"item":{"@id":"https://gambitbsm.github.io/documentation/code/gambit_2-2/files/src_2specbit__tests_8cpp/"}}]},{"@context":"https://schema.org","@graph":[{"@type":"ImageObject","@id":"https://gambitbsm.github.io/documentation/code/gambit_2-2/files/src_2specbit__tests_8cpp/#/schema/image/2","url":"https://gambitbsm.github.io/gambit_logo.png","contentUrl":"https://gambitbsm.github.io/gambit_logo.png","caption":"file src\/src\/SpecBit_tests.cpp"}]}]}</script><meta name="theme-color" content="#fff"/><link rel="icon" href="https://gambitbsm.github.io/favicon.ico" sizes="any"/><link rel="icon" type="image/svg+xml" href="https://gambitbsm.github.io/favicon.svg"/><link rel="apple-touch-icon" sizes="180x180" href="https://gambitbsm.github.io/apple-touch-icon.png"/><link rel="icon" type="image/png" sizes="32x32" href="https://gambitbsm.github.io/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="16x16" href="https://gambitbsm.github.io/favicon-16x16.png"/><link rel="manifest" crossorigin="use-credentials" href="https://gambitbsm.github.io/site.webmanifest"/></head><body class="documentation single light"><div class="sticky-top"><div class="header-bar"></div><header class="navbar navbar-expand-md navbar-light doks-navbar"><nav class="container-xxl flex-wrap flex-md-nowrap" aria-label="Main navigation"><a class="navbar-brand p-0 me-auto" href="https://gambitbsm.github.io/" aria-label="GAMBIT"><img class="logo-light" src="https://gambitbsm.github.io//images/gambit_logo.png" width="50px"/>
<img class="logo-dark d-none" src="https://gambitbsm.github.io//images/gambit_logo.png" width="50px"/>
GAMBIT</a>
<button class="btn btn-menu order-2 d-block d-lg-none" type="button" data-bs-toggle="offcanvas" data-bs-target="#offcanvasDoks" aria-controls="offcanvasDoks" aria-label="Open main menu"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-menu"><line x1="3" y1="12" x2="21" y2="12"></line><line x1="3" y1="6" x2="21" y2="6"></line><line x1="3" y1="18" x2="21" y2="18"></line></svg></button><div class="offcanvas offcanvas-end border-0 py-lg-1" tabindex="-1" id="offcanvasDoks" data-bs-backdrop="true" aria-labelledby="offcanvasDoksLabel"><div class="header-bar d-lg-none"></div><div class="offcanvas-header d-lg-none"><h2 class="h5 offcanvas-title ps-2" id="offcanvasDoksLabel"><a class="text-dark" href="/">GAMBIT</a></h2><button type="button" class="btn-close text-reset me-2" data-bs-dismiss="offcanvas" aria-label="Close main menu"></button></div><div class="offcanvas-body p-4 p-lg-0"><ul class="nav flex-column flex-lg-row align-items-lg-center mt-2 mt-lg-0 ms-lg-2 me-lg-auto"><li class="nav-item dropdown"><a class="nav-link dropdown-toggle ps-0 py-1" href="#" id="navbarDropdownMenuLink" role="button" data-bs-toggle="dropdown" aria-expanded="false">Documentation
<span class="dropdown-caret"><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-chevron-down"><polyline points="6 9 12 15 18 9"></polyline></svg></span></a><ul class="dropdown-menu dropdown-menu-main shadow rounded border-0" aria-labelledby="navbarDropdownMenuLink"><li><a class="dropdown-item" href="/documentation/installation/introduction/">Installation</a></li><li><a class="dropdown-item" href="/documentation/examples/colliderbit_example">Examples</a></li><li><a class="dropdown-item" href="/documentation/help/faqs/">Help</a></li><li><a class="dropdown-item" href="/documentation/code/gambit_2-2/index_classes">Code Reference</a></li></ul></li><li class="nav-item dropdown"><a class="nav-link dropdown-toggle ps-0 py-1" href="#" id="navbarDropdownMenuLink" role="button" data-bs-toggle="dropdown" aria-expanded="false">Community
<span class="dropdown-caret"><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-chevron-down"><polyline points="6 9 12 15 18 9"></polyline></svg></span></a><ul class="dropdown-menu dropdown-menu-main shadow rounded border-0" aria-labelledby="navbarDropdownMenuLink"><li><a class="dropdown-item" href="/community/publications/">Publications</a></li><li><a class="dropdown-item" href="/community/talks/">Talks</a></li><li><a class="dropdown-item" href="/community/members/">Members</a></li><li><a class="dropdown-item active" href="/community/code_of_conduct/" aria-current="true">Code of Conduct</a></li><li><a class="dropdown-item" href="/community/contact/">Contact</a></li></ul></li><li class="nav-item"><a class="nav-link ps-0 py-1" href="/wiki/general/homepage/">Wiki</a></li></ul><hr class="text-black-50 my-4 d-lg-none"/><form class="doks-search position-relative flex-grow-1 ms-lg-auto me-lg-2"><input id="search" class="form-control is-search" type="search" placeholder="Search site..." aria-label="Search site..." autocomplete="off"/><div id="suggestions" class="shadow bg-white rounded d-none"></div></form><hr class="text-black-50 my-4 d-lg-none"/><ul class="nav flex-column flex-lg-row"><li class="nav-item"><a class="nav-link social-link" href="https://github.com/GambitBSM"><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-github"><path d="M9 19c-5 1.5-5-2.5-7-3m14 6v-3.87a3.37 3.37.0 00-.94-2.61c3.14-.35 6.44-1.54 6.44-7A5.44 5.44.0 0020 4.77 5.07 5.07.0 0019.91 1S18.73.65 16 2.48a13.38 13.38.0 00-7 0C6.27.65 5.09 1 5.09 1A5.07 5.07.0 005 4.77 5.44 5.44.0 003.5 8.55c0 5.42 3.3 6.61 6.44 7A3.37 3.37.0 009 18.13V22"></path></svg><small class="ms-2 d-lg-none">GitHub</small></a></li></ul><hr class="text-black-50 my-4 d-lg-none"/><button id="mode" class="btn btn-link" type="button" aria-label="Toggle user interface mode">
<span class="toggle-dark"><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-moon"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"></path></svg></span><span class="toggle-light"><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-sun"><circle cx="12" cy="12" r="5"></circle><line x1="12" y1="1" x2="12" y2="3"></line><line x1="12" y1="21" x2="12" y2="23"></line><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line><line x1="1" y1="12" x2="3" y2="12"></line><line x1="21" y1="12" x2="23" y2="12"></line><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line></svg></span></button></div></div></nav></header></div><div class="wrap container-xxl" role="document"><div class="content"><div class="row flex-xl-nowrap"><div class="col-lg-5 col-xl-4 docs-sidebar"><nav class="docs-links" aria-label="Main navigation"><ul class="list-unstyled collapsible-sidebar"><li class="mb-1"><button class="btn btn-toggle align-items-center rounded collapsed" data-bs-toggle="collapse" data-bs-target="#section-installation" aria-expanded="false">
Installation</button><div class="collapse" id="section-installation"><ul class="btn-toggle-nav list-unstyled fw-normal pb-1 small"><li><a class="docs-link rounded" href="/documentation/installation/introduction/">Getting Started</a></li><li><a class="docs-link rounded" href="/documentation/installation/docker_usage/">Docker Usage</a></li><li><a class="docs-link rounded" href="/documentation/installation/installation_for_linux/">Installation for Linux</a></li><li><a class="docs-link rounded" href="/documentation/installation/installation_for_windows/">Installation for Windows</a></li><li><a class="docs-link rounded" href="/documentation/installation/installation_for_macos/">Installation for macOS</a></li></ul></div></li><li class="mb-1"><button class="btn btn-toggle align-items-center rounded collapsed" data-bs-toggle="collapse" data-bs-target="#section-examples" aria-expanded="false">
Examples</button><div class="collapse" id="section-examples"><ul class="btn-toggle-nav list-unstyled fw-normal pb-1 small"><li><a class="docs-link rounded" href="/documentation/examples/colliderbit_example/">ColliderBit Example</a></li><li><a class="docs-link rounded" href="/documentation/examples/anotherbit/">AnotherBit</a></li><li><a class="docs-link rounded" href="/documentation/examples/anotherbit2/">AnotherBit2</a></li></ul></div></li><li class="mb-1"><button class="btn btn-toggle align-items-center rounded collapsed" data-bs-toggle="collapse" data-bs-target="#section-help" aria-expanded="false">
Help</button><div class="collapse" id="section-help"><ul class="btn-toggle-nav list-unstyled fw-normal pb-1 small"><li><a class="docs-link rounded" href="/documentation/help/faqs/">FAQs</a></li><li><a class="docs-link rounded" href="/documentation/help/compiler_matrix/">Compiler Matrix</a></li><li><a class="docs-link rounded" href="/documentation/help/known_issues/">Known Issues</a></li><li><a class="docs-link rounded" href="/documentation/help/configuration_examples/">Configuration Examples</a></li></ul></div></li><li class="mb-1"><button class="btn btn-toggle align-items-center rounded collapsed" data-bs-toggle="collapse" data-bs-target="#section-code" aria-expanded="true">
Code Reference</button><div class="collapse show" id="section-code"><ul class="btn-toggle-nav list-unstyled fw-normal pb-1 small"><li class="my-1 ms-3"><button class="btn btn-toggle align-items-center rounded collapsed" data-bs-toggle="collapse" data-bs-target="#section-gambit_2-2" aria-expanded="true">
<font style="color: #5d2f86;" size="-6">release</font>   gambit 2-2</button><div class="collapse show" id="section-gambit_2-2"><ul class="btn-toggle-nav list-unstyled fw-normal pb-1 small"><li><a class="docs-link rounded" href="/documentation/code/gambit_2-2/index_classes/">Classes</a></li><li><a class="docs-link rounded" href="/documentation/code/gambit_2-2/index_files/">Files</a></li><li><a class="docs-link rounded" href="/documentation/code/gambit_2-2/index_pages/">Pages</a></li><li><a class="docs-link rounded" href="/documentation/code/gambit_2-2/index_namespaces/">Namespaces</a></li></ul></div></li></ul></div></li></ul></nav></div><nav class="docs-toc d-none d-xl-block col-xl-3" aria-label="Secondary navigation"><div class="d-xl-none"><button class="btn btn-outline-primary btn-sm doks-toc-toggle collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#onThisPage" aria-controls="doks-docs-nav" aria-expanded="false" aria-label="Toggle On this page navigation">
<span>On this page</span>
<span><svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24" class="doks doks-expand" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><title>Expand</title><polyline points="7 13 12 18 17 13"></polyline><polyline points="7 6 12 11 17 6"></polyline></svg><svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24" class="doks doks-collapse" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><title>Collapse</title><polyline points="17 11 12 6 7 11"></polyline><polyline points="17 18 12 13 7 18"></polyline></svg></span></button><div class="collapse" id="onThisPage"><div class="card card-body mt-3 py-1"><div class="page-links"><nav id="TableOfContents"><ul><li><ul><li><a href="#namespaces">Namespaces</a></li><li><a href="#defines">Defines</a></li><li><a href="#detailed-description">Detailed Description</a></li><li><a href="#macros-documentation">Macros Documentation</a><ul><li><a href="#define-echo">define ECHO</a></li><li><a href="#define-get_mix_matrix_el">define GET_MIX_MATRIX_EL</a></li><li><a href="#define-get_mix_matrix">define GET_MIX_MATRIX</a></li><li><a href="#define-get_matrix_el">define GET_MATRIX_EL</a></li><li><a href="#define-get_matrix">define GET_MATRIX</a></li><li><a href="#define-get_m1_matrix_el">define GET_M1_MATRIX_EL</a></li><li><a href="#define-get_m1_matrix">define GET_M1_MATRIX</a></li><li><a href="#define-get_m2_matrix_el">define GET_M2_MATRIX_EL</a></li><li><a href="#define-get_m2_matrix">define GET_M2_MATRIX</a></li></ul></li><li><a href="#source-code">Source code</a></li></ul></li></ul></nav></div></div></div></div><div class="page-links d-none d-xl-block"><h3>On this page</h3><nav id="TableOfContents"><ul><li><ul><li><a href="#namespaces">Namespaces</a></li><li><a href="#defines">Defines</a></li><li><a href="#detailed-description">Detailed Description</a></li><li><a href="#macros-documentation">Macros Documentation</a><ul><li><a href="#define-echo">define ECHO</a></li><li><a href="#define-get_mix_matrix_el">define GET_MIX_MATRIX_EL</a></li><li><a href="#define-get_mix_matrix">define GET_MIX_MATRIX</a></li><li><a href="#define-get_matrix_el">define GET_MATRIX_EL</a></li><li><a href="#define-get_matrix">define GET_MATRIX</a></li><li><a href="#define-get_m1_matrix_el">define GET_M1_MATRIX_EL</a></li><li><a href="#define-get_m1_matrix">define GET_M1_MATRIX</a></li><li><a href="#define-get_m2_matrix_el">define GET_M2_MATRIX_EL</a></li><li><a href="#define-get_m2_matrix">define GET_M2_MATRIX</a></li></ul></li><li><a href="#source-code">Source code</a></li></ul></li></ul></nav></div></nav><main class="docs-content col-lg-11 col-xl-9 mx-xl-auto"><nav aria-label="breadcrumb"><ol class="breadcrumb"><li class="breadcrumb-item"><a href="/">Home</a></li><li class="breadcrumb-item"><a href="/documentation/">Documentation</a></li><li class="breadcrumb-item"><a href="/documentation/code/">Code Reference</a></li><li class="breadcrumb-item"><a href="/documentation/code/gambit_2-2/">gambit_2-2</a></li><li class="breadcrumb-item active" aria-current="page">file src/src/SpecBit_tests.cpp</li></ol></nav><h1>file src/src/SpecBit_tests.cpp</h1><p class="lead"></p><p>[No description available] <a href="#detailed-description">More…</a></p><h2 id="namespaces">Namespaces <a href="#namespaces" class="anchor" aria-hidden="true">#</a></h2><table><thead><tr><th>Name</th></tr></thead><tbody><tr><td><strong><a href="/documentation/code/gambit_2-2/namespaces/namespacegambit/">Gambit</a></strong><br/>TODO: see if we can use this one:</td></tr><tr><td><strong><a href="/documentation/code/gambit_2-2/namespaces/namespacegambit_1_1specbit/">Gambit::SpecBit</a></strong></td></tr></tbody></table><h2 id="defines">Defines <a href="#defines" class="anchor" aria-hidden="true">#</a></h2><table><thead><tr><th></th><th>Name</th></tr></thead><tbody><tr><td></td><td><strong><a href="/documentation/code/gambit_2-2/files/src_2specbit__tests_8cpp/#define-echo">ECHO</a></strong>(COMMAND)</td></tr><tr><td></td><td><strong><a href="/documentation/code/gambit_2-2/files/src_2specbit__tests_8cpp/#define-get-mix-matrix-el">GET_MIX_MATRIX_EL</a></strong>(r, PRODUCT)</td></tr><tr><td></td><td><strong><a href="/documentation/code/gambit_2-2/files/src_2specbit__tests_8cpp/#define-get-mix-matrix">GET_MIX_MATRIX</a></strong>(NAME, BLOCK, __IND1, __IND2)</td></tr><tr><td></td><td><strong><a href="/documentation/code/gambit_2-2/files/src_2specbit__tests_8cpp/#define-get-matrix-el">GET_MATRIX_EL</a></strong>(r, PRODUCT)</td></tr><tr><td></td><td><strong><a href="/documentation/code/gambit_2-2/files/src_2specbit__tests_8cpp/#define-get-matrix">GET_MATRIX</a></strong>(NAME, BLOCK, __IND1, __IND2)</td></tr><tr><td></td><td><strong><a href="/documentation/code/gambit_2-2/files/src_2specbit__tests_8cpp/#define-get-m1-matrix-el">GET_M1_MATRIX_EL</a></strong>(r, PRODUCT)</td></tr><tr><td></td><td><strong><a href="/documentation/code/gambit_2-2/files/src_2specbit__tests_8cpp/#define-get-m1-matrix">GET_M1_MATRIX</a></strong>(NAME, BLOCK, __IND1, __IND2)</td></tr><tr><td></td><td><strong><a href="/documentation/code/gambit_2-2/files/src_2specbit__tests_8cpp/#define-get-m2-matrix-el">GET_M2_MATRIX_EL</a></strong>(r, PRODUCT)</td></tr><tr><td></td><td><strong><a href="/documentation/code/gambit_2-2/files/src_2specbit__tests_8cpp/#define-get-m2-matrix">GET_M2_MATRIX</a></strong>(NAME, BLOCK, __IND1, __IND2)</td></tr></tbody></table><h2 id="detailed-description">Detailed Description <a href="#detailed-description" class="anchor" aria-hidden="true">#</a></h2><p><strong>Author</strong>:</p><ul><li>Ben Farmer (<a href="mailto:ben.farmer@gmail.com">ben.farmer@gmail.com</a>)</li><li>Tomas Gonzalo (<a href="mailto:t.e.gonzalo@fys.uio.no_">t.e.gonzalo@fys.uio.no_</a>)</li></ul><p><strong>Date</strong>:</p><ul><li>2015 Aug</li><li>2016 Apr - Sep</li></ul><p>Tests to verify that Spectrum objects are working correctly.</p><hr/><p>Authors (add name and date if you modify):</p><hr/><h2 id="macros-documentation">Macros Documentation <a href="#macros-documentation" class="anchor" aria-hidden="true">#</a></h2><h3 id="define-echo">define ECHO <a href="#define-echo" class="anchor" aria-hidden="true">#</a></h3><pre><code>#define ECHO(
    COMMAND
)
         {                                                    \
             try {                                            \
                cout &lt;&lt; &#34;  &#34; &lt;&lt; STRINGIFY(COMMAND) &lt;&lt; &#34; = &#34; &lt;&lt; COMMAND &lt;&lt; endl;\
             }                                                \
             catch (const std::exception&amp; e)                  \
             { add_error(report,e,STRINGIFY(COMMAND)); }      \
         }
</code></pre><h3 id="define-get_mix_matrix_el">define GET_MIX_MATRIX_EL <a href="#define-get_mix_matrix_el" class="anchor" aria-hidden="true">#</a></h3><pre><code>#define GET_MIX_MATRIX_EL(
    r,
    PRODUCT
)
         {                                                                       \
            str label = BOOST_PP_SEQ_ELEM(0, PRODUCT);                           \
            str block = BOOST_PP_SEQ_ELEM(1, PRODUCT);                           \
            int i = BOOST_PP_SEQ_ELEM(2, PRODUCT);                               \
            int j = BOOST_PP_SEQ_ELEM(3, PRODUCT);                               \
           try{                                                                  \
            std::ostringstream echo1;                                            \
            std::ostringstream echo2;                                            \
            echo1 &lt;&lt;     &#34;  spec.get(Par::Pole_Mixing,&#34;&lt;&lt;label&lt;&lt;&#34;,&#34;&lt;&lt;i&lt;&lt;&#34;,&#34;&lt;&lt;j&lt;&lt;&#34;) = &#34;; \
            double value1 = spec.get(Par::Pole_Mixing,label,i,j); \
            echo2 &lt;&lt;     &#34;  SLHAea::to&lt;double&gt;( slhaea.at(&#34;&lt;&lt;block&lt;&lt;&#34;).at(&#34;&lt;&lt;i&lt;&lt;&#34;,&#34;&lt;&lt;j&lt;&lt;&#34;).at(2) ) = &#34;; \
            double value2 = SLHAea::to&lt;double&gt;( slhaea.at(block).at(i,j).at(2) ); \
            cout &lt;&lt; echo1.str() &lt;&lt; value1 &lt;&lt;endl;                                \
            cout &lt;&lt; echo2.str() &lt;&lt; value2 &lt;&lt;endl;                                \
            cout &lt;&lt; endl;                                                        \
           }                                                                     \
           catch (const std::exception&amp; e)                                       \
           { add_error(report,e,label+&#34;: &#34;+block); }                             \
         }
</code></pre><h3 id="define-get_mix_matrix">define GET_MIX_MATRIX <a href="#define-get_mix_matrix" class="anchor" aria-hidden="true">#</a></h3><pre><code>#define GET_MIX_MATRIX(
    NAME,
    BLOCK,
    __IND1,
    __IND2
)
BOOST_PP_SEQ_FOR_EACH_PRODUCT(GET_MIX_MATRIX_EL, ((NAME))((BLOCK))(BOOST_PP_TUPLE_TO_SEQ(__IND1))(BOOST_PP_TUPLE_TO_SEQ(__IND2)))
</code></pre><h3 id="define-get_matrix_el">define GET_MATRIX_EL <a href="#define-get_matrix_el" class="anchor" aria-hidden="true">#</a></h3><pre><code>#define GET_MATRIX_EL(
    r,
    PRODUCT
)
         {                                                                       \
            str label = BOOST_PP_SEQ_ELEM(0, PRODUCT);                           \
            str block = BOOST_PP_SEQ_ELEM(1, PRODUCT);                           \
            int i = BOOST_PP_SEQ_ELEM(2, PRODUCT);                               \
            int j = BOOST_PP_SEQ_ELEM(3, PRODUCT);                               \
           try{                                                                  \
            std::ostringstream echo1;                                            \
            std::ostringstream echo2;                                            \
            echo1 &lt;&lt;     &#34;  spec.get(Par::dimensionless,&#34;&lt;&lt;label&lt;&lt;&#34;,&#34;&lt;&lt;i&lt;&lt;&#34;,&#34;&lt;&lt;j&lt;&lt;&#34;) = &#34;; \
            double value1 = spec.get(Par::dimensionless,label,i,j); \
            echo2 &lt;&lt;     &#34;  SLHAea::to&lt;double&gt;( slhaea.at(&#34;&lt;&lt;block&lt;&lt;&#34;).at(&#34;&lt;&lt;i&lt;&lt;&#34;,&#34;&lt;&lt;j&lt;&lt;&#34;).at(2) ) = &#34;; \
            double value2 = SLHAea::to&lt;double&gt;( slhaea.at(block).at(i,j).at(2) ); \
            cout &lt;&lt; echo1.str() &lt;&lt; value1 &lt;&lt;endl;                                \
            cout &lt;&lt; echo2.str() &lt;&lt; value2 &lt;&lt;endl;                                \
            cout &lt;&lt; endl;                                                        \
           } catch (const std::exception&amp; e)                                       \
           { add_error(report,e,label+&#34;: &#34;+block); }                             \
         }
</code></pre><h3 id="define-get_matrix">define GET_MATRIX <a href="#define-get_matrix" class="anchor" aria-hidden="true">#</a></h3><pre><code>#define GET_MATRIX(
    NAME,
    BLOCK,
    __IND1,
    __IND2
)
BOOST_PP_SEQ_FOR_EACH_PRODUCT(GET_MATRIX_EL, ((NAME))((BLOCK))(BOOST_PP_TUPLE_TO_SEQ(__IND1))(BOOST_PP_TUPLE_TO_SEQ(__IND2)))
</code></pre><h3 id="define-get_m1_matrix_el">define GET_M1_MATRIX_EL <a href="#define-get_m1_matrix_el" class="anchor" aria-hidden="true">#</a></h3><pre><code>#define GET_M1_MATRIX_EL(
    r,
    PRODUCT
)
         {                                                                       \
            str label = BOOST_PP_SEQ_ELEM(0, PRODUCT);                           \
            str block = BOOST_PP_SEQ_ELEM(1, PRODUCT);                           \
            int i = BOOST_PP_SEQ_ELEM(2, PRODUCT);                               \
            int j = BOOST_PP_SEQ_ELEM(3, PRODUCT);                               \
           try{                                                                  \
            std::ostringstream echo1;                                            \
            std::ostringstream echo2;                                            \
            echo1 &lt;&lt;     &#34;  spec.get(Par::mass1,&#34;&lt;&lt;label&lt;&lt;&#34;,&#34;&lt;&lt;i&lt;&lt;&#34;,&#34;&lt;&lt;j&lt;&lt;&#34;) = &#34;; \
            double value1 = spec.get(Par::mass1,label,i,j); \
            echo2 &lt;&lt;     &#34;  SLHAea::to&lt;double&gt;( slhaea.at(&#34;&lt;&lt;block&lt;&lt;&#34;).at(&#34;&lt;&lt;i&lt;&lt;&#34;,&#34;&lt;&lt;j&lt;&lt;&#34;).at(2) ) = &#34;; \
            double value2 = SLHAea::to&lt;double&gt;( slhaea.at(block).at(i,j).at(2) ); \
            cout &lt;&lt; echo1.str() &lt;&lt; value1 &lt;&lt;endl;                                \
            cout &lt;&lt; echo2.str() &lt;&lt; value2 &lt;&lt;endl;                                \
            cout &lt;&lt; endl;                                                        \
           } catch (const std::exception&amp; e)                                       \
           { add_error(report,e,label+&#34;: &#34;+block); }                             \
         }
</code></pre><h3 id="define-get_m1_matrix">define GET_M1_MATRIX <a href="#define-get_m1_matrix" class="anchor" aria-hidden="true">#</a></h3><pre><code>#define GET_M1_MATRIX(
    NAME,
    BLOCK,
    __IND1,
    __IND2
)
BOOST_PP_SEQ_FOR_EACH_PRODUCT(GET_M1_MATRIX_EL, ((NAME))((BLOCK))(BOOST_PP_TUPLE_TO_SEQ(__IND1))(BOOST_PP_TUPLE_TO_SEQ(__IND2)))
</code></pre><h3 id="define-get_m2_matrix_el">define GET_M2_MATRIX_EL <a href="#define-get_m2_matrix_el" class="anchor" aria-hidden="true">#</a></h3><pre><code>#define GET_M2_MATRIX_EL(
    r,
    PRODUCT
)
         {                                                                       \
            str label = BOOST_PP_SEQ_ELEM(0, PRODUCT);                           \
            str block = BOOST_PP_SEQ_ELEM(1, PRODUCT);                           \
            int i = BOOST_PP_SEQ_ELEM(2, PRODUCT);                               \
            int j = BOOST_PP_SEQ_ELEM(3, PRODUCT);                               \
            std::ostringstream echo1;                                            \
           try {                                                                 \
            std::ostringstream echo2;                                            \
            echo1 &lt;&lt;     &#34;  spec.get(Par::mass2,&#34;&lt;&lt;label&lt;&lt;&#34;,&#34;&lt;&lt;i&lt;&lt;&#34;,&#34;&lt;&lt;j&lt;&lt;&#34;) = &#34;; \
            double value1 = spec.get(Par::mass2,label,i,j); \
            echo2 &lt;&lt;     &#34;  SLHAea::to&lt;double&gt;( slhaea.at(&#34;&lt;&lt;block&lt;&lt;&#34;).at(&#34;&lt;&lt;i&lt;&lt;&#34;,&#34;&lt;&lt;j&lt;&lt;&#34;).at(2) ) = &#34;; \
            double value2 = SLHAea::to&lt;double&gt;( slhaea.at(block).at(i,j).at(2) ); \
            cout &lt;&lt; echo1.str() &lt;&lt; value1 &lt;&lt;endl;                                \
            cout &lt;&lt; echo2.str() &lt;&lt; value2 &lt;&lt;endl;                                \
            cout &lt;&lt; endl;                                                        \
           } catch (const std::exception&amp; e)                                       \
           { add_error(report,e,label+&#34;: &#34;+block); }                             \
        }
</code></pre><h3 id="define-get_m2_matrix">define GET_M2_MATRIX <a href="#define-get_m2_matrix" class="anchor" aria-hidden="true">#</a></h3><pre><code>#define GET_M2_MATRIX(
    NAME,
    BLOCK,
    __IND1,
    __IND2
)
BOOST_PP_SEQ_FOR_EACH_PRODUCT(GET_M2_MATRIX_EL, ((NAME))((BLOCK))(BOOST_PP_TUPLE_TO_SEQ(__IND1))(BOOST_PP_TUPLE_TO_SEQ(__IND2)))
</code></pre><h2 id="source-code">Source code <a href="#source-code" class="anchor" aria-hidden="true">#</a></h2><pre><code>//   GAMBIT: Global and Modular BSM Inference Tool
//   *********************************************
///  \file
///
///  Tests to verify that Spectrum objects are
///  working correctly.
///
///  *********************************************
///
///  Authors (add name and date if you modify):
///
///  \author Ben Farmer
///          (ben.farmer@gmail.com)
///    \date 2015 Aug
///
///  \author Tomas Gonzalo
///          (t.e.gonzalo@fys.uio.no_)
///     \date 2016 Apr - Sep
///
///
///  *********************************************

#include &lt;string&gt;
#include &lt;sstream&gt;
#include &lt;cmath&gt;

#include &#34;gambit/Elements/gambit_module_headers.hpp&#34;
#include &#34;gambit/Elements/spectrum.hpp&#34;
#include &#34;gambit/SpecBit/SpecBit_rollcall.hpp&#34;

#include &#34;SLHAea/slhaea.h&#34;
#include &lt;boost/preprocessor/tuple/to_seq.hpp&gt;
#include &lt;boost/preprocessor/seq/for_each.hpp&gt;
#include &lt;boost/preprocessor/seq/elem.hpp&gt;
#include &lt;boost/preprocessor/seq/for_each_product.hpp&gt;

#include &#34;gambit/Utils/stream_overloads.hpp&#34;

// MAtrix macros were super slow to compile, have now removed them.

namespace Gambit
{

  namespace SpecBit
  {

    using namespace std;
    using namespace LogTags;

    // Helper function to add error information to report
    void add_error(std::ostringstream&amp; out, const std::exception&amp; e, const std::string&amp; msg)
    {
       out &lt;&lt; &#34;------------------------------&#34; &lt;&lt; std::endl;
       out &lt;&lt; &#34;TEST FAIL: &#34; &lt;&lt; msg &lt;&lt; std::endl;
       out &lt;&lt; &#34;Exception thrown was: &#34;&lt;&lt;e.what()&lt;&lt;std::endl;
       return;
    }

    // Test function for Matematica
    void Math_test(bool &amp;result)
    {
      namespace myPipe = Pipes::Math_test;

      int input1 = 3, input2 = 4;

      int output= myPipe::BEreq::MathTest(input1,input2);
      cout &lt;&lt; &#34;Testing Mathematica&#34; &lt;&lt; endl;
      cout &lt;&lt; &#34;Result : &#34; &lt;&lt; output &lt;&lt; endl;


      result = true;

    }

    void SUSYHD_test(bool &amp;result)
    {
      using namespace Pipes::SUSYHD_test;

      const triplet&lt;double&gt; &amp;mh = *Dep::prec_mh;

      cout &lt;&lt; &#34;mh = &#34; &lt;&lt; mh.central &lt;&lt; &#34; + &#34;  &lt;&lt; mh.upper &lt;&lt; &#34; - &#34;  &lt;&lt; mh.lower &lt;&lt; endl;

      if(!mh.central) result = false;
      else result = true;

      return ;
    }

    // Testing function for SPheno
    void SPheno_MSSM_test(bool &amp;result)
    {
      namespace myPipe = Pipes::SPheno_MSSM_test;
      const Spectrum&amp; fullspectrum = *myPipe::Dep::unimproved_MSSM_spectrum;

      std::cout &lt;&lt; fullspectrum.getSLHAea(2) &lt;&lt; std::endl;

      result = 0;
    }

    /// Verify consistency of the contents of a Spectrum object of capability MSSMspectrum.
    /// (derived from old &#39;exampleRead&#39; function)
    void MSSMspectrum_test (bool &amp;result)
    {

      // Retrieve pointer to Spectrum object, delivered by dependency resolver
      // Module function asks for Spectrum* with capability unimproved_MSSM_spectrum.
      namespace myPipe = Pipes::MSSMspectrum_test;
      const Spectrum&amp; fullspectrum = *myPipe::Dep::unimproved_MSSM_spectrum;
      const SubSpectrum&amp; spec = fullspectrum.get_HE(); // MSSMSpec SubSpectrum object
      const SubSpectrum&amp; SM   = fullspectrum.get_LE(); // QedQcdWrapper SubSpectrum object

      using namespace Par; // Bring parameter tags into scope

      std::ostringstream report; // Information about any problems encountered

      // Extract SLHAea object
      // This copies the data out. Could possibly change it to pass out a
      // reference instead, or have another function to do that.
      SLHAea::Coll slhaea = fullspectrum.getSLHAea(2);
      // for testing, write this to file
      std::ofstream out1;
      out1.open(&#34;SpecBit/MSSMspectrum_test.slha&#34;);
      out1 &lt;&lt; slhaea;
      out1.close();

      // SLHAea::Coll slhaea = spec.getSLHAea(2); // The above is just a wrapper for this.

      // If this is a valid model point, return true and dump information, else false

      // SLHAea objects behave mostly like maps, but with special kinds of keys. For
      // &#34;at&#34; and &#34;operator[]&#34;, it does automatic conversion, but for &#34;find&#34; it does
      // not, so we have to manually do it.
      SLHAea::Block spinfo = slhaea.at(&#34;SPINFO&#34;);
      //std::vector&lt;std::string&gt; k3(1, &#34;3&#34;);
      std::vector&lt;std::string&gt; k4(1, &#34;4&#34;);

      // See if error code entries exist
      //if(spinfo.find(k3) == spinfo.end() and spinfo.find(k4) == spinfo.end())
      if(spinfo.find(k4) == spinfo.end())
      {
         std::cout &lt;&lt; &#34;Good spectrum found! Inspecting contents...&#34; &lt;&lt; std::endl;
         std::cout &lt;&lt; std::endl &lt;&lt; slhaea &lt;&lt; std::endl;

         // Write to file so we can check it
         spec.writeSLHAfile(2, &#34;SpecBit/MSSMspectrum_test_good.slha&#34;);

         // ---------------------------------------------------------
         // BEGIN DEMO OF SPECTRUM OBJECT AND PARTICLE DATABASE
         // ---------------------------------------------------------

         #define ECHO(COMMAND)                                \
         {                                                    \
             try {                                            \
                cout &lt;&lt; &#34;  &#34; &lt;&lt; STRINGIFY(COMMAND) &lt;&lt; &#34; = &#34; &lt;&lt; COMMAND &lt;&lt; endl;\
             }                                                \
             catch (const std::exception&amp; e)                  \
             { add_error(report,e,STRINGIFY(COMMAND)); }      \
         }

         /* ----------Test particle database access ---------------- */
         const auto&amp; PDB = Models::ParticleDB();

         // First check out what is actually in the database
         PDB.check_contents();

         // Demo a couple of particle name retrievals
         cout&lt;&lt;endl;
         cout&lt;&lt;&#34;Demo retrieval of lightest neutralino info from particle database&#34;&lt;&lt;endl;
         cout&lt;&lt;&#34;-----------------------------------------------------------------&#34;&lt;&lt;endl;
         ECHO( PDB.pdg_pair(&#34;~chi0_1&#34;)                   ) // Input long name, retrieve PDG code + context integer
         ECHO( PDB.pdg_pair(&#34;~chi0&#34;,1)                   ) // Input short name + index, retrieve PDG code + context integer
         ECHO( PDB.long_name(&#34;~chi0&#34;,1)                  ) // Input short name + index, retrieve long name
         ECHO( PDB.long_name(std::make_pair(1000022,0))  ) // Input PDG code + context integer, retrieve long name
         ECHO( PDB.long_name(1000022,0)                  ) // Input PDG code + context integer, retrieve long name
         ECHO( PDB.short_name_pair(&#34;~chi0_1&#34;)            ) // Input long name, retrieve short name + index
         ECHO( PDB.short_name_pair(std::make_pair(1000022,0)) ) // Input PDG code plus context integer, retrieve short name + index
         ECHO( PDB.short_name_pair(1000022,0)            ) // Input PDG code plus context integer, retrieve short name + index

         cout&lt;&lt;endl;
         cout&lt;&lt;&#34;Demo retrieval of antiparticle names/codes using particle names/codes&#34;&lt;&lt;endl;
         cout&lt;&lt;&#34;-----------------------------------------------------------------&#34;&lt;&lt;endl;
         // Check existence in various ways
         ECHO( PDB.has_antiparticle(&#34;~chi0_1&#34;)                 )
         ECHO( PDB.has_antiparticle(&#34;~chi0&#34;,1)                 )
         ECHO( PDB.has_antiparticle(std::make_pair(&#34;~chi0&#34;,1)) )
         ECHO( PDB.has_antiparticle(1000022,0)                 )
         ECHO( PDB.has_antiparticle(std::make_pair(1000022,0)) )
         ECHO( PDB.get_antiparticle(&#34;~chi0_1&#34;)                 ) // Input long name, retrieve antiparticle long name
         ECHO( PDB.get_antiparticle(&#34;~chi0&#34;,1)                 ) // Input short name + index, retrieve antiparticle short name + index
         ECHO( PDB.get_antiparticle(std::make_pair(&#34;~chi0&#34;,1)) ) // Input short name + index, retrieve antiparticle short name + index
         ECHO( PDB.get_antiparticle(1000022,0)                 ) // Input PDG code + context integet, retrieve antiparticle PDG code + context integer
         ECHO( PDB.get_antiparticle(std::make_pair(1000022,0)) ) // Input PDG code + context integet, retrieve antiparticle PDG code + context integer
         ECHO( PDB.has_antiparticle(&#34;~chi+_1&#34;)                 )
         ECHO( PDB.has_antiparticle(&#34;~chi+&#34;,1)                 )
         ECHO( PDB.has_antiparticle(std::make_pair(&#34;~chi+&#34;,1)) )
         ECHO( PDB.has_antiparticle(1000024,0)                 )
         ECHO( PDB.has_antiparticle(std::make_pair(1000024,0)) )
         ECHO( PDB.get_antiparticle(&#34;~chi+_1&#34;)                 ) // Input long name, retrieve antiparticle long name
         ECHO( PDB.get_antiparticle(&#34;~chi+&#34;,1)                 ) // Input short name + index, retrieve antiparticle short name + index
         ECHO( PDB.get_antiparticle(std::make_pair(&#34;~chi+&#34;,1)) ) // Input short name + index, retrieve antiparticle short name + index
         ECHO( PDB.get_antiparticle(1000024,0)                 ) // Input PDG code + context integet, retrieve antiparticle PDG code + context integer
         ECHO( PDB.get_antiparticle(std::make_pair(1000024,0)) ) // Input PDG code + context integet, retrieve antiparticle PDG code + context integer
         ECHO( PDB.has_antiparticle(&#34;u_1&#34;)                 )
         ECHO( PDB.has_antiparticle(&#34;u&#34;,1)                 )
         ECHO( PDB.has_antiparticle(std::make_pair(&#34;u&#34;,1)) )
         ECHO( PDB.has_antiparticle(2,0)                   )
         ECHO( PDB.has_antiparticle(std::make_pair(2,0))   )
         ECHO( PDB.get_antiparticle(&#34;u_1&#34;)                 ) // Input long name, retrieve antiparticle long name
         ECHO( PDB.get_antiparticle(&#34;u&#34;,1)                 ) // Input short name + index, retrieve antiparticle short name + index
         ECHO( PDB.get_antiparticle(std::make_pair(&#34;u&#34;,1)) ) // Input short name + index, retrieve antiparticle short name + index
         ECHO( PDB.get_antiparticle(2,0)                   ) // Input PDG code + context integet, retrieve antiparticle PDG code + context integer
         ECHO( PDB.get_antiparticle(std::make_pair(2,0))   ) // Input PDG code + context integet, retrieve antiparticle PDG code + context integer


         cout&lt;&lt;endl;
         cout&lt;&lt;&#34;Demo retrieval when no short name exists&#34;&lt;&lt;endl;
         cout&lt;&lt;&#34;-----------------------------------------------------------------&#34;&lt;&lt;endl;
         ECHO( PDB.pdg_pair(&#34;H+&#34;)                        )
         //ECHO( PDB.pdg_pair(&#34;H+&#34;,1)                      ) // Error!
         //ECHO( PDB.long_name(&#34;H+&#34;,1)                     ) // Error!
         ECHO( PDB.long_name(std::make_pair(37,0))       )
         ECHO( PDB.long_name(37,0)                       )
         //ECHO( PDB.short_name_pair(&#34;H+&#34;)                 ) // Error!
         //ECHO( PDB.short_name_pair(std::make_pair(37,0)) ) // Error!
         //ECHO( PDB.short_name_pair(37,0)                 ) // Error!
         //ECHO( PDB.short_name_pair(37)                   ) // Error!
         cout&lt;&lt;endl;
         /* ----------------- Pole masses --------------------------- */

         cout&lt;&lt;&#34;Begin demo retrievals from Spectrum and SubSpectrum objects&#34;&lt;&lt;endl;
         cout&lt;&lt;&#34;-----------------------------------------------------------------&#34;&lt;&lt;endl;
         cout&lt;&lt;endl;
         cout&lt;&lt;&#34;First, general methods for accessing different sorts of information.&#34;&lt;&lt;endl;
         cout&lt;&lt;endl;
         // At the moment it is only pole masses which have getters overloaded to use
         // the particle database information. It is only the MASS block in the
         // spectrum generator output SLHA files which use PDG numbers anyway, so I
         // think this makes sense.
         cout&lt;&lt;&#34;Lightest neutral Higgs boson pole mass:&#34;&lt;&lt;endl;
         ECHO(  fullspectrum.get(Pole_Mass, PDB.short_name_pair(25,0) )   )
         ECHO(  fullspectrum.get(Pole_Mass, PDB.long_name(25,0) )         )
         ECHO(  fullspectrum.get(Pole_Mass,25,0)                          )
         ECHO(  fullspectrum.get(Pole_Mass, PDB.pdg_pair(&#34;h0&#34;,1) )        )
         ECHO(  fullspectrum.get(Pole_Mass,&#34;h0&#34;,1)                        )
         ECHO(  fullspectrum.get(Pole_Mass,&#34;h0_1&#34;)                        )

         ECHO(  spec.get(Pole_Mass, PDB.short_name_pair(25,0) )   )
         ECHO(  spec.get(Pole_Mass, PDB.long_name(25,0) )         )
         ECHO(  spec.get(Pole_Mass,25,0)                          )
         ECHO(  spec.get(Pole_Mass, PDB.pdg_pair(&#34;h0&#34;,1) )        )
         ECHO(  spec.get(Pole_Mass,&#34;h0&#34;,1)                        )
         ECHO(  spec.get(Pole_Mass,&#34;h0_1&#34;)                        )

         cout&lt;&lt;endl;
         cout&lt;&lt;&#34;Retrieval of Spectrum object contents, with&#34;&lt;&lt;endl;
         cout&lt;&lt;&#34;correspondence to SLHAea object entries&#34;&lt;&lt;endl;
         cout&lt;&lt;&#34;-----------------------------------------------------------------&#34;&lt;&lt;endl;

         // MZ was a bad first example; it is empty unless you switch on the SM pole mass
         // calculator for flexiblesusy. We do not yet pass any input value of MZ though
         // Similar issues with other gauge boson masses. So don&#39;t use these yet or
         // you&#39;ll get zero for all these masses.
         cout&lt;&lt;endl;
         cout&lt;&lt;&#34;Gauge boson pole masses:&#34;&lt;&lt;endl;
         cout&lt;&lt;endl;
         ECHO(  fullspectrum.get(Par::Pole_Mass,&#34;Z0&#34;) )
         ECHO(  SM.get(Par::Pole_Mass,&#34;Z0&#34;)           )
         ECHO(  slhaea.at(&#34;SMINPUTS&#34;).at(4).at(1)      )
         cout&lt;&lt;endl;
         ECHO(  fullspectrum.get(Par::Pole_Mass,&#34;gamma&#34;)    )
         ECHO(  SM.get(Par::Pole_Mass,&#34;gamma&#34;)    )
         cout&lt;&lt;&#34;  ***Not in slha***&#34;&lt;&lt;endl;
         cout&lt;&lt;endl;
         ECHO(  fullspectrum.get(Par::Pole_Mass,&#34;W+&#34;)       )
         ECHO(  SM.get(Par::Pole_Mass,&#34;W+&#34;)         )
         ECHO(  slhaea.at(&#34;MASS&#34;).at(24).at(1)    )
         cout&lt;&lt;endl;
         ECHO(  fullspectrum.get(Par::Pole_Mass,&#34;g&#34;)       )
         ECHO(  SM.get(Par::Pole_Mass,&#34;g&#34;)          )
         cout&lt;&lt;&#34;  ***Not in slha***&#34;&lt;&lt;endl;
         cout&lt;&lt;endl;
         cout&lt;&lt;&#34;Quark pole masses (actually the slha entries are MSbar except the top mass):&#34;&lt;&lt;endl;
         cout&lt;&lt;endl;
         // I&#39;m a little unclear on what the pole masses for the lighter quarks mean, since I thought
         // that non-perturbative effects made definining them difficult... well anyway will have
         // to ask Peter what is being computed here.

         //ECHO(  spec.get(Par::Pole_Mass,&#34;u&#34;,1)      )  // i.e. up (mass eigenstate)
         cout&lt;&lt;&#34;  ***u Pole mass not well defined***&#34;&lt;&lt;endl;
         ECHO(  slhaea.at(&#34;SMINPUTS&#34;).at(22).at(1)   )  // mu(2 GeV)^MS-bar, not pole mass
         cout&lt;&lt;endl;
         //ECHO(  spec.get(Par::Pole_Mass,&#34;u&#34;,2)      )  // i.e. charm
         cout&lt;&lt;&#34;  ***c Pole mass not well defined***&#34;&lt;&lt;endl;
         ECHO(  slhaea.at(&#34;SMINPUTS&#34;).at(24).at(1)   )  // mc(mc)^MS-bar, not pole mass
         cout&lt;&lt;endl;
         //ECHO(  spec.get(Par::Pole_Mass,&#34;u&#34;,3)      )  // i.e. top
         ECHO(  fullspectrum.get(Par::Pole_Mass,&#34;t&#34;)       )
         ECHO(  SM.get(Par::Pole_Mass,&#34;u&#34;,3)      )  // i.e. top
         ECHO(  slhaea.at(&#34;SMINPUTS&#34;).at(6).at(1)    )
         cout&lt;&lt;endl;
         //ECHO(  spec.get(Par::Pole_Mass,&#34;d&#34;,1)      )  // i.e. down
         cout&lt;&lt;&#34;  ***d Pole mass not well defined***&#34;&lt;&lt;endl;
         ECHO(  slhaea.at(&#34;SMINPUTS&#34;).at(21).at(1)   )  // md(2 GeV)^MS-bar, not pole mass
         cout&lt;&lt;endl;
         //ECHO(  spec.get(Par::Pole_Mass,&#34;d&#34;,2)      )  // i.e. strange
         cout&lt;&lt;&#34;  ***s Pole mass not well defined***&#34;&lt;&lt;endl;
         ECHO(  slhaea.at(&#34;SMINPUTS&#34;).at(23).at(1)   )  // ms(2 GeV)^MS-bar, not pole mass
         cout&lt;&lt;endl;
         //ECHO(  spec.get(Par::Pole_Mass,&#34;d&#34;,3)      )  // i.e. bottom
         ECHO(  fullspectrum.get(Par::Pole_Mass,&#34;b&#34;)       )
         ECHO(  SM.get(Par::Pole_Mass,&#34;d&#34;,3)      )  // i.e. bottom
         ECHO(  slhaea.at(&#34;SMINPUTS&#34;).at(5).at(1)    )  //  mb(mb)^MS-bar, not pole mass.
         cout&lt;&lt;endl;
         cout&lt;&lt;&#34;Charged fermions pole masses:&#34;&lt;&lt;endl;
         cout&lt;&lt;endl;
         //ECHO(  spec.get(Par::Pole_Mass,&#34;e-&#34;,1)     )  // i.e. electron
         ECHO(  fullspectrum.get(Par::Pole_Mass,&#34;e-&#34;)       )
         ECHO(  SM.get(Par::Pole_Mass,&#34;e-&#34;,1)     )  // i.e. electron
         ECHO(  slhaea.at(&#34;SMINPUTS&#34;).at(11).at(1)   )
         cout&lt;&lt;endl;
         //ECHO(  spec.get(Par::Pole_Mass,&#34;e-&#34;,2)     )  // i.e. muon
         ECHO(  fullspectrum.get(Par::Pole_Mass,&#34;mu-&#34;)       )
         ECHO(  SM.get(Par::Pole_Mass,&#34;e-&#34;,2)     )  // i.e. muon
         ECHO(  slhaea.at(&#34;SMINPUTS&#34;).at(13).at(1)   )
         cout&lt;&lt;endl;
         //ECHO(  spec.get(Par::Pole_Mass,&#34;e-&#34;,3)     )  // i.e. tau
         ECHO(  fullspectrum.get(Par::Pole_Mass,&#34;tau-&#34;)       )
         ECHO(  SM.get(Par::Pole_Mass,&#34;e-&#34;,3)     )  // i.e. tau
         ECHO(  slhaea.at(&#34;SMINPUTS&#34;).at(7).at(1)    )
         cout&lt;&lt;endl;
         cout&lt;&lt;&#34;Neutrinos pole masses:&#34;&lt;&lt;endl;
         cout&lt;&lt;endl;
         // These will produce errors because currently no neutrino mass getters are hooked up
         //ECHO(  spec.get(Par::Pole_Mass,&#34;nu&#34;,1)     )  // Just mass ordered (if there is mixing)
         ECHO(  fullspectrum.get(Par::Pole_Mass,&#34;nu&#34;,1)       )
         ECHO(  SM.get(Par::Pole_Mass,&#34;nu&#34;,1)     )  // Just mass ordered (if there is mixing)
         ECHO(  slhaea.at(&#34;SMINPUTS&#34;).at(12).at(1)   )
         cout&lt;&lt;endl;
         //ECHO(  spec.get(Par::Pole_Mass,&#34;nu&#34;,2)     )
         ECHO(  fullspectrum.get(Par::Pole_Mass,&#34;nu&#34;,2)       )
         ECHO(  SM.get(Par::Pole_Mass,&#34;nu&#34;,2)     )
         ECHO(  slhaea.at(&#34;SMINPUTS&#34;).at(14).at(1)   )
         cout&lt;&lt;endl;
         //ECHO(  spec.get(Par::Pole_Mass,&#34;nu&#34;,3)     )
         ECHO(  fullspectrum.get(Par::Pole_Mass,&#34;nu&#34;,3)       )
         ECHO(  SM.get(Par::Pole_Mass,&#34;nu&#34;,3)     )
         ECHO(  slhaea.at(&#34;SMINPUTS&#34;).at(8).at(1)    )
         cout&lt;&lt;endl;
         // Now for SUSY particles
         cout&lt;&lt;endl;
         cout&lt;&lt;&#34;MSSM Higgs sector pole masses:&#34;&lt;&lt;endl;
         cout&lt;&lt;endl;
         ECHO(  fullspectrum.get(Par::Pole_Mass,&#34;h0&#34;,1)       )
         ECHO(  spec.get(Par::Pole_Mass,&#34;h0&#34;,1)     )  // Lightest neutral Higgs boson
         ECHO(  slhaea.at(&#34;MASS&#34;).at(25).at(1)       )
         cout&lt;&lt;endl;
         ECHO(  fullspectrum.get(Par::Pole_Mass,&#34;h0&#34;,2)       )
         ECHO(  spec.get(Par::Pole_Mass,&#34;h0&#34;,2)     )  // Heavy neutral Higgs boson
         ECHO(  slhaea.at(&#34;MASS&#34;).at(35).at(1)       )
         cout&lt;&lt;endl;
         ECHO(  fullspectrum.get(Par::Pole_Mass,&#34;H+&#34;)       )
         ECHO(  spec.get(Par::Pole_Mass,&#34;H+&#34;)       )  // Charged Higgs
         ECHO(  slhaea.at(&#34;MASS&#34;).at(37).at(1)       )
         cout&lt;&lt;endl;
         ECHO(  fullspectrum.get(Par::Pole_Mass,&#34;A0&#34;)       )
         ECHO(  spec.get(Par::Pole_Mass,&#34;A0&#34;)       )  // Pseudoscalar neutral Higgs
         ECHO(  slhaea.at(&#34;MASS&#34;).at(36).at(1)       )
         cout&lt;&lt;endl;

         // I&#39;m going to use these nested functors to save lots of typing for the rest. It is just the
         // same as the examples above, except that the PDG codes are retrieved from the particle database.
         // The PDG code - string name correspondences are defined in &#39;Models/src/particle_database.cpp&#39;

         struct get_polemass_functor
         {
           // Single mass
           void operator()(const std::string&amp; longname)
           {
             std::ostringstream echo1, echo2, echo3;
             echo1 &lt;&lt;     &#34;  fullspectrum.get(Par::Pole_Mass,&#34;&lt;&lt;longname&lt;&lt;&#34;) = &#34;;
             double value1 = fullspectrum.get(Par::Pole_Mass,longname);
             cout &lt;&lt; echo1.str() &lt;&lt; value1 &lt;&lt; endl;
             echo2 &lt;&lt;     &#34;  spec.get(Par::Pole_Mass,&#34;&lt;&lt;longname&lt;&lt;&#34;) = &#34;;
             double value2 = spec.get(Par::Pole_Mass,longname);
             cout &lt;&lt; echo2.str() &lt;&lt; value2 &lt;&lt; endl;
             echo3 &lt;&lt;  &#34;  slhaea.at(\&#34;MASS\&#34;).at(&#34;&lt;&lt;PDB.pdg_pair(longname).first&lt;&lt;&#34;).at(1) = &#34;;
             str value3 = slhaea.at(&#34;MASS&#34;).at( PDB.pdg_pair(longname).first ).at(1);
             cout &lt;&lt; echo3.str() &lt;&lt; value3 &lt;&lt; endl;
             cout&lt;&lt;endl;
           }
           // Range of indexes masses
           void operator()(const std::string&amp; longname, int from, int to)
           {
             for(int i=from; i&lt;=to; ++i)
             {
               std::ostringstream echo1;
               std::ostringstream echo2;
               echo1 &lt;&lt;     &#34;  spec.get(Par::Pole_Mass,&#34;&lt;&lt;longname&lt;&lt;&#34;,&#34;&lt;&lt;i&lt;&lt;&#34;) = &#34;;
               double value1 = spec.get(Par::Pole_Mass,longname,i);
               echo2 &lt;&lt;  &#34;  slhaea.at(\&#34;MASS\&#34;).at(&#34;&lt;&lt;PDB.pdg_pair(longname,i).first&lt;&lt;&#34;).at(1) = &#34;;
               str value2 = slhaea.at(&#34;MASS&#34;).at( PDB.pdg_pair(longname,i).first ).at(1);
               cout &lt;&lt; echo1.str() &lt;&lt; value1 &lt;&lt; endl;
               cout &lt;&lt; echo2.str() &lt;&lt; value2 &lt;&lt; endl;
               cout&lt;&lt;endl;
             }
           }

           get_polemass_functor(const Spectrum&amp; fullin, const SubSpectrum&amp; specin, SLHAea::Coll&amp; slhaeain)
             : fullspectrum(fullin)
             , spec(specin)
             , slhaea(slhaeain)
           {}

           private:
             const Spectrum&amp; fullspectrum;
             const SubSpectrum&amp; spec;
             SLHAea::Coll slhaea;
             const Models::partmap&amp; PDB = Models::ParticleDB();
         };

         get_polemass_functor get_polemass(fullspectrum,spec,slhaea);

         cout&lt;&lt;endl&lt;&lt;&#34;Gaugino pole masses:&#34;&lt;&lt;endl&lt;&lt;endl;
         get_polemass(&#34;~g&#34;);
         get_polemass(&#34;~chi+&#34;,1,2);
         get_polemass(&#34;~chi0&#34;,1,4);
         cout&lt;&lt;endl&lt;&lt;&#34;Squark pole masses:&#34;&lt;&lt;endl&lt;&lt;endl;
         get_polemass(&#34;~d&#34;,1,6);
         get_polemass(&#34;~u&#34;,1,6);
         cout&lt;&lt;endl&lt;&lt;&#34;Slepton pole masses:&#34;&lt;&lt;endl&lt;&lt;endl;
         get_polemass(&#34;~e-&#34;,1,6);
         get_polemass(&#34;~nu&#34;,1,3);

         cout &lt;&lt; endl &lt;&lt; &#34;Mixing matrices:&#34; &lt;&lt; endl &lt;&lt; endl;

         // Note, currently we are not using a matrix object or any such thing, so you have to
         // extract the elements of each matrix one at a time. It would probably be handy to
         // add such a return type though.

         #define GET_MIX_MATRIX_EL(r, PRODUCT)                                   \
         {                                                                       \
            str label = BOOST_PP_SEQ_ELEM(0, PRODUCT);                           \
            str block = BOOST_PP_SEQ_ELEM(1, PRODUCT);                           \
            int i = BOOST_PP_SEQ_ELEM(2, PRODUCT);                               \
            int j = BOOST_PP_SEQ_ELEM(3, PRODUCT);                               \
           try{                                                                  \
            std::ostringstream echo1;                                            \
            std::ostringstream echo2;                                            \
            echo1 &lt;&lt;     &#34;  spec.get(Par::Pole_Mixing,&#34;&lt;&lt;label&lt;&lt;&#34;,&#34;&lt;&lt;i&lt;&lt;&#34;,&#34;&lt;&lt;j&lt;&lt;&#34;) = &#34;; \
            double value1 = spec.get(Par::Pole_Mixing,label,i,j); \
            echo2 &lt;&lt;     &#34;  SLHAea::to&lt;double&gt;( slhaea.at(&#34;&lt;&lt;block&lt;&lt;&#34;).at(&#34;&lt;&lt;i&lt;&lt;&#34;,&#34;&lt;&lt;j&lt;&lt;&#34;).at(2) ) = &#34;; \
            double value2 = SLHAea::to&lt;double&gt;( slhaea.at(block).at(i,j).at(2) ); \
            cout &lt;&lt; echo1.str() &lt;&lt; value1 &lt;&lt;endl;                                \
            cout &lt;&lt; echo2.str() &lt;&lt; value2 &lt;&lt;endl;                                \
            cout &lt;&lt; endl;                                                        \
           }                                                                     \
           catch (const std::exception&amp; e)                                       \
           { add_error(report,e,label+&#34;: &#34;+block); }                             \
         }

         #define GET_MIX_MATRIX(NAME,BLOCK,__IND1,__IND2) BOOST_PP_SEQ_FOR_EACH_PRODUCT(GET_MIX_MATRIX_EL, ((NAME))((BLOCK))(BOOST_PP_TUPLE_TO_SEQ(__IND1))(BOOST_PP_TUPLE_TO_SEQ(__IND2)))

         // The names here could perhaps be improved. They are not so immediately obvious to me.

         // GET_MIX_MATRIX(&#34;~chi-&#34;,&#34;UMIX&#34;,(1,2),(1,2)) cout&lt;&lt;endl;
         // GET_MIX_MATRIX(&#34;~chi+&#34;,&#34;VMIX&#34;,(1,2),(1,2)) cout&lt;&lt;endl;
         // GET_MIX_MATRIX(&#34;A0&#34;,&#34;PSEUDOSCALARMIX&#34;,(1,2),(1,2)) cout&lt;&lt;endl;
         // GET_MIX_MATRIX(&#34;~d&#34;,&#34;DSQMIX&#34;,(1,2,3,4,5,6),(1,2,3,4,5,6)) cout&lt;&lt;endl;
         // GET_MIX_MATRIX(&#34;~e-&#34;,&#34;SELMIX&#34;,(1,2,3,4,5,6),(1,2,3,4,5,6)) cout&lt;&lt;endl;
         // GET_MIX_MATRIX(&#34;h0&#34;,&#34;SCALARMIX&#34;,(1,2),(1,2)) cout&lt;&lt;endl;
         // GET_MIX_MATRIX(&#34;~chi0&#34;,&#34;NMIX&#34;,(1,2,3,4),(1,2,3,4)) cout&lt;&lt;endl;
         // GET_MIX_MATRIX(&#34;H+&#34;,&#34;CHARGEMIX&#34;,(1,2),(1,2)) cout&lt;&lt;endl;
         // GET_MIX_MATRIX(&#34;~u&#34;,&#34;USQMIX&#34;,(1,2,3,4,5,6),(1,2,3,4,5,6)) cout&lt;&lt;endl;
         // GET_MIX_MATRIX(&#34;~nu&#34;,&#34;SNUMIX&#34;,(1,2,3),(1,2,3)) cout&lt;&lt;endl;

         cout&lt;&lt;endl;
         cout &lt;&lt; &#34;Next up: running parameters&#34; &lt;&lt; endl;
         cout &lt;&lt; &#34;These are all given in the DRbar scheme, at least when running FlexibleSUSY or SoftSUSY. &#34;;
         cout &lt;&lt; &#34;There may be some switching or converting once other spectrum generator are added.&#34; &lt;&lt; endl;
         cout&lt;&lt;endl;
         cout &lt;&lt; &#34;Spectrum object running parameters are currently defined at scale Q=&#34;
              &lt;&lt; spec.GetScale() &lt;&lt; &#34; [GeV]&#34; &lt;&lt; endl &lt;&lt; endl;
         cout&lt;&lt;endl;
         cout &lt;&lt; &#34;-- Dimensionless parameters --&#34; &lt;&lt;endl;
         cout &lt;&lt; endl &lt;&lt; &#34;Gauge couplings:&#34; &lt;&lt; endl &lt;&lt; endl;
         ECHO(  spec.get(Par::dimensionless,&#34;g1&#34;)  )  // U_Y(1) gauge coupling in SU(5) normalisation
         ECHO(  slhaea.at(&#34;GAUGE&#34;).at(1).at(1)  ) // This is in the Standard Model normalisation as per SLHA conventions
         cout &lt;&lt; &#34;Note: &#34; &lt;&lt; spec.get(Par::dimensionless,&#34;g1&#34;) &lt;&lt; &#34; * sqrt(3/5) = &#34;
                          &lt;&lt; spec.get(Par::dimensionless,&#34;g1&#34;)*sqrt(3./5.) &lt;&lt; endl;
         cout&lt;&lt;endl;
         ECHO(  spec.get(Par::dimensionless,&#34;g2&#34;)  )  // SU(2) gauge coupling
         ECHO(  slhaea.at(&#34;GAUGE&#34;).at(2).at(1)  )
         cout&lt;&lt;endl;
         ECHO(  spec.get(Par::dimensionless,&#34;g3&#34;)  )  // SU(3) gauge coupling
         ECHO(  slhaea.at(&#34;GAUGE&#34;).at(3).at(1)  )
         cout&lt;&lt;endl;

         cout &lt;&lt; endl &lt;&lt; &#34;Yukawa matrices:&#34; &lt;&lt; endl &lt;&lt; endl;

         // Note, currently we are not using a matrix object or any such thing, so you have to
         // extract the elements of the matrix one at a time. It would probably be handy to
         // add such a return type though.

         #define GET_MATRIX_EL(r, PRODUCT)                                       \
         {                                                                       \
            str label = BOOST_PP_SEQ_ELEM(0, PRODUCT);                           \
            str block = BOOST_PP_SEQ_ELEM(1, PRODUCT);                           \
            int i = BOOST_PP_SEQ_ELEM(2, PRODUCT);                               \
            int j = BOOST_PP_SEQ_ELEM(3, PRODUCT);                               \
           try{                                                                  \
            std::ostringstream echo1;                                            \
            std::ostringstream echo2;                                            \
            echo1 &lt;&lt;     &#34;  spec.get(Par::dimensionless,&#34;&lt;&lt;label&lt;&lt;&#34;,&#34;&lt;&lt;i&lt;&lt;&#34;,&#34;&lt;&lt;j&lt;&lt;&#34;) = &#34;; \
            double value1 = spec.get(Par::dimensionless,label,i,j); \
            echo2 &lt;&lt;     &#34;  SLHAea::to&lt;double&gt;( slhaea.at(&#34;&lt;&lt;block&lt;&lt;&#34;).at(&#34;&lt;&lt;i&lt;&lt;&#34;,&#34;&lt;&lt;j&lt;&lt;&#34;).at(2) ) = &#34;; \
            double value2 = SLHAea::to&lt;double&gt;( slhaea.at(block).at(i,j).at(2) ); \
            cout &lt;&lt; echo1.str() &lt;&lt; value1 &lt;&lt;endl;                                \
            cout &lt;&lt; echo2.str() &lt;&lt; value2 &lt;&lt;endl;                                \
            cout &lt;&lt; endl;                                                        \
           } catch (const std::exception&amp; e)                                       \
           { add_error(report,e,label+&#34;: &#34;+block); }                             \
         }

         #define GET_MATRIX(NAME,BLOCK,__IND1,__IND2) BOOST_PP_SEQ_FOR_EACH_PRODUCT(GET_MATRIX_EL, ((NAME))((BLOCK))(BOOST_PP_TUPLE_TO_SEQ(__IND1))(BOOST_PP_TUPLE_TO_SEQ(__IND2)))

         // GET_MATRIX(&#34;Yu&#34;,&#34;YU&#34;,(1,2,3),(1,2,3)) cout &lt;&lt; endl;
         // GET_MATRIX(&#34;Yd&#34;,&#34;YD&#34;,(1,2,3),(1,2,3)) cout &lt;&lt; endl;
         // GET_MATRIX(&#34;Ye&#34;,&#34;YE&#34;,(1,2,3),(1,2,3)) cout &lt;&lt; endl;

         // Mass dimension 1 parameters

         cout&lt;&lt;endl;
         cout&lt;&lt;&#34;MSSM mass dimension 1 running parameters&#34;&lt;&lt;endl;
         cout&lt;&lt;endl;
         ECHO(  spec.get(Par::mass1,&#34;M1&#34;)    )  // Gaugino mass parameter &#34;MassB&#34;
         ECHO(  slhaea.at(&#34;MSOFT&#34;).at(1).at(1)                )
         cout&lt;&lt;endl;
         ECHO(  spec.get(Par::mass1,&#34;M2&#34;)    )  // Gaugino mass parameter &#34;MassWB&#34;
         ECHO(  slhaea.at(&#34;MSOFT&#34;).at(2).at(1)                )
         cout&lt;&lt;endl;
         ECHO(  spec.get(Par::mass1,&#34;M3&#34;)    )  // Gaugino mass parameter &#34;MassG&#34;
         ECHO(  slhaea.at(&#34;MSOFT&#34;).at(3).at(1)                )
         cout&lt;&lt;endl;
         ECHO(  spec.get(Par::mass1,&#34;Mu&#34;)    )  // Superpotential mu parameter
         ECHO(  slhaea.at(&#34;HMIX&#34;).at(1).at(1)                 )
         cout&lt;&lt;endl;
         ECHO(  spec.get(Par::mass1,&#34;vd&#34;)    )  // Down-type Higgs vev
         ECHO(  slhaea.at(&#34;HMIX&#34;).at(102).at(1)               )
         cout&lt;&lt;endl;
         ECHO(  spec.get(Par::mass1,&#34;vu&#34;)    )  // Up-type Higgs vev
         ECHO(  slhaea.at(&#34;HMIX&#34;).at(103).at(1)               )
         cout&lt;&lt;endl;

         // Matrices

         #define GET_M1_MATRIX_EL(r, PRODUCT)                                    \
         {                                                                       \
            str label = BOOST_PP_SEQ_ELEM(0, PRODUCT);                           \
            str block = BOOST_PP_SEQ_ELEM(1, PRODUCT);                           \
            int i = BOOST_PP_SEQ_ELEM(2, PRODUCT);                               \
            int j = BOOST_PP_SEQ_ELEM(3, PRODUCT);                               \
           try{                                                                  \
            std::ostringstream echo1;                                            \
            std::ostringstream echo2;                                            \
            echo1 &lt;&lt;     &#34;  spec.get(Par::mass1,&#34;&lt;&lt;label&lt;&lt;&#34;,&#34;&lt;&lt;i&lt;&lt;&#34;,&#34;&lt;&lt;j&lt;&lt;&#34;) = &#34;; \
            double value1 = spec.get(Par::mass1,label,i,j); \
            echo2 &lt;&lt;     &#34;  SLHAea::to&lt;double&gt;( slhaea.at(&#34;&lt;&lt;block&lt;&lt;&#34;).at(&#34;&lt;&lt;i&lt;&lt;&#34;,&#34;&lt;&lt;j&lt;&lt;&#34;).at(2) ) = &#34;; \
            double value2 = SLHAea::to&lt;double&gt;( slhaea.at(block).at(i,j).at(2) ); \
            cout &lt;&lt; echo1.str() &lt;&lt; value1 &lt;&lt;endl;                                \
            cout &lt;&lt; echo2.str() &lt;&lt; value2 &lt;&lt;endl;                                \
            cout &lt;&lt; endl;                                                        \
           } catch (const std::exception&amp; e)                                       \
           { add_error(report,e,label+&#34;: &#34;+block); }                             \
         }

         #define GET_M1_MATRIX(NAME,BLOCK,__IND1,__IND2) BOOST_PP_SEQ_FOR_EACH_PRODUCT(GET_M1_MATRIX_EL, ((NAME))((BLOCK))(BOOST_PP_TUPLE_TO_SEQ(__IND1))(BOOST_PP_TUPLE_TO_SEQ(__IND2)))

         cout &lt;&lt; endl &lt;&lt; &#34;Triliner coupling matrices? SLHA says these blocks should be called AU,AD,AE, not TU,TD,TE though, so I&#39;m not sure. Need to check with Peter.&#34; &lt;&lt; endl &lt;&lt; endl;

         // Seem to be the trilinears, and TYu and au etc. seem to be equal. Ask Peter...

         // GET_M1_MATRIX(&#34;TYu&#34;,&#34;TU&#34;,(1,2,3),(1,2,3)) cout &lt;&lt; endl;
         // GET_M1_MATRIX(&#34;TYd&#34;,&#34;TD&#34;,(1,2,3),(1,2,3)) cout &lt;&lt; endl;
         // GET_M1_MATRIX(&#34;TYe&#34;,&#34;TE&#34;,(1,2,3),(1,2,3)) cout &lt;&lt; endl;
         // cout &lt;&lt; endl;
         // GET_M1_MATRIX(&#34;au&#34;,&#34;TU&#34;,(1,2,3),(1,2,3)) cout &lt;&lt; endl;
         // GET_M1_MATRIX(&#34;ad&#34;,&#34;TD&#34;,(1,2,3),(1,2,3)) cout &lt;&lt; endl;
         // GET_M1_MATRIX(&#34;ae&#34;,&#34;TE&#34;,(1,2,3),(1,2,3)) cout &lt;&lt; endl;

         // Mass dimension 2 parameters

         cout&lt;&lt;endl;
         cout&lt;&lt;&#34;MSSM mass dimension 2 running parameters&#34;&lt;&lt;endl;
         cout&lt;&lt;endl;
         ECHO(  spec.get(Par::mass2,&#34;mHd2&#34;)  )  // Down-type Higgs soft mass
         ECHO(  slhaea.at(&#34;MSOFT&#34;).at(21).at(1)               )
         cout&lt;&lt;endl;
         ECHO(  spec.get(Par::mass2,&#34;mHu2&#34;)  )  // Up-type Higgs soft mass
         ECHO(  slhaea.at(&#34;MSOFT&#34;).at(22).at(1)               )
         cout&lt;&lt;endl;
         ECHO(  spec.get(Par::mass2,&#34;BMu&#34;)   )  // Higgs bilinear soft parameter
         ECHO(  slhaea.at(&#34;HMIX&#34;).at(101).at(1)               )
         cout&lt;&lt;endl;

         // Matrices

         #define GET_M2_MATRIX_EL(r, PRODUCT)                                    \
         {                                                                       \
            str label = BOOST_PP_SEQ_ELEM(0, PRODUCT);                           \
            str block = BOOST_PP_SEQ_ELEM(1, PRODUCT);                           \
            int i = BOOST_PP_SEQ_ELEM(2, PRODUCT);                               \
            int j = BOOST_PP_SEQ_ELEM(3, PRODUCT);                               \
            std::ostringstream echo1;                                            \
           try {                                                                 \
            std::ostringstream echo2;                                            \
            echo1 &lt;&lt;     &#34;  spec.get(Par::mass2,&#34;&lt;&lt;label&lt;&lt;&#34;,&#34;&lt;&lt;i&lt;&lt;&#34;,&#34;&lt;&lt;j&lt;&lt;&#34;) = &#34;; \
            double value1 = spec.get(Par::mass2,label,i,j); \
            echo2 &lt;&lt;     &#34;  SLHAea::to&lt;double&gt;( slhaea.at(&#34;&lt;&lt;block&lt;&lt;&#34;).at(&#34;&lt;&lt;i&lt;&lt;&#34;,&#34;&lt;&lt;j&lt;&lt;&#34;).at(2) ) = &#34;; \
            double value2 = SLHAea::to&lt;double&gt;( slhaea.at(block).at(i,j).at(2) ); \
            cout &lt;&lt; echo1.str() &lt;&lt; value1 &lt;&lt;endl;                                \
            cout &lt;&lt; echo2.str() &lt;&lt; value2 &lt;&lt;endl;                                \
            cout &lt;&lt; endl;                                                        \
           } catch (const std::exception&amp; e)                                       \
           { add_error(report,e,label+&#34;: &#34;+block); }                             \
        }

         #define GET_M2_MATRIX(NAME,BLOCK,__IND1,__IND2) BOOST_PP_SEQ_FOR_EACH_PRODUCT(GET_M2_MATRIX_EL, ((NAME))((BLOCK))(BOOST_PP_TUPLE_TO_SEQ(__IND1))(BOOST_PP_TUPLE_TO_SEQ(__IND2)))

         cout &lt;&lt; endl &lt;&lt; &#34;Mass matrices:&#34; &lt;&lt; endl &lt;&lt; endl;

         // GET_M2_MATRIX(&#34;mq2&#34;,&#34;MSQ2&#34;,(1,2,3),(1,2,3)) cout &lt;&lt; endl;
         // GET_M2_MATRIX(&#34;mu2&#34;,&#34;MSU2&#34;,(1,2,3),(1,2,3)) cout &lt;&lt; endl;
         // GET_M2_MATRIX(&#34;md2&#34;,&#34;MSD2&#34;,(1,2,3),(1,2,3)) cout &lt;&lt; endl;
         // GET_M2_MATRIX(&#34;me2&#34;,&#34;MSE2&#34;,(1,2,3),(1,2,3)) cout &lt;&lt; endl;
         // GET_M2_MATRIX(&#34;ml2&#34;,&#34;MSL2&#34;,(1,2,3),(1,2,3)) cout &lt;&lt; endl;

         cout &lt;&lt; endl;

         /// NEW! Tests of override setters
         /// These cannot be run on a const spectrum object, so we need to clone it first
         std::unique_ptr&lt;SubSpectrum&gt; clonedspec = spec.clone();

         cout &lt;&lt; &#34;Testing set_override functions&#34; &lt;&lt; endl;

         cout &lt;&lt; &#34;Original M1:&#34; &lt;&lt; clonedspec-&gt;get(Par::mass1,&#34;M1&#34;) &lt;&lt; endl;
         clonedspec-&gt;set_override(Par::mass1,-666,&#34;M1&#34;);
         cout &lt;&lt; &#34;Override M1:&#34; &lt;&lt; clonedspec-&gt;get(Par::mass1,&#34;M1&#34;) &lt;&lt; endl;
          // Check that original can still be accessed using special optional argument
         cout &lt;&lt; &#34;Original M1 via no_overrides:&#34; &lt;&lt; clonedspec-&gt;get(Par::mass1,&#34;M1&#34;,ignore_overrides) &lt;&lt; endl;

         cout &lt;&lt; &#34;Original ~e-(1):&#34; &lt;&lt; clonedspec-&gt;get(Par::Pole_Mass,&#34;~e-&#34;,1) &lt;&lt; endl;
         clonedspec-&gt;set_override(Par::Pole_Mass,-667,&#34;~e-&#34;,1);
         cout &lt;&lt; &#34;Override ~e-(1):&#34; &lt;&lt; clonedspec-&gt;get(Par::Pole_Mass,&#34;~e-&#34;,1) &lt;&lt; endl;
         cout &lt;&lt; &#34;Original ~e-(1) via no_overrides:&#34; &lt;&lt; clonedspec-&gt;get(Par::Pole_Mass,&#34;~e-&#34;,1,ignore_overrides) &lt;&lt; endl;

         // Make sure that we can set overrides via long name strings properly
         cout &lt;&lt; &#34;Original ~e-(2):&#34; &lt;&lt; clonedspec-&gt;get(Par::Pole_Mass,&#34;~e-&#34;,2) &lt;&lt; endl;
         clonedspec-&gt;set_override(Par::Pole_Mass,-345,&#34;~e-_2&#34;);
         cout &lt;&lt; &#34;Override ~e-(2):&#34; &lt;&lt; clonedspec-&gt;get(Par::Pole_Mass,&#34;~e-&#34;,2) &lt;&lt; endl;
         cout &lt;&lt; &#34;Original ~e-(2) via no_overrides:&#34; &lt;&lt; clonedspec-&gt;get(Par::Pole_Mass,&#34;~e-&#34;,2,ignore_overrides) &lt;&lt; endl;
         clonedspec-&gt;set_override(Par::Pole_Mass,-347,&#34;~e-&#34;,2);
         cout &lt;&lt; &#34;Override ~e-(2) (second time):&#34; &lt;&lt; clonedspec-&gt;get(Par::Pole_Mass,&#34;~e-&#34;,2) &lt;&lt; endl;
         cout &lt;&lt; &#34;Original ~e-(2) via no_overrides (second time):&#34; &lt;&lt; clonedspec-&gt;get(Par::Pole_Mass,&#34;~e-&#34;,2,ignore_overrides) &lt;&lt; endl;



         cout &lt;&lt; &#34;Original ml2(1,1):&#34; &lt;&lt; clonedspec-&gt;get(Par::mass2,&#34;ml2&#34;,1,1) &lt;&lt; endl;
         clonedspec-&gt;set_override(Par::mass2,-668,&#34;ml2&#34;,1,1);
         cout &lt;&lt; &#34;Override ml2(1,1):&#34; &lt;&lt; clonedspec-&gt;get(Par::mass2,&#34;ml2&#34;,1,1) &lt;&lt; endl;
         cout &lt;&lt; &#34;Original ml2(1,1) via no_overrides:&#34; &lt;&lt; clonedspec-&gt;get(Par::mass2,&#34;ml2&#34;,1,1,ignore_overrides) &lt;&lt; endl;


         /// Now add some entry that didn&#39;t exist before
         cout &lt;&lt; &#34;has &#39;new_entry&#39;? &#34; &lt;&lt; clonedspec-&gt;has(Par::mass1,&#34;new_entry&#34;) &lt;&lt; endl;
         cout &lt;&lt; &#34;...&#34; &lt;&lt; endl;
         /// Note: if we try to do it like this, it should fail:
         //clonedspec-&gt;set_override(Par::mass2,-1234,&#34;new_entry&#34;); // incorrect: &#34;allow_new&#34; false by default
         clonedspec-&gt;set_override(Par::mass1,-1234,&#34;new_entry&#34;,true); // correct: &#34;allow_new&#34; = true
         cout &lt;&lt; &#34;has &#39;new_entry&#39;? &#34; &lt;&lt; clonedspec-&gt;has(Par::mass1,&#34;new_entry&#34;) &lt;&lt; endl;
         cout &lt;&lt; &#34;new_entry = &#34; &lt;&lt; clonedspec-&gt;get(Par::mass1,&#34;new_entry&#34;) &lt;&lt; endl;
         cout &lt;&lt; endl;

         /// TODO: Tests of ordinary &#39;setter&#39; functions (these actually replace data in the wrapped object)


         /// Tests of spectrum/particle database antiparticle getters/setters interaction
         cout &lt;&lt; &#34;Test retrieval of antiparticle entries&#34; &lt;&lt; endl;

         cout &lt;&lt; &#34;has &#39;~e+&#39; pole mass? &#34; &lt;&lt; clonedspec-&gt;has(Par::Pole_Mass,&#34;~e+&#34;,1) &lt;&lt; endl;
         cout &lt;&lt; &#34;&#39;~e+&#39; pole mass = &#34; &lt;&lt; clonedspec-&gt;get(Par::Pole_Mass,&#34;~e+&#34;,1) &lt;&lt; endl;
         cout &lt;&lt; &#34;&#39;~e-&#39; pole mass = &#34; &lt;&lt; clonedspec-&gt;get(Par::Pole_Mass,&#34;~e-&#34;,1) &lt;&lt; endl;
         cout &lt;&lt; &#34;Setting new ~e+ pole mass value&#34; &lt;&lt; endl;
         clonedspec-&gt;set(Par::Pole_Mass,-666,&#34;~e+&#34;,1);
         cout &lt;&lt; &#34;&#39;~e+&#39; pole mass = &#34; &lt;&lt; clonedspec-&gt;get(Par::Pole_Mass,&#34;~e+&#34;,1) &lt;&lt; endl;
         cout &lt;&lt; &#34;&#39;~e-&#39; pole mass = &#34; &lt;&lt; clonedspec-&gt;get(Par::Pole_Mass,&#34;~e-&#34;,1) &lt;&lt; endl;
         cout &lt;&lt; &#34;Setting override ~e+ pole mass value&#34; &lt;&lt; endl;
         // Need to turn on the &#34;allow_new&#34; check for this, because no explicit entry for
         // ~e+_1 exists yet, and need to turn on the &#34;decouple&#34; option to prevent conversion
         // to the antiparticle string name. This action will decouple the ~e-_1 and ~e+_1 masses from
         // here onwards.
         clonedspec-&gt;set_override(Par::Pole_Mass,-999,&#34;~e+&#34;,1,true,true); // &#34;allow_new&#34; + &#34;decouple&#34; = true
         cout &lt;&lt; &#34;&#39;~e+&#39; pole mass = &#34; &lt;&lt; clonedspec-&gt;get(Par::Pole_Mass,&#34;~e+&#34;,1) &lt;&lt; endl;
         cout &lt;&lt; &#34;&#39;~e-&#39; pole mass = &#34; &lt;&lt; clonedspec-&gt;get(Par::Pole_Mass,&#34;~e-&#34;,1) &lt;&lt; endl;
         cout &lt;&lt; &#34;Set ~e+ pole mass via PDG code&#34; &lt;&lt; endl;
         // Can leave safety check on this time, because now an explicit entry for
         // ~e+_1 DOES exist (i.e. the previous override entry)
         clonedspec-&gt;set_override(Par::Pole_Mass,-111,std::make_pair(-1000011,0));
         cout &lt;&lt; &#34;&#39;(-1000011,0)&#39; pole mass = &#34; &lt;&lt; clonedspec-&gt;get(Par::Pole_Mass,std::make_pair(-1000011,0)) &lt;&lt; endl;
         cout &lt;&lt; &#34;&#39;~e+&#39; pole mass = &#34; &lt;&lt; clonedspec-&gt;get(Par::Pole_Mass,&#34;~e+&#34;,1) &lt;&lt; endl;
         cout &lt;&lt; &#34;&#39;~e-&#39; pole mass = &#34; &lt;&lt; clonedspec-&gt;get(Par::Pole_Mass,&#34;~e-&#34;,1) &lt;&lt; endl;
         cout &lt;&lt; &#34;Setting new ~e+ pole mass value (will be hidden by override!)&#34; &lt;&lt; endl;
         // This should also throw a warning explaining that the newly set value is not retrievable by
         // the getters, due to being hidden by an override value.
         clonedspec-&gt;set(Par::Pole_Mass,-96969,&#34;~e+&#34;,1);
         cout &lt;&lt; &#34;&#39;~e+&#39; pole mass = &#34; &lt;&lt; clonedspec-&gt;get(Par::Pole_Mass,&#34;~e+&#34;,1) &lt;&lt; endl;
         cout &lt;&lt; &#34;&#39;~e-&#39; pole mass = &#34; &lt;&lt; clonedspec-&gt;get(Par::Pole_Mass,&#34;~e-&#34;,1) &lt;&lt; endl;
         cout &lt;&lt; endl;

         cout &lt;&lt; &#34;has &#39;~e+,2&#39; pole mass? &#34; &lt;&lt; clonedspec-&gt;has(Par::Pole_Mass,&#34;~e+&#34;,2) &lt;&lt; endl;
         cout &lt;&lt; &#34;&#39;~e+,2&#39; pole mass = &#34; &lt;&lt; clonedspec-&gt;get(Par::Pole_Mass,&#34;~e+&#34;,2) &lt;&lt; endl;
         cout &lt;&lt; &#34;&#39;~e-,2&#39; pole mass = &#34; &lt;&lt; clonedspec-&gt;get(Par::Pole_Mass,&#34;~e-&#34;,2) &lt;&lt; endl;
         cout &lt;&lt; &#34;Setting new ~e+,2 pole mass value&#34; &lt;&lt; endl;
         clonedspec-&gt;set(Par::Pole_Mass,-666,&#34;~e+&#34;,2);
         cout &lt;&lt; &#34;&#39;~e+,2&#39; pole mass = &#34; &lt;&lt; clonedspec-&gt;get(Par::Pole_Mass,&#34;~e+&#34;,2) &lt;&lt; endl;
         cout &lt;&lt; &#34;&#39;~e-,2&#39; pole mass = &#34; &lt;&lt; clonedspec-&gt;get(Par::Pole_Mass,&#34;~e-&#34;,2) &lt;&lt; endl;
         cout &lt;&lt; &#34;Setting override ~e+,2 pole mass value&#34; &lt;&lt; endl;
         clonedspec-&gt;set_override(Par::Pole_Mass,-999,&#34;~e+&#34;,2,true);
         cout &lt;&lt; &#34;&#39;~e+,2&#39; pole mass = &#34; &lt;&lt; clonedspec-&gt;get(Par::Pole_Mass,&#34;~e+&#34;,2) &lt;&lt; endl;
         cout &lt;&lt; &#34;&#39;~e-,2&#39; pole mass = &#34; &lt;&lt; clonedspec-&gt;get(Par::Pole_Mass,&#34;~e-&#34;,2) &lt;&lt; endl;
         cout &lt;&lt; &#34;Set ~e+,2 pole mass via PDG code&#34; &lt;&lt; endl;
         clonedspec-&gt;set_override(Par::Pole_Mass,-111,std::make_pair(-1000013,0));
         cout &lt;&lt; &#34;&#39;(-1000013,0)&#39; pole mass = &#34; &lt;&lt; clonedspec-&gt;get(Par::Pole_Mass,std::make_pair(-1000013,0)) &lt;&lt; endl;
         cout &lt;&lt; &#34;&#39;~e+,2&#39; pole mass = &#34; &lt;&lt; clonedspec-&gt;get(Par::Pole_Mass,&#34;~e+&#34;,2) &lt;&lt; endl;
         cout &lt;&lt; &#34;&#39;~e-,2&#39; pole mass = &#34; &lt;&lt; clonedspec-&gt;get(Par::Pole_Mass,&#34;~e-&#34;,2) &lt;&lt; endl;


         cout &lt;&lt; &#34;Test report:&#34; &lt;&lt; std::endl &lt;&lt; report.str();

         /// Turn SpecBit warnings to &#39;fatal&#39; in order to trigger stop after this function runs.
         SpecBit_warning().raise(LOCAL_INFO,&#34;\n *** Finished examining spectrum contents ***&#34;);
         result = 0;
      }
    }

    // Test that output of Standard Model wrapper (e.g. QedQcdWrapper) matches
    // SMINPUTS sufficiently accurately
    // Set flag SLHAonly=1 if SMskeleton and/or MSSMskeleton are being used.
    void light_quark_test(bool&amp;)
    {
       namespace myPipe = Pipes::light_quark_test;
       const SubSpectrum&amp; qedqcd = **myPipe::Dep::qedqcd_subspectrum;

       // Check light quark mass ratios
       logger() &lt;&lt; &#34;Checking light quark mass ratios:&#34; &lt;&lt; EOM;

       /// Generate data for a plot of quark mass
       double Qs[] = {
       1.00000000e-02,   1.25892541e-02,   1.58489319e-02,
       1.99526231e-02,   2.51188643e-02,   3.16227766e-02,
       3.98107171e-02,   5.01187234e-02,   6.30957344e-02,
       7.94328235e-02,   1.00000000e-01,   1.25892541e-01,
       1.58489319e-01,   1.99526231e-01,   2.51188643e-01,
       3.16227766e-01,   3.98107171e-01,   5.01187234e-01,
       6.30957344e-01,   7.94328235e-01,   1.00000000e+00,
       1.25892541e+00,   1.58489319e+00,   1.99526231e+00,
       2.51188643e+00,   3.16227766e+00,   3.98107171e+00,
       5.01187234e+00,   6.30957344e+00,   7.94328235e+00,
       1.00000000e+01,   1.25892541e+01,   1.58489319e+01,
       1.99526231e+01,   2.51188643e+01,   3.16227766e+01,
       3.98107171e+01,   5.01187234e+01,   6.30957344e+01,
       7.94328235e+01,   1.00000000e+02,   1.25892541e+02,
       1.58489319e+02,   1.99526231e+02,   2.51188643e+02,
       3.16227766e+02,   3.98107171e+02,   5.01187234e+02,
       6.30957344e+02,   7.94328235e+02,   1.00000000e+03,
       1.25892541e+03,   1.58489319e+03,   1.99526231e+03,
       2.51188643e+03,   3.16227766e+03,   3.98107171e+03,
       5.01187234e+03,   6.30957344e+03,   7.94328235e+03,
       1.00000000e+04,   1.25892541e+04,   1.58489319e+04,
       1.99526231e+04,   2.51188643e+04,   3.16227766e+04,
       3.98107171e+04,   5.01187234e+04,   6.30957344e+04,
       7.94328235e+04
       };

       std::vector&lt;double&gt; Qvec(Qs, Utils::endA(Qs));

       std::ofstream Qout;
       Qout.open(&#34;SpecBit/light_quark_txt&#34;);

       Qout &lt;&lt;std::setw(12)&lt;&lt;&#34;Qin&#34;
            &lt;&lt;std::setw(12)&lt;&lt;&#34;Qreal&#34;
            &lt;&lt;std::setw(12)&lt;&lt;&#34;alphaS&#34;
            &lt;&lt;std::setw(12)&lt;&lt;&#34;md&#34;
            &lt;&lt;std::setw(12)&lt;&lt;&#34;mu&#34;
            &lt;&lt;std::setw(12)&lt;&lt;&#34;ms&#34;
            &lt;&lt;std::setw(12)&lt;&lt;&#34;mu/md&#34;
            &lt;&lt;std::setw(12)&lt;&lt;&#34;ms/md&#34;
            &lt;&lt;std::endl;
       for(std::vector&lt;double&gt;::iterator it = Qvec.begin(); it != Qvec.end(); ++it)
       {
          // Clone to avoid buildup of errors
          std::unique_ptr&lt;SubSpectrum&gt; SMloop = qedqcd.clone();

          SMloop-&gt;RunToScale(*it);
          double Q = SMloop-&gt;GetScale();
          double mu = SMloop-&gt;get(Par::mass1,&#34;u&#34;);
          double md = SMloop-&gt;get(Par::mass1,&#34;d&#34;);
          double ms = SMloop-&gt;get(Par::mass1,&#34;s&#34;);
          double alphas = SMloop-&gt;get(Par::dimensionless,&#34;alphaS&#34;);
          // Write to file
          Qout &lt;&lt;std::setw(12)&lt;&lt;*it
               &lt;&lt;std::setw(12)&lt;&lt;Q
               &lt;&lt;std::setw(12)&lt;&lt;alphas
               &lt;&lt;std::setw(12)&lt;&lt;md
               &lt;&lt;std::setw(12)&lt;&lt;mu
               &lt;&lt;std::setw(12)&lt;&lt;ms
               &lt;&lt;std::setw(12)&lt;&lt;mu/md
               &lt;&lt;std::setw(12)&lt;&lt;ms/md
               &lt;&lt;std::endl;
       }

       Qout.close();

       std::cout &lt;&lt; &#34; light quark test finished, bailing out!&#34; &lt;&lt; std::endl;
       exit(0);
    }
  }

}

#undef PDB
</code></pre><hr/><p>Updated on 2022-08-10 at 17:51:35 +0000</p></main></div></div></div><footer class="footer text-muted"><div class="container-xxl"><div class="row"><div class="col-lg-8 order-last order-lg-first"><ul class="list-inline"><li class="list-inline-item">Powered by <a class="text-muted" href="https://gohugo.io/">Hugo</a> and <a class="text-muted" href="https://getdoks.org/">Doks</a></li></ul></div><div class="col-lg-8 order-first order-lg-last text-lg-end"><ul class="list-inline"><li class="list-inline-item"><a href="/license/">License</a></li></ul></div></div></div></footer><script src="/js/bootstrap.min.54bf0932b8a36d0e152b1635b099a6ef1394d35327e2437550a075c9c8ed1bd8aed5847c21b36fc02ed24014c031d9ca24017b0c78b1639d7e2fa8329898b842.js" integrity="sha512-VL8JMrijbQ4VKxY1sJmm7xOU01Mn4kN1UKB1ycjtG9iu1YR8IbNvwC7SQBTAMdnKJAF7DHixY51+L6gymJi4Qg==" crossorigin="anonymous" defer=""></script>
<script src="/js/highlight.min.5b48bc253dc75aeea5fb366ecf700f4925e2b6eb1a1466f2124b722d68148d67bc0a9365d2b8ad9c585161b46372d23b08509a16f1fd518542b894756d4752d0.js" integrity="sha512-W0i8JT3HWu6l+zZuz3APSSXitusaFGbyEktyLWgUjWe8CpNl0ritnFhRYbRjctI7CFCaFvH9UYVCuJR1bUdS0A==" crossorigin="anonymous" defer=""></script>
<script src="/main.min.40265e9a032aeba5eaf67baac3cbbc22667a7533215d326eeb3e9f4d5e4be40f9ff4dcd22949db73ae527ca26a19d7998091a8973c82af760b2c0daa335190ed.js" integrity="sha512-QCZemgMq66Xq9nuqw8u8ImZ6dTMhXTJu6z6fTV5L5A+f9NzSKUnbc65SfKJqGdeZgJGolzyCr3YLLA2qM1GQ7Q==" crossorigin="anonymous" defer=""></script>
<script src="https://gambitbsm.github.io/index.min.1e0f859443ac81a8b8c357ddfae5d899d83ab224e24e44c1c9620a99f2a527d70a1676148a868f87f22fb67994386d592e508dafb575df7c2b80d97f143ad1ea.js" integrity="sha512-Hg+FlEOsgai4w1fd+uXYmdg6siTiTkTByWIKmfKlJ9cKFnYUioaPh/IvtnmUOG1ZLlCNr7V133wrgNl/FDrR6g==" crossorigin="anonymous" defer=""></script></body></html>