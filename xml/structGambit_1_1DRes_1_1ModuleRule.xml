<?xml version='1.0' encoding='UTF-8' standalone='no'?>
<doxygen xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="compound.xsd" version="1.9.4" xml:lang="en-US">
  <compounddef id="structGambit_1_1DRes_1_1ModuleRule" kind="struct" language="C++" prot="public">
    <compoundname>Gambit::DRes::ModuleRule</compoundname>
    <basecompoundref refid="structGambit_1_1DRes_1_1Rule" prot="public" virt="non-virtual">Gambit::DRes::Rule</basecompoundref>
    <includes refid="rule_8hpp" local="no">rule.hpp</includes>
      <sectiondef kind="public-attrib">
      <memberdef kind="variable" id="structGambit_1_1DRes_1_1ModuleRule_1accec32476fd6efe16f3bb3774ede76a9" prot="public" static="no" mutable="no">
        <type>std::string</type>
        <definition>std::string Gambit::DRes::ModuleRule::module</definition>
        <argsstring></argsstring>
        <name>module</name>
        <qualifiedname>Gambit::DRes::ModuleRule::module</qualifiedname>
        <briefdescription>
<para>Module field targeted by the rule. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="Core/include/gambit/Core/rule.hpp" line="155" column="19" bodyfile="Core/include/gambit/Core/rule.hpp" bodystart="155" bodyend="-1"/>
      </memberdef>
      <memberdef kind="variable" id="structGambit_1_1DRes_1_1ModuleRule_1a1406795cd4d4763f9e1e26e9b1570d72" prot="public" static="no" mutable="no">
        <type>bool</type>
        <definition>bool Gambit::DRes::ModuleRule::if_module</definition>
        <argsstring></argsstring>
        <name>if_module</name>
        <qualifiedname>Gambit::DRes::ModuleRule::if_module</qualifiedname>
        <briefdescription>
<para>Module field appears in &apos;if&apos; clause. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="Core/include/gambit/Core/rule.hpp" line="157" column="12" bodyfile="Core/include/gambit/Core/rule.hpp" bodystart="157" bodyend="-1"/>
      </memberdef>
      <memberdef kind="variable" id="structGambit_1_1DRes_1_1ModuleRule_1a5e0bed4517ff09e1b67861cf03c69fb2" prot="public" static="no" mutable="no">
        <type>bool</type>
        <definition>bool Gambit::DRes::ModuleRule::then_module</definition>
        <argsstring></argsstring>
        <name>then_module</name>
        <qualifiedname>Gambit::DRes::ModuleRule::then_module</qualifiedname>
        <briefdescription>
<para>Module field appears in &apos;then&apos; clause. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="Core/include/gambit/Core/rule.hpp" line="159" column="12" bodyfile="Core/include/gambit/Core/rule.hpp" bodystart="159" bodyend="-1"/>
      </memberdef>
      <memberdef kind="variable" id="structGambit_1_1DRes_1_1ModuleRule_1a9a92d688b9f59e7829961d7f7fa0622e" prot="public" static="no" mutable="no">
        <type><ref refid="classGambit_1_1Options" kindref="compound">Options</ref></type>
        <definition>Options Gambit::DRes::ModuleRule::options</definition>
        <argsstring></argsstring>
        <name>options</name>
        <qualifiedname>Gambit::DRes::ModuleRule::options</qualifiedname>
        <briefdescription>
<para><ref refid="classGambit_1_1Options" kindref="compound">Options</ref> provided by the rule. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="Core/include/gambit/Core/rule.hpp" line="162" column="15" bodyfile="Core/include/gambit/Core/rule.hpp" bodystart="162" bodyend="-1"/>
      </memberdef>
      <memberdef kind="variable" id="structGambit_1_1DRes_1_1ModuleRule_1a349200560bdc52da4e6d67c9137518a0" prot="public" static="no" mutable="no">
        <type>bool</type>
        <definition>bool Gambit::DRes::ModuleRule::then_options</definition>
        <argsstring></argsstring>
        <name>then_options</name>
        <qualifiedname>Gambit::DRes::ModuleRule::then_options</qualifiedname>
        <briefdescription>
<para><ref refid="classGambit_1_1Options" kindref="compound">Options</ref> appear in &apos;then&apos; clause. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="Core/include/gambit/Core/rule.hpp" line="164" column="12" bodyfile="Core/include/gambit/Core/rule.hpp" bodystart="164" bodyend="-1"/>
      </memberdef>
      <memberdef kind="variable" id="structGambit_1_1DRes_1_1ModuleRule_1af8f173e2f3d71874174186888d8015b2" prot="public" static="no" mutable="no">
        <type>std::vector&lt; <ref refid="structGambit_1_1DRes_1_1ModuleRule" kindref="compound">ModuleRule</ref> &gt;</type>
        <definition>std::vector&lt;ModuleRule&gt; Gambit::DRes::ModuleRule::dependencies</definition>
        <argsstring></argsstring>
        <name>dependencies</name>
        <qualifiedname>Gambit::DRes::ModuleRule::dependencies</qualifiedname>
        <briefdescription>
<para>Subjugate dependency rules provided by the rule. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="Core/include/gambit/Core/rule.hpp" line="167" column="19" bodyfile="Core/include/gambit/Core/rule.hpp" bodystart="167" bodyend="-1"/>
      </memberdef>
      <memberdef kind="variable" id="structGambit_1_1DRes_1_1ModuleRule_1a52546f2024eb75be45eeba318d0becbc" prot="public" static="no" mutable="no">
        <type>bool</type>
        <definition>bool Gambit::DRes::ModuleRule::then_dependencies</definition>
        <argsstring></argsstring>
        <name>then_dependencies</name>
        <qualifiedname>Gambit::DRes::ModuleRule::then_dependencies</qualifiedname>
        <briefdescription>
<para>Subjugate dependency rules appear in &apos;then&apos; clause. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="Core/include/gambit/Core/rule.hpp" line="169" column="12" bodyfile="Core/include/gambit/Core/rule.hpp" bodystart="169" bodyend="-1"/>
      </memberdef>
      <memberdef kind="variable" id="structGambit_1_1DRes_1_1ModuleRule_1ae9633b915e1b0f182a2a2d5d29ebd61a" prot="public" static="no" mutable="no">
        <type>std::vector&lt; <ref refid="structGambit_1_1DRes_1_1BackendRule" kindref="compound">BackendRule</ref> &gt;</type>
        <definition>std::vector&lt;BackendRule&gt; Gambit::DRes::ModuleRule::backends</definition>
        <argsstring></argsstring>
        <name>backends</name>
        <qualifiedname>Gambit::DRes::ModuleRule::backends</qualifiedname>
        <briefdescription>
<para>Subjugate backend rules provided by the rule. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="Core/include/gambit/Core/rule.hpp" line="172" column="19" bodyfile="Core/include/gambit/Core/rule.hpp" bodystart="172" bodyend="-1"/>
      </memberdef>
      <memberdef kind="variable" id="structGambit_1_1DRes_1_1ModuleRule_1abd7eb9a5f6534a743d87bc123f5e95ac" prot="public" static="no" mutable="no">
        <type>bool</type>
        <definition>bool Gambit::DRes::ModuleRule::then_backends</definition>
        <argsstring></argsstring>
        <name>then_backends</name>
        <qualifiedname>Gambit::DRes::ModuleRule::then_backends</qualifiedname>
        <briefdescription>
<para>Subjugate backend rules appear in &apos;then&apos; clause. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="Core/include/gambit/Core/rule.hpp" line="174" column="12" bodyfile="Core/include/gambit/Core/rule.hpp" bodystart="174" bodyend="-1"/>
      </memberdef>
      <memberdef kind="variable" id="structGambit_1_1DRes_1_1ModuleRule_1a030e20bd81a0be13cc7ec44154d42c1b" prot="public" static="no" mutable="no">
        <type>std::vector&lt; std::string &gt;</type>
        <definition>std::vector&lt;std::string&gt; Gambit::DRes::ModuleRule::functionChain</definition>
        <argsstring></argsstring>
        <name>functionChain</name>
        <qualifiedname>Gambit::DRes::ModuleRule::functionChain</qualifiedname>
        <briefdescription>
<para>Function chain provided by the rule. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="Core/include/gambit/Core/rule.hpp" line="177" column="19" bodyfile="Core/include/gambit/Core/rule.hpp" bodystart="177" bodyend="-1"/>
      </memberdef>
      <memberdef kind="variable" id="structGambit_1_1DRes_1_1ModuleRule_1a83a7fb44758b4828e690cf9d6a32cdf5" prot="public" static="no" mutable="no">
        <type>bool</type>
        <definition>bool Gambit::DRes::ModuleRule::then_functionChain</definition>
        <argsstring></argsstring>
        <name>then_functionChain</name>
        <qualifiedname>Gambit::DRes::ModuleRule::then_functionChain</qualifiedname>
        <briefdescription>
<para>Function chain appears in the &apos;then&apos; clause. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="Core/include/gambit/Core/rule.hpp" line="179" column="12" bodyfile="Core/include/gambit/Core/rule.hpp" bodystart="179" bodyend="-1"/>
      </memberdef>
      </sectiondef>
      <sectiondef kind="public-func">
      <memberdef kind="function" id="structGambit_1_1DRes_1_1ModuleRule_1aaea07bb7805d40a408656f88242796e1" prot="public" static="no" const="yes" explicit="no" inline="no" virt="non-virtual">
        <type>bool</type>
        <definition>bool Gambit::DRes::ModuleRule::antecedent_matches</definition>
        <argsstring>(functor *, const Utils::type_equivalency &amp;) const</argsstring>
        <name>antecedent_matches</name>
        <qualifiedname>Gambit::DRes::ModuleRule::antecedent_matches</qualifiedname>
        <param>
          <type><ref refid="classGambit_1_1functor" kindref="compound">functor</ref> *</type>
          <defname>f</defname>
        </param>
        <param>
          <type>const <ref refid="structGambit_1_1Utils_1_1type__equivalency" kindref="compound">Utils::type_equivalency</ref> &amp;</type>
          <defname>te</defname>
        </param>
        <briefdescription>
<para>True if and only if the passed module functor matches the &apos;if&apos; part of a rule. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="Core/include/gambit/Core/rule.hpp" line="182" column="12" bodyfile="Core/src/rule.cpp" bodystart="115" bodyend="124"/>
      </memberdef>
      <memberdef kind="function" id="structGambit_1_1DRes_1_1ModuleRule_1a5cb0b6e36deadb83d7e6b43355150ca6" prot="public" static="no" const="yes" explicit="no" inline="no" virt="non-virtual">
        <type>bool</type>
        <definition>bool Gambit::DRes::ModuleRule::consequent_matches</definition>
        <argsstring>(functor *, const Utils::type_equivalency &amp;) const</argsstring>
        <name>consequent_matches</name>
        <qualifiedname>Gambit::DRes::ModuleRule::consequent_matches</qualifiedname>
        <param>
          <type><ref refid="classGambit_1_1functor" kindref="compound">functor</ref> *</type>
          <defname>f</defname>
        </param>
        <param>
          <type>const <ref refid="structGambit_1_1Utils_1_1type__equivalency" kindref="compound">Utils::type_equivalency</ref> &amp;</type>
          <defname>te</defname>
        </param>
        <briefdescription>
<para>True if and only if the passed module functor matches the &apos;then&apos; part of a rule. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="Core/include/gambit/Core/rule.hpp" line="185" column="12" bodyfile="Core/src/rule.cpp" bodystart="127" bodyend="139"/>
      </memberdef>
      <memberdef kind="function" id="structGambit_1_1DRes_1_1ModuleRule_1af49fe7c2580a2be4e5ae0e25931b126c" prot="public" static="no" const="yes" explicit="no" inline="no" virt="non-virtual">
        <type>bool</type>
        <definition>bool Gambit::DRes::ModuleRule::allows</definition>
        <argsstring>(functor *, const Utils::type_equivalency &amp;, bool ignore_if_weak=true) const</argsstring>
        <name>allows</name>
        <qualifiedname>Gambit::DRes::ModuleRule::allows</qualifiedname>
        <param>
          <type><ref refid="classGambit_1_1functor" kindref="compound">functor</ref> *</type>
          <defname>f</defname>
        </param>
        <param>
          <type>const <ref refid="structGambit_1_1Utils_1_1type__equivalency" kindref="compound">Utils::type_equivalency</ref> &amp;</type>
          <defname>te</defname>
        </param>
        <param>
          <type>bool</type>
          <declname>ignore_if_weak</declname>
          <defval>true</defval>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Whether a module rule allows a given module functor or not. <linebreak/>
 Must be true for a module functor to be used to resolve a dependency. <linebreak/>
 True unless the functor passes the antecedent (&apos;if&apos; part of the rule) but fails the consequent (&apos;then&apos; part of the rule). <linebreak/>
 </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="Core/include/gambit/Core/rule.hpp" line="190" column="12" bodyfile="Core/src/rule.cpp" bodystart="144" bodyend="150"/>
      </memberdef>
      <memberdef kind="function" id="structGambit_1_1DRes_1_1ModuleRule_1a9486884e5db032739a9ca2a70490f55c" prot="public" static="no" const="yes" explicit="no" inline="no" virt="non-virtual">
        <type>bool</type>
        <definition>bool Gambit::DRes::ModuleRule::dependencies_allow</definition>
        <argsstring>(functor *, const Utils::type_equivalency &amp;, bool ignore_if_weak=true) const</argsstring>
        <name>dependencies_allow</name>
        <qualifiedname>Gambit::DRes::ModuleRule::dependencies_allow</qualifiedname>
        <param>
          <type><ref refid="classGambit_1_1functor" kindref="compound">functor</ref> *</type>
          <defname>f</defname>
        </param>
        <param>
          <type>const <ref refid="structGambit_1_1Utils_1_1type__equivalency" kindref="compound">Utils::type_equivalency</ref> &amp;</type>
          <defname>te</defname>
        </param>
        <param>
          <type>bool</type>
          <declname>ignore_if_weak</declname>
          <defval>true</defval>
        </param>
        <briefdescription>
<para>Whether the set of dependency rules subjugate to this rule allow a given module functor or not. </para>
        </briefdescription>
        <detaileddescription>
<para>Whether the set of dependency rules subjugate to this rule allow a given module functor or not. Must be true for the passed module functor to be used to resolve a dependency of another module functor that matches this rule (the dependee). Does not test if the dependee actually matches the rule, so should typically only be used after confirming this first. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="Core/include/gambit/Core/rule.hpp" line="195" column="12" bodyfile="Core/src/rule.cpp" bodystart="153" bodyend="159"/>
      </memberdef>
      <memberdef kind="function" id="structGambit_1_1DRes_1_1ModuleRule_1ac911d5596c9aba2261f575db98b0532d" prot="public" static="no" const="yes" explicit="no" inline="no" virt="non-virtual">
        <type>bool</type>
        <definition>bool Gambit::DRes::ModuleRule::function_chain_allows</definition>
        <argsstring>(functor *, functor *, const Utils::type_equivalency &amp;, bool ignore_if_weak=true) const</argsstring>
        <name>function_chain_allows</name>
        <qualifiedname>Gambit::DRes::ModuleRule::function_chain_allows</qualifiedname>
        <param>
          <type><ref refid="classGambit_1_1functor" kindref="compound">functor</ref> *</type>
          <defname>candidate</defname>
        </param>
        <param>
          <type><ref refid="classGambit_1_1functor" kindref="compound">functor</ref> *</type>
          <defname>dependee</defname>
        </param>
        <param>
          <type>const <ref refid="structGambit_1_1Utils_1_1type__equivalency" kindref="compound">Utils::type_equivalency</ref> &amp;</type>
          <defname>te</defname>
        </param>
        <param>
          <type>bool</type>
          <declname>ignore_if_weak</declname>
          <defval>true</defval>
        </param>
        <briefdescription>
<para>Whether the functionChain of this rule allows a given module functor to be used to resolve the dependency of another. </para>
        </briefdescription>
        <detaileddescription>
<para>Whether the functionChain of this rule allow a given module functor to be used to resolve the dependency of another. Does not test if the dependent functor actually matches the rule, so should typically only be used after confirming this first. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="Core/include/gambit/Core/rule.hpp" line="199" column="12" bodyfile="Core/src/rule.cpp" bodystart="162" bodyend="177"/>
      </memberdef>
      <memberdef kind="function" id="structGambit_1_1DRes_1_1ModuleRule_1ae89448cc127adddc14233199b87ede89" prot="public" static="no" const="yes" explicit="no" inline="no" virt="non-virtual">
        <type>bool</type>
        <definition>bool Gambit::DRes::ModuleRule::backend_reqs_allow</definition>
        <argsstring>(functor *, const Utils::type_equivalency &amp;, const str &amp;, bool ignore_if_weak=true) const</argsstring>
        <name>backend_reqs_allow</name>
        <qualifiedname>Gambit::DRes::ModuleRule::backend_reqs_allow</qualifiedname>
        <param>
          <type><ref refid="classGambit_1_1functor" kindref="compound">functor</ref> *</type>
          <defname>f</defname>
        </param>
        <param>
          <type>const <ref refid="structGambit_1_1Utils_1_1type__equivalency" kindref="compound">Utils::type_equivalency</ref> &amp;</type>
          <defname>te</defname>
        </param>
        <param>
          <type>const <ref refid="namespaceGambit_1aff3f41b9e6112a6d471a03b2df1f2427" kindref="member">str</ref> &amp;</type>
          <defname>group_being_resolved</defname>
        </param>
        <param>
          <type>bool</type>
          <declname>ignore_if_weak</declname>
          <defval>true</defval>
        </param>
        <briefdescription>
<para>Whether the set of backend rules subjugate to this rule allow a given backend functor or not. </para>
        </briefdescription>
        <detaileddescription>
<para>Whether the set of backend rules subjugate to this rule allow a given backend functor or not. Must be true for the passed backend functor to be used to resolve a backend requirement of another module functor that matches this rule (the requiree). Does not test if the requiree actually matches the rule, so should typically only be used after confirming this first. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="Core/include/gambit/Core/rule.hpp" line="204" column="12" bodyfile="Core/src/rule.cpp" bodystart="180" bodyend="186"/>
      </memberdef>
      <memberdef kind="function" id="structGambit_1_1DRes_1_1ModuleRule_1a4a2cdc6fa012f37c9f243b4cc0ef8b8d" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type></type>
        <definition>Gambit::DRes::ModuleRule::ModuleRule</definition>
        <argsstring>()</argsstring>
        <name>ModuleRule</name>
        <qualifiedname>Gambit::DRes::ModuleRule::ModuleRule</qualifiedname>
        <briefdescription>
<para>Default constructor. Sets all fields empty. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="Core/include/gambit/Core/rule.hpp" line="207" column="7" bodyfile="Core/include/gambit/Core/rule.hpp" bodystart="207" bodyend="220"/>
      </memberdef>
      </sectiondef>
      <sectiondef kind="public-static-func">
      <memberdef kind="function" id="structGambit_1_1DRes_1_1ModuleRule_1a549fc02c088400792720664ac848ac49" prot="public" static="yes" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>bool</type>
        <definition>bool Gambit::DRes::ModuleRule::permits_field</definition>
        <argsstring>(const str &amp;)</argsstring>
        <name>permits_field</name>
        <qualifiedname>Gambit::DRes::ModuleRule::permits_field</qualifiedname>
        <param>
          <type>const <ref refid="namespaceGambit_1aff3f41b9e6112a6d471a03b2df1f2427" kindref="member">str</ref> &amp;</type>
          <defname>field</defname>
        </param>
        <briefdescription>
<para>Check if a given string is a permitted field of this class. </para>
        </briefdescription>
        <detaileddescription>
<para>Check if a given string is a permitted field of the <ref refid="structGambit_1_1DRes_1_1ModuleRule" kindref="compound">ModuleRule</ref> class. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="Core/include/gambit/Core/rule.hpp" line="223" column="19" bodyfile="Core/src/rule.cpp" bodystart="101" bodyend="112"/>
      </memberdef>
      </sectiondef>
    <briefdescription>
<para>Derived class rule for resolution of dependencies. </para>
    </briefdescription>
    <detaileddescription>
    </detaileddescription>
    <inheritancegraph>
      <node id="1">
        <label>Gambit::DRes::ModuleRule</label>
        <link refid="structGambit_1_1DRes_1_1ModuleRule"/>
        <childnode refid="2" relation="public-inheritance">
        </childnode>
      </node>
      <node id="2">
        <label>Gambit::DRes::Rule</label>
        <link refid="structGambit_1_1DRes_1_1Rule"/>
      </node>
    </inheritancegraph>
    <collaborationgraph>
      <node id="1">
        <label>Gambit::DRes::ModuleRule</label>
        <link refid="structGambit_1_1DRes_1_1ModuleRule"/>
        <childnode refid="2" relation="public-inheritance">
        </childnode>
        <childnode refid="3" relation="usage">
          <edgelabel>module</edgelabel>
        </childnode>
        <childnode refid="4" relation="usage">
          <edgelabel>options</edgelabel>
        </childnode>
      </node>
      <node id="2">
        <label>Gambit::DRes::Rule</label>
        <link refid="structGambit_1_1DRes_1_1Rule"/>
        <childnode refid="3" relation="usage">
          <edgelabel>capability</edgelabel>
          <edgelabel>function</edgelabel>
          <edgelabel>type</edgelabel>
        </childnode>
      </node>
      <node id="4">
        <label>Gambit::Options</label>
        <link refid="classGambit_1_1Options"/>
      </node>
      <node id="3">
        <label>string</label>
      </node>
    </collaborationgraph>
    <location file="Core/include/gambit/Core/rule.hpp" line="151" column="5" bodyfile="Core/include/gambit/Core/rule.hpp" bodystart="152" bodyend="225"/>
    <listofallmembers>
      <member refid="structGambit_1_1DRes_1_1ModuleRule_1af49fe7c2580a2be4e5ae0e25931b126c" prot="public" virt="non-virtual"><scope>Gambit::DRes::ModuleRule</scope><name>allows</name></member>
      <member refid="structGambit_1_1DRes_1_1ModuleRule_1aaea07bb7805d40a408656f88242796e1" prot="public" virt="non-virtual"><scope>Gambit::DRes::ModuleRule</scope><name>antecedent_matches</name></member>
      <member refid="structGambit_1_1DRes_1_1ModuleRule_1ae89448cc127adddc14233199b87ede89" prot="public" virt="non-virtual"><scope>Gambit::DRes::ModuleRule</scope><name>backend_reqs_allow</name></member>
      <member refid="structGambit_1_1DRes_1_1ModuleRule_1ae9633b915e1b0f182a2a2d5d29ebd61a" prot="public" virt="non-virtual"><scope>Gambit::DRes::ModuleRule</scope><name>backends</name></member>
      <member refid="structGambit_1_1DRes_1_1Rule_1a1dcfee83f84288b64809ac36e5bb74e0" prot="public" virt="non-virtual"><scope>Gambit::DRes::ModuleRule</scope><name>base_antecedent_matches</name></member>
      <member refid="structGambit_1_1DRes_1_1Rule_1afc73a482519ed65671e232000d753869" prot="public" virt="non-virtual"><scope>Gambit::DRes::ModuleRule</scope><name>base_consequent_matches</name></member>
      <member refid="structGambit_1_1DRes_1_1Rule_1aa4644d0b22f3c6f46104661642f30eb8" prot="public" virt="non-virtual"><scope>Gambit::DRes::ModuleRule</scope><name>capability</name></member>
      <member refid="structGambit_1_1DRes_1_1ModuleRule_1a5cb0b6e36deadb83d7e6b43355150ca6" prot="public" virt="non-virtual"><scope>Gambit::DRes::ModuleRule</scope><name>consequent_matches</name></member>
      <member refid="structGambit_1_1DRes_1_1ModuleRule_1af8f173e2f3d71874174186888d8015b2" prot="public" virt="non-virtual"><scope>Gambit::DRes::ModuleRule</scope><name>dependencies</name></member>
      <member refid="structGambit_1_1DRes_1_1ModuleRule_1a9486884e5db032739a9ca2a70490f55c" prot="public" virt="non-virtual"><scope>Gambit::DRes::ModuleRule</scope><name>dependencies_allow</name></member>
      <member refid="structGambit_1_1DRes_1_1Rule_1a9a917156b3e4081a8eb8b6e9f0fe00ca" prot="public" virt="non-virtual"><scope>Gambit::DRes::ModuleRule</scope><name>function</name></member>
      <member refid="structGambit_1_1DRes_1_1ModuleRule_1ac911d5596c9aba2261f575db98b0532d" prot="public" virt="non-virtual"><scope>Gambit::DRes::ModuleRule</scope><name>function_chain_allows</name></member>
      <member refid="structGambit_1_1DRes_1_1ModuleRule_1a030e20bd81a0be13cc7ec44154d42c1b" prot="public" virt="non-virtual"><scope>Gambit::DRes::ModuleRule</scope><name>functionChain</name></member>
      <member refid="structGambit_1_1DRes_1_1Rule_1a79f355e8510046bb422ba03cc8917088" prot="public" virt="non-virtual"><scope>Gambit::DRes::ModuleRule</scope><name>has_if</name></member>
      <member refid="structGambit_1_1DRes_1_1Rule_1a84d238260560a5705dfa6601589e130b" prot="public" virt="non-virtual"><scope>Gambit::DRes::ModuleRule</scope><name>has_then</name></member>
      <member refid="structGambit_1_1DRes_1_1Rule_1a7e7ca0cb7fbf4dc75cfc23dba706d369" prot="public" virt="non-virtual"><scope>Gambit::DRes::ModuleRule</scope><name>if_capability</name></member>
      <member refid="structGambit_1_1DRes_1_1Rule_1a7d7e39b02fb0595e16522dc3dbe6bacb" prot="public" virt="non-virtual"><scope>Gambit::DRes::ModuleRule</scope><name>if_function</name></member>
      <member refid="structGambit_1_1DRes_1_1ModuleRule_1a1406795cd4d4763f9e1e26e9b1570d72" prot="public" virt="non-virtual"><scope>Gambit::DRes::ModuleRule</scope><name>if_module</name></member>
      <member refid="structGambit_1_1DRes_1_1Rule_1af9c5df4e4857eaa4bcdfe2b11793db24" prot="public" virt="non-virtual"><scope>Gambit::DRes::ModuleRule</scope><name>if_type</name></member>
      <member refid="structGambit_1_1DRes_1_1Rule_1afda2bf7cb57ccaaac571540135f247b1" prot="public" virt="non-virtual"><scope>Gambit::DRes::ModuleRule</scope><name>log_matches</name></member>
      <member refid="structGambit_1_1DRes_1_1ModuleRule_1accec32476fd6efe16f3bb3774ede76a9" prot="public" virt="non-virtual"><scope>Gambit::DRes::ModuleRule</scope><name>module</name></member>
      <member refid="structGambit_1_1DRes_1_1ModuleRule_1a4a2cdc6fa012f37c9f243b4cc0ef8b8d" prot="public" virt="non-virtual"><scope>Gambit::DRes::ModuleRule</scope><name>ModuleRule</name></member>
      <member refid="structGambit_1_1DRes_1_1ModuleRule_1a9a92d688b9f59e7829961d7f7fa0622e" prot="public" virt="non-virtual"><scope>Gambit::DRes::ModuleRule</scope><name>options</name></member>
      <member refid="structGambit_1_1DRes_1_1ModuleRule_1a549fc02c088400792720664ac848ac49" prot="public" virt="non-virtual"><scope>Gambit::DRes::ModuleRule</scope><name>permits_field</name></member>
      <member refid="structGambit_1_1DRes_1_1Rule_1a144af7d7bc63a3b298ab7fffdedd77a4" prot="public" virt="non-virtual"><scope>Gambit::DRes::ModuleRule</scope><name>Rule</name></member>
      <member refid="structGambit_1_1DRes_1_1ModuleRule_1abd7eb9a5f6534a743d87bc123f5e95ac" prot="public" virt="non-virtual"><scope>Gambit::DRes::ModuleRule</scope><name>then_backends</name></member>
      <member refid="structGambit_1_1DRes_1_1Rule_1a07754e26554a8594db6b96b9501dc6cf" prot="public" virt="non-virtual"><scope>Gambit::DRes::ModuleRule</scope><name>then_capability</name></member>
      <member refid="structGambit_1_1DRes_1_1ModuleRule_1a52546f2024eb75be45eeba318d0becbc" prot="public" virt="non-virtual"><scope>Gambit::DRes::ModuleRule</scope><name>then_dependencies</name></member>
      <member refid="structGambit_1_1DRes_1_1Rule_1ac7d7706ebd72295b1f950fc52db5cf7a" prot="public" virt="non-virtual"><scope>Gambit::DRes::ModuleRule</scope><name>then_function</name></member>
      <member refid="structGambit_1_1DRes_1_1ModuleRule_1a83a7fb44758b4828e690cf9d6a32cdf5" prot="public" virt="non-virtual"><scope>Gambit::DRes::ModuleRule</scope><name>then_functionChain</name></member>
      <member refid="structGambit_1_1DRes_1_1ModuleRule_1a5e0bed4517ff09e1b67861cf03c69fb2" prot="public" virt="non-virtual"><scope>Gambit::DRes::ModuleRule</scope><name>then_module</name></member>
      <member refid="structGambit_1_1DRes_1_1ModuleRule_1a349200560bdc52da4e6d67c9137518a0" prot="public" virt="non-virtual"><scope>Gambit::DRes::ModuleRule</scope><name>then_options</name></member>
      <member refid="structGambit_1_1DRes_1_1Rule_1a14ae28482623485c663bc10d9b7556b2" prot="public" virt="non-virtual"><scope>Gambit::DRes::ModuleRule</scope><name>then_type</name></member>
      <member refid="structGambit_1_1DRes_1_1Rule_1a111c16c35b0ab2a4e064de91dc8d6938" prot="public" virt="non-virtual"><scope>Gambit::DRes::ModuleRule</scope><name>type</name></member>
      <member refid="structGambit_1_1DRes_1_1Rule_1a5c0ccfecbf63233ec3998a4b61f954fc" prot="public" virt="non-virtual"><scope>Gambit::DRes::ModuleRule</scope><name>weakrule</name></member>
      <member refid="structGambit_1_1DRes_1_1Rule_1a2e8921e04523c203789068c480b3d8f8" prot="public" virt="non-virtual"><scope>Gambit::DRes::ModuleRule</scope><name>yaml</name></member>
    </listofallmembers>
  </compounddef>
</doxygen>
